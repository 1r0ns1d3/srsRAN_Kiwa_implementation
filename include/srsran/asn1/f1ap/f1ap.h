/*
 *
 * Copyright 2021-2023 Software Radio Systems Limited
 *
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the distribution.
 *
 */

/*******************************************************************************
 *
 *                     3GPP TS ASN1 F1AP v17.4.1 (2023-04)
 *
 ******************************************************************************/

#pragma once

#include "srsran/asn1/asn1_utils.h"
#include <cstdio>
#include <stdarg.h>

namespace asn1 {
namespace f1ap {

/*******************************************************************************
 *                             Constant Definitions
 ******************************************************************************/

#define ASN1_F1AP_ID_RESET 0
#define ASN1_F1AP_ID_F1_SETUP 1
#define ASN1_F1AP_ID_ERROR_IND 2
#define ASN1_F1AP_ID_GNB_DU_CFG_UPD 3
#define ASN1_F1AP_ID_GNB_CU_CFG_UPD 4
#define ASN1_F1AP_ID_UE_CONTEXT_SETUP 5
#define ASN1_F1AP_ID_UE_CONTEXT_RELEASE 6
#define ASN1_F1AP_ID_UE_CONTEXT_MOD 7
#define ASN1_F1AP_ID_UE_CONTEXT_MOD_REQUIRED 8
#define ASN1_F1AP_ID_UE_MOB_CMD 9
#define ASN1_F1AP_ID_UE_CONTEXT_RELEASE_REQUEST 10
#define ASN1_F1AP_ID_INIT_UL_RRC_MSG_TRANSFER 11
#define ASN1_F1AP_ID_DL_RRC_MSG_TRANSFER 12
#define ASN1_F1AP_ID_UL_RRC_MSG_TRANSFER 13
#define ASN1_F1AP_ID_PRIVATE_MSG 14
#define ASN1_F1AP_ID_UE_INACTIVITY_NOTIF 15
#define ASN1_F1AP_ID_GNB_DU_RES_COORDINATION 16
#define ASN1_F1AP_ID_SYS_INFO_DELIVERY_CMD 17
#define ASN1_F1AP_ID_PAGING 18
#define ASN1_F1AP_ID_NOTIFY 19
#define ASN1_F1AP_ID_WRITE_REPLACE_WARNING 20
#define ASN1_F1AP_ID_PWS_CANCEL 21
#define ASN1_F1AP_ID_PWS_RESTART_IND 22
#define ASN1_F1AP_ID_PWS_FAIL_IND 23
#define ASN1_F1AP_ID_GNB_DU_STATUS_IND 24
#define ASN1_F1AP_ID_RRC_DELIVERY_REPORT 25
#define ASN1_F1AP_ID_F1_REMOVAL 26
#define ASN1_F1AP_ID_NETWORK_ACCESS_RATE_REDUCTION 27
#define ASN1_F1AP_ID_TRACE_START 28
#define ASN1_F1AP_ID_DEACTIV_TRACE 29
#define ASN1_F1AP_ID_DU_CU_RADIO_INFO_TRANSFER 30
#define ASN1_F1AP_ID_CU_DU_RADIO_INFO_TRANSFER 31
#define ASN1_F1AP_ID_BAP_MAP_CFG 32
#define ASN1_F1AP_ID_GNB_DU_RES_CFG 33
#define ASN1_F1AP_ID_IAB_TNL_ADDRESS_ALLOC 34
#define ASN1_F1AP_ID_IAB_UP_CFG_UPD 35
#define ASN1_F1AP_ID_RES_STATUS_REPORT_INITIATION 36
#define ASN1_F1AP_ID_RES_STATUS_REPORT 37
#define ASN1_F1AP_ID_ACCESS_AND_MOB_IND 38
#define ASN1_F1AP_ID_ACCESS_SUCCESS 39
#define ASN1_F1AP_ID_CELL_TRAFFIC_TRACE 40
#define ASN1_F1AP_ID_POSITIONING_MEAS_EXCHANGE 41
#define ASN1_F1AP_ID_POSITIONING_ASSIST_INFO_CTRL 42
#define ASN1_F1AP_ID_POSITIONING_ASSIST_INFO_FEEDBACK 43
#define ASN1_F1AP_ID_POSITIONING_MEAS_REPORT 44
#define ASN1_F1AP_ID_POSITIONING_MEAS_ABORT 45
#define ASN1_F1AP_ID_POSITIONING_MEAS_FAIL_IND 46
#define ASN1_F1AP_ID_POSITIONING_MEAS_UPD 47
#define ASN1_F1AP_ID_TRP_INFO_EXCHANGE 48
#define ASN1_F1AP_ID_POSITIONING_INFO_EXCHANGE 49
#define ASN1_F1AP_ID_POSITIONING_ACTIVATION 50
#define ASN1_F1AP_ID_POSITIONING_DEACTIVATION 51
#define ASN1_F1AP_ID_E_C_ID_MEAS_INITIATION 52
#define ASN1_F1AP_ID_E_C_ID_MEAS_FAIL_IND 53
#define ASN1_F1AP_ID_E_C_ID_MEAS_REPORT 54
#define ASN1_F1AP_ID_E_C_ID_MEAS_TERMINATION 55
#define ASN1_F1AP_ID_POSITIONING_INFO_UPD 56
#define ASN1_F1AP_ID_REF_TIME_INFO_REPORT 57
#define ASN1_F1AP_ID_REF_TIME_INFO_REPORT_CTRL 58
#define ASN1_F1AP_ID_BROADCAST_CONTEXT_SETUP 59
#define ASN1_F1AP_ID_BROADCAST_CONTEXT_RELEASE 60
#define ASN1_F1AP_ID_BROADCAST_CONTEXT_RELEASE_REQUEST 61
#define ASN1_F1AP_ID_BROADCAST_CONTEXT_MOD 62
#define ASN1_F1AP_ID_MULTICAST_GROUP_PAGING 63
#define ASN1_F1AP_ID_MULTICAST_CONTEXT_SETUP 64
#define ASN1_F1AP_ID_MULTICAST_CONTEXT_RELEASE 65
#define ASN1_F1AP_ID_MULTICAST_CONTEXT_RELEASE_REQUEST 66
#define ASN1_F1AP_ID_MULTICAST_CONTEXT_MOD 67
#define ASN1_F1AP_ID_MULTICAST_DISTRIBUTION_SETUP 68
#define ASN1_F1AP_ID_MULTICAST_DISTRIBUTION_RELEASE 69
#define ASN1_F1AP_ID_PDC_MEAS_INITIATION 70
#define ASN1_F1AP_ID_PDC_MEAS_REPORT 71
#define ASN1_F1AP_ID_PDC_MEAS_INITIATION_REQUEST 72
#define ASN1_F1AP_ID_PDC_MEAS_INITIATION_RESP 73
#define ASN1_F1AP_ID_PDC_MEAS_INITIATION_FAIL 74
#define ASN1_F1AP_ID_P_RS_CFG_EXCHANGE 75
#define ASN1_F1AP_ID_MEAS_PRECFG 76
#define ASN1_F1AP_ID_MEAS_ACTIVATION 77
#define ASN1_F1AP_ID_QO_E_INFO_TRANSFER 78
#define ASN1_F1AP_ID_PDC_MEAS_TERMINATION_CMD 79
#define ASN1_F1AP_ID_PDC_MEAS_FAIL_IND 80
#define ASN1_F1AP_ID_POS_SYS_INFO_DELIVERY_CMD 81
#define ASN1_F1AP_MAX_PRIVATE_IES 65535
#define ASN1_F1AP_MAX_PROTOCOL_EXTS 65535
#define ASN1_F1AP_MAX_PROTOCOL_IES 65535
#define ASN1_F1AP_MAX_NR_ARFCN 3279165
#define ASN1_F1AP_MAXNOOF_ERRORS 256
#define ASN1_F1AP_MAXNOOF_INDIVIDUAL_F1_CONNS_TO_RESET 65536
#define ASN1_F1AP_MAX_CELLIN_GNB_DU 512
#define ASN1_F1AP_MAXNOOF_SCELLS 32
#define ASN1_F1AP_MAXNOOF_SRBS 8
#define ASN1_F1AP_MAXNOOF_DRBS 64
#define ASN1_F1AP_MAXNOOF_UL_UP_TNL_INFO 2
#define ASN1_F1AP_MAXNOOF_DL_UP_TNL_INFO 2
#define ASN1_F1AP_MAXNOOF_BPLMNS 6
#define ASN1_F1AP_MAXNOOF_CANDIDATE_SP_CELLS 64
#define ASN1_F1AP_MAXNOOF_POTENTIAL_SP_CELLS 64
#define ASN1_F1AP_MAXNOOF_NR_CELL_BANDS 32
#define ASN1_F1AP_MAXNOOF_SIB_TYPES 32
#define ASN1_F1AP_MAXNOOF_SI_TYPES 32
#define ASN1_F1AP_MAXNOOF_PAGING_CELLS 512
#define ASN1_F1AP_MAXNOOF_TNL_ASSOCS 32
#define ASN1_F1AP_MAXNOOF_QOS_FLOWS 64
#define ASN1_F1AP_MAXNOOF_SLICE_ITEMS 1024
#define ASN1_F1AP_MAX_CELLIN_ENB 256
#define ASN1_F1AP_MAXNOOF_EXTENDED_BPLMNS 6
#define ASN1_F1AP_MAXNOOF_UE_IDS 65536
#define ASN1_F1AP_MAXNOOF_BPLMNS_NR 12
#define ASN1_F1AP_MAXNOOF_UAC_PLMNS 12
#define ASN1_F1AP_MAXNOOF_UAC_PER_PLMN 64
#define ASN1_F1AP_MAXNOOF_ADD_SIBS 63
#define ASN1_F1AP_MAXNOOFSLOTS 5120
#define ASN1_F1AP_MAXNOOF_TLAS 16
#define ASN1_F1AP_MAXNOOF_GTP_TLAS 16
#define ASN1_F1AP_MAXNOOF_BH_RLC_CHS 65536
#define ASN1_F1AP_MAXNOOF_ROUTING_ENTRIES 1024
#define ASN1_F1AP_MAXNOOF_IABSTC_INFO 45
#define ASN1_F1AP_MAXNOOF_SYMBOLS 14
#define ASN1_F1AP_MAXNOOF_SERVING_CELLS 32
#define ASN1_F1AP_MAXNOOF_DU_F_SLOTS 320
#define ASN1_F1AP_MAXNOOF_HS_NAS_LOTS 5120
#define ASN1_F1AP_MAXNOOF_SERVED_CELLS_IAB 512
#define ASN1_F1AP_MAXNOOF_CHILD_IAB_NODES 1024
#define ASN1_F1AP_MAXNOOF_NON_UP_TRAFFIC_MAPS 32
#define ASN1_F1AP_MAXNOOF_TLAS_IAB 1024
#define ASN1_F1AP_MAXNOOF_MAP_ENTRIES 67108864
#define ASN1_F1AP_MAXNOOF_D_SI_NFO 64
#define ASN1_F1AP_MAXNOOF_EGRESS_LINKS 2
#define ASN1_F1AP_MAXNOOF_UL_UP_TNL_INFOFOR_IAB 32678
#define ASN1_F1AP_MAXNOOF_UP_TNL_ADDRESSES 8
#define ASN1_F1AP_MAXNOOF_SL_DRBS 512
#define ASN1_F1AP_MAXNOOF_QOS_PARA_SETS 8
#define ASN1_F1AP_MAXNOOF_PC5_QOS_FLOWS 2048
#define ASN1_F1AP_MAXNOOF_SSB_AREAS 64
#define ASN1_F1AP_MAXNOOF_PHYS_RES_BLOCKS 275
#define ASN1_F1AP_MAXNOOF_PHYS_RES_BLOCKS_1 274
#define ASN1_F1AP_MAXNOOF_PRAC_HCFGS 16
#define ASN1_F1AP_MAXNOOF_RACH_REPORTS 64
#define ASN1_F1AP_MAXNOOF_RLF_REPORTS 64
#define ASN1_F1AP_MAXNOOF_ADD_PDCP_DUPL_TNL 2
#define ASN1_F1AP_MAXNOOF_RLC_DUPL_STATE 3
#define ASN1_F1AP_MAXNOOF_CH_OCELLS 8
#define ASN1_F1AP_MAXNOOF_MDT_PLMNS 16
#define ASN1_F1AP_MAXNOOF_CA_GSUPPORTED 12
#define ASN1_F1AP_MAXNOOF_N_ID_SUPPORTED 12
#define ASN1_F1AP_MAXNOOF_NR_SC_SS 5
#define ASN1_F1AP_MAXNOOF_EXT_SLICE_ITEMS 65535
#define ASN1_F1AP_MAXNOOF_POS_MEAS 16384
#define ASN1_F1AP_MAXNOOF_TRP_INFO_TYPES 64
#define ASN1_F1AP_MAXNOOF_TR_PS 65535
#define ASN1_F1AP_MAXNOOF_SRS_TRIGGER_STATES 3
#define ASN1_F1AP_MAXNOOF_SPATIAL_RELATIONS 64
#define ASN1_F1AP_MAXNO_BCAST_CELL 16384
#define ASN1_F1AP_MAXNOOF_ANGLE_INFO 65535
#define ASN1_F1AP_MAXNOOFLCS_GCS_TRANSLATION 3
#define ASN1_F1AP_MAXNOOF_PATH 2
#define ASN1_F1AP_MAXNOOF_MEAS_E_C_ID 64
#define ASN1_F1AP_MAXNOOF_SS_BS 255
#define ASN1_F1AP_MAXNO_SRS_RES_SETS 16
#define ASN1_F1AP_MAXNO_SRS_RES_PER_SET 16
#define ASN1_F1AP_MAXNO_SRS_CARRIERS 32
#define ASN1_F1AP_MAXNO_SC_SS 5
#define ASN1_F1AP_MAXNO_SRS_RES 64
#define ASN1_F1AP_MAXNO_SRS_POS_RES 64
#define ASN1_F1AP_MAXNO_SRS_POS_RES_SETS 16
#define ASN1_F1AP_MAXNO_SRS_POS_RES_PER_SET 16
#define ASN1_F1AP_MAXNOOF_PRS_RES_SETS 2
#define ASN1_F1AP_MAXNOOF_PRS_RES_PER_SET 64
#define ASN1_F1AP_MAX_NO_OF_MEAS_TR_PS 64
#define ASN1_F1AP_MAXNOOF_PR_SRES_SETS 8
#define ASN1_F1AP_MAXNOOF_PR_SRES 64
#define ASN1_F1AP_MAXNOOF_SUCCESSFUL_HO_REPORTS 64
#define ASN1_F1AP_MAXNOOF_NR_U_CH_IDS 16
#define ASN1_F1AP_MAX_SERVED_CELLFOR_SON 256
#define ASN1_F1AP_MAX_NEIGHBOUR_CELLFOR_SON 32
#define ASN1_F1AP_MAX_AFFECTED_CELLS 32
#define ASN1_F1AP_MAXNOOF_M_RBS 32
#define ASN1_F1AP_MAXNOOF_MBS_QOS_FLOWS 64
#define ASN1_F1AP_MAXNOOF_MBSFS_AS 256
#define ASN1_F1AP_MAXNOOF_UE_ID_FOR_PAGING 4096
#define ASN1_F1AP_MAXNOOF_CELLSFOR_MBS 512
#define ASN1_F1AP_MAXNOOF_TAI_FOR_MBS 512
#define ASN1_F1AP_MAXNOOF_MBS_AREA_SESSION_IDS 256
#define ASN1_F1AP_MAXNOOF_MBS_SERVICE_AREA_INFO 256
#define ASN1_F1AP_MAXNOOF_IAB_CONG_IND 1024
#define ASN1_F1AP_MAXNOOF_NEIGHBOUR_NODE_CELLS_IAB 1024
#define ASN1_F1AP_MAXNOOF_R_BSETS_PER_CELL 8
#define ASN1_F1AP_MAXNOOF_R_BSETS_PER_CELL_1 7
#define ASN1_F1AP_MAXNOOF_MEAS_PDC 16
#define ASN1_F1AP_MAXNO_AR_PS 16
#define ASN1_F1AP_MAXNOOF_UL_AO_AS 8
#define ASN1_F1AP_MAX_NO_PATH_EXTENDED 8
#define ASN1_F1AP_MAXNO_TRPTE_GS 8
#define ASN1_F1AP_MAX_FREQ_LAYERS 4
#define ASN1_F1AP_MAX_NUM_RES_PER_ANGLE 24
#define ASN1_F1AP_MAXNO_AZIMUTH_ANGLES 3600
#define ASN1_F1AP_MAXNO_ELEVATION_ANGLES 1801
#define ASN1_F1AP_MAXNOOF_PRSTR_PS 256
#define ASN1_F1AP_MAXNOOF_QO_E_INFO 16
#define ASN1_F1AP_MAXNOOF_UU_RLC_CHS 32
#define ASN1_F1AP_MAXNOOF_PC5_RLC_CHS 512
#define ASN1_F1AP_MAXNOOF_SMBR_VALUES 8
#define ASN1_F1AP_MAXNOOF_MR_BSFOR_UE 64
#define ASN1_F1AP_MAXNOOF_MBS_SESSIONSOF_UE 256
#define ASN1_F1AP_MAXNOOF_S_LDESTS 32
#define ASN1_F1AP_MAXNOOF_NSA_GS 256
#define ASN1_F1AP_MAXNOOF_SDT_BEARERS 72
#define ASN1_F1AP_MAXNOOF_SERVING_CELL_M_OS 16
#define ASN1_F1AP_MAX_NROF_BW_PS 8
#define ASN1_F1AP_MAXNOOF_POS_SI_TYPES 32
#define ASN1_F1AP_ID_CAUSE 0
#define ASN1_F1AP_ID_CELLS_FAILED_TO_BE_ACTIV_LIST 1
#define ASN1_F1AP_ID_CELLS_FAILED_TO_BE_ACTIV_LIST_ITEM 2
#define ASN1_F1AP_ID_CELLS_TO_BE_ACTIV_LIST 3
#define ASN1_F1AP_ID_CELLS_TO_BE_ACTIV_LIST_ITEM 4
#define ASN1_F1AP_ID_CELLS_TO_BE_DEACTIV_LIST 5
#define ASN1_F1AP_ID_CELLS_TO_BE_DEACTIV_LIST_ITEM 6
#define ASN1_F1AP_ID_CRIT_DIAGNOSTICS 7
#define ASN1_F1AP_ID_CU_TO_DU_RRC_INFO 9
#define ASN1_F1AP_ID_DRBS_FAILED_TO_BE_MODIFIED_ITEM 12
#define ASN1_F1AP_ID_DRBS_FAILED_TO_BE_MODIFIED_LIST 13
#define ASN1_F1AP_ID_DRBS_FAILED_TO_BE_SETUP_ITEM 14
#define ASN1_F1AP_ID_DRBS_FAILED_TO_BE_SETUP_LIST 15
#define ASN1_F1AP_ID_DRBS_FAILED_TO_BE_SETUP_MOD_ITEM 16
#define ASN1_F1AP_ID_DRBS_FAILED_TO_BE_SETUP_MOD_LIST 17
#define ASN1_F1AP_ID_DRBS_MODIFIED_CONF_ITEM 18
#define ASN1_F1AP_ID_DRBS_MODIFIED_CONF_LIST 19
#define ASN1_F1AP_ID_DRBS_MODIFIED_ITEM 20
#define ASN1_F1AP_ID_DRBS_MODIFIED_LIST 21
#define ASN1_F1AP_ID_DRBS_REQUIRED_TO_BE_MODIFIED_ITEM 22
#define ASN1_F1AP_ID_DRBS_REQUIRED_TO_BE_MODIFIED_LIST 23
#define ASN1_F1AP_ID_DRBS_REQUIRED_TO_BE_RELEASED_ITEM 24
#define ASN1_F1AP_ID_DRBS_REQUIRED_TO_BE_RELEASED_LIST 25
#define ASN1_F1AP_ID_DRBS_SETUP_ITEM 26
#define ASN1_F1AP_ID_DRBS_SETUP_LIST 27
#define ASN1_F1AP_ID_DRBS_SETUP_MOD_ITEM 28
#define ASN1_F1AP_ID_DRBS_SETUP_MOD_LIST 29
#define ASN1_F1AP_ID_DRBS_TO_BE_MODIFIED_ITEM 30
#define ASN1_F1AP_ID_DRBS_TO_BE_MODIFIED_LIST 31
#define ASN1_F1AP_ID_DRBS_TO_BE_RELEASED_ITEM 32
#define ASN1_F1AP_ID_DRBS_TO_BE_RELEASED_LIST 33
#define ASN1_F1AP_ID_DRBS_TO_BE_SETUP_ITEM 34
#define ASN1_F1AP_ID_DRBS_TO_BE_SETUP_LIST 35
#define ASN1_F1AP_ID_DRBS_TO_BE_SETUP_MOD_ITEM 36
#define ASN1_F1AP_ID_DRBS_TO_BE_SETUP_MOD_LIST 37
#define ASN1_F1AP_ID_DRX_CYCLE 38
#define ASN1_F1AP_ID_DU_TO_CU_RRC_INFO 39
#define ASN1_F1AP_ID_GNB_CU_UE_F1AP_ID 40
#define ASN1_F1AP_ID_GNB_DU_UE_F1AP_ID 41
#define ASN1_F1AP_ID_GNB_DU_ID 42
#define ASN1_F1AP_ID_GNB_DU_SERVED_CELLS_ITEM 43
#define ASN1_F1AP_ID_GNB_DU_SERVED_CELLS_LIST 44
#define ASN1_F1AP_ID_GNB_DU_NAME 45
#define ASN1_F1AP_ID_NR_CELL_ID 46
#define ASN1_F1AP_ID_OLD_GNB_DU_UE_F1AP_ID 47
#define ASN1_F1AP_ID_RESET_TYPE 48
#define ASN1_F1AP_ID_RES_COORDINATION_TRANSFER_CONTAINER 49
#define ASN1_F1AP_ID_RRC_CONTAINER 50
#define ASN1_F1AP_ID_SCELL_TO_BE_REMD_ITEM 51
#define ASN1_F1AP_ID_SCELL_TO_BE_REMD_LIST 52
#define ASN1_F1AP_ID_SCELL_TO_BE_SETUP_ITEM 53
#define ASN1_F1AP_ID_SCELL_TO_BE_SETUP_LIST 54
#define ASN1_F1AP_ID_SCELL_TO_BE_SETUP_MOD_ITEM 55
#define ASN1_F1AP_ID_SCELL_TO_BE_SETUP_MOD_LIST 56
#define ASN1_F1AP_ID_SERVED_CELLS_TO_ADD_ITEM 57
#define ASN1_F1AP_ID_SERVED_CELLS_TO_ADD_LIST 58
#define ASN1_F1AP_ID_SERVED_CELLS_TO_DELETE_ITEM 59
#define ASN1_F1AP_ID_SERVED_CELLS_TO_DELETE_LIST 60
#define ASN1_F1AP_ID_SERVED_CELLS_TO_MODIFY_ITEM 61
#define ASN1_F1AP_ID_SERVED_CELLS_TO_MODIFY_LIST 62
#define ASN1_F1AP_ID_SP_CELL_ID 63
#define ASN1_F1AP_ID_SRB_ID 64
#define ASN1_F1AP_ID_SRBS_FAILED_TO_BE_SETUP_ITEM 65
#define ASN1_F1AP_ID_SRBS_FAILED_TO_BE_SETUP_LIST 66
#define ASN1_F1AP_ID_SRBS_FAILED_TO_BE_SETUP_MOD_ITEM 67
#define ASN1_F1AP_ID_SRBS_FAILED_TO_BE_SETUP_MOD_LIST 68
#define ASN1_F1AP_ID_SRBS_REQUIRED_TO_BE_RELEASED_ITEM 69
#define ASN1_F1AP_ID_SRBS_REQUIRED_TO_BE_RELEASED_LIST 70
#define ASN1_F1AP_ID_SRBS_TO_BE_RELEASED_ITEM 71
#define ASN1_F1AP_ID_SRBS_TO_BE_RELEASED_LIST 72
#define ASN1_F1AP_ID_SRBS_TO_BE_SETUP_ITEM 73
#define ASN1_F1AP_ID_SRBS_TO_BE_SETUP_LIST 74
#define ASN1_F1AP_ID_SRBS_TO_BE_SETUP_MOD_ITEM 75
#define ASN1_F1AP_ID_SRBS_TO_BE_SETUP_MOD_LIST 76
#define ASN1_F1AP_ID_TIME_TO_WAIT 77
#define ASN1_F1AP_ID_TRANSACTION_ID 78
#define ASN1_F1AP_ID_TX_ACTION_IND 79
#define ASN1_F1AP_ID_UE_ASSOCIATED_LC_F1_CONN_ITEM 80
#define ASN1_F1AP_ID_UE_ASSOCIATED_LC_F1_CONN_LIST_RES_ACK 81
#define ASN1_F1AP_ID_GNB_CU_NAME 82
#define ASN1_F1AP_ID_SCELL_FAILEDTO_SETUP_LIST 83
#define ASN1_F1AP_ID_SCELL_FAILEDTO_SETUP_ITEM 84
#define ASN1_F1AP_ID_SCELL_FAILEDTO_SETUP_MOD_LIST 85
#define ASN1_F1AP_ID_SCELL_FAILEDTO_SETUP_MOD_ITEM 86
#define ASN1_F1AP_ID_RRC_RECFG_COMPLETE_IND 87
#define ASN1_F1AP_ID_CELLS_STATUS_ITEM 88
#define ASN1_F1AP_ID_CELLS_STATUS_LIST 89
#define ASN1_F1AP_ID_CANDIDATE_SP_CELL_LIST 90
#define ASN1_F1AP_ID_CANDIDATE_SP_CELL_ITEM 91
#define ASN1_F1AP_ID_POTENTIAL_SP_CELL_LIST 92
#define ASN1_F1AP_ID_POTENTIAL_SP_CELL_ITEM 93
#define ASN1_F1AP_ID_FULL_CFG 94
#define ASN1_F1AP_ID_C_RNTI 95
#define ASN1_F1AP_ID_SP_CELL_UL_CFG 96
#define ASN1_F1AP_ID_INACTIVITY_MONITORING_REQUEST 97
#define ASN1_F1AP_ID_INACTIVITY_MONITORING_RESP 98
#define ASN1_F1AP_ID_DRB_ACTIVITY_ITEM 99
#define ASN1_F1AP_ID_DRB_ACTIVITY_LIST 100
#define ASN1_F1AP_ID_EUTRA_NR_CELL_RES_COORDINATION_REQ_CONTAINER 101
#define ASN1_F1AP_ID_EUTRA_NR_CELL_RES_COORDINATION_REQ_ACK_CONTAINER 102
#define ASN1_F1AP_ID_PROTECTED_EUTRA_RES_LIST 105
#define ASN1_F1AP_ID_REQUEST_TYPE 106
#define ASN1_F1AP_ID_SERV_CELL_IDX 107
#define ASN1_F1AP_ID_RAT_FREQ_PRIO_INFO 108
#define ASN1_F1AP_ID_EXECUTE_DUPL 109
#define ASN1_F1AP_ID_NR_CGI 111
#define ASN1_F1AP_ID_PAGING_CELL_ITEM 112
#define ASN1_F1AP_ID_PAGING_CELL_LIST 113
#define ASN1_F1AP_ID_PAGING_DRX 114
#define ASN1_F1AP_ID_PAGING_PRIO 115
#define ASN1_F1AP_ID_SITYPE_LIST 116
#define ASN1_F1AP_ID_UE_ID_IDX_VALUE 117
#define ASN1_F1AP_ID_GNB_CU_SYS_INFO 118
#define ASN1_F1AP_ID_HO_PREP_INFO 119
#define ASN1_F1AP_ID_GNB_CU_TNL_ASSOC_TO_ADD_ITEM 120
#define ASN1_F1AP_ID_GNB_CU_TNL_ASSOC_TO_ADD_LIST 121
#define ASN1_F1AP_ID_GNB_CU_TNL_ASSOC_TO_REM_ITEM 122
#define ASN1_F1AP_ID_GNB_CU_TNL_ASSOC_TO_REM_LIST 123
#define ASN1_F1AP_ID_GNB_CU_TNL_ASSOC_TO_UPD_ITEM 124
#define ASN1_F1AP_ID_GNB_CU_TNL_ASSOC_TO_UPD_LIST 125
#define ASN1_F1AP_ID_MASKED_IMEISV 126
#define ASN1_F1AP_ID_PAGING_ID 127
#define ASN1_F1AP_ID_DU_TO_CU_RRC_CONTAINER 128
#define ASN1_F1AP_ID_CELLS_TO_BE_BARRED_LIST 129
#define ASN1_F1AP_ID_CELLS_TO_BE_BARRED_ITEM 130
#define ASN1_F1AP_ID_TAI_SLICE_SUPPORT_LIST 131
#define ASN1_F1AP_ID_GNB_CU_TNL_ASSOC_SETUP_LIST 132
#define ASN1_F1AP_ID_GNB_CU_TNL_ASSOC_SETUP_ITEM 133
#define ASN1_F1AP_ID_GNB_CU_TNL_ASSOC_FAILED_TO_SETUP_LIST 134
#define ASN1_F1AP_ID_GNB_CU_TNL_ASSOC_FAILED_TO_SETUP_ITEM 135
#define ASN1_F1AP_ID_DRB_NOTIFY_ITEM 136
#define ASN1_F1AP_ID_DRB_NOTIFY_LIST 137
#define ASN1_F1AP_ID_NOTFICATION_CTRL 138
#define ASN1_F1AP_ID_RANAC 139
#define ASN1_F1AP_ID_PWS_SYS_INFO 140
#define ASN1_F1AP_ID_REPEAT_PERIOD 141
#define ASN1_F1AP_ID_NUMOF_BROADCAST_REQUEST 142
#define ASN1_F1AP_ID_CELLS_TO_BE_BROADCAST_LIST 144
#define ASN1_F1AP_ID_CELLS_TO_BE_BROADCAST_ITEM 145
#define ASN1_F1AP_ID_CELLS_BROADCAST_COMPLETED_LIST 146
#define ASN1_F1AP_ID_CELLS_BROADCAST_COMPLETED_ITEM 147
#define ASN1_F1AP_ID_BROADCAST_TO_BE_CANCELLED_LIST 148
#define ASN1_F1AP_ID_BROADCAST_TO_BE_CANCELLED_ITEM 149
#define ASN1_F1AP_ID_CELLS_BROADCAST_CANCELLED_LIST 150
#define ASN1_F1AP_ID_CELLS_BROADCAST_CANCELLED_ITEM 151
#define ASN1_F1AP_ID_NR_CGI_LIST_FOR_RESTART_LIST 152
#define ASN1_F1AP_ID_NR_CGI_LIST_FOR_RESTART_ITEM 153
#define ASN1_F1AP_ID_PWS_FAILED_NR_CGI_LIST 154
#define ASN1_F1AP_ID_PWS_FAILED_NR_CGI_ITEM 155
#define ASN1_F1AP_ID_CONFIRMED_UE_ID 156
#define ASN1_F1AP_ID_CANCEL_ALL_WARNING_MSGS_IND 157
#define ASN1_F1AP_ID_GNB_DU_UE_AMBR_UL 158
#define ASN1_F1AP_ID_DRX_CFG_IND 159
#define ASN1_F1AP_ID_RLC_STATUS 160
#define ASN1_F1AP_ID_DL_PDCP_SN_LEN 161
#define ASN1_F1AP_ID_GNB_DU_CFG_QUERY 162
#define ASN1_F1AP_ID_MEAS_TIMING_CFG 163
#define ASN1_F1AP_ID_DRB_INFO 164
#define ASN1_F1AP_ID_SERVING_PLMN 165
#define ASN1_F1AP_ID_PROTECTED_EUTRA_RES_ITEM 168
#define ASN1_F1AP_ID_GNB_CU_RRC_VERSION 170
#define ASN1_F1AP_ID_GNB_DU_RRC_VERSION 171
#define ASN1_F1AP_ID_GNB_DU_OVERLOAD_INFO 172
#define ASN1_F1AP_ID_CELL_GROUP_CFG 173
#define ASN1_F1AP_ID_RLC_FAIL_IND 174
#define ASN1_F1AP_ID_UL_TX_DIRECT_CURRENT_LIST_INFO 175
#define ASN1_F1AP_ID_DC_BASED_DUPL_CFG 176
#define ASN1_F1AP_ID_DC_BASED_DUPL_ACTIVATION 177
#define ASN1_F1AP_ID_SUL_ACCESS_IND 178
#define ASN1_F1AP_ID_AVAILABLE_PLMN_LIST 179
#define ASN1_F1AP_ID_PDU_SESSION_ID 180
#define ASN1_F1AP_ID_UL_PDU_SESSION_AGGR_MAX_BIT_RATE 181
#define ASN1_F1AP_ID_SERVING_CELL_MO 182
#define ASN1_F1AP_ID_QOS_FLOW_MAP_IND 183
#define ASN1_F1AP_ID_RRC_DELIVERY_STATUS_REQUEST 184
#define ASN1_F1AP_ID_RRC_DELIVERY_STATUS 185
#define ASN1_F1AP_ID_BEARER_TYPE_CHANGE 186
#define ASN1_F1AP_ID_RLC_MODE 187
#define ASN1_F1AP_ID_DUPL_ACTIVATION 188
#define ASN1_F1AP_ID_DED_SI_DELIVERY_NEEDED_UE_LIST 189
#define ASN1_F1AP_ID_DED_SI_DELIVERY_NEEDED_UE_ITEM 190
#define ASN1_F1AP_ID_DRX_LONG_CYCLE_START_OFFSET 191
#define ASN1_F1AP_ID_UL_PDCP_SN_LEN 192
#define ASN1_F1AP_ID_SEL_BAND_COMBINATION_IDX 193
#define ASN1_F1AP_ID_SEL_FEATURE_SET_ENTRY_IDX 194
#define ASN1_F1AP_ID_RES_COORDINATION_TRANSFER_INFO 195
#define ASN1_F1AP_ID_EXTENDED_SERVED_PLMNS_LIST 196
#define ASN1_F1AP_ID_EXTENDED_AVAILABLE_PLMN_LIST 197
#define ASN1_F1AP_ID_ASSOCIATED_SCELL_LIST 198
#define ASN1_F1AP_ID_LATEST_RRC_VERSION_ENHANCED 199
#define ASN1_F1AP_ID_ASSOCIATED_SCELL_ITEM 200
#define ASN1_F1AP_ID_CELL_DIRECTION 201
#define ASN1_F1AP_ID_SRBS_SETUP_LIST 202
#define ASN1_F1AP_ID_SRBS_SETUP_ITEM 203
#define ASN1_F1AP_ID_SRBS_SETUP_MOD_LIST 204
#define ASN1_F1AP_ID_SRBS_SETUP_MOD_ITEM 205
#define ASN1_F1AP_ID_SRBS_MODIFIED_LIST 206
#define ASN1_F1AP_ID_SRBS_MODIFIED_ITEM 207
#define ASN1_F1AP_ID_PH_INFO_SCG 208
#define ASN1_F1AP_ID_REQUESTED_BAND_COMBINATION_IDX 209
#define ASN1_F1AP_ID_REQUESTED_FEATURE_SET_ENTRY_IDX 210
#define ASN1_F1AP_ID_REQUESTED_P_MAX_FR2 211
#define ASN1_F1AP_ID_DRX_CFG 212
#define ASN1_F1AP_ID_IGNORE_RES_COORDINATION_CONTAINER 213
#define ASN1_F1AP_ID_UE_ASSIST_INFO 214
#define ASN1_F1AP_ID_NEEDFOR_GAP 215
#define ASN1_F1AP_ID_PAGING_ORIGIN 216
#define ASN1_F1AP_ID_NEW_GNB_CU_UE_F1AP_ID 217
#define ASN1_F1AP_ID_REDIRECTED_RRC_MSG 218
#define ASN1_F1AP_ID_NEW_GNB_DU_UE_F1AP_ID 219
#define ASN1_F1AP_ID_NOTIF_INFO 220
#define ASN1_F1AP_ID_PLMN_ASSIST_INFO_FOR_NET_SHAR 221
#define ASN1_F1AP_ID_UE_CONTEXT_NOT_RETRIEVABLE 222
#define ASN1_F1AP_ID_BPLMN_ID_INFO_LIST 223
#define ASN1_F1AP_ID_SEL_PLMN_ID 224
#define ASN1_F1AP_ID_UAC_ASSIST_INFO 225
#define ASN1_F1AP_ID_RAN_UE_ID 226
#define ASN1_F1AP_ID_GNB_DU_TNL_ASSOC_TO_REM_ITEM 227
#define ASN1_F1AP_ID_GNB_DU_TNL_ASSOC_TO_REM_LIST 228
#define ASN1_F1AP_ID_TNL_ASSOC_TRANSPORT_LAYER_ADDRESS_GNB_DU 229
#define ASN1_F1AP_ID_PORT_NUM 230
#define ASN1_F1AP_ID_ADD_SIB_MSG_LIST 231
#define ASN1_F1AP_ID_CELL_TYPE 232
#define ASN1_F1AP_ID_IGNORE_PRACH_CFG 233
#define ASN1_F1AP_ID_CG_CFG 234
#define ASN1_F1AP_ID_PDCCH_BLIND_DETECTION_SCG 235
#define ASN1_F1AP_ID_REQUESTED_PDCCH_BLIND_DETECTION_SCG 236
#define ASN1_F1AP_ID_PH_INFO_MCG 237
#define ASN1_F1AP_ID_MEAS_GAP_SHARING_CFG 238
#define ASN1_F1AP_ID_SYS_INFO_AREA_ID 239
#define ASN1_F1AP_ID_AREA_SCOPE 240
#define ASN1_F1AP_ID_RRC_CONTAINER_RRC_SETUP_COMPLETE 241
#define ASN1_F1AP_ID_TRACE_ACTIVATION 242
#define ASN1_F1AP_ID_TRACE_ID 243
#define ASN1_F1AP_ID_NEIGHBOUR_CELL_INFO_LIST 244
#define ASN1_F1AP_ID_SYMBOL_ALLOC_IN_SLOT 246
#define ASN1_F1AP_ID_NUM_DL_UL_SYMBOLS 247
#define ASN1_F1AP_ID_ADD_RRM_PRIO_IDX 248
#define ASN1_F1AP_ID_DU_CU_RADIO_INFO_TYPE 249
#define ASN1_F1AP_ID_CU_DU_RADIO_INFO_TYPE 250
#define ASN1_F1AP_ID_AGGRESSOR_GNB_SET_ID 251
#define ASN1_F1AP_ID_VICTIM_GNB_SET_ID 252
#define ASN1_F1AP_ID_LOWER_LAYER_PRESENCE_STATUS_CHANGE 253
#define ASN1_F1AP_ID_TRANSPORT_LAYER_ADDRESS_INFO 254
#define ASN1_F1AP_ID_NEIGHBOUR_CELL_INFO_ITEM 255
#define ASN1_F1AP_ID_INTENDED_TDD_DL_UL_CFG 256
#define ASN1_F1AP_ID_QOS_MONITORING_REQUEST 257
#define ASN1_F1AP_ID_BH_CHS_TO_BE_SETUP_LIST 258
#define ASN1_F1AP_ID_BH_CHS_TO_BE_SETUP_ITEM 259
#define ASN1_F1AP_ID_BH_CHS_SETUP_LIST 260
#define ASN1_F1AP_ID_BH_CHS_SETUP_ITEM 261
#define ASN1_F1AP_ID_BH_CHS_TO_BE_MODIFIED_ITEM 262
#define ASN1_F1AP_ID_BH_CHS_TO_BE_MODIFIED_LIST 263
#define ASN1_F1AP_ID_BH_CHS_TO_BE_RELEASED_ITEM 264
#define ASN1_F1AP_ID_BH_CHS_TO_BE_RELEASED_LIST 265
#define ASN1_F1AP_ID_BH_CHS_TO_BE_SETUP_MOD_ITEM 266
#define ASN1_F1AP_ID_BH_CHS_TO_BE_SETUP_MOD_LIST 267
#define ASN1_F1AP_ID_BH_CHS_FAILED_TO_BE_MODIFIED_ITEM 268
#define ASN1_F1AP_ID_BH_CHS_FAILED_TO_BE_MODIFIED_LIST 269
#define ASN1_F1AP_ID_BH_CHS_FAILED_TO_BE_SETUP_MOD_ITEM 270
#define ASN1_F1AP_ID_BH_CHS_FAILED_TO_BE_SETUP_MOD_LIST 271
#define ASN1_F1AP_ID_BH_CHS_MODIFIED_ITEM 272
#define ASN1_F1AP_ID_BH_CHS_MODIFIED_LIST 273
#define ASN1_F1AP_ID_BH_CHS_SETUP_MOD_ITEM 274
#define ASN1_F1AP_ID_BH_CHS_SETUP_MOD_LIST 275
#define ASN1_F1AP_ID_BH_CHS_REQUIRED_TO_BE_RELEASED_ITEM 276
#define ASN1_F1AP_ID_BH_CHS_REQUIRED_TO_BE_RELEASED_LIST 277
#define ASN1_F1AP_ID_BH_CHS_FAILED_TO_BE_SETUP_ITEM 278
#define ASN1_F1AP_ID_BH_CHS_FAILED_TO_BE_SETUP_LIST 279
#define ASN1_F1AP_ID_BH_INFO 280
#define ASN1_F1AP_ID_BAP_ADDRESS 281
#define ASN1_F1AP_ID_CFG_BAP_ADDRESS 282
#define ASN1_F1AP_ID_BH_ROUTING_INFO_ADDED_LIST 283
#define ASN1_F1AP_ID_BH_ROUTING_INFO_ADDED_LIST_ITEM 284
#define ASN1_F1AP_ID_BH_ROUTING_INFO_REMD_LIST 285
#define ASN1_F1AP_ID_BH_ROUTING_INFO_REMD_LIST_ITEM 286
#define ASN1_F1AP_ID_UL_BH_NON_UP_TRAFFIC_MAP 287
#define ASN1_F1AP_ID_ACTIV_CELLS_TO_BE_UPD_LIST 288
#define ASN1_F1AP_ID_CHILD_NODES_LIST 289
#define ASN1_F1AP_ID_IAB_INFO_IAB_DU 290
#define ASN1_F1AP_ID_IAB_INFO_IAB_DONOR_CU 291
#define ASN1_F1AP_ID_IAB_TNL_ADDRESSES_TO_REM_LIST 292
#define ASN1_F1AP_ID_IAB_TNL_ADDRESSES_TO_REM_ITEM 293
#define ASN1_F1AP_ID_IAB_ALLOCATED_TNL_ADDRESS_LIST 294
#define ASN1_F1AP_ID_IAB_ALLOCATED_TNL_ADDRESS_ITEM 295
#define ASN1_F1AP_ID_IAB_IP_V6_REQUEST_TYPE 296
#define ASN1_F1AP_ID_IA_BV4_ADDRESSES_REQUESTED 297
#define ASN1_F1AP_ID_IAB_BARRED 298
#define ASN1_F1AP_ID_TRAFFIC_MAP_INFO 299
#define ASN1_F1AP_ID_UL_UP_TNL_INFO_TO_UPD_LIST 300
#define ASN1_F1AP_ID_UL_UP_TNL_INFO_TO_UPD_LIST_ITEM 301
#define ASN1_F1AP_ID_UL_UP_TNL_ADDRESS_TO_UPD_LIST 302
#define ASN1_F1AP_ID_UL_UP_TNL_ADDRESS_TO_UPD_LIST_ITEM 303
#define ASN1_F1AP_ID_DL_UP_TNL_ADDRESS_TO_UPD_LIST 304
#define ASN1_F1AP_ID_DL_UP_TNL_ADDRESS_TO_UPD_LIST_ITEM 305
#define ASN1_F1AP_ID_NR_V2X_SERVICES_AUTHORIZED 306
#define ASN1_F1AP_ID_LTEV2X_SERVICES_AUTHORIZED 307
#define ASN1_F1AP_ID_NR_UE_SIDELINK_AGGR_MAX_BITRATE 308
#define ASN1_F1AP_ID_LTE_UE_SIDELINK_AGGR_MAX_BITRATE 309
#define ASN1_F1AP_ID_SIB12_MSG 310
#define ASN1_F1AP_ID_SIB13_MSG 311
#define ASN1_F1AP_ID_SIB14_MSG 312
#define ASN1_F1AP_ID_SL_DRBS_FAILED_TO_BE_MODIFIED_ITEM 313
#define ASN1_F1AP_ID_SL_DRBS_FAILED_TO_BE_MODIFIED_LIST 314
#define ASN1_F1AP_ID_SL_DRBS_FAILED_TO_BE_SETUP_ITEM 315
#define ASN1_F1AP_ID_SL_DRBS_FAILED_TO_BE_SETUP_LIST 316
#define ASN1_F1AP_ID_SL_DRBS_MODIFIED_ITEM 317
#define ASN1_F1AP_ID_SL_DRBS_MODIFIED_LIST 318
#define ASN1_F1AP_ID_SL_DRBS_REQUIRED_TO_BE_MODIFIED_ITEM 319
#define ASN1_F1AP_ID_SL_DRBS_REQUIRED_TO_BE_MODIFIED_LIST 320
#define ASN1_F1AP_ID_SL_DRBS_REQUIRED_TO_BE_RELEASED_ITEM 321
#define ASN1_F1AP_ID_SL_DRBS_REQUIRED_TO_BE_RELEASED_LIST 322
#define ASN1_F1AP_ID_SL_DRBS_SETUP_ITEM 323
#define ASN1_F1AP_ID_SL_DRBS_SETUP_LIST 324
#define ASN1_F1AP_ID_SL_DRBS_TO_BE_MODIFIED_ITEM 325
#define ASN1_F1AP_ID_SL_DRBS_TO_BE_MODIFIED_LIST 326
#define ASN1_F1AP_ID_SL_DRBS_TO_BE_RELEASED_ITEM 327
#define ASN1_F1AP_ID_SL_DRBS_TO_BE_RELEASED_LIST 328
#define ASN1_F1AP_ID_SL_DRBS_TO_BE_SETUP_ITEM 329
#define ASN1_F1AP_ID_SL_DRBS_TO_BE_SETUP_LIST 330
#define ASN1_F1AP_ID_SL_DRBS_TO_BE_SETUP_MOD_ITEM 331
#define ASN1_F1AP_ID_SL_DRBS_TO_BE_SETUP_MOD_LIST 332
#define ASN1_F1AP_ID_SL_DRBS_SETUP_MOD_LIST 333
#define ASN1_F1AP_ID_SL_DRBS_FAILED_TO_BE_SETUP_MOD_LIST 334
#define ASN1_F1AP_ID_SL_DRBS_SETUP_MOD_ITEM 335
#define ASN1_F1AP_ID_SL_DRBS_FAILED_TO_BE_SETUP_MOD_ITEM 336
#define ASN1_F1AP_ID_SL_DRBS_MODIFIED_CONF_LIST 337
#define ASN1_F1AP_ID_SL_DRBS_MODIFIED_CONF_ITEM 338
#define ASN1_F1AP_ID_UE_ASSIST_INFO_EUTRA 339
#define ASN1_F1AP_ID_PC5_LINK_AMBR 340
#define ASN1_F1AP_ID_SL_PHY_MAC_RLC_CFG 341
#define ASN1_F1AP_ID_SL_CFG_DED_EUTRA_INFO 342
#define ASN1_F1AP_ID_ALT_QOS_PARA_SET_LIST 343
#define ASN1_F1AP_ID_CURRENT_QOS_PARA_SET_IDX 344
#define ASN1_F1AP_ID_GNB_CU_MEAS_ID 345
#define ASN1_F1AP_ID_GNB_DU_MEAS_ID 346
#define ASN1_F1AP_ID_REGIST_REQUEST 347
#define ASN1_F1AP_ID_REPORT_CHARACTERISTICS 348
#define ASN1_F1AP_ID_CELL_TO_REPORT_LIST 349
#define ASN1_F1AP_ID_CELL_MEAS_RESULT_LIST 350
#define ASN1_F1AP_ID_HARDWARE_LOAD_IND 351
#define ASN1_F1AP_ID_REPORT_PERIODICITY 352
#define ASN1_F1AP_ID_TNL_CAPACITY_IND 353
#define ASN1_F1AP_ID_CARRIER_LIST 354
#define ASN1_F1AP_ID_UL_CARRIER_LIST 355
#define ASN1_F1AP_ID_FREQ_SHIFT7P5KHZ 356
#define ASN1_F1AP_ID_SSB_POSITIONS_IN_BURST 357
#define ASN1_F1AP_ID_NR_PRACH_CFG 358
#define ASN1_F1AP_ID_RACH_REPORT_INFO_LIST 359
#define ASN1_F1AP_ID_RLF_REPORT_INFO_LIST 360
#define ASN1_F1AP_ID_TDD_UL_DL_CFG_COMMON_NR 361
#define ASN1_F1AP_ID_CN_PACKET_DELAY_BUDGET_DL 362
#define ASN1_F1AP_ID_EXTENDED_PACKET_DELAY_BUDGET 363
#define ASN1_F1AP_ID_TSC_TRAFFIC_CHARACTERISTICS 364
#define ASN1_F1AP_ID_REPORT_REQUEST_TYPE 365
#define ASN1_F1AP_ID_TIME_REF_INFO 366
#define ASN1_F1AP_ID_CN_PACKET_DELAY_BUDGET_UL 369
#define ASN1_F1AP_ID_ADD_PDCP_DUPL_TNL_LIST 370
#define ASN1_F1AP_ID_RLC_DUPL_INFO 371
#define ASN1_F1AP_ID_ADD_DUPL_IND 372
#define ASN1_F1AP_ID_CONDITIONAL_INTER_DU_MOB_INFO 373
#define ASN1_F1AP_ID_CONDITIONAL_INTRA_DU_MOB_INFO 374
#define ASN1_F1AP_ID_TARGET_CELLS_TO_CANCEL 375
#define ASN1_F1AP_ID_REQUESTED_TARGET_CELL_GLOBAL_ID 376
#define ASN1_F1AP_ID_MANAGEMENT_BASED_MDT_PLMN_LIST 377
#define ASN1_F1AP_ID_TRACE_COLLECTION_ENTITY_IP_ADDRESS 378
#define ASN1_F1AP_ID_PRIVACY_IND 379
#define ASN1_F1AP_ID_TRACE_COLLECTION_ENTITY_URI 380
#define ASN1_F1AP_ID_MDT_CFG 381
#define ASN1_F1AP_ID_SERVING_N_ID 382
#define ASN1_F1AP_ID_NPN_BROADCAST_INFO 383
#define ASN1_F1AP_ID_NPN_SUPPORT_INFO 384
#define ASN1_F1AP_ID_N_ID 385
#define ASN1_F1AP_ID_AVAILABLE_SN_PN_ID_LIST 386
#define ASN1_F1AP_ID_SIB10_MSG 387
#define ASN1_F1AP_ID_DL_CARRIER_LIST 389
#define ASN1_F1AP_ID_EXTENDED_TAI_SLICE_SUPPORT_LIST 390
#define ASN1_F1AP_ID_REQUESTED_SRS_TX_CHARACTERISTICS 391
#define ASN1_F1AP_ID_POS_ASSIST_INFO 392
#define ASN1_F1AP_ID_POS_BROADCAST 393
#define ASN1_F1AP_ID_ROUTING_ID 394
#define ASN1_F1AP_ID_POS_ASSIST_INFO_FAIL_LIST 395
#define ASN1_F1AP_ID_POS_MEAS_QUANTITIES 396
#define ASN1_F1AP_ID_POS_MEAS_RESULT_LIST 397
#define ASN1_F1AP_ID_TRP_INFO_TYPE_LIST_TRP_REQ 398
#define ASN1_F1AP_ID_TRP_INFO_TYPE_ITEM 399
#define ASN1_F1AP_ID_TRP_INFO_LIST_TRP_RESP 400
#define ASN1_F1AP_ID_TRP_INFO_ITEM 401
#define ASN1_F1AP_ID_LMF_MEAS_ID 402
#define ASN1_F1AP_ID_SRS_TYPE 403
#define ASN1_F1AP_ID_ACTIVATION_TIME 404
#define ASN1_F1AP_ID_ABORT_TX 405
#define ASN1_F1AP_ID_POSITIONING_BROADCAST_CELLS 406
#define ASN1_F1AP_ID_SRS_CFG 407
#define ASN1_F1AP_ID_POS_REPORT_CHARACTERISTICS 408
#define ASN1_F1AP_ID_POS_MEAS_PERIODICITY 409
#define ASN1_F1AP_ID_TRP_LIST 410
#define ASN1_F1AP_ID_RAN_MEAS_ID 411
#define ASN1_F1AP_ID_LMF_UE_MEAS_ID 412
#define ASN1_F1AP_ID_RAN_UE_MEAS_ID 413
#define ASN1_F1AP_ID_E_C_ID_MEAS_QUANTITIES 414
#define ASN1_F1AP_ID_E_C_ID_MEAS_QUANTITIES_ITEM 415
#define ASN1_F1AP_ID_E_C_ID_MEAS_PERIODICITY 416
#define ASN1_F1AP_ID_E_C_ID_MEAS_RESULT 417
#define ASN1_F1AP_ID_CELL_PORTION_ID 418
#define ASN1_F1AP_ID_SFN_INITISATION_TIME 419
#define ASN1_F1AP_ID_SYS_FRAME_NUM 420
#define ASN1_F1AP_ID_SLOT_NUM 421
#define ASN1_F1AP_ID_TRP_MEAS_REQUEST_LIST 422
#define ASN1_F1AP_ID_MEAS_BEAM_INFO_REQUEST 423
#define ASN1_F1AP_ID_E_C_ID_REPORT_CHARACTERISTICS 424
#define ASN1_F1AP_ID_CFG_TAC_IND 425
#define ASN1_F1AP_ID_EXTENDED_GNB_CU_NAME 426
#define ASN1_F1AP_ID_EXTENDED_GNB_DU_NAME 427
#define ASN1_F1AP_ID_F1_C_TRANSFER_PATH 428
#define ASN1_F1AP_ID_SFN_OFFSET 429
#define ASN1_F1AP_ID_TX_STOP_IND 430
#define ASN1_F1AP_ID_SRS_FREQ 431
#define ASN1_F1AP_ID_SCG_IND 432
#define ASN1_F1AP_ID_ESTIMATED_ARRIVAL_PROBABILITY 433
#define ASN1_F1AP_ID_TRP_TYPE 434
#define ASN1_F1AP_ID_SRS_SPATIAL_RELATION_PER_SRS_RES 435
#define ASN1_F1AP_ID_PDCP_TERMINATING_NODE_DL_TNL_ADDR_INFO 436
#define ASN1_F1AP_ID_ENB_DL_TNL_ADDRESS 437
#define ASN1_F1AP_ID_POS_MEAS_PERIODICITY_EXTENDED 438
#define ASN1_F1AP_ID_PRS_RES_ID 439
#define ASN1_F1AP_ID_LOCATION_MEAS_INFO 440
#define ASN1_F1AP_ID_SLICE_RR_STATUS 441
#define ASN1_F1AP_ID_COMPOSITE_AVAILABLE_CAPACITY_SUL 442
#define ASN1_F1AP_ID_SUCCESSFUL_HO_REPORT_INFO_LIST 443
#define ASN1_F1AP_ID_NR_U_CH_LIST 444
#define ASN1_F1AP_ID_NR_U 445
#define ASN1_F1AP_ID_COVERAGE_MOD_NOTIF 446
#define ASN1_F1AP_ID_CCO_ASSIST_INFO 447
#define ASN1_F1AP_ID_NEIGHBOR_NODE_CCO_ASSIST_INFO_LIST 448
#define ASN1_F1AP_ID_CELLS_FOR_SON_LIST 449
#define ASN1_F1AP_ID_MIMO_PRB_USAGE_INFO 450
#define ASN1_F1AP_ID_GNB_CU_MBS_F1AP_ID 451
#define ASN1_F1AP_ID_GNB_DU_MBS_F1AP_ID 452
#define ASN1_F1AP_ID_MBS_AREA_SESSION_ID 453
#define ASN1_F1AP_ID_MBS_CU_TO_DU_RRC_INFO 454
#define ASN1_F1AP_ID_MBS_SESSION_ID 455
#define ASN1_F1AP_ID_SNSSAI 456
#define ASN1_F1AP_ID_MBS_BROADCAST_NEIGHBOUR_CELL_LIST 457
#define ASN1_F1AP_ID_BROADCAST_M_RBS_FAILED_TO_BE_MODIFIED_LIST 458
#define ASN1_F1AP_ID_BROADCAST_M_RBS_FAILED_TO_BE_MODIFIED_ITEM 459
#define ASN1_F1AP_ID_BROADCAST_M_RBS_FAILED_TO_BE_SETUP_LIST 460
#define ASN1_F1AP_ID_BROADCAST_M_RBS_FAILED_TO_BE_SETUP_ITEM 461
#define ASN1_F1AP_ID_BROADCAST_M_RBS_FAILED_TO_BE_SETUP_MOD_LIST 462
#define ASN1_F1AP_ID_BROADCAST_M_RBS_FAILED_TO_BE_SETUP_MOD_ITEM 463
#define ASN1_F1AP_ID_BROADCAST_M_RBS_MODIFIED_LIST 464
#define ASN1_F1AP_ID_BROADCAST_M_RBS_MODIFIED_ITEM 465
#define ASN1_F1AP_ID_BROADCAST_M_RBS_SETUP_LIST 466
#define ASN1_F1AP_ID_BROADCAST_M_RBS_SETUP_ITEM 467
#define ASN1_F1AP_ID_BROADCAST_M_RBS_SETUP_MOD_LIST 468
#define ASN1_F1AP_ID_BROADCAST_M_RBS_SETUP_MOD_ITEM 469
#define ASN1_F1AP_ID_BROADCAST_M_RBS_TO_BE_MODIFIED_LIST 470
#define ASN1_F1AP_ID_BROADCAST_M_RBS_TO_BE_MODIFIED_ITEM 471
#define ASN1_F1AP_ID_BROADCAST_M_RBS_TO_BE_RELEASED_LIST 472
#define ASN1_F1AP_ID_BROADCAST_M_RBS_TO_BE_RELEASED_ITEM 473
#define ASN1_F1AP_ID_BROADCAST_M_RBS_TO_BE_SETUP_LIST 474
#define ASN1_F1AP_ID_BROADCAST_M_RBS_TO_BE_SETUP_ITEM 475
#define ASN1_F1AP_ID_BROADCAST_M_RBS_TO_BE_SETUP_MOD_LIST 476
#define ASN1_F1AP_ID_BROADCAST_M_RBS_TO_BE_SETUP_MOD_ITEM 477
#define ASN1_F1AP_ID_SUPPORTED_MBS_FSA_ID_LIST 478
#define ASN1_F1AP_ID_UE_ID_LIST_FOR_PAGING_LIST 479
#define ASN1_F1AP_ID_UE_ID_LIST_FOR_PAGING_ITEM 480
#define ASN1_F1AP_ID_MBS_SERVICE_AREA 481
#define ASN1_F1AP_ID_MULTICAST_M_RBS_FAILED_TO_BE_MODIFIED_LIST 482
#define ASN1_F1AP_ID_MULTICAST_M_RBS_FAILED_TO_BE_MODIFIED_ITEM 483
#define ASN1_F1AP_ID_MULTICAST_M_RBS_FAILED_TO_BE_SETUP_LIST 484
#define ASN1_F1AP_ID_MULTICAST_M_RBS_FAILED_TO_BE_SETUP_ITEM 485
#define ASN1_F1AP_ID_MULTICAST_M_RBS_FAILED_TO_BE_SETUP_MOD_LIST 486
#define ASN1_F1AP_ID_MULTICAST_M_RBS_FAILED_TO_BE_SETUP_MOD_ITEM 487
#define ASN1_F1AP_ID_MULTICAST_M_RBS_MODIFIED_LIST 488
#define ASN1_F1AP_ID_MULTICAST_M_RBS_MODIFIED_ITEM 489
#define ASN1_F1AP_ID_MULTICAST_M_RBS_SETUP_LIST 490
#define ASN1_F1AP_ID_MULTICAST_M_RBS_SETUP_ITEM 491
#define ASN1_F1AP_ID_MULTICAST_M_RBS_SETUP_MOD_LIST 492
#define ASN1_F1AP_ID_MULTICAST_M_RBS_SETUP_MOD_ITEM 493
#define ASN1_F1AP_ID_MULTICAST_M_RBS_TO_BE_MODIFIED_LIST 494
#define ASN1_F1AP_ID_MULTICAST_M_RBS_TO_BE_MODIFIED_ITEM 495
#define ASN1_F1AP_ID_MULTICAST_M_RBS_TO_BE_RELEASED_LIST 496
#define ASN1_F1AP_ID_MULTICAST_M_RBS_TO_BE_RELEASED_ITEM 497
#define ASN1_F1AP_ID_MULTICAST_M_RBS_TO_BE_SETUP_LIST 498
#define ASN1_F1AP_ID_MULTICAST_M_RBS_TO_BE_SETUP_ITEM 499
#define ASN1_F1AP_ID_MULTICAST_M_RBS_TO_BE_SETUP_MOD_LIST 500
#define ASN1_F1AP_ID_MULTICAST_M_RBS_TO_BE_SETUP_MOD_ITEM 501
#define ASN1_F1AP_ID_MBS_MULTICAST_F1_U_CONTEXT_DESCRIPTOR 502
#define ASN1_F1AP_ID_MULTICAST_F1_U_CONTEXT_TO_BE_SETUP_LIST 503
#define ASN1_F1AP_ID_MULTICAST_F1_U_CONTEXT_TO_BE_SETUP_ITEM 504
#define ASN1_F1AP_ID_MULTICAST_F1_U_CONTEXT_SETUP_LIST 505
#define ASN1_F1AP_ID_MULTICAST_F1_U_CONTEXT_SETUP_ITEM 506
#define ASN1_F1AP_ID_MULTICAST_F1_U_CONTEXT_FAILED_TO_BE_SETUP_LIST 507
#define ASN1_F1AP_ID_MULTICAST_F1_U_CONTEXT_FAILED_TO_BE_SETUP_ITEM 508
#define ASN1_F1AP_ID_IAB_CONGESTION_IND 509
#define ASN1_F1AP_ID_IAB_CONDITIONAL_RRC_MSG_DELIVERY_IND 510
#define ASN1_F1AP_ID_F1_C_TRANSFER_PATH_NR_DC 511
#define ASN1_F1AP_ID_BUFFER_SIZE_THRESH 512
#define ASN1_F1AP_ID_IAB_TNL_ADDRESSES_EXCEPTION 513
#define ASN1_F1AP_ID_BAP_HDR_REWRITING_ADDED_LIST 514
#define ASN1_F1AP_ID_BAP_HDR_REWRITING_ADDED_LIST_ITEM 515
#define ASN1_F1AP_ID_RE_ROUTING_ENABLE_IND 516
#define ASN1_F1AP_ID_NON_F1TERMINATING_TOPOLOGY_IND 517
#define ASN1_F1AP_ID_EGRESS_NON_F1TERMINATING_TOPOLOGY_IND 518
#define ASN1_F1AP_ID_INGRESS_NON_F1TERMINATING_TOPOLOGY_IND 519
#define ASN1_F1AP_ID_R_B_SET_CFG 520
#define ASN1_F1AP_ID_FREQ_DOMAIN_H_SN_A_CFG_LIST 521
#define ASN1_F1AP_ID_CHILD_IAB_NODES_NA_RES_LIST 522
#define ASN1_F1AP_ID_PARENT_IAB_NODES_NA_RES_CFG_LIST 523
#define ASN1_F1AP_ID_U_L_FREQ_INFO 524
#define ASN1_F1AP_ID_U_L_TX_BW 525
#define ASN1_F1AP_ID_D_L_FREQ_INFO 526
#define ASN1_F1AP_ID_D_L_TX_BW 527
#define ASN1_F1AP_ID_U_L_NR_CARRIER_LIST 528
#define ASN1_F1AP_ID_D_L_NR_CARRIER_LIST 529
#define ASN1_F1AP_ID_N_R_FREQ_INFO 530
#define ASN1_F1AP_ID_TX_BW 531
#define ASN1_F1AP_ID_N_R_CARRIER_LIST 532
#define ASN1_F1AP_ID_NEIGHBOUR_NODE_CELLS_LIST 533
#define ASN1_F1AP_ID_SERVING_CELLS_LIST 534
#define ASN1_F1AP_ID_PERMUTATION 535
#define ASN1_F1AP_ID_MDT_POLLUTED_MEAS_IND 536
#define ASN1_F1AP_ID_M5_REPORT_AMOUNT 537
#define ASN1_F1AP_ID_M6_REPORT_AMOUNT 538
#define ASN1_F1AP_ID_M7_REPORT_AMOUNT 539
#define ASN1_F1AP_ID_SURVIVAL_TIME 540
#define ASN1_F1AP_ID_PDC_MEAS_PERIODICITY 541
#define ASN1_F1AP_ID_PDC_MEAS_QUANTITIES 542
#define ASN1_F1AP_ID_PDC_MEAS_QUANTITIES_ITEM 543
#define ASN1_F1AP_ID_PDC_MEAS_RESULT 544
#define ASN1_F1AP_ID_PDC_REPORT_TYPE 545
#define ASN1_F1AP_ID_RAN_UE_PDC_MEAS_ID 546
#define ASN1_F1AP_ID_SCG_ACTIVATION_REQUEST 547
#define ASN1_F1AP_ID_SCG_ACTIVATION_STATUS 548
#define ASN1_F1AP_ID_PRSTRP_LIST 549
#define ASN1_F1AP_ID_PRS_TX_TRP_LIST 550
#define ASN1_F1AP_ID_ON_DEMAND_PRS 551
#define ASN1_F1AP_ID_AO_A_SEARCH_WIN 552
#define ASN1_F1AP_ID_TRP_MEAS_UPD_LIST 553
#define ASN1_F1AP_ID_ZO_A_INFO 554
#define ASN1_F1AP_ID_RESP_TIME 555
#define ASN1_F1AP_ID_ARP_LOCATION_INFO 556
#define ASN1_F1AP_ID_ARP_ID 557
#define ASN1_F1AP_ID_MULTIPLE_UL_AO_A 558
#define ASN1_F1AP_ID_UL_SRS_RSRP_P 559
#define ASN1_F1AP_ID_SRS_RESTYPE 560
#define ASN1_F1AP_ID_EXTENDED_ADD_PATH_LIST 561
#define ASN1_F1AP_ID_LO_S_N_LO_SI_NFORMATION 562
#define ASN1_F1AP_ID_NOF_TRP_RX_TEG 564
#define ASN1_F1AP_ID_NOF_TRP_RX_TX_TEG 565
#define ASN1_F1AP_ID_TRP_TX_TEG_ASSOC 566
#define ASN1_F1AP_ID_TRPTEG_INFO 567
#define ASN1_F1AP_ID_TRP_RX_TEG_INFO 568
#define ASN1_F1AP_ID_TRP_PRS_INFO_LIST 569
#define ASN1_F1AP_ID_PRS_MEAS_INFO_LIST 570
#define ASN1_F1AP_ID_PRS_CFG_REQUEST_TYPE 571
#define ASN1_F1AP_ID_MEAS_TIME_OCCASION 573
#define ASN1_F1AP_ID_MEAS_CHARACTERISTICS_REQUEST_IND 574
#define ASN1_F1AP_ID_UE_REPORT_INFO 575
#define ASN1_F1AP_ID_POS_CONEXT_REV_IND 576
#define ASN1_F1AP_ID_TRP_BEAM_ANT_INFO 577
#define ASN1_F1AP_ID_NR_RED_CAP_UE_IND 578
#define ASN1_F1AP_ID_REDCAP_BCAST_INFO 579
#define ASN1_F1AP_ID_RAN_UE_PAGING_DRX 580
#define ASN1_F1AP_ID_CN_UE_PAGING_DRX 581
#define ASN1_F1AP_ID_NR_PAGINGE_DRX_INFO 582
#define ASN1_F1AP_ID_NR_PAGINGE_DRX_INFOFOR_RRC_INACTIVE 583
#define ASN1_F1AP_ID_NR_TADV 584
#define ASN1_F1AP_ID_QO_E_INFO 585
#define ASN1_F1AP_ID_CG_SDT_QUERY_IND 586
#define ASN1_F1AP_ID_SDT_MAC_PHY_CG_CFG 587
#define ASN1_F1AP_ID_CG_SDT_KEPT_IND 588
#define ASN1_F1AP_ID_CG_SD_TIND_SETUP 589
#define ASN1_F1AP_ID_CG_SD_TIND_MOD 590
#define ASN1_F1AP_ID_CG_SDT_SESSION_INFO_OLD 591
#define ASN1_F1AP_ID_SDT_INFO 592
#define ASN1_F1AP_ID_SDT_RLC_BEARER_CFG 593
#define ASN1_F1AP_ID_FIVE_G_PRO_SE_AUTHORIZED 594
#define ASN1_F1AP_ID_FIVE_G_PRO_SE_UE_PC5_AGGR_MAX_BITRATE 595
#define ASN1_F1AP_ID_FIVE_G_PRO_SE_PC5_LINK_AMBR 596
#define ASN1_F1AP_ID_SRB_MAP_INFO 597
#define ASN1_F1AP_ID_DRB_MAP_INFO 598
#define ASN1_F1AP_ID_UU_RLC_CH_TO_BE_SETUP_LIST 599
#define ASN1_F1AP_ID_UU_RLC_CH_TO_BE_MODIFIED_LIST 600
#define ASN1_F1AP_ID_UU_RLC_CH_TO_BE_RELEASED_LIST 601
#define ASN1_F1AP_ID_UU_RLC_CH_SETUP_LIST 602
#define ASN1_F1AP_ID_UU_RLC_CH_FAILED_TO_BE_SETUP_LIST 603
#define ASN1_F1AP_ID_UU_RLC_CH_MODIFIED_LIST 604
#define ASN1_F1AP_ID_UU_RLC_CH_FAILED_TO_BE_MODIFIED_LIST 605
#define ASN1_F1AP_ID_UU_RLC_CH_REQUIRED_TO_BE_MODIFIED_LIST 606
#define ASN1_F1AP_ID_UU_RLC_CH_REQUIRED_TO_BE_RELEASED_LIST 607
#define ASN1_F1AP_ID_PC5_RLC_CH_TO_BE_SETUP_LIST 608
#define ASN1_F1AP_ID_PC5_RLC_CH_TO_BE_MODIFIED_LIST 609
#define ASN1_F1AP_ID_PC5_RLC_CH_TO_BE_RELEASED_LIST 610
#define ASN1_F1AP_ID_PC5_RLC_CH_SETUP_LIST 611
#define ASN1_F1AP_ID_PC5_RLC_CH_FAILED_TO_BE_SETUP_LIST 612
#define ASN1_F1AP_ID_PC5_RLC_CH_FAILED_TO_BE_MODIFIED_LIST 613
#define ASN1_F1AP_ID_PC5_RLC_CH_REQUIRED_TO_BE_MODIFIED_LIST 614
#define ASN1_F1AP_ID_PC5_RLC_CH_REQUIRED_TO_BE_RELEASED_LIST 615
#define ASN1_F1AP_ID_PC5_RLC_CH_MODIFIED_LIST 616
#define ASN1_F1AP_ID_SIDELINK_RELAY_CFG 617
#define ASN1_F1AP_ID_UPD_REMOTE_UE_LOCAL_ID 618
#define ASN1_F1AP_ID_PATH_SWITCH_CFG 619
#define ASN1_F1AP_ID_PAGING_CAUSE 620
#define ASN1_F1AP_ID_MU_SI_M_GAP_CFG 621
#define ASN1_F1AP_ID_PE_IP_S_ASSIST_INFO 622
#define ASN1_F1AP_ID_UE_PAGING_CAP 623
#define ASN1_F1AP_ID_LAST_USED_CELL_IND 624
#define ASN1_F1AP_ID_SIB17_MSG 625
#define ASN1_F1AP_ID_GNB_DU_UE_SLICE_MAX_BIT_RATE_LIST 626
#define ASN1_F1AP_ID_SIB20_MSG 627
#define ASN1_F1AP_ID_UE_MULTICAST_M_RBS_TO_BE_RELEASED_LIST 628
#define ASN1_F1AP_ID_UE_MULTICAST_M_RBS_TO_BE_RELEASED_ITEM 629
#define ASN1_F1AP_ID_UE_MULTICAST_M_RBS_TO_BE_SETUP_LIST 630
#define ASN1_F1AP_ID_UE_MULTICAST_M_RBS_TO_BE_SETUP_ITEM 631
#define ASN1_F1AP_ID_MULTICAST_MBS_SESSION_SETUP_LIST 632
#define ASN1_F1AP_ID_MULTICAST_MBS_SESSION_REM_LIST 633
#define ASN1_F1AP_ID_POS_MEAS_AMOUNT 634
#define ASN1_F1AP_ID_SDT_TERMINATION_REQUEST 635
#define ASN1_F1AP_ID_PATH_PWR 636
#define ASN1_F1AP_ID_DU_RX_MT_RX_EXTEND 637
#define ASN1_F1AP_ID_DU_TX_MT_TX_EXTEND 638
#define ASN1_F1AP_ID_DU_RX_MT_TX_EXTEND 639
#define ASN1_F1AP_ID_DU_TX_MT_RX_EXTEND 640
#define ASN1_F1AP_ID_BAP_HDR_REWRITING_REMD_LIST 641
#define ASN1_F1AP_ID_BAP_HDR_REWRITING_REMD_LIST_ITEM 642
#define ASN1_F1AP_ID_SLDRX_CYCLE_LIST 643
#define ASN1_F1AP_ID_TAI_NSAG_SUPPORT_LIST 644
#define ASN1_F1AP_ID_SL_RLC_CH_TO_ADD_MOD_LIST 645
#define ASN1_F1AP_ID_BROADCAST_AREA_SCOPE 646
#define ASN1_F1AP_ID_MANAGEMENT_BASED_MDT_PLMN_MOD_LIST 647
#define ASN1_F1AP_ID_SIB15_MSG 648
#define ASN1_F1AP_ID_ACTIVATION_REQUEST_TYPE 649
#define ASN1_F1AP_ID_POS_MEAS_GAP_PRE_CFG_LIST 650
#define ASN1_F1AP_ID_INTERFREQ_CFG_NO_GAP 651
#define ASN1_F1AP_ID_MB_SI_NTEREST_IND 652
#define ASN1_F1AP_ID_UE_MULTICAST_M_RBS_CONFIRMED_TO_BE_MODIFIED_LIST 653
#define ASN1_F1AP_ID_UE_MULTICAST_M_RBS_CONFIRMED_TO_BE_MODIFIED_ITEM 654
#define ASN1_F1AP_ID_UE_MULTICAST_M_RBS_REQUIRED_TO_BE_MODIFIED_LIST 655
#define ASN1_F1AP_ID_UE_MULTICAST_M_RBS_REQUIRED_TO_BE_MODIFIED_ITEM 656
#define ASN1_F1AP_ID_UE_MULTICAST_M_RBS_REQUIRED_TO_BE_RELEASED_LIST 657
#define ASN1_F1AP_ID_UE_MULTICAST_M_RBS_REQUIRED_TO_BE_RELEASED_ITEM 658
#define ASN1_F1AP_ID_L571_INFO 659
#define ASN1_F1AP_ID_L1151_INFO 660
#define ASN1_F1AP_ID_SCS_480 661
#define ASN1_F1AP_ID_SCS_960 662
#define ASN1_F1AP_ID_SRS_PORT_IDX 663
#define ASN1_F1AP_ID_PEI_SUBGROUPING_SUPPORT_IND 664
#define ASN1_F1AP_ID_NEED_FOR_GAPS_INFO_NR 665
#define ASN1_F1AP_ID_NEED_FOR_GAP_NCSG_INFO_NR 666
#define ASN1_F1AP_ID_NEED_FOR_GAP_NCSG_INFO_EUTRA 667
#define ASN1_F1AP_ID_PROC_CODE_668_NOT_TO_BE_USED 668
#define ASN1_F1AP_ID_PROC_CODE_669_NOT_TO_BE_USED 669
#define ASN1_F1AP_ID_PROC_CODE_670_NOT_TO_BE_USED 670
#define ASN1_F1AP_ID_SOURCE_MRB_ID 671
#define ASN1_F1AP_ID_POS_MEAS_PERIODICITY_NR_AO_A 672
#define ASN1_F1AP_ID_RED_CAP_IND 673
#define ASN1_F1AP_ID_SRS_POS_RRC_INACTIVE_CFG 674
#define ASN1_F1AP_ID_SDT_BEARER_CFG_QUERY_IND 675
#define ASN1_F1AP_ID_SDT_BEARER_CFG_INFO 676
#define ASN1_F1AP_ID_UL_GAP_FR2_CFG 677
#define ASN1_F1AP_ID_CFG_RESTRICT_INFO_DAPS 678
#define ASN1_F1AP_ID_UE_MULTICAST_M_RBS_SETUP_LIST 679
#define ASN1_F1AP_ID_UE_MULTICAST_M_RBS_SETUP_ITEM 680
#define ASN1_F1AP_ID_MULTICAST_F1_U_CONTEXT_REF_CU 681
#define ASN1_F1AP_ID_POS_SITYPE_LIST 682
#define ASN1_F1AP_ID_DAPS_HO_STATUS 683
#define ASN1_F1AP_ID_UL_TX_DIRECT_CURRENT_TWO_CARRIER_LIST_INFO 684
#define ASN1_F1AP_ID_UE_MULTICAST_M_RBS_TO_BE_SETUP_AT_MODIFY_LIST 685
#define ASN1_F1AP_ID_UE_MULTICAST_M_RBS_TO_BE_SETUP_AT_MODIFY_ITEM 686
#define ASN1_F1AP_ID_MC_PAGING_CELL_LIST 687
#define ASN1_F1AP_ID_MC_PAGING_CELL_ITEM 688
#define ASN1_F1AP_ID_SRS_POS_RRC_INACTIVE_QUERY_IND 689
#define ASN1_F1AP_ID_UL_TX_DIRECT_CURRENT_MORE_CARRIER_INFO 690
#define ASN1_F1AP_ID_CP_ACMCG_INFO 691
#define ASN1_F1AP_ID_TWO_PHR_MODE_MCG 692
#define ASN1_F1AP_ID_TWO_PHR_MODE_SCG 693
#define ASN1_F1AP_ID_EXTENDED_UE_ID_IDX_VALUE 694
#define ASN1_F1AP_ID_SERVING_CELL_MO_LIST 695
#define ASN1_F1AP_ID_SERVING_CELL_MO_LIST_ITEM 696
#define ASN1_F1AP_ID_SERVING_CELL_MO_ENCODED_IN_CGC_LIST 697

/*******************************************************************************
 *                              Struct Definitions
 ******************************************************************************/

// LocationUncertainty-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using location_uncertainty_ext_ies_o = protocol_ext_empty_o;

using location_uncertainty_ext_ies_container = protocol_ext_container_empty_l;

// LocationUncertainty ::= SEQUENCE
struct location_uncertainty_s {
  bool                                   ie_exts_present        = false;
  uint16_t                               horizontal_uncertainty = 0;
  uint8_t                                horizontal_confidence  = 0;
  uint16_t                               vertical_uncertainty   = 0;
  uint8_t                                vertical_confidence    = 0;
  location_uncertainty_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RelativeCartesianLocation-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using relative_cartesian_location_ext_ies_o = protocol_ext_empty_o;

// RelativeGeodeticLocation-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using relative_geodetic_location_ext_ies_o = protocol_ext_empty_o;

// ARPLocationType-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
using arp_location_type_ext_ies_o = protocol_ies_empty_o;

using relative_cartesian_location_ext_ies_container = protocol_ext_container_empty_l;

// RelativeCartesianLocation ::= SEQUENCE
struct relative_cartesian_location_s {
  struct xy_zunit_opts {
    enum options { mm, cm, dm, /*...*/ nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<xy_zunit_opts, true> xy_zunit_e_;

  // member variables
  bool                                          ie_exts_present = false;
  xy_zunit_e_                                   xy_zunit;
  int32_t                                       xvalue = -65536;
  int32_t                                       yvalue = -65536;
  int32_t                                       zvalue = -32768;
  location_uncertainty_s                        location_uncertainty;
  relative_cartesian_location_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using relative_geodetic_location_ext_ies_container = protocol_ext_container_empty_l;

// RelativeGeodeticLocation ::= SEQUENCE
struct relative_geodetic_location_s {
  struct milli_arc_second_units_opts {
    enum options { zerodot03, zerodot3, three, /*...*/ nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<milli_arc_second_units_opts, true> milli_arc_second_units_e_;
  struct height_units_opts {
    enum options { mm, cm, m, /*...*/ nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<height_units_opts, true> height_units_e_;

  // member variables
  bool                                         ie_exts_present = false;
  milli_arc_second_units_e_                    milli_arc_second_units;
  height_units_e_                              height_units;
  int16_t                                      delta_latitude  = -1024;
  int16_t                                      delta_longitude = -1024;
  int16_t                                      delta_height    = -1024;
  location_uncertainty_s                       location_uncertainty;
  relative_geodetic_location_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// ARPLocationInformation-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using arp_location_info_ext_ies_o = protocol_ext_empty_o;

// ARPLocationType ::= CHOICE
struct arp_location_type_c {
  struct types_opts {
    enum options { arp_position_relative_geodetic, arp_position_relative_cartesian, choice_ext, nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  arp_location_type_c() = default;
  arp_location_type_c(const arp_location_type_c& other);
  arp_location_type_c& operator=(const arp_location_type_c& other);
  ~arp_location_type_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  relative_geodetic_location_s& arp_position_relative_geodetic()
  {
    assert_choice_type(types::arp_position_relative_geodetic, type_, "ARPLocationType");
    return c.get<relative_geodetic_location_s>();
  }
  relative_cartesian_location_s& arp_position_relative_cartesian()
  {
    assert_choice_type(types::arp_position_relative_cartesian, type_, "ARPLocationType");
    return c.get<relative_cartesian_location_s>();
  }
  protocol_ie_single_container_s<arp_location_type_ext_ies_o>& choice_ext()
  {
    assert_choice_type(types::choice_ext, type_, "ARPLocationType");
    return c.get<protocol_ie_single_container_s<arp_location_type_ext_ies_o>>();
  }
  const relative_geodetic_location_s& arp_position_relative_geodetic() const
  {
    assert_choice_type(types::arp_position_relative_geodetic, type_, "ARPLocationType");
    return c.get<relative_geodetic_location_s>();
  }
  const relative_cartesian_location_s& arp_position_relative_cartesian() const
  {
    assert_choice_type(types::arp_position_relative_cartesian, type_, "ARPLocationType");
    return c.get<relative_cartesian_location_s>();
  }
  const protocol_ie_single_container_s<arp_location_type_ext_ies_o>& choice_ext() const
  {
    assert_choice_type(types::choice_ext, type_, "ARPLocationType");
    return c.get<protocol_ie_single_container_s<arp_location_type_ext_ies_o>>();
  }
  relative_geodetic_location_s&                                set_arp_position_relative_geodetic();
  relative_cartesian_location_s&                               set_arp_position_relative_cartesian();
  protocol_ie_single_container_s<arp_location_type_ext_ies_o>& set_choice_ext();

private:
  types type_;
  choice_buffer_t<protocol_ie_single_container_s<arp_location_type_ext_ies_o>,
                  relative_cartesian_location_s,
                  relative_geodetic_location_s>
      c;

  void destroy_();
};

using arp_location_info_ext_ies_container = protocol_ext_container_empty_l;

// ARPLocationInformation-Item ::= SEQUENCE
struct arp_location_info_item_s {
  bool                                ext             = false;
  bool                                ie_exts_present = false;
  uint8_t                             arp_id          = 1;
  arp_location_type_c                 arp_location_type;
  arp_location_info_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// ARPLocationInformation ::= SEQUENCE (SIZE (1..16)) OF ARPLocationInformation-Item
using arp_location_info_l = dyn_array<arp_location_info_item_s>;

// AbortTransmission-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
using abort_tx_ext_ies_o = protocol_ies_empty_o;

// AbortTransmission ::= CHOICE
struct abort_tx_c {
  struct types_opts {
    enum options { srs_res_set_id, release_all, choice_ext, nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  abort_tx_c() = default;
  abort_tx_c(const abort_tx_c& other);
  abort_tx_c& operator=(const abort_tx_c& other);
  ~abort_tx_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  uint8_t& srs_res_set_id()
  {
    assert_choice_type(types::srs_res_set_id, type_, "AbortTransmission");
    return c.get<uint8_t>();
  }
  protocol_ie_single_container_s<abort_tx_ext_ies_o>& choice_ext()
  {
    assert_choice_type(types::choice_ext, type_, "AbortTransmission");
    return c.get<protocol_ie_single_container_s<abort_tx_ext_ies_o>>();
  }
  const uint8_t& srs_res_set_id() const
  {
    assert_choice_type(types::srs_res_set_id, type_, "AbortTransmission");
    return c.get<uint8_t>();
  }
  const protocol_ie_single_container_s<abort_tx_ext_ies_o>& choice_ext() const
  {
    assert_choice_type(types::choice_ext, type_, "AbortTransmission");
    return c.get<protocol_ie_single_container_s<abort_tx_ext_ies_o>>();
  }
  uint8_t&                                            set_srs_res_set_id();
  void                                                set_release_all();
  protocol_ie_single_container_s<abort_tx_ext_ies_o>& set_choice_ext();

private:
  types                                                               type_;
  choice_buffer_t<protocol_ie_single_container_s<abort_tx_ext_ies_o>> c;

  void destroy_();
};

// RACHReportInformationItem-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using rach_report_info_item_ext_ies_o = protocol_ext_empty_o;

// RLFReportInformationItem-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using rlf_report_info_item_ext_ies_o = protocol_ext_empty_o;

// SuccessfulHOReportInformation-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using successful_ho_report_info_item_ext_ies_o = protocol_ext_empty_o;

using rach_report_info_item_ext_ies_container = protocol_ext_container_empty_l;

// RACHReportInformationItem ::= SEQUENCE
struct rach_report_info_item_s {
  bool                                    ext                    = false;
  bool                                    ue_assitant_id_present = false;
  bool                                    ie_exts_present        = false;
  unbounded_octstring<true>               rach_report_container;
  uint64_t                                ue_assitant_id = 0;
  rach_report_info_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using rlf_report_info_item_ext_ies_container = protocol_ext_container_empty_l;

// RLFReportInformationItem ::= SEQUENCE
struct rlf_report_info_item_s {
  bool                                   ext                    = false;
  bool                                   ue_assitant_id_present = false;
  bool                                   ie_exts_present        = false;
  unbounded_octstring<true>              nr_ue_rlf_report_container;
  uint64_t                               ue_assitant_id = 0;
  rlf_report_info_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using successful_ho_report_info_item_ext_ies_container = protocol_ext_container_empty_l;

// SuccessfulHOReportInformation-Item ::= SEQUENCE
struct successful_ho_report_info_item_s {
  bool                                             ie_exts_present = false;
  unbounded_octstring<true>                        successful_ho_report_container;
  successful_ho_report_info_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RACHReportInformationList ::= SEQUENCE (SIZE (1..64)) OF RACHReportInformationItem
using rach_report_info_list_l = dyn_array<rach_report_info_item_s>;

// RLFReportInformationList ::= SEQUENCE (SIZE (1..64)) OF RLFReportInformationItem
using rlf_report_info_list_l = dyn_array<rlf_report_info_item_s>;

// SuccessfulHOReportInformationList ::= SEQUENCE (SIZE (1..64)) OF SuccessfulHOReportInformation-Item
using successful_ho_report_info_list_l = dyn_array<successful_ho_report_info_item_s>;

// AccessAndMobilityIndicationIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct access_and_mob_ind_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options {
        transaction_id,
        rach_report_info_list,
        rlf_report_info_list,
        successful_ho_report_info_list,
        nulltype
      } value;
      typedef uint8_t number_type;

      const char* to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint16_t&                               transaction_id();
    rach_report_info_list_l&                rach_report_info_list();
    rlf_report_info_list_l&                 rlf_report_info_list();
    successful_ho_report_info_list_l&       successful_ho_report_info_list();
    const uint16_t&                         transaction_id() const;
    const rach_report_info_list_l&          rach_report_info_list() const;
    const rlf_report_info_list_l&           rlf_report_info_list() const;
    const successful_ho_report_info_list_l& successful_ho_report_info_list() const;

  private:
    types                                                                                              type_;
    choice_buffer_t<rach_report_info_list_l, rlf_report_info_list_l, successful_ho_report_info_list_l> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

struct access_and_mob_ind_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                                                  rach_report_info_list_present          = false;
  bool                                                                  rlf_report_info_list_present           = false;
  bool                                                                  successful_ho_report_info_list_present = false;
  ie_field_s<integer<uint16_t, 0, 255, true, true>>                     transaction_id;
  ie_field_s<dyn_seq_of<rach_report_info_item_s, 1, 64, true>>          rach_report_info_list;
  ie_field_s<dyn_seq_of<rlf_report_info_item_s, 1, 64, true>>           rlf_report_info_list;
  ie_field_s<dyn_seq_of<successful_ho_report_info_item_s, 1, 64, true>> successful_ho_report_info_list;

  // sequence methods
  access_and_mob_ind_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// AccessAndMobilityIndication ::= SEQUENCE
using access_and_mob_ind_s = elementary_procedure_option<access_and_mob_ind_ies_container>;

// AccessPointPosition-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using access_point_position_ext_ies_o = protocol_ext_empty_o;

using access_point_position_ext_ies_container = protocol_ext_container_empty_l;

// AccessPointPosition ::= SEQUENCE
struct access_point_position_s {
  struct latitude_sign_opts {
    enum options { north, south, nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<latitude_sign_opts> latitude_sign_e_;
  struct direction_of_altitude_opts {
    enum options { height, depth, nulltype } value;
    typedef uint8_t number_type;

    const char* to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<direction_of_altitude_opts> direction_of_altitude_e_;

  // member variables
  bool                                    ie_exts_present = false;
  latitude_sign_e_                        latitude_sign;
  uint32_t                                latitude  = 0;
  int32_t                                 longitude = -8388608;
  direction_of_altitude_e_                direction_of_altitude;
  uint16_t                                altitude                  = 0;
  uint8_t                                 uncertainty_semi_major    = 0;
  uint8_t                                 uncertainty_semi_minor    = 0;
  uint8_t                                 orientation_of_major_axis = 0;
  uint8_t                                 uncertainty_altitude      = 0;
  uint8_t                                 confidence                = 0;
  access_point_position_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// NRCGI-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using nr_cgi_ext_ies_o = protocol_ext_empty_o;

using nr_cgi_ext_ies_container = protocol_ext_container_empty_l;

// NRCGI ::= SEQUENCE
struct nr_cgi_s {
  bool                             ext             = false;
  bool                             ie_exts_present = false;
  fixed_octstring<3, true>         plmn_id;
  fixed_bitstring<36, false, true> nr_cell_id;
  nr_cgi_ext_ies_container         ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// AccessSuccessIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct access_success_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { gnb_cu_ue_f1ap_id, gnb_du_ue_f1ap_id, nr_cgi, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint64_t&       gnb_cu_ue_f1ap_id();
    uint64_t&       gnb_du_ue_f1ap_id();
    nr_cgi_s&       nr_cgi();
    const uint64_t& gnb_cu_ue_f1ap_id() const;
    const uint64_t& gnb_du_ue_f1ap_id() const;
    const nr_cgi_s& nr_cgi() const;

  private:
    types                     type_;
    choice_buffer_t<nr_cgi_s> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

struct access_success_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_cu_ue_f1ap_id;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_du_ue_f1ap_id;
  ie_field_s<nr_cgi_s>                                      nr_cgi;

  // sequence methods
  access_success_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// AccessSuccess ::= SEQUENCE
using access_success_s = elementary_procedure_option<access_success_ies_container>;

// Frequency-Domain-HSNA-Slot-Configuration-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using freq_domain_h_sn_a_slot_cfg_item_ext_ies_o = protocol_ext_empty_o;

// HSNADownlink ::= ENUMERATED
struct h_sn_a_dl_opts {
  enum options { hard, soft, notavailable, nulltype } value;

  const char* to_string() const;
};
typedef enumerated<h_sn_a_dl_opts> h_sn_a_dl_e;

// HSNAFlexible ::= ENUMERATED
struct h_sn_a_flex_opts {
  enum options { hard, soft, notavailable, nulltype } value;

  const char* to_string() const;
};
typedef enumerated<h_sn_a_flex_opts> h_sn_a_flex_e;

// HSNAUplink ::= ENUMERATED
struct h_sn_a_ul_opts {
  enum options { hard, soft, notavailable, nulltype } value;

  const char* to_string() const;
};
typedef enumerated<h_sn_a_ul_opts> h_sn_a_ul_e;

// NA-Resource-Configuration-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using na_res_cfg_item_ext_ies_o = protocol_ext_empty_o;

// NADownlink ::= ENUMERATED
struct na_dl_opts {
  enum options { true_value, false_value, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<na_dl_opts, true> na_dl_e;

// NAFlexible ::= ENUMERATED
struct na_flex_opts {
  enum options { true_value, false_value, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<na_flex_opts, true> na_flex_e;

// NAUplink ::= ENUMERATED
struct na_ul_opts {
  enum options { true_value, false_value, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<na_ul_opts, true> na_ul_e;

// NRCarrierItem-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using nr_carrier_item_ext_ies_o = protocol_ext_empty_o;

// NRSCS ::= ENUMERATED
struct nr_scs_opts {
  enum options { scs15, scs30, scs60, scs120, /*...*/ scs480, scs960, nulltype } value;
  typedef uint16_t number_type;

  const char* to_string() const;
  uint16_t    to_number() const;
};
typedef enumerated<nr_scs_opts, true, 2> nr_scs_e;

using freq_domain_h_sn_a_slot_cfg_item_ext_ies_container = protocol_ext_container_empty_l;

// Frequency-Domain-HSNA-Slot-Configuration-Item ::= SEQUENCE
struct freq_domain_h_sn_a_slot_cfg_item_s {
  bool                                               slot_idx_present   = false;
  bool                                               hsn_a_dl_present   = false;
  bool                                               hsn_a_ul_present   = false;
  bool                                               hsn_a_flex_present = false;
  bool                                               ie_exts_present    = false;
  uint16_t                                           slot_idx           = 0;
  h_sn_a_dl_e                                        hsn_a_dl;
  h_sn_a_ul_e                                        hsn_a_ul;
  h_sn_a_flex_e                                      hsn_a_flex;
  freq_domain_h_sn_a_slot_cfg_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using na_res_cfg_item_ext_ies_container = protocol_ext_container_empty_l;

// NA-Resource-Configuration-Item ::= SEQUENCE
struct na_res_cfg_item_s {
  bool                              na_dl_present   = false;
  bool                              na_ul_present   = false;
  bool                              na_flex_present = false;
  bool                              ie_exts_present = false;
  na_dl_e                           na_dl;
  na_ul_e                           na_ul;
  na_flex_e                         na_flex;
  na_res_cfg_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using nr_carrier_item_ext_ies_container = protocol_ext_container_empty_l;

// NRCarrierItem ::= SEQUENCE
struct nr_carrier_item_s {
  bool                              ext            = false;
  bool                              ie_ext_present = false;
  nr_scs_e                          carrier_scs;
  uint16_t                          offset_to_carrier = 0;
  uint16_t                          carrier_bw        = 0;
  nr_carrier_item_ext_ies_container ie_ext;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// Child-IAB-Nodes-NA-Resource-List-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using child_iab_nodes_na_res_list_item_ext_ies_o = protocol_ext_empty_o;

// ExplicitFormat-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using explicit_format_ext_ies_o = protocol_ext_empty_o;

// Frequency-Domain-HSNA-Configuration-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using freq_domain_h_sn_a_cfg_item_ext_ies_o = protocol_ext_empty_o;

// Frequency-Domain-HSNA-Slot-Configuration-List ::= SEQUENCE (SIZE (1..5120)) OF
// Frequency-Domain-HSNA-Slot-Configuration-Item
using freq_domain_h_sn_a_slot_cfg_list_l = dyn_array<freq_domain_h_sn_a_slot_cfg_item_s>;

// FrequencyShift7p5khz ::= ENUMERATED
struct freq_shift7p5khz_opts {
  enum options { false_value, true_value, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<freq_shift7p5khz_opts, true> freq_shift7p5khz_e;

// ImplicitFormat-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using implicit_format_ext_ies_o = protocol_ext_empty_o;

// NA-Resource-Configuration-List ::= SEQUENCE (SIZE (1..5120)) OF NA-Resource-Configuration-Item
using na_res_cfg_list_l = dyn_array<na_res_cfg_item_s>;

// NRCarrierList ::= SEQUENCE (SIZE (1..5)) OF NRCarrierItem
using nr_carrier_list_l = dyn_array<nr_carrier_item_s>;

// NRNRB ::= ENUMERATED
struct nr_nrb_opts {
  enum options {
    nrb11,
    nrb18,
    nrb24,
    nrb25,
    nrb31,
    nrb32,
    nrb38,
    nrb51,
    nrb52,
    nrb65,
    nrb66,
    nrb78,
    nrb79,
    nrb93,
    nrb106,
    nrb107,
    nrb121,
    nrb132,
    nrb133,
    nrb135,
    nrb160,
    nrb162,
    nrb189,
    nrb216,
    nrb217,
    nrb245,
    nrb264,
    nrb270,
    nrb273,
    // ...
    nrb33,
    nrb62,
    nrb124,
    nrb148,
    nrb248,
    nrb44,
    nrb58,
    nrb92,
    nrb119,
    nrb188,
    nrb242,
    nulltype
  } value;
  typedef uint16_t number_type;

  const char* to_string() const;
  uint16_t    to_number() const;
};
typedef enumerated<nr_nrb_opts, true, 11> nr_nrb_e;

// Parent-IAB-Nodes-NA-Resource-Configuration-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using parent_iab_nodes_na_res_cfg_item_ext_ies_o = protocol_ext_empty_o;

// Permutation ::= ENUMERATED
struct permutation_opts {
  enum options { dfu, ufd, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<permutation_opts, true> permutation_e;

// SupportedSULFreqBandItem-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using supported_sul_freq_band_item_ext_ies_o = protocol_ext_empty_o;

// Transmission-Bandwidth-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using tx_bw_ext_ies_o = protocol_ext_empty_o;

using child_iab_nodes_na_res_list_item_ext_ies_container = protocol_ext_container_empty_l;

// Child-IAB-Nodes-NA-Resource-List-Item ::= SEQUENCE
struct child_iab_nodes_na_res_list_item_s {
  bool                                               ie_exts_present   = false;
  uint64_t                                           gnb_cu_ue_f1ap_id = 0;
  uint64_t                                           gnb_du_ue_f1ap_id = 0;
  na_res_cfg_list_l                                  na_res_cfg_list;
  child_iab_nodes_na_res_list_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// DUF-Slot-Config-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
using du_f_slot_cfg_item_ext_ies_o = protocol_ies_empty_o;

using explicit_format_ext_ies_container = protocol_ext_container_empty_l;

// ExplicitFormat ::= SEQUENCE
struct explicit_format_s {
  bool                              noof_dl_symbols_present = false;
  bool                              noof_ul_symbols_present = false;
  bool                              ie_exts_present         = false;
  permutation_e                     permutation;
  uint8_t                           noof_dl_symbols = 0;
  uint8_t                           noof_ul_symbols = 0;
  explicit_format_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// FreqBandNrItem-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using freq_band_nr_item_ext_ies_o = protocol_ext_empty_o;

using freq_domain_h_sn_a_cfg_item_ext_ies_container = protocol_ext_container_empty_l;

// Frequency-Domain-HSNA-Configuration-Item ::= SEQUENCE
struct freq_domain_h_sn_a_cfg_item_s {
  bool                                          ie_exts_present = false;
  uint8_t                                       rb_set_idx      = 0;
  freq_domain_h_sn_a_slot_cfg_list_l            freq_domain_h_sn_a_slot_cfg_list;
  freq_domain_h_sn_a_cfg_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// HSNASlotConfigItem-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using hs_nas_lot_cfg_item_ext_ies_o = protocol_ext_empty_o;

using implicit_format_ext_ies_container = protocol_ext_container_empty_l;

// ImplicitFormat ::= SEQUENCE
struct implicit_format_s {
  bool                              ie_exts_present     = false;
  uint8_t                           du_f_slotformat_idx = 0;
  implicit_format_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using parent_iab_nodes_na_res_cfg_item_ext_ies_container = protocol_ext_container_empty_l;

// Parent-IAB-Nodes-NA-Resource-Configuration-Item ::= SEQUENCE
struct parent_iab_nodes_na_res_cfg_item_s {
  bool                                               na_dl_present   = false;
  bool                                               na_ul_present   = false;
  bool                                               na_flex_present = false;
  bool                                               ie_exts_present = false;
  na_dl_e                                            na_dl;
  na_ul_e                                            na_ul;
  na_flex_e                                          na_flex;
  parent_iab_nodes_na_res_cfg_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RBSetConfiguration-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using rb_set_cfg_ext_ies_o = protocol_ext_empty_o;

// RBSetSize ::= ENUMERATED
struct rb_set_size_opts {
  enum options { rb2, rb4, rb8, rb16, rb32, rb64, nulltype } value;
  typedef uint8_t number_type;

  const char* to_string() const;
  uint8_t     to_number() const;
};
typedef enumerated<rb_set_size_opts> rb_set_size_e;

// SUL-InformationExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
struct sul_info_ext_ies_o {
  // Extension ::= OPEN TYPE
  struct ext_c {
    struct types_opts {
      enum options { carrier_list, freq_shift7p5khz, nulltype } value;
      typedef uint8_t number_type;

      const char* to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    ext_c() = default;
    ext_c(const ext_c& other);
    ext_c& operator=(const ext_c& other);
    ~ext_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    nr_carrier_list_l&        carrier_list();
    freq_shift7p5khz_e&       freq_shift7p5khz();
    const nr_carrier_list_l&  carrier_list() const;
    const freq_shift7p5khz_e& freq_shift7p5khz() const;

  private:
    types                              type_;
    choice_buffer_t<nr_carrier_list_l> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static ext_c      get_ext(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// SubcarrierSpacing ::= ENUMERATED
struct subcarrier_spacing_opts {
  enum options { khz15, khz30, khz60, khz120, khz240, spare3, spare2, spare1, /*...*/ nulltype } value;
  typedef uint8_t number_type;

  const char* to_string() const;
  uint8_t     to_number() const;
};
typedef enumerated<subcarrier_spacing_opts, true> subcarrier_spacing_e;

using supported_sul_freq_band_item_ext_ies_container = protocol_ext_container_empty_l;

// SupportedSULFreqBandItem ::= SEQUENCE
struct supported_sul_freq_band_item_s {
  bool                                           ext              = false;
  bool                                           ie_exts_present  = false;
  uint16_t                                       freq_band_ind_nr = 1;
  supported_sul_freq_band_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using tx_bw_ext_ies_container = protocol_ext_container_empty_l;

// Transmission-Bandwidth ::= SEQUENCE
struct tx_bw_s {
  bool                    ext             = false;
  bool                    ie_exts_present = false;
  nr_scs_e                nr_scs;
  nr_nrb_e                nr_nrb;
  tx_bw_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// Child-IAB-Nodes-NA-Resource-List ::= SEQUENCE (SIZE (1..1024)) OF Child-IAB-Nodes-NA-Resource-List-Item
using child_iab_nodes_na_res_list_l = dyn_array<child_iab_nodes_na_res_list_item_s>;

// DUF-Slot-Config-Item ::= CHOICE
struct du_f_slot_cfg_item_c {
  struct types_opts {
    enum options { explicit_format, implicit_format, choice_ext, nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  du_f_slot_cfg_item_c() = default;
  du_f_slot_cfg_item_c(const du_f_slot_cfg_item_c& other);
  du_f_slot_cfg_item_c& operator=(const du_f_slot_cfg_item_c& other);
  ~du_f_slot_cfg_item_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  explicit_format_s& explicit_format()
  {
    assert_choice_type(types::explicit_format, type_, "DUF-Slot-Config-Item");
    return c.get<explicit_format_s>();
  }
  implicit_format_s& implicit_format()
  {
    assert_choice_type(types::implicit_format, type_, "DUF-Slot-Config-Item");
    return c.get<implicit_format_s>();
  }
  protocol_ie_single_container_s<du_f_slot_cfg_item_ext_ies_o>& choice_ext()
  {
    assert_choice_type(types::choice_ext, type_, "DUF-Slot-Config-Item");
    return c.get<protocol_ie_single_container_s<du_f_slot_cfg_item_ext_ies_o>>();
  }
  const explicit_format_s& explicit_format() const
  {
    assert_choice_type(types::explicit_format, type_, "DUF-Slot-Config-Item");
    return c.get<explicit_format_s>();
  }
  const implicit_format_s& implicit_format() const
  {
    assert_choice_type(types::implicit_format, type_, "DUF-Slot-Config-Item");
    return c.get<implicit_format_s>();
  }
  const protocol_ie_single_container_s<du_f_slot_cfg_item_ext_ies_o>& choice_ext() const
  {
    assert_choice_type(types::choice_ext, type_, "DUF-Slot-Config-Item");
    return c.get<protocol_ie_single_container_s<du_f_slot_cfg_item_ext_ies_o>>();
  }
  explicit_format_s&                                            set_explicit_format();
  implicit_format_s&                                            set_implicit_format();
  protocol_ie_single_container_s<du_f_slot_cfg_item_ext_ies_o>& set_choice_ext();

private:
  types type_;
  choice_buffer_t<explicit_format_s, implicit_format_s, protocol_ie_single_container_s<du_f_slot_cfg_item_ext_ies_o>> c;

  void destroy_();
};

using freq_band_nr_item_ext_ies_container = protocol_ext_container_empty_l;

// FreqBandNrItem ::= SEQUENCE
struct freq_band_nr_item_s {
  using supported_sul_band_list_l_ = dyn_array<supported_sul_freq_band_item_s>;

  // member variables
  bool                                ext              = false;
  bool                                ie_exts_present  = false;
  uint16_t                            freq_band_ind_nr = 1;
  supported_sul_band_list_l_          supported_sul_band_list;
  freq_band_nr_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// Frequency-Domain-HSNA-Configuration-List ::= SEQUENCE (SIZE (1..8)) OF Frequency-Domain-HSNA-Configuration-Item
using freq_domain_h_sn_a_cfg_list_l = dyn_array<freq_domain_h_sn_a_cfg_item_s>;

using hs_nas_lot_cfg_item_ext_ies_container = protocol_ext_container_empty_l;

// HSNASlotConfigItem ::= SEQUENCE
struct hs_nas_lot_cfg_item_s {
  bool                                  hsn_a_dl_present   = false;
  bool                                  hsn_a_ul_present   = false;
  bool                                  hsn_a_flex_present = false;
  bool                                  ie_exts_present    = false;
  h_sn_a_dl_e                           hsn_a_dl;
  h_sn_a_ul_e                           hsn_a_ul;
  h_sn_a_flex_e                         hsn_a_flex;
  hs_nas_lot_cfg_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// NRFreqInfoExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
struct nr_freq_info_ext_ies_o {
  // Extension ::= OPEN TYPE
  struct ext_c {
    struct types_opts {
      enum options { freq_shift7p5khz, nulltype } value;
      typedef uint8_t number_type;

      const char* to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::freq_shift7p5khz; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    freq_shift7p5khz_e&       freq_shift7p5khz() { return c; }
    const freq_shift7p5khz_e& freq_shift7p5khz() const { return c; }

  private:
    freq_shift7p5khz_e c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static ext_c      get_ext(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// Parent-IAB-Nodes-NA-Resource-Configuration-List ::= SEQUENCE (SIZE (1..5120)) OF
// Parent-IAB-Nodes-NA-Resource-Configuration-Item
using parent_iab_nodes_na_res_cfg_list_l = dyn_array<parent_iab_nodes_na_res_cfg_item_s>;

using rb_set_cfg_ext_ies_container = protocol_ext_container_empty_l;

// RBSetConfiguration ::= SEQUENCE
struct rb_set_cfg_s {
  bool                         ie_exts_present = false;
  subcarrier_spacing_e         subcarrier_spacing;
  rb_set_size_e                rb_set_size;
  uint8_t                      num_r_bsets = 1;
  rb_set_cfg_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

struct sul_info_ext_ies_container {
  template <class extT_>
  using ie_field_s = protocol_ext_container_item_s<extT_>;

  // member variables
  bool                                                  carrier_list_present     = false;
  bool                                                  freq_shift7p5khz_present = false;
  ie_field_s<dyn_seq_of<nr_carrier_item_s, 1, 5, true>> carrier_list;
  ie_field_s<freq_shift7p5khz_e>                        freq_shift7p5khz;

  // sequence methods
  sul_info_ext_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SUL-Information ::= SEQUENCE
struct sul_info_s {
  bool                       ext             = false;
  bool                       ie_exts_present = false;
  uint32_t                   sul_nr_arfcn    = 0;
  tx_bw_s                    sul_tx_bw;
  sul_info_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// DUF-Slot-Config-List ::= SEQUENCE (SIZE (1..320)) OF DUF-Slot-Config-Item
using du_f_slot_cfg_list_l = dyn_array<du_f_slot_cfg_item_c>;

// DUFTransmissionPeriodicity ::= ENUMERATED
struct du_f_tx_periodicity_opts {
  enum options { ms0p5, ms0p625, ms1, ms1p25, ms2, ms2p5, ms5, ms10, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<du_f_tx_periodicity_opts, true> du_f_tx_periodicity_e;

// GNB-DU-Cell-Resource-Configuration-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
struct gnb_du_cell_res_cfg_ext_ies_o {
  // Extension ::= OPEN TYPE
  struct ext_c {
    struct types_opts {
      enum options {
        rb_set_cfg,
        freq_domain_h_sn_a_cfg_list,
        child_iab_nodes_na_res_list,
        parent_iab_nodes_na_res_cfg_list,
        nulltype
      } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    ext_c() = default;
    ext_c(const ext_c& other);
    ext_c& operator=(const ext_c& other);
    ~ext_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    rb_set_cfg_s&                             rb_set_cfg();
    freq_domain_h_sn_a_cfg_list_l&            freq_domain_h_sn_a_cfg_list();
    child_iab_nodes_na_res_list_l&            child_iab_nodes_na_res_list();
    parent_iab_nodes_na_res_cfg_list_l&       parent_iab_nodes_na_res_cfg_list();
    const rb_set_cfg_s&                       rb_set_cfg() const;
    const freq_domain_h_sn_a_cfg_list_l&      freq_domain_h_sn_a_cfg_list() const;
    const child_iab_nodes_na_res_list_l&      child_iab_nodes_na_res_list() const;
    const parent_iab_nodes_na_res_cfg_list_l& parent_iab_nodes_na_res_cfg_list() const;

  private:
    types type_;
    choice_buffer_t<child_iab_nodes_na_res_list_l,
                    freq_domain_h_sn_a_cfg_list_l,
                    parent_iab_nodes_na_res_cfg_list_l,
                    rb_set_cfg_s>
        c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static ext_c      get_ext(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// HSNASlotConfigList ::= SEQUENCE (SIZE (1..5120)) OF HSNASlotConfigItem
using hs_nas_lot_cfg_list_l = dyn_array<hs_nas_lot_cfg_item_s>;

// HSNATransmissionPeriodicity ::= ENUMERATED
struct h_sn_a_tx_periodicity_opts {
  enum options { ms0p5, ms0p625, ms1, ms1p25, ms2, ms2p5, ms5, ms10, ms20, ms40, ms80, ms160, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<h_sn_a_tx_periodicity_opts, true> h_sn_a_tx_periodicity_e;

// NRFreqInfo ::= SEQUENCE
struct nr_freq_info_s {
  using freq_band_list_nr_l_ = dyn_array<freq_band_nr_item_s>;

  // member variables
  bool                                             ext              = false;
  bool                                             sul_info_present = false;
  uint32_t                                         nr_arfcn         = 0;
  sul_info_s                                       sul_info;
  freq_band_list_nr_l_                             freq_band_list_nr;
  protocol_ext_container_l<nr_freq_info_ext_ies_o> ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

struct gnb_du_cell_res_cfg_ext_ies_container {
  template <class extT_>
  using ie_field_s = protocol_ext_container_item_s<extT_>;

  // member variables
  bool                                                              rb_set_cfg_present                       = false;
  bool                                                              freq_domain_h_sn_a_cfg_list_present      = false;
  bool                                                              child_iab_nodes_na_res_list_present      = false;
  bool                                                              parent_iab_nodes_na_res_cfg_list_present = false;
  ie_field_s<rb_set_cfg_s>                                          rb_set_cfg;
  ie_field_s<dyn_seq_of<freq_domain_h_sn_a_cfg_item_s, 1, 8, true>> freq_domain_h_sn_a_cfg_list;
  ie_field_s<dyn_seq_of<child_iab_nodes_na_res_list_item_s, 1, 1024, true>> child_iab_nodes_na_res_list;
  ie_field_s<dyn_seq_of<parent_iab_nodes_na_res_cfg_item_s, 1, 5120, true>> parent_iab_nodes_na_res_cfg_list;

  // sequence methods
  gnb_du_cell_res_cfg_ext_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// GNB-DU-Cell-Resource-Configuration ::= SEQUENCE
struct gnb_du_cell_res_cfg_s {
  bool                                  du_f_tx_periodicity_present = false;
  bool                                  ie_exts_present             = false;
  subcarrier_spacing_e                  subcarrier_spacing;
  du_f_tx_periodicity_e                 du_f_tx_periodicity;
  du_f_slot_cfg_list_l                  du_f_slot_cfg_list;
  h_sn_a_tx_periodicity_e               hsn_a_tx_periodicity;
  hs_nas_lot_cfg_list_l                 hs_nsa_slot_cfg_list;
  gnb_du_cell_res_cfg_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// IAB-DU-Cell-Resource-Configuration-FDD-Info-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
struct iab_du_cell_res_cfg_fdd_info_ext_ies_o {
  // Extension ::= OPEN TYPE
  struct ext_c {
    struct types_opts {
      enum options {
        ul_freq_info,
        ul_tx_bw,
        ul_nr_carrier_list,
        dl_freq_info,
        dl_tx_bw,
        dl_nr_carrier_list,
        nulltype
      } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    ext_c() = default;
    ext_c(const ext_c& other);
    ext_c& operator=(const ext_c& other);
    ~ext_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    nr_freq_info_s&          ul_freq_info();
    tx_bw_s&                 ul_tx_bw();
    nr_carrier_list_l&       ul_nr_carrier_list();
    nr_freq_info_s&          dl_freq_info();
    tx_bw_s&                 dl_tx_bw();
    nr_carrier_list_l&       dl_nr_carrier_list();
    const nr_freq_info_s&    ul_freq_info() const;
    const tx_bw_s&           ul_tx_bw() const;
    const nr_carrier_list_l& ul_nr_carrier_list() const;
    const nr_freq_info_s&    dl_freq_info() const;
    const tx_bw_s&           dl_tx_bw() const;
    const nr_carrier_list_l& dl_nr_carrier_list() const;

  private:
    types                                                       type_;
    choice_buffer_t<nr_carrier_list_l, nr_freq_info_s, tx_bw_s> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static ext_c      get_ext(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// IAB-DU-Cell-Resource-Configuration-TDD-Info-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
struct iab_du_cell_res_cfg_tdd_info_ext_ies_o {
  // Extension ::= OPEN TYPE
  struct ext_c {
    struct types_opts {
      enum options { nr_freq_info, tx_bw, nr_carrier_list, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    ext_c() = default;
    ext_c(const ext_c& other);
    ext_c& operator=(const ext_c& other);
    ~ext_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    nr_freq_info_s&          nr_freq_info();
    tx_bw_s&                 tx_bw();
    nr_carrier_list_l&       nr_carrier_list();
    const nr_freq_info_s&    nr_freq_info() const;
    const tx_bw_s&           tx_bw() const;
    const nr_carrier_list_l& nr_carrier_list() const;

  private:
    types                                                       type_;
    choice_buffer_t<nr_carrier_list_l, nr_freq_info_s, tx_bw_s> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static ext_c      get_ext(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

struct iab_du_cell_res_cfg_fdd_info_ext_ies_container {
  template <class extT_>
  using ie_field_s = protocol_ext_container_item_s<extT_>;

  // member variables
  bool                                                  ul_freq_info_present       = false;
  bool                                                  ul_tx_bw_present           = false;
  bool                                                  ul_nr_carrier_list_present = false;
  bool                                                  dl_freq_info_present       = false;
  bool                                                  dl_tx_bw_present           = false;
  bool                                                  dl_nr_carrier_list_present = false;
  ie_field_s<nr_freq_info_s>                            ul_freq_info;
  ie_field_s<tx_bw_s>                                   ul_tx_bw;
  ie_field_s<dyn_seq_of<nr_carrier_item_s, 1, 5, true>> ul_nr_carrier_list;
  ie_field_s<nr_freq_info_s>                            dl_freq_info;
  ie_field_s<tx_bw_s>                                   dl_tx_bw;
  ie_field_s<dyn_seq_of<nr_carrier_item_s, 1, 5, true>> dl_nr_carrier_list;

  // sequence methods
  iab_du_cell_res_cfg_fdd_info_ext_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// IAB-DU-Cell-Resource-Configuration-FDD-Info ::= SEQUENCE
struct iab_du_cell_res_cfg_fdd_info_s {
  bool                                           ext             = false;
  bool                                           ie_exts_present = false;
  gnb_du_cell_res_cfg_s                          gnb_du_cell_res_cfg_fdd_ul;
  gnb_du_cell_res_cfg_s                          gnb_du_cell_res_cfg_fdd_dl;
  iab_du_cell_res_cfg_fdd_info_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// IAB-DU-Cell-Resource-Configuration-Mode-Info-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
using iab_du_cell_res_cfg_mode_info_ext_ies_o = protocol_ies_empty_o;

struct iab_du_cell_res_cfg_tdd_info_ext_ies_container {
  template <class extT_>
  using ie_field_s = protocol_ext_container_item_s<extT_>;

  // member variables
  bool                                                  nr_freq_info_present    = false;
  bool                                                  tx_bw_present           = false;
  bool                                                  nr_carrier_list_present = false;
  ie_field_s<nr_freq_info_s>                            nr_freq_info;
  ie_field_s<tx_bw_s>                                   tx_bw;
  ie_field_s<dyn_seq_of<nr_carrier_item_s, 1, 5, true>> nr_carrier_list;

  // sequence methods
  iab_du_cell_res_cfg_tdd_info_ext_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// IAB-DU-Cell-Resource-Configuration-TDD-Info ::= SEQUENCE
struct iab_du_cell_res_cfg_tdd_info_s {
  bool                                           ext             = false;
  bool                                           ie_exts_present = false;
  gnb_du_cell_res_cfg_s                          gnb_du_cell_resourc_cfg_tdd;
  iab_du_cell_res_cfg_tdd_info_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// Activated-Cells-to-be-Updated-List-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using activ_cells_to_be_upd_list_item_ext_ies_o = protocol_ext_empty_o;

// IAB-DU-Cell-Resource-Configuration-Mode-Info ::= CHOICE
struct iab_du_cell_res_cfg_mode_info_c {
  struct types_opts {
    enum options { fdd, tdd, choice_ext, nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  iab_du_cell_res_cfg_mode_info_c() = default;
  iab_du_cell_res_cfg_mode_info_c(const iab_du_cell_res_cfg_mode_info_c& other);
  iab_du_cell_res_cfg_mode_info_c& operator=(const iab_du_cell_res_cfg_mode_info_c& other);
  ~iab_du_cell_res_cfg_mode_info_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  iab_du_cell_res_cfg_fdd_info_s& fdd()
  {
    assert_choice_type(types::fdd, type_, "IAB-DU-Cell-Resource-Configuration-Mode-Info");
    return c.get<iab_du_cell_res_cfg_fdd_info_s>();
  }
  iab_du_cell_res_cfg_tdd_info_s& tdd()
  {
    assert_choice_type(types::tdd, type_, "IAB-DU-Cell-Resource-Configuration-Mode-Info");
    return c.get<iab_du_cell_res_cfg_tdd_info_s>();
  }
  protocol_ie_single_container_s<iab_du_cell_res_cfg_mode_info_ext_ies_o>& choice_ext()
  {
    assert_choice_type(types::choice_ext, type_, "IAB-DU-Cell-Resource-Configuration-Mode-Info");
    return c.get<protocol_ie_single_container_s<iab_du_cell_res_cfg_mode_info_ext_ies_o>>();
  }
  const iab_du_cell_res_cfg_fdd_info_s& fdd() const
  {
    assert_choice_type(types::fdd, type_, "IAB-DU-Cell-Resource-Configuration-Mode-Info");
    return c.get<iab_du_cell_res_cfg_fdd_info_s>();
  }
  const iab_du_cell_res_cfg_tdd_info_s& tdd() const
  {
    assert_choice_type(types::tdd, type_, "IAB-DU-Cell-Resource-Configuration-Mode-Info");
    return c.get<iab_du_cell_res_cfg_tdd_info_s>();
  }
  const protocol_ie_single_container_s<iab_du_cell_res_cfg_mode_info_ext_ies_o>& choice_ext() const
  {
    assert_choice_type(types::choice_ext, type_, "IAB-DU-Cell-Resource-Configuration-Mode-Info");
    return c.get<protocol_ie_single_container_s<iab_du_cell_res_cfg_mode_info_ext_ies_o>>();
  }
  iab_du_cell_res_cfg_fdd_info_s&                                          set_fdd();
  iab_du_cell_res_cfg_tdd_info_s&                                          set_tdd();
  protocol_ie_single_container_s<iab_du_cell_res_cfg_mode_info_ext_ies_o>& set_choice_ext();

private:
  types type_;
  choice_buffer_t<iab_du_cell_res_cfg_fdd_info_s,
                  iab_du_cell_res_cfg_tdd_info_s,
                  protocol_ie_single_container_s<iab_du_cell_res_cfg_mode_info_ext_ies_o>>
      c;

  void destroy_();
};

using activ_cells_to_be_upd_list_item_ext_ies_container = protocol_ext_container_empty_l;

// Activated-Cells-to-be-Updated-List-Item ::= SEQUENCE
struct activ_cells_to_be_upd_list_item_s {
  bool                                              ie_exts_present = false;
  nr_cgi_s                                          nr_cgi;
  iab_du_cell_res_cfg_mode_info_c                   iab_du_cell_res_cfg_mode_info;
  activ_cells_to_be_upd_list_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// Activated-Cells-to-be-Updated-List ::= SEQUENCE (SIZE (1..512)) OF Activated-Cells-to-be-Updated-List-Item
using activ_cells_to_be_upd_list_l = dyn_array<activ_cells_to_be_upd_list_item_s>;

// PRSInformationPos-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using pr_si_nformation_pos_ext_ies_o = protocol_ext_empty_o;

// PosResourceSetTypeAP-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using pos_res_set_type_ap_ext_ies_o = protocol_ext_empty_o;

// PosResourceSetTypePR-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using pos_res_set_type_pr_ext_ies_o = protocol_ext_empty_o;

// PosResourceSetTypeSP-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using pos_res_set_type_sp_ext_ies_o = protocol_ext_empty_o;

// ResourceSetTypeAperiodic-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using res_set_type_aperiodic_ext_ies_o = protocol_ext_empty_o;

// ResourceSetTypePeriodic-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using res_set_type_periodic_ext_ies_o = protocol_ext_empty_o;

// ResourceSetTypeSemi-persistent-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using res_set_type_semi_persistent_ext_ies_o = protocol_ext_empty_o;

// ResourceTypeAperiodic-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using res_type_aperiodic_ext_ies_o = protocol_ext_empty_o;

// ResourceTypeAperiodicPos-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using res_type_aperiodic_pos_ext_ies_o = protocol_ext_empty_o;

// ResourceTypePeriodic-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using res_type_periodic_ext_ies_o = protocol_ext_empty_o;

// ResourceTypePeriodicPos-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using res_type_periodic_pos_ext_ies_o = protocol_ext_empty_o;

// ResourceTypeSemi-persistent-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using res_type_semi_persistent_ext_ies_o = protocol_ext_empty_o;

// ResourceTypeSemi-persistentPos-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using res_type_semi_persistent_pos_ext_ies_o = protocol_ext_empty_o;

// SSB-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using ssb_ext_ies_o = protocol_ext_empty_o;

using pr_si_nformation_pos_ext_ies_container = protocol_ext_container_empty_l;

// PRSInformationPos ::= SEQUENCE
struct pr_si_nformation_pos_s {
  bool                                   prs_res_id_pos_present = false;
  bool                                   ie_exts_present        = false;
  uint16_t                               prs_id_pos             = 0;
  uint8_t                                prs_res_set_id_pos     = 0;
  uint8_t                                prs_res_id_pos         = 0;
  pr_si_nformation_pos_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PosResourceSetType-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
using pos_res_set_type_ext_ies_o = protocol_ies_empty_o;

using pos_res_set_type_ap_ext_ies_container = protocol_ext_container_empty_l;

// PosResourceSetTypeAP ::= SEQUENCE
struct pos_res_set_type_ap_s {
  bool                                  ie_exts_present      = false;
  uint8_t                               srs_res_trigger_list = 1;
  pos_res_set_type_ap_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using pos_res_set_type_pr_ext_ies_container = protocol_ext_container_empty_l;

// PosResourceSetTypePR ::= SEQUENCE
struct pos_res_set_type_pr_s {
  struct posperiodic_set_opts {
    enum options { true_value, /*...*/ nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<posperiodic_set_opts, true> posperiodic_set_e_;

  // member variables
  bool                                  ie_exts_present = false;
  posperiodic_set_e_                    posperiodic_set;
  pos_res_set_type_pr_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using pos_res_set_type_sp_ext_ies_container = protocol_ext_container_empty_l;

// PosResourceSetTypeSP ::= SEQUENCE
struct pos_res_set_type_sp_s {
  struct possemi_persistent_set_opts {
    enum options { true_value, /*...*/ nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<possemi_persistent_set_opts, true> possemi_persistent_set_e_;

  // member variables
  bool                                  ie_exts_present = false;
  possemi_persistent_set_e_             possemi_persistent_set;
  pos_res_set_type_sp_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// ResourceSetType-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
using res_set_type_ext_ies_o = protocol_ies_empty_o;

using res_set_type_aperiodic_ext_ies_container = protocol_ext_container_empty_l;

// ResourceSetTypeAperiodic ::= SEQUENCE
struct res_set_type_aperiodic_s {
  bool                                     ie_exts_present      = false;
  uint8_t                                  srs_res_trigger_list = 1;
  uint8_t                                  slotoffset           = 0;
  res_set_type_aperiodic_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using res_set_type_periodic_ext_ies_container = protocol_ext_container_empty_l;

// ResourceSetTypePeriodic ::= SEQUENCE
struct res_set_type_periodic_s {
  struct periodic_set_opts {
    enum options { true_value, /*...*/ nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<periodic_set_opts, true> periodic_set_e_;

  // member variables
  bool                                    ie_exts_present = false;
  periodic_set_e_                         periodic_set;
  res_set_type_periodic_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using res_set_type_semi_persistent_ext_ies_container = protocol_ext_container_empty_l;

// ResourceSetTypeSemi-persistent ::= SEQUENCE
struct res_set_type_semi_persistent_s {
  struct semi_persistent_set_opts {
    enum options { true_value, /*...*/ nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<semi_persistent_set_opts, true> semi_persistent_set_e_;

  // member variables
  bool                                           ie_exts_present = false;
  semi_persistent_set_e_                         semi_persistent_set;
  res_set_type_semi_persistent_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// ResourceType-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
using res_type_ext_ies_o = protocol_ies_empty_o;

using res_type_aperiodic_ext_ies_container = protocol_ext_container_empty_l;

// ResourceTypeAperiodic ::= SEQUENCE
struct res_type_aperiodic_s {
  struct aperiodic_res_type_opts {
    enum options { true_value, /*...*/ nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<aperiodic_res_type_opts, true> aperiodic_res_type_e_;

  // member variables
  bool                                 ie_exts_present = false;
  aperiodic_res_type_e_                aperiodic_res_type;
  res_type_aperiodic_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using res_type_aperiodic_pos_ext_ies_container = protocol_ext_container_empty_l;

// ResourceTypeAperiodicPos ::= SEQUENCE
struct res_type_aperiodic_pos_s {
  bool                                     ie_exts_present = false;
  uint8_t                                  slot_offset     = 0;
  res_type_aperiodic_pos_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using res_type_periodic_ext_ies_container = protocol_ext_container_empty_l;

// ResourceTypePeriodic ::= SEQUENCE
struct res_type_periodic_s {
  struct periodicity_opts {
    enum options {
      slot1,
      slot2,
      slot4,
      slot5,
      slot8,
      slot10,
      slot16,
      slot20,
      slot32,
      slot40,
      slot64,
      slot80,
      slot160,
      slot320,
      slot640,
      slot1280,
      slot2560,
      // ...
      nulltype
    } value;
    typedef uint16_t number_type;

    const char* to_string() const;
    uint16_t    to_number() const;
  };
  typedef enumerated<periodicity_opts, true> periodicity_e_;

  // member variables
  bool                                ie_exts_present = false;
  periodicity_e_                      periodicity;
  uint16_t                            offset = 0;
  res_type_periodic_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using res_type_periodic_pos_ext_ies_container = protocol_ext_container_empty_l;

// ResourceTypePeriodicPos ::= SEQUENCE
struct res_type_periodic_pos_s {
  struct periodicity_opts {
    enum options {
      slot1,
      slot2,
      slot4,
      slot5,
      slot8,
      slot10,
      slot16,
      slot20,
      slot32,
      slot40,
      slot64,
      slot80,
      slot160,
      slot320,
      slot640,
      slot1280,
      slot2560,
      slot5120,
      slot10240,
      slot40960,
      slot81920,
      // ...
      slot128,
      slot256,
      slot512,
      slot20480,
      nulltype
    } value;
    typedef uint32_t number_type;

    const char* to_string() const;
    uint32_t    to_number() const;
  };
  typedef enumerated<periodicity_opts, true, 4> periodicity_e_;

  // member variables
  bool                                    ie_exts_present = false;
  periodicity_e_                          periodicity;
  uint32_t                                offset = 0;
  res_type_periodic_pos_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// ResourceTypePos-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
using res_type_pos_ext_ies_o = protocol_ies_empty_o;

using res_type_semi_persistent_ext_ies_container = protocol_ext_container_empty_l;

// ResourceTypeSemi-persistent ::= SEQUENCE
struct res_type_semi_persistent_s {
  struct periodicity_opts {
    enum options {
      slot1,
      slot2,
      slot4,
      slot5,
      slot8,
      slot10,
      slot16,
      slot20,
      slot32,
      slot40,
      slot64,
      slot80,
      slot160,
      slot320,
      slot640,
      slot1280,
      slot2560,
      // ...
      nulltype
    } value;
    typedef uint16_t number_type;

    const char* to_string() const;
    uint16_t    to_number() const;
  };
  typedef enumerated<periodicity_opts, true> periodicity_e_;

  // member variables
  bool                                       ie_exts_present = false;
  periodicity_e_                             periodicity;
  uint16_t                                   offset = 0;
  res_type_semi_persistent_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using res_type_semi_persistent_pos_ext_ies_container = protocol_ext_container_empty_l;

// ResourceTypeSemi-persistentPos ::= SEQUENCE
struct res_type_semi_persistent_pos_s {
  struct periodicity_opts {
    enum options {
      slot1,
      slot2,
      slot4,
      slot5,
      slot8,
      slot10,
      slot16,
      slot20,
      slot32,
      slot40,
      slot64,
      slot80,
      slot160,
      slot320,
      slot640,
      slot1280,
      slot2560,
      slot5120,
      slot10240,
      slot40960,
      slot81920,
      // ...
      slot128,
      slot256,
      slot512,
      slot20480,
      nulltype
    } value;
    typedef uint32_t number_type;

    const char* to_string() const;
    uint32_t    to_number() const;
  };
  typedef enumerated<periodicity_opts, true, 4> periodicity_e_;

  // member variables
  bool                                           ie_exts_present = false;
  periodicity_e_                                 periodicity;
  uint32_t                                       offset = 0;
  res_type_semi_persistent_pos_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using ssb_ext_ies_container = protocol_ext_container_empty_l;

// SSB ::= SEQUENCE
struct ssb_s {
  bool                  ssb_idx_present = false;
  bool                  ie_exts_present = false;
  uint16_t              pci_nr          = 0;
  uint8_t               ssb_idx         = 0;
  ssb_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SpatialInformationPos-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
using spatial_info_pos_ext_ies_o = protocol_ies_empty_o;

// TransmissionComb-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
using tx_comb_ext_ies_o = protocol_ies_empty_o;

// TransmissionCombPos-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
using tx_comb_pos_ext_ies_o = protocol_ies_empty_o;

// PosResourceSetType ::= CHOICE
struct pos_res_set_type_c {
  struct types_opts {
    enum options { periodic, semi_persistent, aperiodic, choice_ext, nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  pos_res_set_type_c() = default;
  pos_res_set_type_c(const pos_res_set_type_c& other);
  pos_res_set_type_c& operator=(const pos_res_set_type_c& other);
  ~pos_res_set_type_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  pos_res_set_type_pr_s& periodic()
  {
    assert_choice_type(types::periodic, type_, "PosResourceSetType");
    return c.get<pos_res_set_type_pr_s>();
  }
  pos_res_set_type_sp_s& semi_persistent()
  {
    assert_choice_type(types::semi_persistent, type_, "PosResourceSetType");
    return c.get<pos_res_set_type_sp_s>();
  }
  pos_res_set_type_ap_s& aperiodic()
  {
    assert_choice_type(types::aperiodic, type_, "PosResourceSetType");
    return c.get<pos_res_set_type_ap_s>();
  }
  protocol_ie_single_container_s<pos_res_set_type_ext_ies_o>& choice_ext()
  {
    assert_choice_type(types::choice_ext, type_, "PosResourceSetType");
    return c.get<protocol_ie_single_container_s<pos_res_set_type_ext_ies_o>>();
  }
  const pos_res_set_type_pr_s& periodic() const
  {
    assert_choice_type(types::periodic, type_, "PosResourceSetType");
    return c.get<pos_res_set_type_pr_s>();
  }
  const pos_res_set_type_sp_s& semi_persistent() const
  {
    assert_choice_type(types::semi_persistent, type_, "PosResourceSetType");
    return c.get<pos_res_set_type_sp_s>();
  }
  const pos_res_set_type_ap_s& aperiodic() const
  {
    assert_choice_type(types::aperiodic, type_, "PosResourceSetType");
    return c.get<pos_res_set_type_ap_s>();
  }
  const protocol_ie_single_container_s<pos_res_set_type_ext_ies_o>& choice_ext() const
  {
    assert_choice_type(types::choice_ext, type_, "PosResourceSetType");
    return c.get<protocol_ie_single_container_s<pos_res_set_type_ext_ies_o>>();
  }
  pos_res_set_type_pr_s&                                      set_periodic();
  pos_res_set_type_sp_s&                                      set_semi_persistent();
  pos_res_set_type_ap_s&                                      set_aperiodic();
  protocol_ie_single_container_s<pos_res_set_type_ext_ies_o>& set_choice_ext();

private:
  types type_;
  choice_buffer_t<pos_res_set_type_ap_s,
                  pos_res_set_type_pr_s,
                  pos_res_set_type_sp_s,
                  protocol_ie_single_container_s<pos_res_set_type_ext_ies_o>>
      c;

  void destroy_();
};

// PosSRSResource-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using pos_srs_res_item_ext_ies_o = protocol_ext_empty_o;

// PosSRSResourceID-List ::= SEQUENCE (SIZE (1..16)) OF INTEGER (0..63)
using pos_srs_res_id_list_l = bounded_array<uint8_t, 16>;

// PosSRSResourceSet-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using pos_srs_res_set_item_ext_ies_o = protocol_ext_empty_o;

// ResourceSetType ::= CHOICE
struct res_set_type_c {
  struct types_opts {
    enum options { periodic, semi_persistent, aperiodic, choice_ext, nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  res_set_type_c() = default;
  res_set_type_c(const res_set_type_c& other);
  res_set_type_c& operator=(const res_set_type_c& other);
  ~res_set_type_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  res_set_type_periodic_s& periodic()
  {
    assert_choice_type(types::periodic, type_, "ResourceSetType");
    return c.get<res_set_type_periodic_s>();
  }
  res_set_type_semi_persistent_s& semi_persistent()
  {
    assert_choice_type(types::semi_persistent, type_, "ResourceSetType");
    return c.get<res_set_type_semi_persistent_s>();
  }
  res_set_type_aperiodic_s& aperiodic()
  {
    assert_choice_type(types::aperiodic, type_, "ResourceSetType");
    return c.get<res_set_type_aperiodic_s>();
  }
  protocol_ie_single_container_s<res_set_type_ext_ies_o>& choice_ext()
  {
    assert_choice_type(types::choice_ext, type_, "ResourceSetType");
    return c.get<protocol_ie_single_container_s<res_set_type_ext_ies_o>>();
  }
  const res_set_type_periodic_s& periodic() const
  {
    assert_choice_type(types::periodic, type_, "ResourceSetType");
    return c.get<res_set_type_periodic_s>();
  }
  const res_set_type_semi_persistent_s& semi_persistent() const
  {
    assert_choice_type(types::semi_persistent, type_, "ResourceSetType");
    return c.get<res_set_type_semi_persistent_s>();
  }
  const res_set_type_aperiodic_s& aperiodic() const
  {
    assert_choice_type(types::aperiodic, type_, "ResourceSetType");
    return c.get<res_set_type_aperiodic_s>();
  }
  const protocol_ie_single_container_s<res_set_type_ext_ies_o>& choice_ext() const
  {
    assert_choice_type(types::choice_ext, type_, "ResourceSetType");
    return c.get<protocol_ie_single_container_s<res_set_type_ext_ies_o>>();
  }
  res_set_type_periodic_s&                                set_periodic();
  res_set_type_semi_persistent_s&                         set_semi_persistent();
  res_set_type_aperiodic_s&                               set_aperiodic();
  protocol_ie_single_container_s<res_set_type_ext_ies_o>& set_choice_ext();

private:
  types type_;
  choice_buffer_t<protocol_ie_single_container_s<res_set_type_ext_ies_o>,
                  res_set_type_aperiodic_s,
                  res_set_type_periodic_s,
                  res_set_type_semi_persistent_s>
      c;

  void destroy_();
};

// ResourceType ::= CHOICE
struct res_type_c {
  struct types_opts {
    enum options { periodic, semi_persistent, aperiodic, choice_ext, nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  res_type_c() = default;
  res_type_c(const res_type_c& other);
  res_type_c& operator=(const res_type_c& other);
  ~res_type_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  res_type_periodic_s& periodic()
  {
    assert_choice_type(types::periodic, type_, "ResourceType");
    return c.get<res_type_periodic_s>();
  }
  res_type_semi_persistent_s& semi_persistent()
  {
    assert_choice_type(types::semi_persistent, type_, "ResourceType");
    return c.get<res_type_semi_persistent_s>();
  }
  res_type_aperiodic_s& aperiodic()
  {
    assert_choice_type(types::aperiodic, type_, "ResourceType");
    return c.get<res_type_aperiodic_s>();
  }
  protocol_ie_single_container_s<res_type_ext_ies_o>& choice_ext()
  {
    assert_choice_type(types::choice_ext, type_, "ResourceType");
    return c.get<protocol_ie_single_container_s<res_type_ext_ies_o>>();
  }
  const res_type_periodic_s& periodic() const
  {
    assert_choice_type(types::periodic, type_, "ResourceType");
    return c.get<res_type_periodic_s>();
  }
  const res_type_semi_persistent_s& semi_persistent() const
  {
    assert_choice_type(types::semi_persistent, type_, "ResourceType");
    return c.get<res_type_semi_persistent_s>();
  }
  const res_type_aperiodic_s& aperiodic() const
  {
    assert_choice_type(types::aperiodic, type_, "ResourceType");
    return c.get<res_type_aperiodic_s>();
  }
  const protocol_ie_single_container_s<res_type_ext_ies_o>& choice_ext() const
  {
    assert_choice_type(types::choice_ext, type_, "ResourceType");
    return c.get<protocol_ie_single_container_s<res_type_ext_ies_o>>();
  }
  res_type_periodic_s&                                set_periodic();
  res_type_semi_persistent_s&                         set_semi_persistent();
  res_type_aperiodic_s&                               set_aperiodic();
  protocol_ie_single_container_s<res_type_ext_ies_o>& set_choice_ext();

private:
  types type_;
  choice_buffer_t<protocol_ie_single_container_s<res_type_ext_ies_o>,
                  res_type_aperiodic_s,
                  res_type_periodic_s,
                  res_type_semi_persistent_s>
      c;

  void destroy_();
};

// ResourceTypePos ::= CHOICE
struct res_type_pos_c {
  struct types_opts {
    enum options { periodic, semi_persistent, aperiodic, choice_ext, nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  res_type_pos_c() = default;
  res_type_pos_c(const res_type_pos_c& other);
  res_type_pos_c& operator=(const res_type_pos_c& other);
  ~res_type_pos_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  res_type_periodic_pos_s& periodic()
  {
    assert_choice_type(types::periodic, type_, "ResourceTypePos");
    return c.get<res_type_periodic_pos_s>();
  }
  res_type_semi_persistent_pos_s& semi_persistent()
  {
    assert_choice_type(types::semi_persistent, type_, "ResourceTypePos");
    return c.get<res_type_semi_persistent_pos_s>();
  }
  res_type_aperiodic_pos_s& aperiodic()
  {
    assert_choice_type(types::aperiodic, type_, "ResourceTypePos");
    return c.get<res_type_aperiodic_pos_s>();
  }
  protocol_ie_single_container_s<res_type_pos_ext_ies_o>& choice_ext()
  {
    assert_choice_type(types::choice_ext, type_, "ResourceTypePos");
    return c.get<protocol_ie_single_container_s<res_type_pos_ext_ies_o>>();
  }
  const res_type_periodic_pos_s& periodic() const
  {
    assert_choice_type(types::periodic, type_, "ResourceTypePos");
    return c.get<res_type_periodic_pos_s>();
  }
  const res_type_semi_persistent_pos_s& semi_persistent() const
  {
    assert_choice_type(types::semi_persistent, type_, "ResourceTypePos");
    return c.get<res_type_semi_persistent_pos_s>();
  }
  const res_type_aperiodic_pos_s& aperiodic() const
  {
    assert_choice_type(types::aperiodic, type_, "ResourceTypePos");
    return c.get<res_type_aperiodic_pos_s>();
  }
  const protocol_ie_single_container_s<res_type_pos_ext_ies_o>& choice_ext() const
  {
    assert_choice_type(types::choice_ext, type_, "ResourceTypePos");
    return c.get<protocol_ie_single_container_s<res_type_pos_ext_ies_o>>();
  }
  res_type_periodic_pos_s&                                set_periodic();
  res_type_semi_persistent_pos_s&                         set_semi_persistent();
  res_type_aperiodic_pos_s&                               set_aperiodic();
  protocol_ie_single_container_s<res_type_pos_ext_ies_o>& set_choice_ext();

private:
  types type_;
  choice_buffer_t<protocol_ie_single_container_s<res_type_pos_ext_ies_o>,
                  res_type_aperiodic_pos_s,
                  res_type_periodic_pos_s,
                  res_type_semi_persistent_pos_s>
      c;

  void destroy_();
};

// SRSResource-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using srs_res_ext_ies_o = protocol_ext_empty_o;

// SRSResourceID-List ::= SEQUENCE (SIZE (1..16)) OF INTEGER (0..63)
using srs_res_id_list_l = bounded_array<uint8_t, 16>;

// SRSResourceSet-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using srs_res_set_ext_ies_o = protocol_ext_empty_o;

// SpatialRelationPos ::= CHOICE
struct spatial_relation_pos_c {
  struct types_opts {
    enum options { ssb_pos, pr_si_nformation_pos, choice_ext, nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  spatial_relation_pos_c() = default;
  spatial_relation_pos_c(const spatial_relation_pos_c& other);
  spatial_relation_pos_c& operator=(const spatial_relation_pos_c& other);
  ~spatial_relation_pos_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  ssb_s& ssb_pos()
  {
    assert_choice_type(types::ssb_pos, type_, "SpatialRelationPos");
    return c.get<ssb_s>();
  }
  pr_si_nformation_pos_s& pr_si_nformation_pos()
  {
    assert_choice_type(types::pr_si_nformation_pos, type_, "SpatialRelationPos");
    return c.get<pr_si_nformation_pos_s>();
  }
  protocol_ie_single_container_s<spatial_info_pos_ext_ies_o>& choice_ext()
  {
    assert_choice_type(types::choice_ext, type_, "SpatialRelationPos");
    return c.get<protocol_ie_single_container_s<spatial_info_pos_ext_ies_o>>();
  }
  const ssb_s& ssb_pos() const
  {
    assert_choice_type(types::ssb_pos, type_, "SpatialRelationPos");
    return c.get<ssb_s>();
  }
  const pr_si_nformation_pos_s& pr_si_nformation_pos() const
  {
    assert_choice_type(types::pr_si_nformation_pos, type_, "SpatialRelationPos");
    return c.get<pr_si_nformation_pos_s>();
  }
  const protocol_ie_single_container_s<spatial_info_pos_ext_ies_o>& choice_ext() const
  {
    assert_choice_type(types::choice_ext, type_, "SpatialRelationPos");
    return c.get<protocol_ie_single_container_s<spatial_info_pos_ext_ies_o>>();
  }
  ssb_s&                                                      set_ssb_pos();
  pr_si_nformation_pos_s&                                     set_pr_si_nformation_pos();
  protocol_ie_single_container_s<spatial_info_pos_ext_ies_o>& set_choice_ext();

private:
  types                                                                                                      type_;
  choice_buffer_t<pr_si_nformation_pos_s, protocol_ie_single_container_s<spatial_info_pos_ext_ies_o>, ssb_s> c;

  void destroy_();
};

// TransmissionComb ::= CHOICE
struct tx_comb_c {
  struct n2_s_ {
    uint8_t comb_offset_n2  = 0;
    uint8_t cyclic_shift_n2 = 0;
  };
  struct n4_s_ {
    uint8_t comb_offset_n4  = 0;
    uint8_t cyclic_shift_n4 = 0;
  };
  struct types_opts {
    enum options { n2, n4, choice_ext, nulltype } value;
    typedef uint8_t number_type;

    const char* to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  tx_comb_c() = default;
  tx_comb_c(const tx_comb_c& other);
  tx_comb_c& operator=(const tx_comb_c& other);
  ~tx_comb_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  n2_s_& n2()
  {
    assert_choice_type(types::n2, type_, "TransmissionComb");
    return c.get<n2_s_>();
  }
  n4_s_& n4()
  {
    assert_choice_type(types::n4, type_, "TransmissionComb");
    return c.get<n4_s_>();
  }
  protocol_ie_single_container_s<tx_comb_ext_ies_o>& choice_ext()
  {
    assert_choice_type(types::choice_ext, type_, "TransmissionComb");
    return c.get<protocol_ie_single_container_s<tx_comb_ext_ies_o>>();
  }
  const n2_s_& n2() const
  {
    assert_choice_type(types::n2, type_, "TransmissionComb");
    return c.get<n2_s_>();
  }
  const n4_s_& n4() const
  {
    assert_choice_type(types::n4, type_, "TransmissionComb");
    return c.get<n4_s_>();
  }
  const protocol_ie_single_container_s<tx_comb_ext_ies_o>& choice_ext() const
  {
    assert_choice_type(types::choice_ext, type_, "TransmissionComb");
    return c.get<protocol_ie_single_container_s<tx_comb_ext_ies_o>>();
  }
  n2_s_&                                             set_n2();
  n4_s_&                                             set_n4();
  protocol_ie_single_container_s<tx_comb_ext_ies_o>& set_choice_ext();

private:
  types                                                                            type_;
  choice_buffer_t<n2_s_, n4_s_, protocol_ie_single_container_s<tx_comb_ext_ies_o>> c;

  void destroy_();
};

// TransmissionCombPos ::= CHOICE
struct tx_comb_pos_c {
  struct n2_s_ {
    uint8_t comb_offset_n2  = 0;
    uint8_t cyclic_shift_n2 = 0;
  };
  struct n4_s_ {
    uint8_t comb_offset_n4  = 0;
    uint8_t cyclic_shift_n4 = 0;
  };
  struct n8_s_ {
    uint8_t comb_offset_n8  = 0;
    uint8_t cyclic_shift_n8 = 0;
  };
  struct types_opts {
    enum options { n2, n4, n8, choice_ext, nulltype } value;
    typedef uint8_t number_type;

    const char* to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  tx_comb_pos_c() = default;
  tx_comb_pos_c(const tx_comb_pos_c& other);
  tx_comb_pos_c& operator=(const tx_comb_pos_c& other);
  ~tx_comb_pos_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  n2_s_& n2()
  {
    assert_choice_type(types::n2, type_, "TransmissionCombPos");
    return c.get<n2_s_>();
  }
  n4_s_& n4()
  {
    assert_choice_type(types::n4, type_, "TransmissionCombPos");
    return c.get<n4_s_>();
  }
  n8_s_& n8()
  {
    assert_choice_type(types::n8, type_, "TransmissionCombPos");
    return c.get<n8_s_>();
  }
  protocol_ie_single_container_s<tx_comb_pos_ext_ies_o>& choice_ext()
  {
    assert_choice_type(types::choice_ext, type_, "TransmissionCombPos");
    return c.get<protocol_ie_single_container_s<tx_comb_pos_ext_ies_o>>();
  }
  const n2_s_& n2() const
  {
    assert_choice_type(types::n2, type_, "TransmissionCombPos");
    return c.get<n2_s_>();
  }
  const n4_s_& n4() const
  {
    assert_choice_type(types::n4, type_, "TransmissionCombPos");
    return c.get<n4_s_>();
  }
  const n8_s_& n8() const
  {
    assert_choice_type(types::n8, type_, "TransmissionCombPos");
    return c.get<n8_s_>();
  }
  const protocol_ie_single_container_s<tx_comb_pos_ext_ies_o>& choice_ext() const
  {
    assert_choice_type(types::choice_ext, type_, "TransmissionCombPos");
    return c.get<protocol_ie_single_container_s<tx_comb_pos_ext_ies_o>>();
  }
  n2_s_&                                                 set_n2();
  n4_s_&                                                 set_n4();
  n8_s_&                                                 set_n8();
  protocol_ie_single_container_s<tx_comb_pos_ext_ies_o>& set_choice_ext();

private:
  types                                                                                       type_;
  choice_buffer_t<n2_s_, n4_s_, n8_s_, protocol_ie_single_container_s<tx_comb_pos_ext_ies_o>> c;

  void destroy_();
};

using pos_srs_res_item_ext_ies_container = protocol_ext_container_empty_l;

// PosSRSResource-Item ::= SEQUENCE
struct pos_srs_res_item_s {
  struct nrof_symbols_opts {
    enum options { n1, n2, n4, n8, n12, nulltype } value;
    typedef uint8_t number_type;

    const char* to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<nrof_symbols_opts> nrof_symbols_e_;
  struct group_or_seq_hop_opts {
    enum options { neither, group_hop, seq_hop, nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<group_or_seq_hop_opts> group_or_seq_hop_e_;

  // member variables
  bool                               spatial_relation_pos_present = false;
  bool                               ie_exts_present              = false;
  uint8_t                            srs_pos_res_id               = 0;
  tx_comb_pos_c                      tx_comb_pos;
  uint8_t                            start_position = 0;
  nrof_symbols_e_                    nrof_symbols;
  uint16_t                           freq_domain_shift = 0;
  uint8_t                            c_srs             = 0;
  group_or_seq_hop_e_                group_or_seq_hop;
  res_type_pos_c                     res_type_pos;
  uint32_t                           seq_id = 0;
  spatial_relation_pos_c             spatial_relation_pos;
  pos_srs_res_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using pos_srs_res_set_item_ext_ies_container = protocol_ext_container_empty_l;

// PosSRSResourceSet-Item ::= SEQUENCE
struct pos_srs_res_set_item_s {
  bool                                   ie_exts_present   = false;
  uint8_t                                possrs_res_set_id = 0;
  pos_srs_res_id_list_l                  poss_rs_res_id_list;
  pos_res_set_type_c                     posres_set_type;
  pos_srs_res_set_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using srs_res_ext_ies_container = protocol_ext_container_empty_l;

// SRSResource ::= SEQUENCE
struct srs_res_s {
  struct nrof_srs_ports_opts {
    enum options { port1, ports2, ports4, nulltype } value;
    typedef uint8_t number_type;

    const char* to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<nrof_srs_ports_opts> nrof_srs_ports_e_;
  struct nrof_symbols_opts {
    enum options { n1, n2, n4, nulltype } value;
    typedef uint8_t number_type;

    const char* to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<nrof_symbols_opts> nrof_symbols_e_;
  struct repeat_factor_opts {
    enum options { n1, n2, n4, nulltype } value;
    typedef uint8_t number_type;

    const char* to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<repeat_factor_opts> repeat_factor_e_;
  struct group_or_seq_hop_opts {
    enum options { neither, group_hop, seq_hop, nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<group_or_seq_hop_opts> group_or_seq_hop_e_;

  // member variables
  bool                      ie_exts_present = false;
  uint8_t                   srs_res_id      = 0;
  nrof_srs_ports_e_         nrof_srs_ports;
  tx_comb_c                 tx_comb;
  uint8_t                   start_position = 0;
  nrof_symbols_e_           nrof_symbols;
  repeat_factor_e_          repeat_factor;
  uint8_t                   freq_domain_position = 0;
  uint16_t                  freq_domain_shift    = 0;
  uint8_t                   c_srs                = 0;
  uint8_t                   b_srs                = 0;
  uint8_t                   b_hop                = 0;
  group_or_seq_hop_e_       group_or_seq_hop;
  res_type_c                res_type;
  uint16_t                  seq_id = 0;
  srs_res_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using srs_res_set_ext_ies_container = protocol_ext_container_empty_l;

// SRSResourceSet ::= SEQUENCE
struct srs_res_set_s {
  bool                          ie_exts_present = false;
  uint8_t                       srs_res_set_id  = 0;
  srs_res_id_list_l             srs_res_id_list;
  res_set_type_c                res_set_type;
  srs_res_set_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PosSRSResource-List ::= SEQUENCE (SIZE (1..64)) OF PosSRSResource-Item
using pos_srs_res_list_l = dyn_array<pos_srs_res_item_s>;

// PosSRSResourceSet-List ::= SEQUENCE (SIZE (1..16)) OF PosSRSResourceSet-Item
using pos_srs_res_set_list_l = dyn_array<pos_srs_res_set_item_s>;

// SRSConfig-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using srs_cfg_ext_ies_o = protocol_ext_empty_o;

// SRSResource-List ::= SEQUENCE (SIZE (1..64)) OF SRSResource
using srs_res_list_l = dyn_array<srs_res_s>;

// SRSResourceSet-List ::= SEQUENCE (SIZE (1..16)) OF SRSResourceSet
using srs_res_set_list_l = dyn_array<srs_res_set_s>;

// ActiveULBWP-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using active_ul_bwp_ext_ies_o = protocol_ext_empty_o;

using srs_cfg_ext_ies_container = protocol_ext_container_empty_l;

// SRSConfig ::= SEQUENCE
struct srs_cfg_s {
  bool                      ie_exts_present = false;
  srs_res_list_l            srs_res_list;
  pos_srs_res_list_l        pos_srs_res_list;
  srs_res_set_list_l        srs_res_set_list;
  pos_srs_res_set_list_l    pos_srs_res_set_list;
  srs_cfg_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using active_ul_bwp_ext_ies_container = protocol_ext_container_empty_l;

// ActiveULBWP ::= SEQUENCE
struct active_ul_bwp_s {
  struct subcarrier_spacing_opts {
    enum options { khz15, khz30, khz60, khz120, /*...*/ nulltype } value;
    typedef uint8_t number_type;

    const char* to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<subcarrier_spacing_opts, true> subcarrier_spacing_e_;
  struct cp_opts {
    enum options { normal, extended, nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<cp_opts> cp_e_;
  struct shift7dot5k_hz_opts {
    enum options { true_value, /*...*/ nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<shift7dot5k_hz_opts, true> shift7dot5k_hz_e_;

  // member variables
  bool                            shift7dot5k_hz_present = false;
  bool                            ie_exts_present        = false;
  uint16_t                        location_and_bw        = 0;
  subcarrier_spacing_e_           subcarrier_spacing;
  cp_e_                           cp;
  uint16_t                        tx_direct_current_location = 0;
  shift7dot5k_hz_e_               shift7dot5k_hz;
  srs_cfg_s                       srs_cfg;
  active_ul_bwp_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// EgressBHRLCCHItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using egress_bh_rlc_ch_item_ext_ies_o = protocol_ext_empty_o;

// BAPRoutingIDExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using bap_routing_id_ext_ies_o = protocol_ext_empty_o;

using egress_bh_rlc_ch_item_ext_ies_container = protocol_ext_container_empty_l;

// EgressBHRLCCHItem ::= SEQUENCE
struct egress_bh_rlc_ch_item_s {
  bool                                    ie_exts_present = false;
  fixed_bitstring<10, false, true>        next_hop_bap_address;
  fixed_bitstring<16, false, true>        bh_rlc_ch_id;
  egress_bh_rlc_ch_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// NonF1terminatingTopologyIndicator ::= ENUMERATED
struct non_f1terminating_topology_ind_opts {
  enum options { true_value, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<non_f1terminating_topology_ind_opts, true> non_f1terminating_topology_ind_e;

using bap_routing_id_ext_ies_container = protocol_ext_container_empty_l;

// BAPRoutingID ::= SEQUENCE
struct bap_routing_id_s {
  bool                             ie_exts_present = false;
  fixed_bitstring<10, false, true> bap_address;
  fixed_bitstring<10, false, true> bap_path_id;
  bap_routing_id_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// BHInfo-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
struct bh_info_ext_ies_o {
  // Extension ::= OPEN TYPE
  struct ext_c {
    struct types_opts {
      enum options { non_f1terminating_topology_ind, nulltype } value;
      typedef uint8_t number_type;

      const char* to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::non_f1terminating_topology_ind; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    non_f1terminating_topology_ind_e&       non_f1terminating_topology_ind() { return c; }
    const non_f1terminating_topology_ind_e& non_f1terminating_topology_ind() const { return c; }

  private:
    non_f1terminating_topology_ind_e c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static ext_c      get_ext(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// EgressBHRLCCHList ::= SEQUENCE (SIZE (1..2)) OF EgressBHRLCCHItem
using egress_bh_rlc_ch_list_l = dyn_array<egress_bh_rlc_ch_item_s>;

// GTPTunnel-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using gtp_tunnel_ext_ies_o = protocol_ext_empty_o;

// BHInfo ::= SEQUENCE
struct bh_info_s {
  bool                                        ba_prouting_id_present = false;
  bap_routing_id_s                            ba_prouting_id;
  egress_bh_rlc_ch_list_l                     egress_bh_rlc_ch_list;
  protocol_ext_container_l<bh_info_ext_ies_o> ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using gtp_tunnel_ext_ies_container = protocol_ext_container_empty_l;

// GTPTunnel ::= SEQUENCE
struct gtp_tunnel_s {
  bool                                  ext             = false;
  bool                                  ie_exts_present = false;
  bounded_bitstring<1, 160, true, true> transport_layer_address;
  fixed_octstring<4, true>              gtp_teid;
  gtp_tunnel_ext_ies_container          ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UPTransportLayerInformation-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
using up_transport_layer_info_ext_ies_o = protocol_ies_empty_o;

// AdditionalPDCPDuplicationTNL-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
struct add_pdcp_dupl_tnl_item_ext_ies_o {
  // Extension ::= OPEN TYPE
  struct ext_c {
    struct types_opts {
      enum options { bh_info, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::bh_info; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    bh_info_s&       bh_info() { return c; }
    const bh_info_s& bh_info() const { return c; }

  private:
    bh_info_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static ext_c      get_ext(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// UPTransportLayerInformation ::= CHOICE
struct up_transport_layer_info_c {
  struct types_opts {
    enum options { gtp_tunnel, choice_ext, nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  up_transport_layer_info_c() = default;
  up_transport_layer_info_c(const up_transport_layer_info_c& other);
  up_transport_layer_info_c& operator=(const up_transport_layer_info_c& other);
  ~up_transport_layer_info_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  gtp_tunnel_s& gtp_tunnel()
  {
    assert_choice_type(types::gtp_tunnel, type_, "UPTransportLayerInformation");
    return c.get<gtp_tunnel_s>();
  }
  protocol_ie_single_container_s<up_transport_layer_info_ext_ies_o>& choice_ext()
  {
    assert_choice_type(types::choice_ext, type_, "UPTransportLayerInformation");
    return c.get<protocol_ie_single_container_s<up_transport_layer_info_ext_ies_o>>();
  }
  const gtp_tunnel_s& gtp_tunnel() const
  {
    assert_choice_type(types::gtp_tunnel, type_, "UPTransportLayerInformation");
    return c.get<gtp_tunnel_s>();
  }
  const protocol_ie_single_container_s<up_transport_layer_info_ext_ies_o>& choice_ext() const
  {
    assert_choice_type(types::choice_ext, type_, "UPTransportLayerInformation");
    return c.get<protocol_ie_single_container_s<up_transport_layer_info_ext_ies_o>>();
  }
  gtp_tunnel_s&                                                      set_gtp_tunnel();
  protocol_ie_single_container_s<up_transport_layer_info_ext_ies_o>& set_choice_ext();

private:
  types                                                                                            type_;
  choice_buffer_t<gtp_tunnel_s, protocol_ie_single_container_s<up_transport_layer_info_ext_ies_o>> c;

  void destroy_();
};

// AdditionalPDCPDuplicationTNL-Item ::= SEQUENCE
struct add_pdcp_dupl_tnl_item_s {
  bool                                                       ext = false;
  up_transport_layer_info_c                                  add_pdcp_dupl_up_tnl_info;
  protocol_ext_container_l<add_pdcp_dupl_tnl_item_ext_ies_o> ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// AdditionalPDCPDuplicationTNL-List ::= SEQUENCE (SIZE (1..2)) OF AdditionalPDCPDuplicationTNL-Item
using add_pdcp_dupl_tnl_list_l = dyn_array<add_pdcp_dupl_tnl_item_s>;

// LCS-to-GCS-Translation-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using lcs_to_gcs_translation_ext_ies_o = protocol_ext_empty_o;

using lcs_to_gcs_translation_ext_ies_container = protocol_ext_container_empty_l;

// LCS-to-GCS-Translation ::= SEQUENCE
struct lcs_to_gcs_translation_s {
  bool                                     ext             = false;
  bool                                     ie_exts_present = false;
  uint16_t                                 alpha           = 0;
  uint16_t                                 beta            = 0;
  uint16_t                                 gamma           = 0;
  lcs_to_gcs_translation_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UL-AoA-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using ul_ao_a_ext_ies_o = protocol_ext_empty_o;

// ZoAInformation-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using zo_a_info_ext_ies_o = protocol_ext_empty_o;

// MultipleULAoA-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
using multiple_ul_ao_a_item_ext_ies_o = protocol_ies_empty_o;

using ul_ao_a_ext_ies_container = protocol_ext_container_empty_l;

// UL-AoA ::= SEQUENCE
struct ul_ao_a_s {
  bool                      ext                            = false;
  bool                      zenith_ao_a_present            = false;
  bool                      lcs_to_gcs_translation_present = false;
  bool                      ie_exts_present                = false;
  uint16_t                  azimuth_ao_a                   = 0;
  uint16_t                  zenith_ao_a                    = 0;
  lcs_to_gcs_translation_s  lcs_to_gcs_translation;
  ul_ao_a_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using zo_a_info_ext_ies_container = protocol_ext_container_empty_l;

// ZoAInformation ::= SEQUENCE
struct zo_a_info_s {
  bool                        ext                            = false;
  bool                        lcs_to_gcs_translation_present = false;
  bool                        ie_exts_present                = false;
  uint16_t                    zenith_ao_a                    = 0;
  lcs_to_gcs_translation_s    lcs_to_gcs_translation;
  zo_a_info_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// AngleMeasurementQuality-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using angle_meas_quality_ext_ies_o = protocol_ext_empty_o;

// MultipleULAoA-Item ::= CHOICE
struct multiple_ul_ao_a_item_c {
  struct types_opts {
    enum options { ul_ao_a, ul_zo_a, choice_ext, nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  multiple_ul_ao_a_item_c() = default;
  multiple_ul_ao_a_item_c(const multiple_ul_ao_a_item_c& other);
  multiple_ul_ao_a_item_c& operator=(const multiple_ul_ao_a_item_c& other);
  ~multiple_ul_ao_a_item_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  ul_ao_a_s& ul_ao_a()
  {
    assert_choice_type(types::ul_ao_a, type_, "MultipleULAoA-Item");
    return c.get<ul_ao_a_s>();
  }
  zo_a_info_s& ul_zo_a()
  {
    assert_choice_type(types::ul_zo_a, type_, "MultipleULAoA-Item");
    return c.get<zo_a_info_s>();
  }
  protocol_ie_single_container_s<multiple_ul_ao_a_item_ext_ies_o>& choice_ext()
  {
    assert_choice_type(types::choice_ext, type_, "MultipleULAoA-Item");
    return c.get<protocol_ie_single_container_s<multiple_ul_ao_a_item_ext_ies_o>>();
  }
  const ul_ao_a_s& ul_ao_a() const
  {
    assert_choice_type(types::ul_ao_a, type_, "MultipleULAoA-Item");
    return c.get<ul_ao_a_s>();
  }
  const zo_a_info_s& ul_zo_a() const
  {
    assert_choice_type(types::ul_zo_a, type_, "MultipleULAoA-Item");
    return c.get<zo_a_info_s>();
  }
  const protocol_ie_single_container_s<multiple_ul_ao_a_item_ext_ies_o>& choice_ext() const
  {
    assert_choice_type(types::choice_ext, type_, "MultipleULAoA-Item");
    return c.get<protocol_ie_single_container_s<multiple_ul_ao_a_item_ext_ies_o>>();
  }
  ul_ao_a_s&                                                       set_ul_ao_a();
  zo_a_info_s&                                                     set_ul_zo_a();
  protocol_ie_single_container_s<multiple_ul_ao_a_item_ext_ies_o>& set_choice_ext();

private:
  types                                                                                                    type_;
  choice_buffer_t<protocol_ie_single_container_s<multiple_ul_ao_a_item_ext_ies_o>, ul_ao_a_s, zo_a_info_s> c;

  void destroy_();
};

// TimingMeasurementQuality-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using timing_meas_quality_ext_ies_o = protocol_ext_empty_o;

using angle_meas_quality_ext_ies_container = protocol_ext_container_empty_l;

// AngleMeasurementQuality ::= SEQUENCE
struct angle_meas_quality_s {
  struct resolution_opts {
    enum options { deg0dot1, /*...*/ nulltype } value;
    typedef float number_type;

    const char* to_string() const;
    float       to_number() const;
    const char* to_number_string() const;
  };
  typedef enumerated<resolution_opts, true> resolution_e_;

  // member variables
  bool                                 zenith_quality_present = false;
  bool                                 ie_exts_present        = false;
  uint16_t                             azimuth_quality        = 0;
  uint16_t                             zenith_quality         = 0;
  resolution_e_                        resolution;
  angle_meas_quality_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MultipleULAoA-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using multiple_ul_ao_a_ext_ies_o = protocol_ext_empty_o;

// MultipleULAoA-List ::= SEQUENCE (SIZE (1..8)) OF MultipleULAoA-Item
using multiple_ul_ao_a_list_l = dyn_array<multiple_ul_ao_a_item_c>;

// TRPMeasurementQuality-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
using trp_meas_quality_item_ext_ies_o = protocol_ies_empty_o;

using timing_meas_quality_ext_ies_container = protocol_ext_container_empty_l;

// TimingMeasurementQuality ::= SEQUENCE
struct timing_meas_quality_s {
  struct resolution_opts {
    enum options { m0dot1, m1, m10, m30, /*...*/ nulltype } value;
    typedef float number_type;

    const char* to_string() const;
    float       to_number() const;
    const char* to_number_string() const;
  };
  typedef enumerated<resolution_opts, true> resolution_e_;

  // member variables
  bool                                  ie_exts_present = false;
  uint8_t                               meas_quality    = 0;
  resolution_e_                         resolution;
  timing_meas_quality_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UL-SRS-RSRPP-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using ul_srs_rsrp_p_ext_ies_o = protocol_ext_empty_o;

using multiple_ul_ao_a_ext_ies_container = protocol_ext_container_empty_l;

// MultipleULAoA ::= SEQUENCE
struct multiple_ul_ao_a_s {
  bool                               ext             = false;
  bool                               ie_exts_present = false;
  multiple_ul_ao_a_list_l            multiple_ul_ao_a;
  multiple_ul_ao_a_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RelativePathDelay-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
using relative_path_delay_ext_ies_o = protocol_ies_empty_o;

// TRPMeasurementQuality-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using trp_meas_quality_ext_ies_o = protocol_ext_empty_o;

// TRPMeasurementQuality-Item ::= CHOICE
struct trp_meas_quality_item_c {
  struct types_opts {
    enum options { timing_meas_quality, angle_meas_quality, choice_ext, nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  trp_meas_quality_item_c() = default;
  trp_meas_quality_item_c(const trp_meas_quality_item_c& other);
  trp_meas_quality_item_c& operator=(const trp_meas_quality_item_c& other);
  ~trp_meas_quality_item_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  timing_meas_quality_s& timing_meas_quality()
  {
    assert_choice_type(types::timing_meas_quality, type_, "TRPMeasurementQuality-Item");
    return c.get<timing_meas_quality_s>();
  }
  angle_meas_quality_s& angle_meas_quality()
  {
    assert_choice_type(types::angle_meas_quality, type_, "TRPMeasurementQuality-Item");
    return c.get<angle_meas_quality_s>();
  }
  protocol_ie_single_container_s<trp_meas_quality_item_ext_ies_o>& choice_ext()
  {
    assert_choice_type(types::choice_ext, type_, "TRPMeasurementQuality-Item");
    return c.get<protocol_ie_single_container_s<trp_meas_quality_item_ext_ies_o>>();
  }
  const timing_meas_quality_s& timing_meas_quality() const
  {
    assert_choice_type(types::timing_meas_quality, type_, "TRPMeasurementQuality-Item");
    return c.get<timing_meas_quality_s>();
  }
  const angle_meas_quality_s& angle_meas_quality() const
  {
    assert_choice_type(types::angle_meas_quality, type_, "TRPMeasurementQuality-Item");
    return c.get<angle_meas_quality_s>();
  }
  const protocol_ie_single_container_s<trp_meas_quality_item_ext_ies_o>& choice_ext() const
  {
    assert_choice_type(types::choice_ext, type_, "TRPMeasurementQuality-Item");
    return c.get<protocol_ie_single_container_s<trp_meas_quality_item_ext_ies_o>>();
  }
  timing_meas_quality_s&                                           set_timing_meas_quality();
  angle_meas_quality_s&                                            set_angle_meas_quality();
  protocol_ie_single_container_s<trp_meas_quality_item_ext_ies_o>& set_choice_ext();

private:
  types type_;
  choice_buffer_t<angle_meas_quality_s,
                  protocol_ie_single_container_s<trp_meas_quality_item_ext_ies_o>,
                  timing_meas_quality_s>
      c;

  void destroy_();
};

using ul_srs_rsrp_p_ext_ies_container = protocol_ext_container_empty_l;

// UL-SRS-RSRPP ::= SEQUENCE
struct ul_srs_rsrp_p_s {
  bool                            ext               = false;
  bool                            ie_exts_present   = false;
  uint8_t                         first_path_rsrp_p = 0;
  ul_srs_rsrp_p_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// AdditionalPath-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
struct add_path_item_ext_ies_o {
  // Extension ::= OPEN TYPE
  struct ext_c {
    struct types_opts {
      enum options { multiple_ul_ao_a, path_pwr, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    ext_c() = default;
    ext_c(const ext_c& other);
    ext_c& operator=(const ext_c& other);
    ~ext_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    multiple_ul_ao_a_s&       multiple_ul_ao_a();
    ul_srs_rsrp_p_s&          path_pwr();
    const multiple_ul_ao_a_s& multiple_ul_ao_a() const;
    const ul_srs_rsrp_p_s&    path_pwr() const;

  private:
    types                                                type_;
    choice_buffer_t<multiple_ul_ao_a_s, ul_srs_rsrp_p_s> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static ext_c      get_ext(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// RelativePathDelay ::= CHOICE
struct relative_path_delay_c {
  struct types_opts {
    enum options { k0, k1, k2, k3, k4, k5, choice_ext, nulltype } value;
    typedef uint8_t number_type;

    const char* to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  relative_path_delay_c() = default;
  relative_path_delay_c(const relative_path_delay_c& other);
  relative_path_delay_c& operator=(const relative_path_delay_c& other);
  ~relative_path_delay_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  uint16_t& k0()
  {
    assert_choice_type(types::k0, type_, "RelativePathDelay");
    return c.get<uint16_t>();
  }
  uint16_t& k1()
  {
    assert_choice_type(types::k1, type_, "RelativePathDelay");
    return c.get<uint16_t>();
  }
  uint16_t& k2()
  {
    assert_choice_type(types::k2, type_, "RelativePathDelay");
    return c.get<uint16_t>();
  }
  uint16_t& k3()
  {
    assert_choice_type(types::k3, type_, "RelativePathDelay");
    return c.get<uint16_t>();
  }
  uint16_t& k4()
  {
    assert_choice_type(types::k4, type_, "RelativePathDelay");
    return c.get<uint16_t>();
  }
  uint16_t& k5()
  {
    assert_choice_type(types::k5, type_, "RelativePathDelay");
    return c.get<uint16_t>();
  }
  protocol_ie_single_container_s<relative_path_delay_ext_ies_o>& choice_ext()
  {
    assert_choice_type(types::choice_ext, type_, "RelativePathDelay");
    return c.get<protocol_ie_single_container_s<relative_path_delay_ext_ies_o>>();
  }
  const uint16_t& k0() const
  {
    assert_choice_type(types::k0, type_, "RelativePathDelay");
    return c.get<uint16_t>();
  }
  const uint16_t& k1() const
  {
    assert_choice_type(types::k1, type_, "RelativePathDelay");
    return c.get<uint16_t>();
  }
  const uint16_t& k2() const
  {
    assert_choice_type(types::k2, type_, "RelativePathDelay");
    return c.get<uint16_t>();
  }
  const uint16_t& k3() const
  {
    assert_choice_type(types::k3, type_, "RelativePathDelay");
    return c.get<uint16_t>();
  }
  const uint16_t& k4() const
  {
    assert_choice_type(types::k4, type_, "RelativePathDelay");
    return c.get<uint16_t>();
  }
  const uint16_t& k5() const
  {
    assert_choice_type(types::k5, type_, "RelativePathDelay");
    return c.get<uint16_t>();
  }
  const protocol_ie_single_container_s<relative_path_delay_ext_ies_o>& choice_ext() const
  {
    assert_choice_type(types::choice_ext, type_, "RelativePathDelay");
    return c.get<protocol_ie_single_container_s<relative_path_delay_ext_ies_o>>();
  }
  uint16_t&                                                      set_k0();
  uint16_t&                                                      set_k1();
  uint16_t&                                                      set_k2();
  uint16_t&                                                      set_k3();
  uint16_t&                                                      set_k4();
  uint16_t&                                                      set_k5();
  protocol_ie_single_container_s<relative_path_delay_ext_ies_o>& set_choice_ext();

private:
  types                                                                          type_;
  choice_buffer_t<protocol_ie_single_container_s<relative_path_delay_ext_ies_o>> c;

  void destroy_();
};

using trp_meas_quality_ext_ies_container = protocol_ext_container_empty_l;

// TRPMeasurementQuality ::= SEQUENCE
struct trp_meas_quality_s {
  bool                               ie_exts_present = false;
  trp_meas_quality_item_c            tr_pmeas_quality_item;
  trp_meas_quality_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

struct add_path_item_ext_ies_container {
  template <class extT_>
  using ie_field_s = protocol_ext_container_item_s<extT_>;

  // member variables
  bool                           multiple_ul_ao_a_present = false;
  bool                           path_pwr_present         = false;
  ie_field_s<multiple_ul_ao_a_s> multiple_ul_ao_a;
  ie_field_s<ul_srs_rsrp_p_s>    path_pwr;

  // sequence methods
  add_path_item_ext_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// AdditionalPath-Item ::= SEQUENCE
struct add_path_item_s {
  bool                            path_quality_present = false;
  bool                            ie_exts_present      = false;
  relative_path_delay_c           relative_path_delay;
  trp_meas_quality_s              path_quality;
  add_path_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// AdditionalPath-List ::= SEQUENCE (SIZE (1..2)) OF AdditionalPath-Item
using add_path_list_l = dyn_array<add_path_item_s>;

// AdditionalSIBMessageList-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using add_sib_msg_list_item_ext_ies_o = protocol_ext_empty_o;

using add_sib_msg_list_item_ext_ies_container = protocol_ext_container_empty_l;

// AdditionalSIBMessageList-Item ::= SEQUENCE
struct add_sib_msg_list_item_s {
  bool                                    ie_exts_present = false;
  unbounded_octstring<true>               add_sib;
  add_sib_msg_list_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// AdditionalSIBMessageList ::= SEQUENCE (SIZE (1..63)) OF AdditionalSIBMessageList-Item
using add_sib_msg_list_l = dyn_array<add_sib_msg_list_item_s>;

// AffectedSSB-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using affected_ssb_item_ext_ies_o = protocol_ext_empty_o;

using affected_ssb_item_ext_ies_container = protocol_ext_container_empty_l;

// AffectedSSB-Item ::= SEQUENCE
struct affected_ssb_item_s {
  bool                                ext             = false;
  bool                                ie_exts_present = false;
  uint8_t                             ssb_idx         = 0;
  affected_ssb_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// AffectedCellsAndBeams-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using affected_cells_and_beams_item_ext_ies_o = protocol_ext_empty_o;

// AffectedSSB-List ::= SEQUENCE (SIZE (1..64)) OF AffectedSSB-Item
using affected_ssb_list_l = dyn_array<affected_ssb_item_s>;

using affected_cells_and_beams_item_ext_ies_container = protocol_ext_container_empty_l;

// AffectedCellsAndBeams-Item ::= SEQUENCE
struct affected_cells_and_beams_item_s {
  bool                                            ext             = false;
  bool                                            ie_exts_present = false;
  nr_cgi_s                                        nr_cgi;
  affected_ssb_list_l                             affected_ssb_list;
  affected_cells_and_beams_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// AffectedCellsAndBeams-List ::= SEQUENCE (SIZE (1..32)) OF AffectedCellsAndBeams-Item
using affected_cells_and_beams_list_l = dyn_array<affected_cells_and_beams_item_s>;

// AggressorCellList-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using aggressor_cell_list_item_ext_ies_o = protocol_ext_empty_o;

using aggressor_cell_list_item_ext_ies_container = protocol_ext_container_empty_l;

// AggressorCellList-Item ::= SEQUENCE
struct aggressor_cell_list_item_s {
  bool                                       ie_exts_present = false;
  nr_cgi_s                                   aggressor_cell_id;
  aggressor_cell_list_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// AggressorCellList ::= SEQUENCE (SIZE (1..512)) OF AggressorCellList-Item
using aggressor_cell_list_l = dyn_array<aggressor_cell_list_item_s>;

// AggressorgNBSetID-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using aggressor_gnb_set_id_ext_ies_o = protocol_ext_empty_o;

using aggressor_gnb_set_id_ext_ies_container = protocol_ext_container_empty_l;

// AggressorgNBSetID ::= SEQUENCE
struct aggressor_gnb_set_id_s {
  bool                                   ie_exts_present = false;
  fixed_bitstring<22, false, true>       aggressor_gnb_set_id;
  aggressor_gnb_set_id_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// AllocationAndRetentionPriority-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using alloc_and_retention_prio_ext_ies_o = protocol_ext_empty_o;

// Pre-emptionCapability ::= ENUMERATED
struct pre_emption_cap_opts {
  enum options { shall_not_trigger_pre_emption, may_trigger_pre_emption, nulltype } value;

  const char* to_string() const;
};
typedef enumerated<pre_emption_cap_opts> pre_emption_cap_e;

// Pre-emptionVulnerability ::= ENUMERATED
struct pre_emption_vulnerability_opts {
  enum options { not_pre_emptable, pre_emptable, nulltype } value;

  const char* to_string() const;
};
typedef enumerated<pre_emption_vulnerability_opts> pre_emption_vulnerability_e;

using alloc_and_retention_prio_ext_ies_container = protocol_ext_container_empty_l;

// AllocationAndRetentionPriority ::= SEQUENCE
struct alloc_and_retention_prio_s {
  bool                                       ext             = false;
  bool                                       ie_exts_present = false;
  uint8_t                                    prio_level      = 0;
  pre_emption_cap_e                          pre_emption_cap;
  pre_emption_vulnerability_e                pre_emption_vulnerability;
  alloc_and_retention_prio_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PacketErrorRate-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using packet_error_rate_ext_ies_o = protocol_ext_empty_o;

// AlternativeQoSParaSetItem-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using alt_qos_para_set_item_ext_ies_o = protocol_ext_empty_o;

using packet_error_rate_ext_ies_container = protocol_ext_container_empty_l;

// PacketErrorRate ::= SEQUENCE
struct packet_error_rate_s {
  bool                                ext             = false;
  bool                                ie_exts_present = false;
  uint8_t                             per_scalar      = 0;
  uint8_t                             per_exponent    = 0;
  packet_error_rate_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using alt_qos_para_set_item_ext_ies_container = protocol_ext_container_empty_l;

// AlternativeQoSParaSetItem ::= SEQUENCE
struct alt_qos_para_set_item_s {
  bool                                    ext                                 = false;
  bool                                    guaranteed_flow_bit_rate_dl_present = false;
  bool                                    guaranteed_flow_bit_rate_ul_present = false;
  bool                                    packet_delay_budget_present         = false;
  bool                                    packet_error_rate_present           = false;
  bool                                    ie_exts_present                     = false;
  uint8_t                                 alt_qos_para_set_idx                = 1;
  uint64_t                                guaranteed_flow_bit_rate_dl         = 0;
  uint64_t                                guaranteed_flow_bit_rate_ul         = 0;
  uint16_t                                packet_delay_budget                 = 0;
  packet_error_rate_s                     packet_error_rate;
  alt_qos_para_set_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// AlternativeQoSParaSetList ::= SEQUENCE (SIZE (1..8)) OF AlternativeQoSParaSetItem
using alt_qos_para_set_list_l = dyn_array<alt_qos_para_set_item_s>;

// Expected-Azimuth-AoA-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using expected_azimuth_ao_a_ext_ies_o = protocol_ext_empty_o;

// Expected-Zenith-AoA-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using expected_zenith_ao_a_ext_ies_o = protocol_ext_empty_o;

using expected_azimuth_ao_a_ext_ies_container = protocol_ext_container_empty_l;

// Expected-Azimuth-AoA ::= SEQUENCE
struct expected_azimuth_ao_a_s {
  bool                                    ext                               = false;
  bool                                    ie_exts_present                   = false;
  uint16_t                                expected_azimuth_ao_a_value       = 0;
  uint16_t                                expected_azimuth_ao_a_uncertainty = 0;
  expected_azimuth_ao_a_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// Expected-UL-AoA-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using expected_ul_ao_a_ext_ies_o = protocol_ext_empty_o;

using expected_zenith_ao_a_ext_ies_container = protocol_ext_container_empty_l;

// Expected-Zenith-AoA ::= SEQUENCE
struct expected_zenith_ao_a_s {
  bool                                   ext                              = false;
  bool                                   ie_exts_present                  = false;
  uint16_t                               expected_zenith_ao_a_value       = 0;
  uint16_t                               expected_zenith_ao_a_uncertainty = 0;
  expected_zenith_ao_a_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// Expected-ZoA-only-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using expected_zo_a_only_ext_ies_o = protocol_ext_empty_o;

// AngleMeasurementType-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
using angle_meas_type_ext_ies_o = protocol_ies_empty_o;

using expected_ul_ao_a_ext_ies_container = protocol_ext_container_empty_l;

// Expected-UL-AoA ::= SEQUENCE
struct expected_ul_ao_a_s {
  bool                               ext                          = false;
  bool                               expected_zenith_ao_a_present = false;
  bool                               ie_exts_present              = false;
  expected_azimuth_ao_a_s            expected_azimuth_ao_a;
  expected_zenith_ao_a_s             expected_zenith_ao_a;
  expected_ul_ao_a_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using expected_zo_a_only_ext_ies_container = protocol_ext_container_empty_l;

// Expected-ZoA-only ::= SEQUENCE
struct expected_zo_a_only_s {
  bool                                 ext             = false;
  bool                                 ie_exts_present = false;
  expected_zenith_ao_a_s               expected_zo_a_only;
  expected_zo_a_only_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// AngleMeasurementType ::= CHOICE
struct angle_meas_type_c {
  struct types_opts {
    enum options { expected_ul_ao_a, expected_zo_a, choice_ext, nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  angle_meas_type_c() = default;
  angle_meas_type_c(const angle_meas_type_c& other);
  angle_meas_type_c& operator=(const angle_meas_type_c& other);
  ~angle_meas_type_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  expected_ul_ao_a_s& expected_ul_ao_a()
  {
    assert_choice_type(types::expected_ul_ao_a, type_, "AngleMeasurementType");
    return c.get<expected_ul_ao_a_s>();
  }
  expected_zo_a_only_s& expected_zo_a()
  {
    assert_choice_type(types::expected_zo_a, type_, "AngleMeasurementType");
    return c.get<expected_zo_a_only_s>();
  }
  protocol_ie_single_container_s<angle_meas_type_ext_ies_o>& choice_ext()
  {
    assert_choice_type(types::choice_ext, type_, "AngleMeasurementType");
    return c.get<protocol_ie_single_container_s<angle_meas_type_ext_ies_o>>();
  }
  const expected_ul_ao_a_s& expected_ul_ao_a() const
  {
    assert_choice_type(types::expected_ul_ao_a, type_, "AngleMeasurementType");
    return c.get<expected_ul_ao_a_s>();
  }
  const expected_zo_a_only_s& expected_zo_a() const
  {
    assert_choice_type(types::expected_zo_a, type_, "AngleMeasurementType");
    return c.get<expected_zo_a_only_s>();
  }
  const protocol_ie_single_container_s<angle_meas_type_ext_ies_o>& choice_ext() const
  {
    assert_choice_type(types::choice_ext, type_, "AngleMeasurementType");
    return c.get<protocol_ie_single_container_s<angle_meas_type_ext_ies_o>>();
  }
  expected_ul_ao_a_s&                                        set_expected_ul_ao_a();
  expected_zo_a_only_s&                                      set_expected_zo_a();
  protocol_ie_single_container_s<angle_meas_type_ext_ies_o>& set_choice_ext();

private:
  types type_;
  choice_buffer_t<expected_ul_ao_a_s, expected_zo_a_only_s, protocol_ie_single_container_s<angle_meas_type_ext_ies_o>>
      c;

  void destroy_();
};

// AoA-AssistanceInfo-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using ao_a_assist_info_ext_ies_o = protocol_ext_empty_o;

using ao_a_assist_info_ext_ies_container = protocol_ext_container_empty_l;

// AoA-AssistanceInfo ::= SEQUENCE
struct ao_a_assist_info_s {
  bool                               ext                            = false;
  bool                               lcs_to_gcs_translation_present = false;
  bool                               ie_exts_present                = false;
  angle_meas_type_c                  angle_meas;
  lcs_to_gcs_translation_s           lcs_to_gcs_translation;
  ao_a_assist_info_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// AperiodicSRSResourceTriggerList ::= SEQUENCE (SIZE (1..3)) OF INTEGER (1..3)
using aperiodic_srs_res_trigger_list_l = bounded_array<uint8_t, 3>;

// SRSResourceTrigger-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using srs_res_trigger_ext_ies_o = protocol_ext_empty_o;

// AperiodicSRS-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using aperiodic_srs_ext_ies_o = protocol_ext_empty_o;

using srs_res_trigger_ext_ies_container = protocol_ext_container_empty_l;

// SRSResourceTrigger ::= SEQUENCE
struct srs_res_trigger_s {
  bool                              ie_exts_present = false;
  aperiodic_srs_res_trigger_list_l  aperiodic_srs_res_trigger_list;
  srs_res_trigger_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using aperiodic_srs_ext_ies_container = protocol_ext_container_empty_l;

// AperiodicSRS ::= SEQUENCE
struct aperiodic_srs_s {
  struct aperiodic_opts {
    enum options { true_value, /*...*/ nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<aperiodic_opts, true> aperiodic_e_;

  // member variables
  bool                            ext                     = false;
  bool                            srs_res_trigger_present = false;
  bool                            ie_exts_present         = false;
  aperiodic_e_                    aperiodic;
  srs_res_trigger_s               srs_res_trigger;
  aperiodic_srs_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// Associated-SCell-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using associated_scell_item_ext_ies_o = protocol_ext_empty_o;

using associated_scell_item_ext_ies_container = protocol_ext_container_empty_l;

// Associated-SCell-Item ::= SEQUENCE
struct associated_scell_item_s {
  bool                                    ie_exts_present = false;
  nr_cgi_s                                scell_id;
  associated_scell_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// Associated-SCell-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct associated_scell_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { associated_scell_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::associated_scell_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    associated_scell_item_s&       associated_scell_item() { return c; }
    const associated_scell_item_s& associated_scell_item() const { return c; }

  private:
    associated_scell_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// Associated-SCell-List ::= SEQUENCE (SIZE (1..32)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES : IEsSetParam}
using associated_scell_list_l = bounded_array<protocol_ie_single_container_s<associated_scell_item_ies_o>, 32>;

// AvailablePLMNList-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using available_plmn_list_item_ext_ies_o = protocol_ext_empty_o;

using available_plmn_list_item_ext_ies_container = protocol_ext_container_empty_l;

// AvailablePLMNList-Item ::= SEQUENCE
struct available_plmn_list_item_s {
  bool                                       ie_exts_present = false;
  fixed_octstring<3, true>                   plmn_id;
  available_plmn_list_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// AvailablePLMNList ::= SEQUENCE (SIZE (1..6)) OF AvailablePLMNList-Item
using available_plmn_list_l = dyn_array<available_plmn_list_item_s>;

// AvailableSNPN-ID-List-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using available_sn_pn_id_list_item_ext_ies_o = protocol_ext_empty_o;

// BroadcastNIDList ::= SEQUENCE (SIZE (1..12)) OF BIT STRING (SIZE (44))
using broadcast_n_id_list_l = bounded_array<fixed_bitstring<44, false, true>, 12>;

using available_sn_pn_id_list_item_ext_ies_container = protocol_ext_container_empty_l;

// AvailableSNPN-ID-List-Item ::= SEQUENCE
struct available_sn_pn_id_list_item_s {
  bool                                           ext             = false;
  bool                                           ie_exts_present = false;
  fixed_octstring<3, true>                       plmn_id;
  broadcast_n_id_list_l                          available_n_id_list;
  available_sn_pn_id_list_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// AvailableSNPN-ID-List ::= SEQUENCE (SIZE (1..12)) OF AvailableSNPN-ID-List-Item
using available_sn_pn_id_list_l = dyn_array<available_sn_pn_id_list_item_s>;

// BAP-Header-Rewriting-Added-List-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using bap_hdr_rewriting_added_list_item_ext_ies_o = protocol_ext_empty_o;

using bap_hdr_rewriting_added_list_item_ext_ies_container = protocol_ext_container_empty_l;

// BAP-Header-Rewriting-Added-List-Item ::= SEQUENCE
struct bap_hdr_rewriting_added_list_item_s {
  bool                                                non_f1terminating_topology_ind_present = false;
  bool                                                ie_exts_present                        = false;
  bap_routing_id_s                                    ingress_bap_routing_id;
  bap_routing_id_s                                    egress_bap_routing_id;
  non_f1terminating_topology_ind_e                    non_f1terminating_topology_ind;
  bap_hdr_rewriting_added_list_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// BAP-Header-Rewriting-Added-List-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct bap_hdr_rewriting_added_list_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { bap_hdr_rewriting_added_list_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::bap_hdr_rewriting_added_list_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    bap_hdr_rewriting_added_list_item_s&       bap_hdr_rewriting_added_list_item() { return c; }
    const bap_hdr_rewriting_added_list_item_s& bap_hdr_rewriting_added_list_item() const { return c; }

  private:
    bap_hdr_rewriting_added_list_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// BAP-Header-Rewriting-Added-List ::= SEQUENCE (SIZE (1..1024)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES :
// IEsSetParam}
using bap_hdr_rewriting_added_list_l =
    dyn_array<protocol_ie_single_container_s<bap_hdr_rewriting_added_list_item_ies_o>>;

// BAP-Header-Rewriting-Removed-List-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using bap_hdr_rewriting_remd_list_item_ext_ies_o = protocol_ext_empty_o;

using bap_hdr_rewriting_remd_list_item_ext_ies_container = protocol_ext_container_empty_l;

// BAP-Header-Rewriting-Removed-List-Item ::= SEQUENCE
struct bap_hdr_rewriting_remd_list_item_s {
  bool                                               ie_exts_present = false;
  bap_routing_id_s                                   ingress_bap_routing_id;
  bap_hdr_rewriting_remd_list_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// BAP-Header-Rewriting-Removed-List-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct bap_hdr_rewriting_remd_list_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { bap_hdr_rewriting_remd_list_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::bap_hdr_rewriting_remd_list_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    bap_hdr_rewriting_remd_list_item_s&       bap_hdr_rewriting_remd_list_item() { return c; }
    const bap_hdr_rewriting_remd_list_item_s& bap_hdr_rewriting_remd_list_item() const { return c; }

  private:
    bap_hdr_rewriting_remd_list_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// BAP-Header-Rewriting-Removed-List ::= SEQUENCE (SIZE (1..1024)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES :
// IEsSetParam}
using bap_hdr_rewriting_remd_list_l = dyn_array<protocol_ie_single_container_s<bap_hdr_rewriting_remd_list_item_ies_o>>;

// IABTNLAddress-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
using iab_tnl_address_ext_ies_o = protocol_ies_empty_o;

// DSInformationList ::= SEQUENCE (SIZE (0..64)) OF BIT STRING (SIZE (6))
using d_si_nformation_list_l = dyn_array<fixed_bitstring<6, false, true>>;

// EgressNonF1terminatingTopologyIndicator ::= ENUMERATED
struct egress_non_f1terminating_topology_ind_opts {
  enum options { true_value, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<egress_non_f1terminating_topology_ind_opts, true> egress_non_f1terminating_topology_ind_e;

// IABTNLAddress ::= CHOICE
struct iab_tnl_address_c {
  struct types_opts {
    enum options { ip_v4_address, ip_v6_address, ip_v6_prefix, choice_ext, nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  iab_tnl_address_c() = default;
  iab_tnl_address_c(const iab_tnl_address_c& other);
  iab_tnl_address_c& operator=(const iab_tnl_address_c& other);
  ~iab_tnl_address_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  fixed_bitstring<32, false, true>& ip_v4_address()
  {
    assert_choice_type(types::ip_v4_address, type_, "IABTNLAddress");
    return c.get<fixed_bitstring<32, false, true>>();
  }
  fixed_bitstring<128, false, true>& ip_v6_address()
  {
    assert_choice_type(types::ip_v6_address, type_, "IABTNLAddress");
    return c.get<fixed_bitstring<128, false, true>>();
  }
  fixed_bitstring<64, false, true>& ip_v6_prefix()
  {
    assert_choice_type(types::ip_v6_prefix, type_, "IABTNLAddress");
    return c.get<fixed_bitstring<64, false, true>>();
  }
  protocol_ie_single_container_s<iab_tnl_address_ext_ies_o>& choice_ext()
  {
    assert_choice_type(types::choice_ext, type_, "IABTNLAddress");
    return c.get<protocol_ie_single_container_s<iab_tnl_address_ext_ies_o>>();
  }
  const fixed_bitstring<32, false, true>& ip_v4_address() const
  {
    assert_choice_type(types::ip_v4_address, type_, "IABTNLAddress");
    return c.get<fixed_bitstring<32, false, true>>();
  }
  const fixed_bitstring<128, false, true>& ip_v6_address() const
  {
    assert_choice_type(types::ip_v6_address, type_, "IABTNLAddress");
    return c.get<fixed_bitstring<128, false, true>>();
  }
  const fixed_bitstring<64, false, true>& ip_v6_prefix() const
  {
    assert_choice_type(types::ip_v6_prefix, type_, "IABTNLAddress");
    return c.get<fixed_bitstring<64, false, true>>();
  }
  const protocol_ie_single_container_s<iab_tnl_address_ext_ies_o>& choice_ext() const
  {
    assert_choice_type(types::choice_ext, type_, "IABTNLAddress");
    return c.get<protocol_ie_single_container_s<iab_tnl_address_ext_ies_o>>();
  }
  fixed_bitstring<32, false, true>&                          set_ip_v4_address();
  fixed_bitstring<128, false, true>&                         set_ip_v6_address();
  fixed_bitstring<64, false, true>&                          set_ip_v6_prefix();
  protocol_ie_single_container_s<iab_tnl_address_ext_ies_o>& set_choice_ext();

private:
  types                                                                                                         type_;
  choice_buffer_t<fixed_bitstring<128, false, true>, protocol_ie_single_container_s<iab_tnl_address_ext_ies_o>> c;

  void destroy_();
};

// IPHeaderInformation-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using ip_hdr_info_item_ext_ies_o = protocol_ext_empty_o;

// IngressNonF1terminatingTopologyIndicator ::= ENUMERATED
struct ingress_non_f1terminating_topology_ind_opts {
  enum options { true_value, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<ingress_non_f1terminating_topology_ind_opts, true> ingress_non_f1terminating_topology_ind_e;

// BAPlayerBHRLCchannelMappingInfo-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
struct ba_player_bh_rlc_ch_map_info_item_ext_ies_o {
  // Extension ::= OPEN TYPE
  struct ext_c {
    struct types_opts {
      enum options { ingress_non_f1terminating_topology_ind, egress_non_f1terminating_topology_ind, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    ext_c() = default;
    ext_c(const ext_c& other);
    ext_c& operator=(const ext_c& other);
    ~ext_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    ingress_non_f1terminating_topology_ind_e&       ingress_non_f1terminating_topology_ind();
    egress_non_f1terminating_topology_ind_e&        egress_non_f1terminating_topology_ind();
    const ingress_non_f1terminating_topology_ind_e& ingress_non_f1terminating_topology_ind() const;
    const egress_non_f1terminating_topology_ind_e&  egress_non_f1terminating_topology_ind() const;

  private:
    types               type_;
    pod_choice_buffer_t c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static ext_c      get_ext(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

using ip_hdr_info_item_ext_ies_container = protocol_ext_container_empty_l;

// IPHeaderInformation ::= SEQUENCE
struct ip_hdr_info_s {
  bool                               ext                      = false;
  bool                               ds_info_list_present     = false;
  bool                               ip_v6_flow_label_present = false;
  bool                               ie_exts_present          = false;
  iab_tnl_address_c                  dest_iab_tnl_address;
  d_si_nformation_list_l             ds_info_list;
  fixed_bitstring<20, false, true>   ip_v6_flow_label;
  ip_hdr_info_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// IPtolayer2TrafficMappingInfo-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using ip_tolayer2_traffic_map_info_item_ext_ies_o = protocol_ext_empty_o;

struct ba_player_bh_rlc_ch_map_info_item_ext_ies_container {
  template <class extT_>
  using ie_field_s = protocol_ext_container_item_s<extT_>;

  // member variables
  bool                                                 ingress_non_f1terminating_topology_ind_present = false;
  bool                                                 egress_non_f1terminating_topology_ind_present  = false;
  ie_field_s<ingress_non_f1terminating_topology_ind_e> ingress_non_f1terminating_topology_ind;
  ie_field_s<egress_non_f1terminating_topology_ind_e>  egress_non_f1terminating_topology_ind;

  // sequence methods
  ba_player_bh_rlc_ch_map_info_item_ext_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// BAPlayerBHRLCchannelMappingInfo-Item ::= SEQUENCE
struct ba_player_bh_rlc_ch_map_info_item_s {
  bool                                                ext                           = false;
  bool                                                prior_hop_bap_address_present = false;
  bool                                                ingressb_h_rlc_ch_id_present  = false;
  bool                                                next_hop_bap_address_present  = false;
  bool                                                egressb_h_rlc_ch_id_present   = false;
  bool                                                ie_exts_present               = false;
  fixed_bitstring<26, false, true>                    map_info_idx;
  fixed_bitstring<10, false, true>                    prior_hop_bap_address;
  fixed_bitstring<16, false, true>                    ingressb_h_rlc_ch_id;
  fixed_bitstring<10, false, true>                    next_hop_bap_address;
  fixed_bitstring<16, false, true>                    egressb_h_rlc_ch_id;
  ba_player_bh_rlc_ch_map_info_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// BH-Routing-Information-Added-List-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
struct bh_routing_info_added_list_item_ext_ies_o {
  // Extension ::= OPEN TYPE
  struct ext_c {
    struct types_opts {
      enum options { non_f1terminating_topology_ind, nulltype } value;
      typedef uint8_t number_type;

      const char* to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::non_f1terminating_topology_ind; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    non_f1terminating_topology_ind_e&       non_f1terminating_topology_ind() { return c; }
    const non_f1terminating_topology_ind_e& non_f1terminating_topology_ind() const { return c; }

  private:
    non_f1terminating_topology_ind_e c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static ext_c      get_ext(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// BH-Routing-Information-Removed-List-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using bh_routing_info_remd_list_item_ext_ies_o = protocol_ext_empty_o;

using ip_tolayer2_traffic_map_info_item_ext_ies_container = protocol_ext_container_empty_l;

// IPtolayer2TrafficMappingInfo-Item ::= SEQUENCE
struct ip_tolayer2_traffic_map_info_item_s {
  bool                                                ext             = false;
  bool                                                ie_exts_present = false;
  fixed_bitstring<26, false, true>                    map_info_idx;
  ip_hdr_info_s                                       ip_hdr_info;
  bh_info_s                                           bh_info;
  ip_tolayer2_traffic_map_info_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// BAPlayerBHRLCchannelMappingInfo-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using ba_player_bh_rlc_ch_map_info_ext_ies_o = protocol_ext_empty_o;

// BAPlayerBHRLCchannelMappingInfoList ::= SEQUENCE (SIZE (1..67108864)) OF BAPlayerBHRLCchannelMappingInfo-Item
using ba_player_bh_rlc_ch_map_info_list_l = dyn_array<ba_player_bh_rlc_ch_map_info_item_s>;

// BH-Routing-Information-Added-List-Item ::= SEQUENCE
struct bh_routing_info_added_list_item_s {
  bap_routing_id_s                                                    bap_routing_id;
  fixed_bitstring<10, false, true>                                    next_hop_bap_address;
  protocol_ext_container_l<bh_routing_info_added_list_item_ext_ies_o> ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using bh_routing_info_remd_list_item_ext_ies_container = protocol_ext_container_empty_l;

// BH-Routing-Information-Removed-List-Item ::= SEQUENCE
struct bh_routing_info_remd_list_item_s {
  bool                                             ie_exts_present = false;
  bap_routing_id_s                                 bap_routing_id;
  bh_routing_info_remd_list_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// IPtolayer2TrafficMappingInfoList ::= SEQUENCE (SIZE (1..67108864)) OF IPtolayer2TrafficMappingInfo-Item
using ip_tolayer2_traffic_map_info_list_l = dyn_array<ip_tolayer2_traffic_map_info_item_s>;

// MappingInformationtoRemove ::= SEQUENCE (SIZE (1..67108864)) OF BIT STRING (SIZE (26))
using map_infoto_rem_l = dyn_array<fixed_bitstring<26, false, true>>;

using ba_player_bh_rlc_ch_map_info_ext_ies_container = protocol_ext_container_empty_l;

// BAPlayerBHRLCchannelMappingInfo ::= SEQUENCE
struct ba_player_bh_rlc_ch_map_info_s {
  bool                                           ext             = false;
  bool                                           ie_exts_present = false;
  ba_player_bh_rlc_ch_map_info_list_l            ba_player_bh_rlc_ch_map_info_to_add;
  map_infoto_rem_l                               ba_player_bh_rlc_ch_map_info_to_rem;
  ba_player_bh_rlc_ch_map_info_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// BH-Routing-Information-Added-List-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct bh_routing_info_added_list_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { bh_routing_info_added_list_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::bh_routing_info_added_list_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    bh_routing_info_added_list_item_s&       bh_routing_info_added_list_item() { return c; }
    const bh_routing_info_added_list_item_s& bh_routing_info_added_list_item() const { return c; }

  private:
    bh_routing_info_added_list_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// BH-Routing-Information-Removed-List-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct bh_routing_info_remd_list_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { bh_routing_info_remd_list_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::bh_routing_info_remd_list_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    bh_routing_info_remd_list_item_s&       bh_routing_info_remd_list_item() { return c; }
    const bh_routing_info_remd_list_item_s& bh_routing_info_remd_list_item() const { return c; }

  private:
    bh_routing_info_remd_list_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// IPtolayer2TrafficMappingInfo ::= SEQUENCE
struct ip_tolayer2_traffic_map_info_s {
  bool                                                ext             = false;
  bool                                                ie_exts_present = false;
  ip_tolayer2_traffic_map_info_list_l                 ip_tolayer2_traffic_map_info_to_add;
  map_infoto_rem_l                                    ip_tolayer2_traffic_map_info_to_rem;
  ip_tolayer2_traffic_map_info_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// TrafficMappingInfo-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
using traffic_map_info_ext_ies_o = protocol_ies_empty_o;

// BH-Routing-Information-Added-List ::= SEQUENCE (SIZE (1..1024)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES :
// IEsSetParam}
using bh_routing_info_added_list_l = dyn_array<protocol_ie_single_container_s<bh_routing_info_added_list_item_ies_o>>;

// BH-Routing-Information-Removed-List ::= SEQUENCE (SIZE (1..1024)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES :
// IEsSetParam}
using bh_routing_info_remd_list_l = dyn_array<protocol_ie_single_container_s<bh_routing_info_remd_list_item_ies_o>>;

// Re-routingEnableIndicator ::= ENUMERATED
struct re_routing_enable_ind_opts {
  enum options { true_value, false_value, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<re_routing_enable_ind_opts, true> re_routing_enable_ind_e;

// TrafficMappingInfo ::= CHOICE
struct traffic_map_info_c {
  struct types_opts {
    enum options { ip_tolayer2_traffic_map_info, ba_player_bh_rlc_ch_map_info, choice_ext, nulltype } value;
    typedef uint8_t number_type;

    const char* to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  traffic_map_info_c() = default;
  traffic_map_info_c(const traffic_map_info_c& other);
  traffic_map_info_c& operator=(const traffic_map_info_c& other);
  ~traffic_map_info_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  ip_tolayer2_traffic_map_info_s& ip_tolayer2_traffic_map_info()
  {
    assert_choice_type(types::ip_tolayer2_traffic_map_info, type_, "TrafficMappingInfo");
    return c.get<ip_tolayer2_traffic_map_info_s>();
  }
  ba_player_bh_rlc_ch_map_info_s& ba_player_bh_rlc_ch_map_info()
  {
    assert_choice_type(types::ba_player_bh_rlc_ch_map_info, type_, "TrafficMappingInfo");
    return c.get<ba_player_bh_rlc_ch_map_info_s>();
  }
  protocol_ie_single_container_s<traffic_map_info_ext_ies_o>& choice_ext()
  {
    assert_choice_type(types::choice_ext, type_, "TrafficMappingInfo");
    return c.get<protocol_ie_single_container_s<traffic_map_info_ext_ies_o>>();
  }
  const ip_tolayer2_traffic_map_info_s& ip_tolayer2_traffic_map_info() const
  {
    assert_choice_type(types::ip_tolayer2_traffic_map_info, type_, "TrafficMappingInfo");
    return c.get<ip_tolayer2_traffic_map_info_s>();
  }
  const ba_player_bh_rlc_ch_map_info_s& ba_player_bh_rlc_ch_map_info() const
  {
    assert_choice_type(types::ba_player_bh_rlc_ch_map_info, type_, "TrafficMappingInfo");
    return c.get<ba_player_bh_rlc_ch_map_info_s>();
  }
  const protocol_ie_single_container_s<traffic_map_info_ext_ies_o>& choice_ext() const
  {
    assert_choice_type(types::choice_ext, type_, "TrafficMappingInfo");
    return c.get<protocol_ie_single_container_s<traffic_map_info_ext_ies_o>>();
  }
  ip_tolayer2_traffic_map_info_s&                             set_ip_tolayer2_traffic_map_info();
  ba_player_bh_rlc_ch_map_info_s&                             set_ba_player_bh_rlc_ch_map_info();
  protocol_ie_single_container_s<traffic_map_info_ext_ies_o>& set_choice_ext();

private:
  types type_;
  choice_buffer_t<ba_player_bh_rlc_ch_map_info_s,
                  ip_tolayer2_traffic_map_info_s,
                  protocol_ie_single_container_s<traffic_map_info_ext_ies_o>>
      c;

  void destroy_();
};

// BAPMappingConfiguration-IEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct bap_map_cfg_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options {
        transaction_id,
        bh_routing_info_added_list,
        bh_routing_info_remd_list,
        traffic_map_info,
        buffer_size_thresh,
        bap_hdr_rewriting_added_list,
        re_routing_enable_ind,
        bap_hdr_rewriting_remd_list,
        nulltype
      } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint16_t&                             transaction_id();
    bh_routing_info_added_list_l&         bh_routing_info_added_list();
    bh_routing_info_remd_list_l&          bh_routing_info_remd_list();
    traffic_map_info_c&                   traffic_map_info();
    uint32_t&                             buffer_size_thresh();
    bap_hdr_rewriting_added_list_l&       bap_hdr_rewriting_added_list();
    re_routing_enable_ind_e&              re_routing_enable_ind();
    bap_hdr_rewriting_remd_list_l&        bap_hdr_rewriting_remd_list();
    const uint16_t&                       transaction_id() const;
    const bh_routing_info_added_list_l&   bh_routing_info_added_list() const;
    const bh_routing_info_remd_list_l&    bh_routing_info_remd_list() const;
    const traffic_map_info_c&             traffic_map_info() const;
    const uint32_t&                       buffer_size_thresh() const;
    const bap_hdr_rewriting_added_list_l& bap_hdr_rewriting_added_list() const;
    const re_routing_enable_ind_e&        re_routing_enable_ind() const;
    const bap_hdr_rewriting_remd_list_l&  bap_hdr_rewriting_remd_list() const;

  private:
    types type_;
    choice_buffer_t<bap_hdr_rewriting_added_list_l,
                    bap_hdr_rewriting_remd_list_l,
                    bh_routing_info_added_list_l,
                    bh_routing_info_remd_list_l,
                    traffic_map_info_c>
        c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

struct bap_map_cfg_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                              bh_routing_info_added_list_present   = false;
  bool                                              bh_routing_info_remd_list_present    = false;
  bool                                              traffic_map_info_present             = false;
  bool                                              buffer_size_thresh_present           = false;
  bool                                              bap_hdr_rewriting_added_list_present = false;
  bool                                              re_routing_enable_ind_present        = false;
  bool                                              bap_hdr_rewriting_remd_list_present  = false;
  ie_field_s<integer<uint16_t, 0, 255, true, true>> transaction_id;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<bh_routing_info_added_list_item_ies_o>, 1, 1024, true>>
      bh_routing_info_added_list;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<bh_routing_info_remd_list_item_ies_o>, 1, 1024, true>>
                                                          bh_routing_info_remd_list;
  ie_field_s<traffic_map_info_c>                          traffic_map_info;
  ie_field_s<integer<uint32_t, 0, 16777215, false, true>> buffer_size_thresh;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<bap_hdr_rewriting_added_list_item_ies_o>, 1, 1024, true>>
                                      bap_hdr_rewriting_added_list;
  ie_field_s<re_routing_enable_ind_e> re_routing_enable_ind;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<bap_hdr_rewriting_remd_list_item_ies_o>, 1, 1024, true>>
      bap_hdr_rewriting_remd_list;

  // sequence methods
  bap_map_cfg_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// BAPMappingConfiguration ::= SEQUENCE
using bap_map_cfg_s = elementary_procedure_option<bap_map_cfg_ies_container>;

// CriticalityDiagnostics-IE-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using crit_diagnostics_ie_item_ext_ies_o = protocol_ext_empty_o;

// TypeOfError ::= ENUMERATED
struct type_of_error_opts {
  enum options { not_understood, missing, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<type_of_error_opts, true> type_of_error_e;

using crit_diagnostics_ie_item_ext_ies_container = protocol_ext_container_empty_l;

// CriticalityDiagnostics-IE-Item ::= SEQUENCE
struct crit_diagnostics_ie_item_s {
  bool                                       ext             = false;
  bool                                       ie_exts_present = false;
  crit_e                                     ie_crit;
  uint32_t                                   ie_id = 0;
  type_of_error_e                            type_of_error;
  crit_diagnostics_ie_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CriticalityDiagnostics-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using crit_diagnostics_ext_ies_o = protocol_ext_empty_o;

// CriticalityDiagnostics-IE-List ::= SEQUENCE (SIZE (1..256)) OF CriticalityDiagnostics-IE-Item
using crit_diagnostics_ie_list_l = dyn_array<crit_diagnostics_ie_item_s>;

// TriggeringMessage ::= ENUMERATED
struct trigger_msg_opts {
  enum options { init_msg, successful_outcome, unsuccessful_outcome, nulltype } value;

  const char* to_string() const;
};
typedef enumerated<trigger_msg_opts> trigger_msg_e;

using crit_diagnostics_ext_ies_container = protocol_ext_container_empty_l;

// CriticalityDiagnostics ::= SEQUENCE
struct crit_diagnostics_s {
  bool                               ext                    = false;
  bool                               proc_code_present      = false;
  bool                               trigger_msg_present    = false;
  bool                               proc_crit_present      = false;
  bool                               transaction_id_present = false;
  bool                               ie_exts_present        = false;
  uint16_t                           proc_code              = 0;
  trigger_msg_e                      trigger_msg;
  crit_e                             proc_crit;
  uint16_t                           transaction_id = 0;
  crit_diagnostics_ie_list_l         ies_crit_diagnostics;
  crit_diagnostics_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// BAPMappingConfigurationAcknowledge-IEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct bap_map_cfg_ack_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { transaction_id, crit_diagnostics, nulltype } value;
      typedef uint8_t number_type;

      const char* to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint16_t&                 transaction_id();
    crit_diagnostics_s&       crit_diagnostics();
    const uint16_t&           transaction_id() const;
    const crit_diagnostics_s& crit_diagnostics() const;

  private:
    types                               type_;
    choice_buffer_t<crit_diagnostics_s> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

struct bap_map_cfg_ack_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                              crit_diagnostics_present = false;
  ie_field_s<integer<uint16_t, 0, 255, true, true>> transaction_id;
  ie_field_s<crit_diagnostics_s>                    crit_diagnostics;

  // sequence methods
  bap_map_cfg_ack_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// BAPMappingConfigurationAcknowledge ::= SEQUENCE
using bap_map_cfg_ack_s = elementary_procedure_option<bap_map_cfg_ack_ies_container>;

// Cause-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
using cause_ext_ies_o = protocol_ies_empty_o;

// CauseMisc ::= ENUMERATED
struct cause_misc_opts {
  enum options {
    ctrl_processing_overload,
    not_enough_user_plane_processing_res,
    hardware_fail,
    om_intervention,
    unspecified,
    // ...
    nulltype
  } value;

  const char* to_string() const;
};
typedef enumerated<cause_misc_opts, true> cause_misc_e;

// CauseProtocol ::= ENUMERATED
struct cause_protocol_opts {
  enum options {
    transfer_syntax_error,
    abstract_syntax_error_reject,
    abstract_syntax_error_ignore_and_notify,
    msg_not_compatible_with_receiver_state,
    semantic_error,
    abstract_syntax_error_falsely_constructed_msg,
    unspecified,
    // ...
    nulltype
  } value;

  const char* to_string() const;
};
typedef enumerated<cause_protocol_opts, true> cause_protocol_e;

// CauseRadioNetwork ::= ENUMERATED
struct cause_radio_network_opts {
  enum options {
    unspecified,
    rl_fail_rlc,
    unknown_or_already_allocated_gnb_cu_ue_f1ap_id,
    unknown_or_already_allocated_gnb_du_ue_f1ap_id,
    unknown_or_inconsistent_pair_of_ue_f1ap_id,
    interaction_with_other_proc,
    not_supported_qci_value,
    action_desirable_for_radio_reasons,
    no_radio_res_available,
    proc_cancelled,
    normal_release,
    // ...
    cell_not_available,
    rl_fail_others,
    ue_rejection,
    res_not_available_for_the_slice,
    amf_initiated_abnormal_release,
    release_due_to_pre_emption,
    plmn_not_served_by_the_gnb_cu,
    multiple_drb_id_instances,
    unknown_drb_id,
    multiple_bh_rlc_ch_id_instances,
    unknown_bh_rlc_ch_id,
    cho_cpc_res_tobechanged,
    npn_not_supported,
    npn_access_denied,
    gnb_cu_cell_capacity_exceeded,
    report_characteristics_empty,
    existing_meas_id,
    meas_temporarily_not_available,
    meas_not_supported_for_the_obj,
    unknown_bh_address,
    unknown_bap_routing_id,
    insufficient_ue_cap,
    scg_activation_deactivation_fail,
    scg_deactivation_fail_due_to_data_tx,
    requested_item_not_supported_on_time,
    unknown_or_already_allocated_gnb_cu_mbs_f1ap_id,
    unknown_or_already_allocated_gnb_du_mbs_f1ap_id,
    unknown_or_inconsistent_pair_of_mbs_f1ap_id,
    unknown_or_inconsistent_mrb_id,
    tat_sdt_expiry,
    nulltype
  } value;

  const char* to_string() const;
};
typedef enumerated<cause_radio_network_opts, true, 30> cause_radio_network_e;

// CauseTransport ::= ENUMERATED
struct cause_transport_opts {
  enum options {
    unspecified,
    transport_res_unavailable,
    // ...
    unknown_tnl_address_for_iab,
    unknown_up_tnl_info_for_iab,
    nulltype
  } value;

  const char* to_string() const;
};
typedef enumerated<cause_transport_opts, true, 2> cause_transport_e;

// Cause ::= CHOICE
struct cause_c {
  struct types_opts {
    enum options { radio_network, transport, protocol, misc, choice_ext, nulltype } value;
    typedef uint8_t number_type;

    const char* to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  cause_c() = default;
  cause_c(const cause_c& other);
  cause_c& operator=(const cause_c& other);
  ~cause_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  cause_radio_network_e& radio_network()
  {
    assert_choice_type(types::radio_network, type_, "Cause");
    return c.get<cause_radio_network_e>();
  }
  cause_transport_e& transport()
  {
    assert_choice_type(types::transport, type_, "Cause");
    return c.get<cause_transport_e>();
  }
  cause_protocol_e& protocol()
  {
    assert_choice_type(types::protocol, type_, "Cause");
    return c.get<cause_protocol_e>();
  }
  cause_misc_e& misc()
  {
    assert_choice_type(types::misc, type_, "Cause");
    return c.get<cause_misc_e>();
  }
  protocol_ie_single_container_s<cause_ext_ies_o>& choice_ext()
  {
    assert_choice_type(types::choice_ext, type_, "Cause");
    return c.get<protocol_ie_single_container_s<cause_ext_ies_o>>();
  }
  const cause_radio_network_e& radio_network() const
  {
    assert_choice_type(types::radio_network, type_, "Cause");
    return c.get<cause_radio_network_e>();
  }
  const cause_transport_e& transport() const
  {
    assert_choice_type(types::transport, type_, "Cause");
    return c.get<cause_transport_e>();
  }
  const cause_protocol_e& protocol() const
  {
    assert_choice_type(types::protocol, type_, "Cause");
    return c.get<cause_protocol_e>();
  }
  const cause_misc_e& misc() const
  {
    assert_choice_type(types::misc, type_, "Cause");
    return c.get<cause_misc_e>();
  }
  const protocol_ie_single_container_s<cause_ext_ies_o>& choice_ext() const
  {
    assert_choice_type(types::choice_ext, type_, "Cause");
    return c.get<protocol_ie_single_container_s<cause_ext_ies_o>>();
  }
  cause_radio_network_e&                           set_radio_network();
  cause_transport_e&                               set_transport();
  cause_protocol_e&                                set_protocol();
  cause_misc_e&                                    set_misc();
  protocol_ie_single_container_s<cause_ext_ies_o>& set_choice_ext();

private:
  types                                                            type_;
  choice_buffer_t<protocol_ie_single_container_s<cause_ext_ies_o>> c;

  void destroy_();
};

// TimeToWait ::= ENUMERATED
struct time_to_wait_opts {
  enum options { v1s, v2s, v5s, v10s, v20s, v60s, /*...*/ nulltype } value;
  typedef uint8_t number_type;

  const char* to_string() const;
  uint8_t     to_number() const;
};
typedef enumerated<time_to_wait_opts, true> time_to_wait_e;

// BAPMappingConfigurationFailureIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct bap_map_cfg_fail_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { transaction_id, cause, time_to_wait, crit_diagnostics, nulltype } value;
      typedef uint8_t number_type;

      const char* to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint16_t&                 transaction_id();
    cause_c&                  cause();
    time_to_wait_e&           time_to_wait();
    crit_diagnostics_s&       crit_diagnostics();
    const uint16_t&           transaction_id() const;
    const cause_c&            cause() const;
    const time_to_wait_e&     time_to_wait() const;
    const crit_diagnostics_s& crit_diagnostics() const;

  private:
    types                                        type_;
    choice_buffer_t<cause_c, crit_diagnostics_s> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

struct bap_map_cfg_fail_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                              time_to_wait_present     = false;
  bool                                              crit_diagnostics_present = false;
  ie_field_s<integer<uint16_t, 0, 255, true, true>> transaction_id;
  ie_field_s<cause_c>                               cause;
  ie_field_s<time_to_wait_e>                        time_to_wait;
  ie_field_s<crit_diagnostics_s>                    crit_diagnostics;

  // sequence methods
  bap_map_cfg_fail_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// BAPMappingConfigurationFailure ::= SEQUENCE
using bap_map_cfg_fail_s = elementary_procedure_option<bap_map_cfg_fail_ies_container>;

// LocationDependentMBSF1UInformation-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using location_dependent_mbsf1_u_info_item_ext_ies_o = protocol_ext_empty_o;

using location_dependent_mbsf1_u_info_item_ext_ies_container = protocol_ext_container_empty_l;

// LocationDependentMBSF1UInformation-Item ::= SEQUENCE
struct location_dependent_mbsf1_u_info_item_s {
  bool                                                   ext                 = false;
  bool                                                   ie_exts_present     = false;
  uint32_t                                               mbs_area_session_id = 0;
  up_transport_layer_info_c                              mbs_f1u_info_at_cu;
  location_dependent_mbsf1_u_info_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MBSF1UInformation-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using mbsf1_u_info_ext_ies_o = protocol_ext_empty_o;

// BCBearerContextF1U-TNLInfo-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
using bc_bearer_context_f1_u_tnl_info_ext_ies_o = protocol_ies_empty_o;

// LocationDependentMBSF1UInformation ::= SEQUENCE (SIZE (1..256)) OF LocationDependentMBSF1UInformation-Item
using location_dependent_mbsf1_u_info_l = dyn_array<location_dependent_mbsf1_u_info_item_s>;

using mbsf1_u_info_ext_ies_container = protocol_ext_container_empty_l;

// MBSF1UInformation ::= SEQUENCE
struct mbsf1_u_info_s {
  bool                           ext             = false;
  bool                           ie_exts_present = false;
  up_transport_layer_info_c      mbs_f1u_info;
  mbsf1_u_info_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// BCBearerContextF1U-TNLInfo ::= CHOICE
struct bc_bearer_context_f1_u_tnl_info_c {
  struct types_opts {
    enum options { locationindpendent, locationdependent, choice_ext, nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  bc_bearer_context_f1_u_tnl_info_c() = default;
  bc_bearer_context_f1_u_tnl_info_c(const bc_bearer_context_f1_u_tnl_info_c& other);
  bc_bearer_context_f1_u_tnl_info_c& operator=(const bc_bearer_context_f1_u_tnl_info_c& other);
  ~bc_bearer_context_f1_u_tnl_info_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  mbsf1_u_info_s& locationindpendent()
  {
    assert_choice_type(types::locationindpendent, type_, "BCBearerContextF1U-TNLInfo");
    return c.get<mbsf1_u_info_s>();
  }
  location_dependent_mbsf1_u_info_l& locationdependent()
  {
    assert_choice_type(types::locationdependent, type_, "BCBearerContextF1U-TNLInfo");
    return c.get<location_dependent_mbsf1_u_info_l>();
  }
  protocol_ie_single_container_s<bc_bearer_context_f1_u_tnl_info_ext_ies_o>& choice_ext()
  {
    assert_choice_type(types::choice_ext, type_, "BCBearerContextF1U-TNLInfo");
    return c.get<protocol_ie_single_container_s<bc_bearer_context_f1_u_tnl_info_ext_ies_o>>();
  }
  const mbsf1_u_info_s& locationindpendent() const
  {
    assert_choice_type(types::locationindpendent, type_, "BCBearerContextF1U-TNLInfo");
    return c.get<mbsf1_u_info_s>();
  }
  const location_dependent_mbsf1_u_info_l& locationdependent() const
  {
    assert_choice_type(types::locationdependent, type_, "BCBearerContextF1U-TNLInfo");
    return c.get<location_dependent_mbsf1_u_info_l>();
  }
  const protocol_ie_single_container_s<bc_bearer_context_f1_u_tnl_info_ext_ies_o>& choice_ext() const
  {
    assert_choice_type(types::choice_ext, type_, "BCBearerContextF1U-TNLInfo");
    return c.get<protocol_ie_single_container_s<bc_bearer_context_f1_u_tnl_info_ext_ies_o>>();
  }
  mbsf1_u_info_s&                                                            set_locationindpendent();
  location_dependent_mbsf1_u_info_l&                                         set_locationdependent();
  protocol_ie_single_container_s<bc_bearer_context_f1_u_tnl_info_ext_ies_o>& set_choice_ext();

private:
  types type_;
  choice_buffer_t<location_dependent_mbsf1_u_info_l,
                  mbsf1_u_info_s,
                  protocol_ie_single_container_s<bc_bearer_context_f1_u_tnl_info_ext_ies_o>>
      c;

  void destroy_();
};

// BHChannels-FailedToBeModified-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using bh_chs_failed_to_be_modified_item_ext_ies_o = protocol_ext_empty_o;

using bh_chs_failed_to_be_modified_item_ext_ies_container = protocol_ext_container_empty_l;

// BHChannels-FailedToBeModified-Item ::= SEQUENCE
struct bh_chs_failed_to_be_modified_item_s {
  bool                                                cause_present   = false;
  bool                                                ie_exts_present = false;
  fixed_bitstring<16, false, true>                    bh_rlc_ch_id;
  cause_c                                             cause;
  bh_chs_failed_to_be_modified_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// BHChannels-FailedToBeModified-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct bh_chs_failed_to_be_modified_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { bh_chs_failed_to_be_modified_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::bh_chs_failed_to_be_modified_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    bh_chs_failed_to_be_modified_item_s&       bh_chs_failed_to_be_modified_item() { return c; }
    const bh_chs_failed_to_be_modified_item_s& bh_chs_failed_to_be_modified_item() const { return c; }

  private:
    bh_chs_failed_to_be_modified_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// BHChannels-FailedToBeModified-List ::= SEQUENCE (SIZE (1..65536)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES :
// IEsSetParam}
using bh_chs_failed_to_be_modified_list_l =
    dyn_array<protocol_ie_single_container_s<bh_chs_failed_to_be_modified_item_ies_o>>;

// BHChannels-FailedToBeSetup-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using bh_chs_failed_to_be_setup_item_ext_ies_o = protocol_ext_empty_o;

using bh_chs_failed_to_be_setup_item_ext_ies_container = protocol_ext_container_empty_l;

// BHChannels-FailedToBeSetup-Item ::= SEQUENCE
struct bh_chs_failed_to_be_setup_item_s {
  bool                                             cause_present   = false;
  bool                                             ie_exts_present = false;
  fixed_bitstring<16, false, true>                 bh_rlc_ch_id;
  cause_c                                          cause;
  bh_chs_failed_to_be_setup_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// BHChannels-FailedToBeSetup-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct bh_chs_failed_to_be_setup_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { bh_chs_failed_to_be_setup_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::bh_chs_failed_to_be_setup_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    bh_chs_failed_to_be_setup_item_s&       bh_chs_failed_to_be_setup_item() { return c; }
    const bh_chs_failed_to_be_setup_item_s& bh_chs_failed_to_be_setup_item() const { return c; }

  private:
    bh_chs_failed_to_be_setup_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// BHChannels-FailedToBeSetup-List ::= SEQUENCE (SIZE (1..65536)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES :
// IEsSetParam}
using bh_chs_failed_to_be_setup_list_l =
    dyn_array<protocol_ie_single_container_s<bh_chs_failed_to_be_setup_item_ies_o>>;

// BHChannels-FailedToBeSetupMod-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using bh_chs_failed_to_be_setup_mod_item_ext_ies_o = protocol_ext_empty_o;

using bh_chs_failed_to_be_setup_mod_item_ext_ies_container = protocol_ext_container_empty_l;

// BHChannels-FailedToBeSetupMod-Item ::= SEQUENCE
struct bh_chs_failed_to_be_setup_mod_item_s {
  bool                                                 cause_present   = false;
  bool                                                 ie_exts_present = false;
  fixed_bitstring<16, false, true>                     bh_rlc_ch_id;
  cause_c                                              cause;
  bh_chs_failed_to_be_setup_mod_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// BHChannels-FailedToBeSetupMod-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct bh_chs_failed_to_be_setup_mod_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { bh_chs_failed_to_be_setup_mod_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::bh_chs_failed_to_be_setup_mod_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    bh_chs_failed_to_be_setup_mod_item_s&       bh_chs_failed_to_be_setup_mod_item() { return c; }
    const bh_chs_failed_to_be_setup_mod_item_s& bh_chs_failed_to_be_setup_mod_item() const { return c; }

  private:
    bh_chs_failed_to_be_setup_mod_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// BHChannels-FailedToBeSetupMod-List ::= SEQUENCE (SIZE (1..65536)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES :
// IEsSetParam}
using bh_chs_failed_to_be_setup_mod_list_l =
    dyn_array<protocol_ie_single_container_s<bh_chs_failed_to_be_setup_mod_item_ies_o>>;

// BHChannels-Modified-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using bh_chs_modified_item_ext_ies_o = protocol_ext_empty_o;

using bh_chs_modified_item_ext_ies_container = protocol_ext_container_empty_l;

// BHChannels-Modified-Item ::= SEQUENCE
struct bh_chs_modified_item_s {
  bool                                   ie_exts_present = false;
  fixed_bitstring<16, false, true>       bh_rlc_ch_id;
  bh_chs_modified_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// BHChannels-Modified-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct bh_chs_modified_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { bh_chs_modified_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::bh_chs_modified_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    bh_chs_modified_item_s&       bh_chs_modified_item() { return c; }
    const bh_chs_modified_item_s& bh_chs_modified_item() const { return c; }

  private:
    bh_chs_modified_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// BHChannels-Modified-List ::= SEQUENCE (SIZE (1..65536)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES :
// IEsSetParam}
using bh_chs_modified_list_l = dyn_array<protocol_ie_single_container_s<bh_chs_modified_item_ies_o>>;

// BHChannels-Required-ToBeReleased-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using bh_chs_required_to_be_released_item_ext_ies_o = protocol_ext_empty_o;

using bh_chs_required_to_be_released_item_ext_ies_container = protocol_ext_container_empty_l;

// BHChannels-Required-ToBeReleased-Item ::= SEQUENCE
struct bh_chs_required_to_be_released_item_s {
  bool                                                  ie_exts_present = false;
  fixed_bitstring<16, false, true>                      bh_rlc_ch_id;
  bh_chs_required_to_be_released_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// BHChannels-Required-ToBeReleased-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct bh_chs_required_to_be_released_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { bh_chs_required_to_be_released_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::bh_chs_required_to_be_released_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    bh_chs_required_to_be_released_item_s&       bh_chs_required_to_be_released_item() { return c; }
    const bh_chs_required_to_be_released_item_s& bh_chs_required_to_be_released_item() const { return c; }

  private:
    bh_chs_required_to_be_released_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// BHChannels-Required-ToBeReleased-List ::= SEQUENCE (SIZE (1..65536)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES
// : IEsSetParam}
using bh_chs_required_to_be_released_list_l =
    dyn_array<protocol_ie_single_container_s<bh_chs_required_to_be_released_item_ies_o>>;

// BHChannels-Setup-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using bh_chs_setup_item_ext_ies_o = protocol_ext_empty_o;

using bh_chs_setup_item_ext_ies_container = protocol_ext_container_empty_l;

// BHChannels-Setup-Item ::= SEQUENCE
struct bh_chs_setup_item_s {
  bool                                ie_exts_present = false;
  fixed_bitstring<16, false, true>    bh_rlc_ch_id;
  bh_chs_setup_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// BHChannels-Setup-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct bh_chs_setup_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { bh_chs_setup_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::bh_chs_setup_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    bh_chs_setup_item_s&       bh_chs_setup_item() { return c; }
    const bh_chs_setup_item_s& bh_chs_setup_item() const { return c; }

  private:
    bh_chs_setup_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// BHChannels-Setup-List ::= SEQUENCE (SIZE (1..65536)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES : IEsSetParam}
using bh_chs_setup_list_l = dyn_array<protocol_ie_single_container_s<bh_chs_setup_item_ies_o>>;

// BHChannels-SetupMod-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using bh_chs_setup_mod_item_ext_ies_o = protocol_ext_empty_o;

using bh_chs_setup_mod_item_ext_ies_container = protocol_ext_container_empty_l;

// BHChannels-SetupMod-Item ::= SEQUENCE
struct bh_chs_setup_mod_item_s {
  bool                                    ie_exts_present = false;
  fixed_bitstring<16, false, true>        bh_rlc_ch_id;
  bh_chs_setup_mod_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// BHChannels-SetupMod-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct bh_chs_setup_mod_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { bh_chs_setup_mod_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::bh_chs_setup_mod_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    bh_chs_setup_mod_item_s&       bh_chs_setup_mod_item() { return c; }
    const bh_chs_setup_mod_item_s& bh_chs_setup_mod_item() const { return c; }

  private:
    bh_chs_setup_mod_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// BHChannels-SetupMod-List ::= SEQUENCE (SIZE (1..65536)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES :
// IEsSetParam}
using bh_chs_setup_mod_list_l = dyn_array<protocol_ie_single_container_s<bh_chs_setup_mod_item_ies_o>>;

// Dynamic5QIDescriptor-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
struct dyn_5qi_descriptor_ext_ies_o {
  // Extension ::= OPEN TYPE
  struct ext_c {
    struct types_opts {
      enum options {
        extended_packet_delay_budget,
        cn_packet_delay_budget_dl,
        cn_packet_delay_budget_ul,
        nulltype
      } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    ext_c() = default;
    ext_c(const ext_c& other);
    ext_c& operator=(const ext_c& other);
    ~ext_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint32_t&       extended_packet_delay_budget();
    uint32_t&       cn_packet_delay_budget_dl();
    uint32_t&       cn_packet_delay_budget_ul();
    const uint32_t& extended_packet_delay_budget() const;
    const uint32_t& cn_packet_delay_budget_dl() const;
    const uint32_t& cn_packet_delay_budget_ul() const;

  private:
    types               type_;
    pod_choice_buffer_t c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static ext_c      get_ext(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// NonDynamic5QIDescriptor-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
struct non_dyn_5qi_descriptor_ext_ies_o {
  // Extension ::= OPEN TYPE
  struct ext_c {
    struct types_opts {
      enum options { cn_packet_delay_budget_dl, cn_packet_delay_budget_ul, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    ext_c() = default;
    ext_c(const ext_c& other);
    ext_c& operator=(const ext_c& other);
    ~ext_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint32_t&       cn_packet_delay_budget_dl();
    uint32_t&       cn_packet_delay_budget_ul();
    const uint32_t& cn_packet_delay_budget_dl() const;
    const uint32_t& cn_packet_delay_budget_ul() const;

  private:
    types               type_;
    pod_choice_buffer_t c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static ext_c      get_ext(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

struct dyn_5qi_descriptor_ext_ies_container {
  template <class extT_>
  using ie_field_s = protocol_ext_container_item_s<extT_>;

  // member variables
  bool                                                extended_packet_delay_budget_present = false;
  bool                                                cn_packet_delay_budget_dl_present    = false;
  bool                                                cn_packet_delay_budget_ul_present    = false;
  ie_field_s<integer<uint32_t, 1, 65535, true, true>> extended_packet_delay_budget;
  ie_field_s<integer<uint32_t, 1, 65535, true, true>> cn_packet_delay_budget_dl;
  ie_field_s<integer<uint32_t, 1, 65535, true, true>> cn_packet_delay_budget_ul;

  // sequence methods
  dyn_5qi_descriptor_ext_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// Dynamic5QIDescriptor ::= SEQUENCE
struct dyn_5qi_descriptor_s {
  struct delay_crit_opts {
    enum options { delay_crit, non_delay_crit, nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<delay_crit_opts> delay_crit_e_;

  // member variables
  bool                                 five_qi_present               = false;
  bool                                 delay_crit_present            = false;
  bool                                 averaging_win_present         = false;
  bool                                 max_data_burst_volume_present = false;
  bool                                 ie_exts_present               = false;
  uint8_t                              qos_prio_level                = 1;
  uint16_t                             packet_delay_budget           = 0;
  packet_error_rate_s                  packet_error_rate;
  uint16_t                             five_qi = 0;
  delay_crit_e_                        delay_crit;
  uint16_t                             averaging_win         = 0;
  uint16_t                             max_data_burst_volume = 0;
  dyn_5qi_descriptor_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// GBR-QosFlowInformation-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
struct gbr_qos_flow_info_ext_ies_o {
  // Extension ::= OPEN TYPE
  struct ext_c {
    struct types_opts {
      enum options { alt_qos_para_set_list, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::alt_qos_para_set_list; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    alt_qos_para_set_list_l&       alt_qos_para_set_list() { return c; }
    const alt_qos_para_set_list_l& alt_qos_para_set_list() const { return c; }

  private:
    alt_qos_para_set_list_l c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static ext_c      get_ext(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// GBR-QosInformation-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using gbr_qos_info_ext_ies_o = protocol_ext_empty_o;

// NGRANAllocationAndRetentionPriority-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using ngran_alloc_and_retention_prio_ext_ies_o = protocol_ext_empty_o;

struct non_dyn_5qi_descriptor_ext_ies_container {
  template <class extT_>
  using ie_field_s = protocol_ext_container_item_s<extT_>;

  // member variables
  bool                                                cn_packet_delay_budget_dl_present = false;
  bool                                                cn_packet_delay_budget_ul_present = false;
  ie_field_s<integer<uint32_t, 1, 65535, true, true>> cn_packet_delay_budget_dl;
  ie_field_s<integer<uint32_t, 1, 65535, true, true>> cn_packet_delay_budget_ul;

  // sequence methods
  non_dyn_5qi_descriptor_ext_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// NonDynamic5QIDescriptor ::= SEQUENCE
struct non_dyn_5qi_descriptor_s {
  bool                                     qos_prio_level_present        = false;
  bool                                     averaging_win_present         = false;
  bool                                     max_data_burst_volume_present = false;
  bool                                     ie_exts_present               = false;
  uint16_t                                 five_qi                       = 0;
  uint8_t                                  qos_prio_level                = 1;
  uint16_t                                 averaging_win                 = 0;
  uint16_t                                 max_data_burst_volume         = 0;
  non_dyn_5qi_descriptor_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// QoS-Characteristics-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
using qos_characteristics_ext_ies_o = protocol_ies_empty_o;

// QosMonitoringRequest ::= ENUMERATED
struct qos_monitoring_request_opts {
  enum options { ul, dl, both, /*...*/ stop, nulltype } value;

  const char* to_string() const;
};
typedef enumerated<qos_monitoring_request_opts, true, 1> qos_monitoring_request_e;

// EUTRANQoS-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
struct eutran_qos_ext_ies_o {
  // Extension ::= OPEN TYPE
  struct ext_c {
    struct types_opts {
      enum options { enb_dl_tnl_address, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::enb_dl_tnl_address; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    bounded_bitstring<1, 160, true, true>&       enb_dl_tnl_address() { return c; }
    const bounded_bitstring<1, 160, true, true>& enb_dl_tnl_address() const { return c; }

  private:
    bounded_bitstring<1, 160, true, true> c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static ext_c      get_ext(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// GBR-QoSFlowInformation ::= SEQUENCE
struct gbr_qos_flow_info_s {
  bool                                                  ext                             = false;
  bool                                                  max_packet_loss_rate_dl_present = false;
  bool                                                  max_packet_loss_rate_ul_present = false;
  uint64_t                                              max_flow_bit_rate_dl            = 0;
  uint64_t                                              max_flow_bit_rate_ul            = 0;
  uint64_t                                              guaranteed_flow_bit_rate_dl     = 0;
  uint64_t                                              guaranteed_flow_bit_rate_ul     = 0;
  uint16_t                                              max_packet_loss_rate_dl         = 0;
  uint16_t                                              max_packet_loss_rate_ul         = 0;
  protocol_ext_container_l<gbr_qos_flow_info_ext_ies_o> ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using gbr_qos_info_ext_ies_container = protocol_ext_container_empty_l;

// GBR-QosInformation ::= SEQUENCE
struct gbr_qos_info_s {
  bool                           ext                        = false;
  bool                           ie_exts_present            = false;
  uint64_t                       erab_max_bitrate_dl        = 0;
  uint64_t                       erab_max_bitrate_ul        = 0;
  uint64_t                       erab_guaranteed_bitrate_dl = 0;
  uint64_t                       erab_guaranteed_bitrate_ul = 0;
  gbr_qos_info_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using ngran_alloc_and_retention_prio_ext_ies_container = protocol_ext_container_empty_l;

// NGRANAllocationAndRetentionPriority ::= SEQUENCE
struct ngran_alloc_and_retention_prio_s {
  bool                                             ie_exts_present = false;
  uint8_t                                          prio_level      = 0;
  pre_emption_cap_e                                pre_emption_cap;
  pre_emption_vulnerability_e                      pre_emption_vulnerability;
  ngran_alloc_and_retention_prio_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// QoS-Characteristics ::= CHOICE
struct qos_characteristics_c {
  struct types_opts {
    enum options { non_dyn_5qi, dyn_5qi, choice_ext, nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  qos_characteristics_c() = default;
  qos_characteristics_c(const qos_characteristics_c& other);
  qos_characteristics_c& operator=(const qos_characteristics_c& other);
  ~qos_characteristics_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  non_dyn_5qi_descriptor_s& non_dyn_5qi()
  {
    assert_choice_type(types::non_dyn_5qi, type_, "QoS-Characteristics");
    return c.get<non_dyn_5qi_descriptor_s>();
  }
  dyn_5qi_descriptor_s& dyn_5qi()
  {
    assert_choice_type(types::dyn_5qi, type_, "QoS-Characteristics");
    return c.get<dyn_5qi_descriptor_s>();
  }
  protocol_ie_single_container_s<qos_characteristics_ext_ies_o>& choice_ext()
  {
    assert_choice_type(types::choice_ext, type_, "QoS-Characteristics");
    return c.get<protocol_ie_single_container_s<qos_characteristics_ext_ies_o>>();
  }
  const non_dyn_5qi_descriptor_s& non_dyn_5qi() const
  {
    assert_choice_type(types::non_dyn_5qi, type_, "QoS-Characteristics");
    return c.get<non_dyn_5qi_descriptor_s>();
  }
  const dyn_5qi_descriptor_s& dyn_5qi() const
  {
    assert_choice_type(types::dyn_5qi, type_, "QoS-Characteristics");
    return c.get<dyn_5qi_descriptor_s>();
  }
  const protocol_ie_single_container_s<qos_characteristics_ext_ies_o>& choice_ext() const
  {
    assert_choice_type(types::choice_ext, type_, "QoS-Characteristics");
    return c.get<protocol_ie_single_container_s<qos_characteristics_ext_ies_o>>();
  }
  non_dyn_5qi_descriptor_s&                                      set_non_dyn_5qi();
  dyn_5qi_descriptor_s&                                          set_dyn_5qi();
  protocol_ie_single_container_s<qos_characteristics_ext_ies_o>& set_choice_ext();

private:
  types type_;
  choice_buffer_t<dyn_5qi_descriptor_s,
                  non_dyn_5qi_descriptor_s,
                  protocol_ie_single_container_s<qos_characteristics_ext_ies_o>>
      c;

  void destroy_();
};

// QoSFlowLevelQoSParameters-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
struct qos_flow_level_qos_params_ext_ies_o {
  // Extension ::= OPEN TYPE
  struct ext_c {
    struct types_opts {
      enum options {
        pdu_session_id,
        ul_pdu_session_aggr_max_bit_rate,
        qos_monitoring_request,
        pdcp_terminating_node_dl_tnl_addr_info,
        nulltype
      } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    ext_c() = default;
    ext_c(const ext_c& other);
    ext_c& operator=(const ext_c& other);
    ~ext_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint16_t&                                    pdu_session_id();
    uint64_t&                                    ul_pdu_session_aggr_max_bit_rate();
    qos_monitoring_request_e&                    qos_monitoring_request();
    bounded_bitstring<1, 160, true, true>&       pdcp_terminating_node_dl_tnl_addr_info();
    const uint16_t&                              pdu_session_id() const;
    const uint64_t&                              ul_pdu_session_aggr_max_bit_rate() const;
    const qos_monitoring_request_e&              qos_monitoring_request() const;
    const bounded_bitstring<1, 160, true, true>& pdcp_terminating_node_dl_tnl_addr_info() const;

  private:
    types                                                  type_;
    choice_buffer_t<bounded_bitstring<1, 160, true, true>> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static ext_c      get_ext(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// BHQoSInformation-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
using bh_qos_info_ext_ies_o = protocol_ies_empty_o;

// EUTRANQoS ::= SEQUENCE
struct eutran_qos_s {
  bool                                           ext                  = false;
  bool                                           gbr_qos_info_present = false;
  uint16_t                                       qci                  = 0;
  alloc_and_retention_prio_s                     alloc_and_retention_prio;
  gbr_qos_info_s                                 gbr_qos_info;
  protocol_ext_container_l<eutran_qos_ext_ies_o> ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

struct qos_flow_level_qos_params_ext_ies_container {
  template <class extT_>
  using ie_field_s = protocol_ext_container_item_s<extT_>;

  // member variables
  bool                                                        pdu_session_id_present                         = false;
  bool                                                        ul_pdu_session_aggr_max_bit_rate_present       = false;
  bool                                                        qos_monitoring_request_present                 = false;
  bool                                                        pdcp_terminating_node_dl_tnl_addr_info_present = false;
  ie_field_s<integer<uint16_t, 0, 255, false, true>>          pdu_session_id;
  ie_field_s<integer<uint64_t, 0, 4000000000000, true, true>> ul_pdu_session_aggr_max_bit_rate;
  ie_field_s<qos_monitoring_request_e>                        qos_monitoring_request;
  ie_field_s<bounded_bitstring<1, 160, true, true>>           pdcp_terminating_node_dl_tnl_addr_info;

  // sequence methods
  qos_flow_level_qos_params_ext_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// QoSFlowLevelQoSParameters ::= SEQUENCE
struct qos_flow_level_qos_params_s {
  struct reflective_qos_attribute_opts {
    enum options { subject_to, /*...*/ nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<reflective_qos_attribute_opts, true> reflective_qos_attribute_e_;

  // member variables
  bool                                        gbr_qos_flow_info_present        = false;
  bool                                        reflective_qos_attribute_present = false;
  bool                                        ie_exts_present                  = false;
  qos_characteristics_c                       qos_characteristics;
  ngran_alloc_and_retention_prio_s            ngra_nalloc_retention_prio;
  gbr_qos_flow_info_s                         gbr_qos_flow_info;
  reflective_qos_attribute_e_                 reflective_qos_attribute;
  qos_flow_level_qos_params_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// BAPCtrlPDUChannel ::= ENUMERATED
struct bap_ctrl_pdu_ch_opts {
  enum options { true_value, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<bap_ctrl_pdu_ch_opts, true> bap_ctrl_pdu_ch_e;

// BHChannels-ToBeModified-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using bh_chs_to_be_modified_item_ext_ies_o = protocol_ext_empty_o;

// BHQoSInformation ::= CHOICE
struct bh_qos_info_c {
  struct types_opts {
    enum options { bh_rlc_ch_qos, eutran_bh_rlc_ch_qos, cp_traffic_type, choice_ext, nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  bh_qos_info_c() = default;
  bh_qos_info_c(const bh_qos_info_c& other);
  bh_qos_info_c& operator=(const bh_qos_info_c& other);
  ~bh_qos_info_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  qos_flow_level_qos_params_s& bh_rlc_ch_qos()
  {
    assert_choice_type(types::bh_rlc_ch_qos, type_, "BHQoSInformation");
    return c.get<qos_flow_level_qos_params_s>();
  }
  eutran_qos_s& eutran_bh_rlc_ch_qos()
  {
    assert_choice_type(types::eutran_bh_rlc_ch_qos, type_, "BHQoSInformation");
    return c.get<eutran_qos_s>();
  }
  uint8_t& cp_traffic_type()
  {
    assert_choice_type(types::cp_traffic_type, type_, "BHQoSInformation");
    return c.get<uint8_t>();
  }
  protocol_ie_single_container_s<bh_qos_info_ext_ies_o>& choice_ext()
  {
    assert_choice_type(types::choice_ext, type_, "BHQoSInformation");
    return c.get<protocol_ie_single_container_s<bh_qos_info_ext_ies_o>>();
  }
  const qos_flow_level_qos_params_s& bh_rlc_ch_qos() const
  {
    assert_choice_type(types::bh_rlc_ch_qos, type_, "BHQoSInformation");
    return c.get<qos_flow_level_qos_params_s>();
  }
  const eutran_qos_s& eutran_bh_rlc_ch_qos() const
  {
    assert_choice_type(types::eutran_bh_rlc_ch_qos, type_, "BHQoSInformation");
    return c.get<eutran_qos_s>();
  }
  const uint8_t& cp_traffic_type() const
  {
    assert_choice_type(types::cp_traffic_type, type_, "BHQoSInformation");
    return c.get<uint8_t>();
  }
  const protocol_ie_single_container_s<bh_qos_info_ext_ies_o>& choice_ext() const
  {
    assert_choice_type(types::choice_ext, type_, "BHQoSInformation");
    return c.get<protocol_ie_single_container_s<bh_qos_info_ext_ies_o>>();
  }
  qos_flow_level_qos_params_s&                           set_bh_rlc_ch_qos();
  eutran_qos_s&                                          set_eutran_bh_rlc_ch_qos();
  uint8_t&                                               set_cp_traffic_type();
  protocol_ie_single_container_s<bh_qos_info_ext_ies_o>& set_choice_ext();

private:
  types type_;
  choice_buffer_t<eutran_qos_s, protocol_ie_single_container_s<bh_qos_info_ext_ies_o>, qos_flow_level_qos_params_s> c;

  void destroy_();
};

// RLCMode ::= ENUMERATED
struct rlc_mode_opts {
  enum options {
    rlc_am,
    rlc_um_bidirectional,
    rlc_um_unidirectional_ul,
    rlc_um_unidirectional_dl,
    /*...*/ nulltype
  } value;

  const char* to_string() const;
};
typedef enumerated<rlc_mode_opts, true> rlc_mode_e;

using bh_chs_to_be_modified_item_ext_ies_container = protocol_ext_container_empty_l;

// BHChannels-ToBeModified-Item ::= SEQUENCE
struct bh_chs_to_be_modified_item_s {
  bool                                         rlc_mode_present         = false;
  bool                                         bap_ctrl_pdu_ch_present  = false;
  bool                                         traffic_map_info_present = false;
  bool                                         ie_exts_present          = false;
  fixed_bitstring<16, false, true>             bh_rlc_ch_id;
  bh_qos_info_c                                bh_qos_info;
  rlc_mode_e                                   rlc_mode;
  bap_ctrl_pdu_ch_e                            bap_ctrl_pdu_ch;
  traffic_map_info_c                           traffic_map_info;
  bh_chs_to_be_modified_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// BHChannels-ToBeModified-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct bh_chs_to_be_modified_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { bh_chs_to_be_modified_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::bh_chs_to_be_modified_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    bh_chs_to_be_modified_item_s&       bh_chs_to_be_modified_item() { return c; }
    const bh_chs_to_be_modified_item_s& bh_chs_to_be_modified_item() const { return c; }

  private:
    bh_chs_to_be_modified_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// BHChannels-ToBeModified-List ::= SEQUENCE (SIZE (1..65536)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES :
// IEsSetParam}
using bh_chs_to_be_modified_list_l = dyn_array<protocol_ie_single_container_s<bh_chs_to_be_modified_item_ies_o>>;

// BHChannels-ToBeReleased-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using bh_chs_to_be_released_item_ext_ies_o = protocol_ext_empty_o;

using bh_chs_to_be_released_item_ext_ies_container = protocol_ext_container_empty_l;

// BHChannels-ToBeReleased-Item ::= SEQUENCE
struct bh_chs_to_be_released_item_s {
  bool                                         ie_exts_present = false;
  fixed_bitstring<16, false, true>             bh_rlc_ch_id;
  bh_chs_to_be_released_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// BHChannels-ToBeReleased-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct bh_chs_to_be_released_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { bh_chs_to_be_released_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::bh_chs_to_be_released_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    bh_chs_to_be_released_item_s&       bh_chs_to_be_released_item() { return c; }
    const bh_chs_to_be_released_item_s& bh_chs_to_be_released_item() const { return c; }

  private:
    bh_chs_to_be_released_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// BHChannels-ToBeReleased-List ::= SEQUENCE (SIZE (1..65536)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES :
// IEsSetParam}
using bh_chs_to_be_released_list_l = dyn_array<protocol_ie_single_container_s<bh_chs_to_be_released_item_ies_o>>;

// BHChannels-ToBeSetup-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using bh_chs_to_be_setup_item_ext_ies_o = protocol_ext_empty_o;

using bh_chs_to_be_setup_item_ext_ies_container = protocol_ext_container_empty_l;

// BHChannels-ToBeSetup-Item ::= SEQUENCE
struct bh_chs_to_be_setup_item_s {
  bool                                      bap_ctrl_pdu_ch_present  = false;
  bool                                      traffic_map_info_present = false;
  bool                                      ie_exts_present          = false;
  fixed_bitstring<16, false, true>          bh_rlc_ch_id;
  bh_qos_info_c                             bh_qos_info;
  rlc_mode_e                                rlc_mode;
  bap_ctrl_pdu_ch_e                         bap_ctrl_pdu_ch;
  traffic_map_info_c                        traffic_map_info;
  bh_chs_to_be_setup_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// BHChannels-ToBeSetup-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct bh_chs_to_be_setup_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { bh_chs_to_be_setup_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::bh_chs_to_be_setup_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    bh_chs_to_be_setup_item_s&       bh_chs_to_be_setup_item() { return c; }
    const bh_chs_to_be_setup_item_s& bh_chs_to_be_setup_item() const { return c; }

  private:
    bh_chs_to_be_setup_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// BHChannels-ToBeSetup-List ::= SEQUENCE (SIZE (1..65536)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES :
// IEsSetParam}
using bh_chs_to_be_setup_list_l = dyn_array<protocol_ie_single_container_s<bh_chs_to_be_setup_item_ies_o>>;

// BHChannels-ToBeSetupMod-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using bh_chs_to_be_setup_mod_item_ext_ies_o = protocol_ext_empty_o;

using bh_chs_to_be_setup_mod_item_ext_ies_container = protocol_ext_container_empty_l;

// BHChannels-ToBeSetupMod-Item ::= SEQUENCE
struct bh_chs_to_be_setup_mod_item_s {
  bool                                          bap_ctrl_pdu_ch_present  = false;
  bool                                          traffic_map_info_present = false;
  bool                                          ie_exts_present          = false;
  fixed_bitstring<16, false, true>              bh_rlc_ch_id;
  bh_qos_info_c                                 bh_qos_info;
  rlc_mode_e                                    rlc_mode;
  bap_ctrl_pdu_ch_e                             bap_ctrl_pdu_ch;
  traffic_map_info_c                            traffic_map_info;
  bh_chs_to_be_setup_mod_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// BHChannels-ToBeSetupMod-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct bh_chs_to_be_setup_mod_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { bh_chs_to_be_setup_mod_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::bh_chs_to_be_setup_mod_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    bh_chs_to_be_setup_mod_item_s&       bh_chs_to_be_setup_mod_item() { return c; }
    const bh_chs_to_be_setup_mod_item_s& bh_chs_to_be_setup_mod_item() const { return c; }

  private:
    bh_chs_to_be_setup_mod_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// BHChannels-ToBeSetupMod-List ::= SEQUENCE (SIZE (1..65536)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES :
// IEsSetParam}
using bh_chs_to_be_setup_mod_list_l = dyn_array<protocol_ie_single_container_s<bh_chs_to_be_setup_mod_item_ies_o>>;

// BHRLCCHItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using bh_rlc_ch_item_ext_ies_o = protocol_ext_empty_o;

using bh_rlc_ch_item_ext_ies_container = protocol_ext_container_empty_l;

// BHRLCCHItem ::= SEQUENCE
struct bh_rlc_ch_item_s {
  bool                             ie_exts_present = false;
  fixed_bitstring<16, false, true> bh_rlc_ch_id;
  bh_rlc_ch_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// BHRLCCHList ::= SEQUENCE (SIZE (1..65536)) OF BHRLCCHItem
using bh_rlc_ch_list_l = dyn_array<bh_rlc_ch_item_s>;

// BroadcastCAGList ::= SEQUENCE (SIZE (1..12)) OF BIT STRING (SIZE (32))
using broadcast_cag_list_l = bounded_array<fixed_bitstring<32, false, true>, 12>;

// BroadcastPNI-NPN-ID-List-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using broadcast_pni_npn_id_list_item_ext_ies_o = protocol_ext_empty_o;

// BroadcastSNPN-ID-List-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using broadcast_sn_pn_id_list_item_ext_ies_o = protocol_ext_empty_o;

using broadcast_pni_npn_id_list_item_ext_ies_container = protocol_ext_container_empty_l;

// BroadcastPNI-NPN-ID-List-Item ::= SEQUENCE
struct broadcast_pni_npn_id_list_item_s {
  bool                                             ext             = false;
  bool                                             ie_exts_present = false;
  fixed_octstring<3, true>                         plmn_id;
  broadcast_cag_list_l                             broadcast_cag_list;
  broadcast_pni_npn_id_list_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using broadcast_sn_pn_id_list_item_ext_ies_container = protocol_ext_container_empty_l;

// BroadcastSNPN-ID-List-Item ::= SEQUENCE
struct broadcast_sn_pn_id_list_item_s {
  bool                                           ext             = false;
  bool                                           ie_exts_present = false;
  fixed_octstring<3, true>                       plmn_id;
  broadcast_n_id_list_l                          broadcast_n_id_list;
  broadcast_sn_pn_id_list_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// BroadcastPNI-NPN-ID-List ::= SEQUENCE (SIZE (1..12)) OF BroadcastPNI-NPN-ID-List-Item
using broadcast_pni_npn_id_list_l = dyn_array<broadcast_pni_npn_id_list_item_s>;

// BroadcastSNPN-ID-List ::= SEQUENCE (SIZE (1..12)) OF BroadcastSNPN-ID-List-Item
using broadcast_sn_pn_id_list_l = dyn_array<broadcast_sn_pn_id_list_item_s>;

// NPN-Broadcast-Information-PNI-NPN-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using npn_broadcast_info_pni_npn_ext_ies_o = protocol_ext_empty_o;

// NPN-Broadcast-Information-SNPN-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using npn_broadcast_info_sn_pn_ext_ies_o = protocol_ext_empty_o;

// ExtendedAvailablePLMN-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using extended_available_plmn_item_ext_ies_o = protocol_ext_empty_o;

using npn_broadcast_info_pni_npn_ext_ies_container = protocol_ext_container_empty_l;

// NPN-Broadcast-Information-PNI-NPN ::= SEQUENCE
struct npn_broadcast_info_pni_npn_s {
  bool                                         ext            = false;
  bool                                         ie_ext_present = false;
  broadcast_pni_npn_id_list_l                  broadcast_pni_npn_id_info;
  npn_broadcast_info_pni_npn_ext_ies_container ie_ext;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using npn_broadcast_info_sn_pn_ext_ies_container = protocol_ext_container_empty_l;

// NPN-Broadcast-Information-SNPN ::= SEQUENCE
struct npn_broadcast_info_sn_pn_s {
  bool                                       ext            = false;
  bool                                       ie_ext_present = false;
  broadcast_sn_pn_id_list_l                  broadcast_sn_pn_id_list;
  npn_broadcast_info_sn_pn_ext_ies_container ie_ext;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// NPNBroadcastInformation-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
using npn_broadcast_info_ext_ies_o = protocol_ies_empty_o;

// ConfiguredTACIndication ::= ENUMERATED
struct cfg_tac_ind_opts {
  enum options { true_value, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<cfg_tac_ind_opts, true> cfg_tac_ind_e;

using extended_available_plmn_item_ext_ies_container = protocol_ext_container_empty_l;

// ExtendedAvailablePLMN-Item ::= SEQUENCE
struct extended_available_plmn_item_s {
  bool                                           ie_exts_present = false;
  fixed_octstring<3, true>                       plmn_id;
  extended_available_plmn_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// NPNBroadcastInformation ::= CHOICE
struct npn_broadcast_info_c {
  struct types_opts {
    enum options { sn_pn_broadcast_info, pni_npn_broadcast_info, choice_ext, nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  npn_broadcast_info_c() = default;
  npn_broadcast_info_c(const npn_broadcast_info_c& other);
  npn_broadcast_info_c& operator=(const npn_broadcast_info_c& other);
  ~npn_broadcast_info_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  npn_broadcast_info_sn_pn_s& sn_pn_broadcast_info()
  {
    assert_choice_type(types::sn_pn_broadcast_info, type_, "NPNBroadcastInformation");
    return c.get<npn_broadcast_info_sn_pn_s>();
  }
  npn_broadcast_info_pni_npn_s& pni_npn_broadcast_info()
  {
    assert_choice_type(types::pni_npn_broadcast_info, type_, "NPNBroadcastInformation");
    return c.get<npn_broadcast_info_pni_npn_s>();
  }
  protocol_ie_single_container_s<npn_broadcast_info_ext_ies_o>& choice_ext()
  {
    assert_choice_type(types::choice_ext, type_, "NPNBroadcastInformation");
    return c.get<protocol_ie_single_container_s<npn_broadcast_info_ext_ies_o>>();
  }
  const npn_broadcast_info_sn_pn_s& sn_pn_broadcast_info() const
  {
    assert_choice_type(types::sn_pn_broadcast_info, type_, "NPNBroadcastInformation");
    return c.get<npn_broadcast_info_sn_pn_s>();
  }
  const npn_broadcast_info_pni_npn_s& pni_npn_broadcast_info() const
  {
    assert_choice_type(types::pni_npn_broadcast_info, type_, "NPNBroadcastInformation");
    return c.get<npn_broadcast_info_pni_npn_s>();
  }
  const protocol_ie_single_container_s<npn_broadcast_info_ext_ies_o>& choice_ext() const
  {
    assert_choice_type(types::choice_ext, type_, "NPNBroadcastInformation");
    return c.get<protocol_ie_single_container_s<npn_broadcast_info_ext_ies_o>>();
  }
  npn_broadcast_info_sn_pn_s&                                   set_sn_pn_broadcast_info();
  npn_broadcast_info_pni_npn_s&                                 set_pni_npn_broadcast_info();
  protocol_ie_single_container_s<npn_broadcast_info_ext_ies_o>& set_choice_ext();

private:
  types type_;
  choice_buffer_t<npn_broadcast_info_pni_npn_s,
                  npn_broadcast_info_sn_pn_s,
                  protocol_ie_single_container_s<npn_broadcast_info_ext_ies_o>>
      c;

  void destroy_();
};

// BPLMN-ID-Info-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
struct bplmn_id_info_item_ext_ies_o {
  // Extension ::= OPEN TYPE
  struct ext_c {
    struct types_opts {
      enum options { cfg_tac_ind, npn_broadcast_info, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    ext_c() = default;
    ext_c(const ext_c& other);
    ext_c& operator=(const ext_c& other);
    ~ext_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    cfg_tac_ind_e&              cfg_tac_ind();
    npn_broadcast_info_c&       npn_broadcast_info();
    const cfg_tac_ind_e&        cfg_tac_ind() const;
    const npn_broadcast_info_c& npn_broadcast_info() const;

  private:
    types                                 type_;
    choice_buffer_t<npn_broadcast_info_c> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static ext_c      get_ext(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// ExtendedAvailablePLMN-List ::= SEQUENCE (SIZE (1..6)) OF ExtendedAvailablePLMN-Item
using extended_available_plmn_list_l = dyn_array<extended_available_plmn_item_s>;

struct bplmn_id_info_item_ext_ies_container {
  template <class extT_>
  using ie_field_s = protocol_ext_container_item_s<extT_>;

  // member variables
  bool                             cfg_tac_ind_present        = false;
  bool                             npn_broadcast_info_present = false;
  ie_field_s<cfg_tac_ind_e>        cfg_tac_ind;
  ie_field_s<npn_broadcast_info_c> npn_broadcast_info;

  // sequence methods
  bplmn_id_info_item_ext_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// BPLMN-ID-Info-Item ::= SEQUENCE
struct bplmn_id_info_item_s {
  bool                                 ext                 = false;
  bool                                 five_gs_tac_present = false;
  bool                                 ranac_present       = false;
  bool                                 ie_exts_present     = false;
  available_plmn_list_l                plmn_id_list;
  extended_available_plmn_list_l       extended_plmn_id_list;
  fixed_octstring<3, true>             five_gs_tac;
  fixed_bitstring<36, false, true>     nr_cell_id;
  uint16_t                             ranac = 0;
  bplmn_id_info_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// BPLMN-ID-Info-List ::= SEQUENCE (SIZE (1..12)) OF BPLMN-ID-Info-Item
using bplmn_id_info_list_l = dyn_array<bplmn_id_info_item_s>;

// BandwidthSRS-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
using bw_srs_ext_ies_o = protocol_ies_empty_o;

// FR1-Bandwidth ::= ENUMERATED
struct fr1_bw_opts {
  enum options { bw5, bw10, bw20, bw40, bw50, bw80, bw100, /*...*/ nulltype } value;
  typedef uint8_t number_type;

  const char* to_string() const;
  uint8_t     to_number() const;
};
typedef enumerated<fr1_bw_opts, true> fr1_bw_e;

// FR2-Bandwidth ::= ENUMERATED
struct fr2_bw_opts {
  enum options { bw50, bw100, bw200, bw400, /*...*/ bw800, bw1600, bw2000, nulltype } value;
  typedef uint16_t number_type;

  const char* to_string() const;
  uint16_t    to_number() const;
};
typedef enumerated<fr2_bw_opts, true, 3> fr2_bw_e;

// BandwidthSRS ::= CHOICE
struct bw_srs_c {
  struct types_opts {
    enum options { fr1, fr2, choice_ext, nulltype } value;
    typedef uint8_t number_type;

    const char* to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  bw_srs_c() = default;
  bw_srs_c(const bw_srs_c& other);
  bw_srs_c& operator=(const bw_srs_c& other);
  ~bw_srs_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  fr1_bw_e& fr1()
  {
    assert_choice_type(types::fr1, type_, "BandwidthSRS");
    return c.get<fr1_bw_e>();
  }
  fr2_bw_e& fr2()
  {
    assert_choice_type(types::fr2, type_, "BandwidthSRS");
    return c.get<fr2_bw_e>();
  }
  protocol_ie_single_container_s<bw_srs_ext_ies_o>& choice_ext()
  {
    assert_choice_type(types::choice_ext, type_, "BandwidthSRS");
    return c.get<protocol_ie_single_container_s<bw_srs_ext_ies_o>>();
  }
  const fr1_bw_e& fr1() const
  {
    assert_choice_type(types::fr1, type_, "BandwidthSRS");
    return c.get<fr1_bw_e>();
  }
  const fr2_bw_e& fr2() const
  {
    assert_choice_type(types::fr2, type_, "BandwidthSRS");
    return c.get<fr2_bw_e>();
  }
  const protocol_ie_single_container_s<bw_srs_ext_ies_o>& choice_ext() const
  {
    assert_choice_type(types::choice_ext, type_, "BandwidthSRS");
    return c.get<protocol_ie_single_container_s<bw_srs_ext_ies_o>>();
  }
  fr1_bw_e&                                         set_fr1();
  fr2_bw_e&                                         set_fr2();
  protocol_ie_single_container_s<bw_srs_ext_ies_o>& set_choice_ext();

private:
  types                                                             type_;
  choice_buffer_t<protocol_ie_single_container_s<bw_srs_ext_ies_o>> c;

  void destroy_();
};

// Broadcast-Cell-List-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using broadcast_cell_list_item_ext_ies_o = protocol_ext_empty_o;

using broadcast_cell_list_item_ext_ies_container = protocol_ext_container_empty_l;

// Broadcast-Cell-List-Item ::= SEQUENCE
struct broadcast_cell_list_item_s {
  bool                                       ext             = false;
  bool                                       ie_exts_present = false;
  nr_cgi_s                                   cell_id;
  broadcast_cell_list_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// Broadcast-To-Be-Cancelled-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using broadcast_to_be_cancelled_item_ext_ies_o = protocol_ext_empty_o;

using broadcast_to_be_cancelled_item_ext_ies_container = protocol_ext_container_empty_l;

// Broadcast-To-Be-Cancelled-Item ::= SEQUENCE
struct broadcast_to_be_cancelled_item_s {
  bool                                             ext             = false;
  bool                                             ie_exts_present = false;
  nr_cgi_s                                         nr_cgi;
  broadcast_to_be_cancelled_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// Broadcast-To-Be-Cancelled-List-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct broadcast_to_be_cancelled_list_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { broadcast_to_be_cancelled_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::broadcast_to_be_cancelled_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    broadcast_to_be_cancelled_item_s&       broadcast_to_be_cancelled_item() { return c; }
    const broadcast_to_be_cancelled_item_s& broadcast_to_be_cancelled_item() const { return c; }

  private:
    broadcast_to_be_cancelled_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// Broadcast-To-Be-Cancelled-List ::= SEQUENCE (SIZE (1..512)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES :
// IEsSetParam}
using broadcast_to_be_cancelled_list_l =
    dyn_array<protocol_ie_single_container_s<broadcast_to_be_cancelled_list_item_ies_o>>;

// BroadcastCellList ::= SEQUENCE (SIZE (1..512)) OF Broadcast-Cell-List-Item
using broadcast_cell_list_l = dyn_array<broadcast_cell_list_item_s>;

// PartialSuccessCell-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using partial_success_cell_ext_ies_o = protocol_ext_empty_o;

// BroadcastAreaScope-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
using broadcast_area_scope_ext_ies_o = protocol_ies_empty_o;

using partial_success_cell_ext_ies_container = protocol_ext_container_empty_l;

// PartialSuccessCell ::= SEQUENCE
struct partial_success_cell_s {
  bool                                   ext             = false;
  bool                                   ie_exts_present = false;
  broadcast_cell_list_l                  broadcast_cell_list;
  partial_success_cell_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// BroadcastAreaScope ::= CHOICE
struct broadcast_area_scope_c {
  struct types_opts {
    enum options { complete_success, partial_success, choice_ext, nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  broadcast_area_scope_c() = default;
  broadcast_area_scope_c(const broadcast_area_scope_c& other);
  broadcast_area_scope_c& operator=(const broadcast_area_scope_c& other);
  ~broadcast_area_scope_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  partial_success_cell_s& partial_success()
  {
    assert_choice_type(types::partial_success, type_, "BroadcastAreaScope");
    return c.get<partial_success_cell_s>();
  }
  protocol_ie_single_container_s<broadcast_area_scope_ext_ies_o>& choice_ext()
  {
    assert_choice_type(types::choice_ext, type_, "BroadcastAreaScope");
    return c.get<protocol_ie_single_container_s<broadcast_area_scope_ext_ies_o>>();
  }
  const partial_success_cell_s& partial_success() const
  {
    assert_choice_type(types::partial_success, type_, "BroadcastAreaScope");
    return c.get<partial_success_cell_s>();
  }
  const protocol_ie_single_container_s<broadcast_area_scope_ext_ies_o>& choice_ext() const
  {
    assert_choice_type(types::choice_ext, type_, "BroadcastAreaScope");
    return c.get<protocol_ie_single_container_s<broadcast_area_scope_ext_ies_o>>();
  }
  void                                                            set_complete_success();
  partial_success_cell_s&                                         set_partial_success();
  protocol_ie_single_container_s<broadcast_area_scope_ext_ies_o>& set_choice_ext();

private:
  types                                                                                                   type_;
  choice_buffer_t<partial_success_cell_s, protocol_ie_single_container_s<broadcast_area_scope_ext_ies_o>> c;

  void destroy_();
};

// BroadcastContextModificationFailureIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct broadcast_context_mod_fail_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { gnb_cu_mbs_f1ap_id, gnb_du_mbs_f1ap_id, cause, crit_diagnostics, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint64_t&                 gnb_cu_mbs_f1ap_id();
    uint64_t&                 gnb_du_mbs_f1ap_id();
    cause_c&                  cause();
    crit_diagnostics_s&       crit_diagnostics();
    const uint64_t&           gnb_cu_mbs_f1ap_id() const;
    const uint64_t&           gnb_du_mbs_f1ap_id() const;
    const cause_c&            cause() const;
    const crit_diagnostics_s& crit_diagnostics() const;

  private:
    types                                        type_;
    choice_buffer_t<cause_c, crit_diagnostics_s> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

struct broadcast_context_mod_fail_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                                      crit_diagnostics_present = false;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_cu_mbs_f1ap_id;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_du_mbs_f1ap_id;
  ie_field_s<cause_c>                                       cause;
  ie_field_s<crit_diagnostics_s>                            crit_diagnostics;

  // sequence methods
  broadcast_context_mod_fail_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// BroadcastContextModificationFailure ::= SEQUENCE
using broadcast_context_mod_fail_s = elementary_procedure_option<broadcast_context_mod_fail_ies_container>;

// MBS-ServiceAreaTAIList-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using mbs_service_area_tai_list_item_ext_ies_o = protocol_ext_empty_o;

// MBS-Flows-Mapped-To-MRB-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using mbs_flows_mapped_to_mrb_item_ext_ies_o = protocol_ext_empty_o;

using mbs_service_area_tai_list_item_ext_ies_container = protocol_ext_container_empty_l;

// MBS-ServiceAreaTAIList-Item ::= SEQUENCE
struct mbs_service_area_tai_list_item_s {
  bool                                             ext             = false;
  bool                                             ie_exts_present = false;
  fixed_octstring<3, true>                         plmn_id;
  fixed_octstring<3, true>                         five5_tac;
  mbs_service_area_tai_list_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using mbs_flows_mapped_to_mrb_item_ext_ies_container = protocol_ext_container_empty_l;

// MBS-Flows-Mapped-To-MRB-Item ::= SEQUENCE
struct mbs_flows_mapped_to_mrb_item_s {
  bool                                           ie_exts_present = false;
  uint8_t                                        mbs_qos_flow_id = 0;
  qos_flow_level_qos_params_s                    mbs_qos_flow_level_qos_params;
  mbs_flows_mapped_to_mrb_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MBS-ServiceAreaCellList ::= SEQUENCE (SIZE (1..512)) OF NRCGI
using mbs_service_area_cell_list_l = dyn_array<nr_cgi_s>;

// MBS-ServiceAreaInformation-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using mbs_service_area_info_ext_ies_o = protocol_ext_empty_o;

// MBS-ServiceAreaTAIList ::= SEQUENCE (SIZE (1..512)) OF MBS-ServiceAreaTAIList-Item
using mbs_service_area_tai_list_l = dyn_array<mbs_service_area_tai_list_item_s>;

// BroadcastMRBs-ToBeModified-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using broadcast_m_rbs_to_be_modified_item_ext_ies_o = protocol_ext_empty_o;

// BroadcastMRBs-ToBeReleased-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using broadcast_m_rbs_to_be_released_item_ext_ies_o = protocol_ext_empty_o;

// BroadcastMRBs-ToBeSetupMod-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using broadcast_m_rbs_to_be_setup_mod_item_ext_ies_o = protocol_ext_empty_o;

// MBS-Broadcast-Cell-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using mbs_broadcast_cell_item_ext_ies_o = protocol_ext_empty_o;

// MBS-Broadcast-MRB-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using mbs_broadcast_mrb_item_ext_ies_o = protocol_ext_empty_o;

// MBS-Flows-Mapped-To-MRB-List ::= SEQUENCE (SIZE (1..64)) OF MBS-Flows-Mapped-To-MRB-Item
using mbs_flows_mapped_to_mrb_list_l = dyn_array<mbs_flows_mapped_to_mrb_item_s>;

using mbs_service_area_info_ext_ies_container = protocol_ext_container_empty_l;

// MBS-ServiceAreaInformation ::= SEQUENCE
struct mbs_service_area_info_s {
  bool                                    ext             = false;
  bool                                    ie_exts_present = false;
  mbs_service_area_cell_list_l            mbs_service_area_cell_list;
  mbs_service_area_tai_list_l             mbs_service_area_tai_list;
  mbs_service_area_info_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MBS-ServiceAreaInformationItem-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using mbs_service_area_info_item_ext_ies_o = protocol_ext_empty_o;

using broadcast_m_rbs_to_be_modified_item_ext_ies_container = protocol_ext_container_empty_l;

// BroadcastMRBs-ToBeModified-Item ::= SEQUENCE
struct broadcast_m_rbs_to_be_modified_item_s {
  bool                                                  ext                                       = false;
  bool                                                  mrb_qos_info_present                      = false;
  bool                                                  bc_bearer_ctxt_f1_u_tnl_infoat_cu_present = false;
  bool                                                  ie_exts_present                           = false;
  uint16_t                                              mrb_id                                    = 1;
  qos_flow_level_qos_params_s                           mrb_qos_info;
  mbs_flows_mapped_to_mrb_list_l                        mbs_flows_mapped_to_mrb_list;
  bc_bearer_context_f1_u_tnl_info_c                     bc_bearer_ctxt_f1_u_tnl_infoat_cu;
  broadcast_m_rbs_to_be_modified_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using broadcast_m_rbs_to_be_released_item_ext_ies_container = protocol_ext_container_empty_l;

// BroadcastMRBs-ToBeReleased-Item ::= SEQUENCE
struct broadcast_m_rbs_to_be_released_item_s {
  bool                                                  ext             = false;
  bool                                                  ie_exts_present = false;
  uint16_t                                              mrb_id          = 1;
  broadcast_m_rbs_to_be_released_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using broadcast_m_rbs_to_be_setup_mod_item_ext_ies_container = protocol_ext_container_empty_l;

// BroadcastMRBs-ToBeSetupMod-Item ::= SEQUENCE
struct broadcast_m_rbs_to_be_setup_mod_item_s {
  bool                                                   ext    = false;
  uint16_t                                               mrb_id = 1;
  qos_flow_level_qos_params_s                            mrb_qos_info;
  mbs_flows_mapped_to_mrb_list_l                         mbs_flows_mapped_to_mrb_list;
  bc_bearer_context_f1_u_tnl_info_c                      bc_bearer_ctxt_f1_u_tnl_infoat_cu;
  broadcast_m_rbs_to_be_setup_mod_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using mbs_broadcast_cell_item_ext_ies_container = protocol_ext_container_empty_l;

// MBS-Broadcast-Cell-Item ::= SEQUENCE
struct mbs_broadcast_cell_item_s {
  bool                                      ext             = false;
  bool                                      ie_exts_present = false;
  nr_cgi_s                                  nr_cgi;
  unbounded_octstring<true>                 mtch_neighbour_cell;
  mbs_broadcast_cell_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using mbs_broadcast_mrb_item_ext_ies_container = protocol_ext_container_empty_l;

// MBS-Broadcast-MRB-Item ::= SEQUENCE
struct mbs_broadcast_mrb_item_s {
  bool                                     ext             = false;
  bool                                     ie_exts_present = false;
  uint16_t                                 mrb_id          = 1;
  unbounded_octstring<true>                mrb_pdcp_cfg_broadcast;
  mbs_broadcast_mrb_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using mbs_service_area_info_item_ext_ies_container = protocol_ext_container_empty_l;

// MBS-ServiceAreaInformationItem ::= SEQUENCE
struct mbs_service_area_info_item_s {
  bool                                         ext                 = false;
  bool                                         ie_exts_present     = false;
  uint32_t                                     mbs_area_session_id = 0;
  mbs_service_area_info_s                      mbs_service_area_info;
  mbs_service_area_info_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// BroadcastMRBs-ToBeModified-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct broadcast_m_rbs_to_be_modified_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { broadcast_m_rbs_to_be_modified_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::broadcast_m_rbs_to_be_modified_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    broadcast_m_rbs_to_be_modified_item_s&       broadcast_m_rbs_to_be_modified_item() { return c; }
    const broadcast_m_rbs_to_be_modified_item_s& broadcast_m_rbs_to_be_modified_item() const { return c; }

  private:
    broadcast_m_rbs_to_be_modified_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// BroadcastMRBs-ToBeReleased-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct broadcast_m_rbs_to_be_released_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { broadcast_m_rbs_to_be_released_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::broadcast_m_rbs_to_be_released_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    broadcast_m_rbs_to_be_released_item_s&       broadcast_m_rbs_to_be_released_item() { return c; }
    const broadcast_m_rbs_to_be_released_item_s& broadcast_m_rbs_to_be_released_item() const { return c; }

  private:
    broadcast_m_rbs_to_be_released_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// BroadcastMRBs-ToBeSetupMod-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct broadcast_m_rbs_to_be_setup_mod_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { broadcast_m_rbs_to_be_setup_mod_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::broadcast_m_rbs_to_be_setup_mod_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    broadcast_m_rbs_to_be_setup_mod_item_s&       broadcast_m_rbs_to_be_setup_mod_item() { return c; }
    const broadcast_m_rbs_to_be_setup_mod_item_s& broadcast_m_rbs_to_be_setup_mod_item() const { return c; }

  private:
    broadcast_m_rbs_to_be_setup_mod_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// MBS-Broadcast-Cell-List ::= SEQUENCE (SIZE (1..512)) OF MBS-Broadcast-Cell-Item
using mbs_broadcast_cell_list_l = dyn_array<mbs_broadcast_cell_item_s>;

// MBS-Broadcast-MRB-List ::= SEQUENCE (SIZE (1..32)) OF MBS-Broadcast-MRB-Item
using mbs_broadcast_mrb_list_l = dyn_array<mbs_broadcast_mrb_item_s>;

// MBS-CUtoDURRCInformation-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using mbs_cu_to_du_rrc_info_ext_ies_o = protocol_ext_empty_o;

// MBS-ServiceAreaInformationList ::= SEQUENCE (SIZE (1..256)) OF MBS-ServiceAreaInformationItem
using mbs_service_area_info_list_l = dyn_array<mbs_service_area_info_item_s>;

// MBSServiceArea-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
using mbs_service_area_ext_ies_o = protocol_ies_empty_o;

// BroadcastMRBs-ToBeModified-List ::= SEQUENCE (SIZE (1..32)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES :
// IEsSetParam}
using broadcast_m_rbs_to_be_modified_list_l =
    bounded_array<protocol_ie_single_container_s<broadcast_m_rbs_to_be_modified_item_ies_o>, 32>;

// BroadcastMRBs-ToBeReleased-List ::= SEQUENCE (SIZE (1..32)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES :
// IEsSetParam}
using broadcast_m_rbs_to_be_released_list_l =
    bounded_array<protocol_ie_single_container_s<broadcast_m_rbs_to_be_released_item_ies_o>, 32>;

// BroadcastMRBs-ToBeSetupMod-List ::= SEQUENCE (SIZE (1..32)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES :
// IEsSetParam}
using broadcast_m_rbs_to_be_setup_mod_list_l =
    bounded_array<protocol_ie_single_container_s<broadcast_m_rbs_to_be_setup_mod_item_ies_o>, 32>;

using mbs_cu_to_du_rrc_info_ext_ies_container = protocol_ext_container_empty_l;

// MBS-CUtoDURRCInformation ::= SEQUENCE
struct mbs_cu_to_du_rrc_info_s {
  bool                                    ext             = false;
  bool                                    ie_exts_present = false;
  mbs_broadcast_cell_list_l               mbs_broadcast_cell_list;
  mbs_broadcast_mrb_list_l                mbs_broadcast_mrb_list;
  mbs_cu_to_du_rrc_info_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MBS-ServiceArea ::= CHOICE
struct mbs_service_area_c {
  struct types_opts {
    enum options { locationindependent, locationdependent, choice_exts, nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  mbs_service_area_c() = default;
  mbs_service_area_c(const mbs_service_area_c& other);
  mbs_service_area_c& operator=(const mbs_service_area_c& other);
  ~mbs_service_area_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  mbs_service_area_info_s& locationindependent()
  {
    assert_choice_type(types::locationindependent, type_, "MBS-ServiceArea");
    return c.get<mbs_service_area_info_s>();
  }
  mbs_service_area_info_list_l& locationdependent()
  {
    assert_choice_type(types::locationdependent, type_, "MBS-ServiceArea");
    return c.get<mbs_service_area_info_list_l>();
  }
  protocol_ie_single_container_s<mbs_service_area_ext_ies_o>& choice_exts()
  {
    assert_choice_type(types::choice_exts, type_, "MBS-ServiceArea");
    return c.get<protocol_ie_single_container_s<mbs_service_area_ext_ies_o>>();
  }
  const mbs_service_area_info_s& locationindependent() const
  {
    assert_choice_type(types::locationindependent, type_, "MBS-ServiceArea");
    return c.get<mbs_service_area_info_s>();
  }
  const mbs_service_area_info_list_l& locationdependent() const
  {
    assert_choice_type(types::locationdependent, type_, "MBS-ServiceArea");
    return c.get<mbs_service_area_info_list_l>();
  }
  const protocol_ie_single_container_s<mbs_service_area_ext_ies_o>& choice_exts() const
  {
    assert_choice_type(types::choice_exts, type_, "MBS-ServiceArea");
    return c.get<protocol_ie_single_container_s<mbs_service_area_ext_ies_o>>();
  }
  mbs_service_area_info_s&                                    set_locationindependent();
  mbs_service_area_info_list_l&                               set_locationdependent();
  protocol_ie_single_container_s<mbs_service_area_ext_ies_o>& set_choice_exts();

private:
  types type_;
  choice_buffer_t<mbs_service_area_info_list_l,
                  mbs_service_area_info_s,
                  protocol_ie_single_container_s<mbs_service_area_ext_ies_o>>
      c;

  void destroy_();
};

// BroadcastContextModificationRequestIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct broadcast_context_mod_request_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options {
        gnb_cu_mbs_f1ap_id,
        gnb_du_mbs_f1ap_id,
        mbs_service_area,
        mbs_cu_to_du_rrc_info,
        broadcast_m_rbs_to_be_setup_mod_list,
        broadcast_m_rbs_to_be_modified_list,
        broadcast_m_rbs_to_be_released_list,
        nulltype
      } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint64_t&                                     gnb_cu_mbs_f1ap_id();
    uint64_t&                                     gnb_du_mbs_f1ap_id();
    mbs_service_area_c&                           mbs_service_area();
    mbs_cu_to_du_rrc_info_s&                      mbs_cu_to_du_rrc_info();
    broadcast_m_rbs_to_be_setup_mod_list_l&       broadcast_m_rbs_to_be_setup_mod_list();
    broadcast_m_rbs_to_be_modified_list_l&        broadcast_m_rbs_to_be_modified_list();
    broadcast_m_rbs_to_be_released_list_l&        broadcast_m_rbs_to_be_released_list();
    const uint64_t&                               gnb_cu_mbs_f1ap_id() const;
    const uint64_t&                               gnb_du_mbs_f1ap_id() const;
    const mbs_service_area_c&                     mbs_service_area() const;
    const mbs_cu_to_du_rrc_info_s&                mbs_cu_to_du_rrc_info() const;
    const broadcast_m_rbs_to_be_setup_mod_list_l& broadcast_m_rbs_to_be_setup_mod_list() const;
    const broadcast_m_rbs_to_be_modified_list_l&  broadcast_m_rbs_to_be_modified_list() const;
    const broadcast_m_rbs_to_be_released_list_l&  broadcast_m_rbs_to_be_released_list() const;

  private:
    types type_;
    choice_buffer_t<broadcast_m_rbs_to_be_modified_list_l,
                    broadcast_m_rbs_to_be_released_list_l,
                    broadcast_m_rbs_to_be_setup_mod_list_l,
                    mbs_cu_to_du_rrc_info_s,
                    mbs_service_area_c>
        c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

struct broadcast_context_mod_request_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                                      mbs_service_area_present                     = false;
  bool                                                      broadcast_m_rbs_to_be_setup_mod_list_present = false;
  bool                                                      broadcast_m_rbs_to_be_modified_list_present  = false;
  bool                                                      broadcast_m_rbs_to_be_released_list_present  = false;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_cu_mbs_f1ap_id;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_du_mbs_f1ap_id;
  ie_field_s<mbs_service_area_c>                            mbs_service_area;
  ie_field_s<mbs_cu_to_du_rrc_info_s>                       mbs_cu_to_du_rrc_info;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<broadcast_m_rbs_to_be_setup_mod_item_ies_o>, 1, 32, true>>
      broadcast_m_rbs_to_be_setup_mod_list;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<broadcast_m_rbs_to_be_modified_item_ies_o>, 1, 32, true>>
      broadcast_m_rbs_to_be_modified_list;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<broadcast_m_rbs_to_be_released_item_ies_o>, 1, 32, true>>
      broadcast_m_rbs_to_be_released_list;

  // sequence methods
  broadcast_context_mod_request_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// BroadcastContextModificationRequest ::= SEQUENCE
using broadcast_context_mod_request_s = elementary_procedure_option<broadcast_context_mod_request_ies_container>;

// BroadcastMRBs-FailedToBeSetupMod-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using broadcast_m_rbs_failed_to_be_setup_mod_item_ext_ies_o = protocol_ext_empty_o;

// BroadcastMRBs-FailedtoBeModified-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using broadcast_m_rbs_failedto_be_modified_item_ext_ies_o = protocol_ext_empty_o;

// BroadcastMRBs-Modified-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using broadcast_m_rbs_modified_item_ext_ies_o = protocol_ext_empty_o;

// BroadcastMRBs-SetupMod-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using broadcast_m_rbs_setup_mod_item_ext_ies_o = protocol_ext_empty_o;

using broadcast_m_rbs_failedto_be_modified_item_ext_ies_container = protocol_ext_container_empty_l;

// BroadcastMRBs-FailedToBeModified-Item ::= SEQUENCE
struct broadcast_m_rbs_failed_to_be_modified_item_s {
  bool                                                        ext             = false;
  bool                                                        cause_present   = false;
  bool                                                        ie_exts_present = false;
  uint16_t                                                    mrb_id          = 1;
  cause_c                                                     cause;
  broadcast_m_rbs_failedto_be_modified_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using broadcast_m_rbs_failed_to_be_setup_mod_item_ext_ies_container = protocol_ext_container_empty_l;

// BroadcastMRBs-FailedToBeSetupMod-Item ::= SEQUENCE
struct broadcast_m_rbs_failed_to_be_setup_mod_item_s {
  bool                                                          ext             = false;
  bool                                                          cause_present   = false;
  bool                                                          ie_exts_present = false;
  uint16_t                                                      mrb_id          = 1;
  cause_c                                                       cause;
  broadcast_m_rbs_failed_to_be_setup_mod_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using broadcast_m_rbs_modified_item_ext_ies_container = protocol_ext_container_empty_l;

// BroadcastMRBs-Modified-Item ::= SEQUENCE
struct broadcast_m_rbs_modified_item_s {
  bool                                            ext                                       = false;
  bool                                            bc_bearer_ctxt_f1_u_tnl_infoat_du_present = false;
  bool                                            ie_exts_present                           = false;
  uint16_t                                        mrb_id                                    = 1;
  bc_bearer_context_f1_u_tnl_info_c               bc_bearer_ctxt_f1_u_tnl_infoat_du;
  broadcast_m_rbs_modified_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using broadcast_m_rbs_setup_mod_item_ext_ies_container = protocol_ext_container_empty_l;

// BroadcastMRBs-SetupMod-Item ::= SEQUENCE
struct broadcast_m_rbs_setup_mod_item_s {
  bool                                             ext             = false;
  bool                                             ie_exts_present = false;
  uint16_t                                         mrb_id          = 1;
  bc_bearer_context_f1_u_tnl_info_c                bc_bearer_ctxt_f1_u_tnl_infoat_du;
  broadcast_m_rbs_setup_mod_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// BroadcastMRBs-FailedToBeModified-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct broadcast_m_rbs_failed_to_be_modified_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { broadcast_m_rbs_failed_to_be_modified_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::broadcast_m_rbs_failed_to_be_modified_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    broadcast_m_rbs_failed_to_be_modified_item_s&       broadcast_m_rbs_failed_to_be_modified_item() { return c; }
    const broadcast_m_rbs_failed_to_be_modified_item_s& broadcast_m_rbs_failed_to_be_modified_item() const { return c; }

  private:
    broadcast_m_rbs_failed_to_be_modified_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// BroadcastMRBs-FailedToBeSetupMod-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct broadcast_m_rbs_failed_to_be_setup_mod_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { broadcast_m_rbs_failed_to_be_setup_mod_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::broadcast_m_rbs_failed_to_be_setup_mod_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    broadcast_m_rbs_failed_to_be_setup_mod_item_s&       broadcast_m_rbs_failed_to_be_setup_mod_item() { return c; }
    const broadcast_m_rbs_failed_to_be_setup_mod_item_s& broadcast_m_rbs_failed_to_be_setup_mod_item() const
    {
      return c;
    }

  private:
    broadcast_m_rbs_failed_to_be_setup_mod_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// BroadcastMRBs-Modified-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct broadcast_m_rbs_modified_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { broadcast_m_rbs_modified_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::broadcast_m_rbs_modified_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    broadcast_m_rbs_modified_item_s&       broadcast_m_rbs_modified_item() { return c; }
    const broadcast_m_rbs_modified_item_s& broadcast_m_rbs_modified_item() const { return c; }

  private:
    broadcast_m_rbs_modified_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// BroadcastMRBs-SetupMod-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct broadcast_m_rbs_setup_mod_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { broadcast_m_rbs_setup_mod_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::broadcast_m_rbs_setup_mod_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    broadcast_m_rbs_setup_mod_item_s&       broadcast_m_rbs_setup_mod_item() { return c; }
    const broadcast_m_rbs_setup_mod_item_s& broadcast_m_rbs_setup_mod_item() const { return c; }

  private:
    broadcast_m_rbs_setup_mod_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// BroadcastMRBs-FailedToBeModified-List ::= SEQUENCE (SIZE (1..32)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES :
// IEsSetParam}
using broadcast_m_rbs_failed_to_be_modified_list_l =
    bounded_array<protocol_ie_single_container_s<broadcast_m_rbs_failed_to_be_modified_item_ies_o>, 32>;

// BroadcastMRBs-FailedToBeSetupMod-List ::= SEQUENCE (SIZE (1..32)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES :
// IEsSetParam}
using broadcast_m_rbs_failed_to_be_setup_mod_list_l =
    bounded_array<protocol_ie_single_container_s<broadcast_m_rbs_failed_to_be_setup_mod_item_ies_o>, 32>;

// BroadcastMRBs-Modified-List ::= SEQUENCE (SIZE (1..32)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES :
// IEsSetParam}
using broadcast_m_rbs_modified_list_l =
    bounded_array<protocol_ie_single_container_s<broadcast_m_rbs_modified_item_ies_o>, 32>;

// BroadcastMRBs-SetupMod-List ::= SEQUENCE (SIZE (1..32)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES :
// IEsSetParam}
using broadcast_m_rbs_setup_mod_list_l =
    bounded_array<protocol_ie_single_container_s<broadcast_m_rbs_setup_mod_item_ies_o>, 32>;

// BroadcastContextModificationResponseIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct broadcast_context_mod_resp_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options {
        gnb_cu_mbs_f1ap_id,
        gnb_du_mbs_f1ap_id,
        broadcast_m_rbs_setup_mod_list,
        broadcast_m_rbs_failed_to_be_setup_mod_list,
        broadcast_m_rbs_modified_list,
        broadcast_m_rbs_failed_to_be_modified_list,
        crit_diagnostics,
        nulltype
      } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint64_t&                                            gnb_cu_mbs_f1ap_id();
    uint64_t&                                            gnb_du_mbs_f1ap_id();
    broadcast_m_rbs_setup_mod_list_l&                    broadcast_m_rbs_setup_mod_list();
    broadcast_m_rbs_failed_to_be_setup_mod_list_l&       broadcast_m_rbs_failed_to_be_setup_mod_list();
    broadcast_m_rbs_modified_list_l&                     broadcast_m_rbs_modified_list();
    broadcast_m_rbs_failed_to_be_modified_list_l&        broadcast_m_rbs_failed_to_be_modified_list();
    crit_diagnostics_s&                                  crit_diagnostics();
    const uint64_t&                                      gnb_cu_mbs_f1ap_id() const;
    const uint64_t&                                      gnb_du_mbs_f1ap_id() const;
    const broadcast_m_rbs_setup_mod_list_l&              broadcast_m_rbs_setup_mod_list() const;
    const broadcast_m_rbs_failed_to_be_setup_mod_list_l& broadcast_m_rbs_failed_to_be_setup_mod_list() const;
    const broadcast_m_rbs_modified_list_l&               broadcast_m_rbs_modified_list() const;
    const broadcast_m_rbs_failed_to_be_modified_list_l&  broadcast_m_rbs_failed_to_be_modified_list() const;
    const crit_diagnostics_s&                            crit_diagnostics() const;

  private:
    types type_;
    choice_buffer_t<broadcast_m_rbs_failed_to_be_modified_list_l,
                    broadcast_m_rbs_failed_to_be_setup_mod_list_l,
                    broadcast_m_rbs_modified_list_l,
                    broadcast_m_rbs_setup_mod_list_l,
                    crit_diagnostics_s>
        c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

struct broadcast_context_mod_resp_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                                      broadcast_m_rbs_setup_mod_list_present              = false;
  bool                                                      broadcast_m_rbs_failed_to_be_setup_mod_list_present = false;
  bool                                                      broadcast_m_rbs_modified_list_present               = false;
  bool                                                      broadcast_m_rbs_failed_to_be_modified_list_present  = false;
  bool                                                      crit_diagnostics_present                            = false;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_cu_mbs_f1ap_id;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_du_mbs_f1ap_id;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<broadcast_m_rbs_setup_mod_item_ies_o>, 1, 32, true>>
      broadcast_m_rbs_setup_mod_list;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<broadcast_m_rbs_failed_to_be_setup_mod_item_ies_o>, 1, 32, true>>
      broadcast_m_rbs_failed_to_be_setup_mod_list;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<broadcast_m_rbs_modified_item_ies_o>, 1, 32, true>>
      broadcast_m_rbs_modified_list;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<broadcast_m_rbs_failed_to_be_modified_item_ies_o>, 1, 32, true>>
                                 broadcast_m_rbs_failed_to_be_modified_list;
  ie_field_s<crit_diagnostics_s> crit_diagnostics;

  // sequence methods
  broadcast_context_mod_resp_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// BroadcastContextModificationResponse ::= SEQUENCE
using broadcast_context_mod_resp_s = elementary_procedure_option<broadcast_context_mod_resp_ies_container>;

// BroadcastContextReleaseCommandIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct broadcast_context_release_cmd_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { gnb_cu_mbs_f1ap_id, gnb_du_mbs_f1ap_id, cause, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint64_t&       gnb_cu_mbs_f1ap_id();
    uint64_t&       gnb_du_mbs_f1ap_id();
    cause_c&        cause();
    const uint64_t& gnb_cu_mbs_f1ap_id() const;
    const uint64_t& gnb_du_mbs_f1ap_id() const;
    const cause_c&  cause() const;

  private:
    types                    type_;
    choice_buffer_t<cause_c> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

struct broadcast_context_release_cmd_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_cu_mbs_f1ap_id;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_du_mbs_f1ap_id;
  ie_field_s<cause_c>                                       cause;

  // sequence methods
  broadcast_context_release_cmd_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// BroadcastContextReleaseCommand ::= SEQUENCE
using broadcast_context_release_cmd_s = elementary_procedure_option<broadcast_context_release_cmd_ies_container>;

// BroadcastContextReleaseCompleteIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct broadcast_context_release_complete_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { gnb_cu_mbs_f1ap_id, gnb_du_mbs_f1ap_id, crit_diagnostics, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint64_t&                 gnb_cu_mbs_f1ap_id();
    uint64_t&                 gnb_du_mbs_f1ap_id();
    crit_diagnostics_s&       crit_diagnostics();
    const uint64_t&           gnb_cu_mbs_f1ap_id() const;
    const uint64_t&           gnb_du_mbs_f1ap_id() const;
    const crit_diagnostics_s& crit_diagnostics() const;

  private:
    types                               type_;
    choice_buffer_t<crit_diagnostics_s> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

struct broadcast_context_release_complete_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                                      crit_diagnostics_present = false;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_cu_mbs_f1ap_id;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_du_mbs_f1ap_id;
  ie_field_s<crit_diagnostics_s>                            crit_diagnostics;

  // sequence methods
  broadcast_context_release_complete_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// BroadcastContextReleaseComplete ::= SEQUENCE
using broadcast_context_release_complete_s =
    elementary_procedure_option<broadcast_context_release_complete_ies_container>;

// BroadcastContextReleaseRequestIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct broadcast_context_release_request_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { gnb_cu_mbs_f1ap_id, gnb_du_mbs_f1ap_id, cause, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint64_t&       gnb_cu_mbs_f1ap_id();
    uint64_t&       gnb_du_mbs_f1ap_id();
    cause_c&        cause();
    const uint64_t& gnb_cu_mbs_f1ap_id() const;
    const uint64_t& gnb_du_mbs_f1ap_id() const;
    const cause_c&  cause() const;

  private:
    types                    type_;
    choice_buffer_t<cause_c> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

struct broadcast_context_release_request_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_cu_mbs_f1ap_id;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_du_mbs_f1ap_id;
  ie_field_s<cause_c>                                       cause;

  // sequence methods
  broadcast_context_release_request_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// BroadcastContextReleaseRequest ::= SEQUENCE
using broadcast_context_release_request_s =
    elementary_procedure_option<broadcast_context_release_request_ies_container>;

// BroadcastContextSetupFailureIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct broadcast_context_setup_fail_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { gnb_cu_mbs_f1ap_id, gnb_du_mbs_f1ap_id, cause, crit_diagnostics, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint64_t&                 gnb_cu_mbs_f1ap_id();
    uint64_t&                 gnb_du_mbs_f1ap_id();
    cause_c&                  cause();
    crit_diagnostics_s&       crit_diagnostics();
    const uint64_t&           gnb_cu_mbs_f1ap_id() const;
    const uint64_t&           gnb_du_mbs_f1ap_id() const;
    const cause_c&            cause() const;
    const crit_diagnostics_s& crit_diagnostics() const;

  private:
    types                                        type_;
    choice_buffer_t<cause_c, crit_diagnostics_s> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

struct broadcast_context_setup_fail_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                                      gnb_du_mbs_f1ap_id_present = false;
  bool                                                      crit_diagnostics_present   = false;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_cu_mbs_f1ap_id;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_du_mbs_f1ap_id;
  ie_field_s<cause_c>                                       cause;
  ie_field_s<crit_diagnostics_s>                            crit_diagnostics;

  // sequence methods
  broadcast_context_setup_fail_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// BroadcastContextSetupFailure ::= SEQUENCE
using broadcast_context_setup_fail_s = elementary_procedure_option<broadcast_context_setup_fail_ies_container>;

// BroadcastMRBs-ToBeSetup-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using broadcast_m_rbs_to_be_setup_item_ext_ies_o = protocol_ext_empty_o;

using broadcast_m_rbs_to_be_setup_item_ext_ies_container = protocol_ext_container_empty_l;

// BroadcastMRBs-ToBeSetup-Item ::= SEQUENCE
struct broadcast_m_rbs_to_be_setup_item_s {
  bool                                               ext    = false;
  uint16_t                                           mrb_id = 1;
  qos_flow_level_qos_params_s                        mrb_qos_info;
  mbs_flows_mapped_to_mrb_list_l                     mbs_flows_mapped_to_mrb_list;
  bc_bearer_context_f1_u_tnl_info_c                  bc_bearer_ctxt_f1_u_tnl_infoat_cu;
  broadcast_m_rbs_to_be_setup_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// BroadcastMRBs-ToBeSetup-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct broadcast_m_rbs_to_be_setup_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { broadcast_m_rbs_to_be_setup_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::broadcast_m_rbs_to_be_setup_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    broadcast_m_rbs_to_be_setup_item_s&       broadcast_m_rbs_to_be_setup_item() { return c; }
    const broadcast_m_rbs_to_be_setup_item_s& broadcast_m_rbs_to_be_setup_item() const { return c; }

  private:
    broadcast_m_rbs_to_be_setup_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// MBS-Session-ID-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using mbs_session_id_ext_ies_o = protocol_ext_empty_o;

// SNSSAI-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using snssai_ext_ies_o = protocol_ext_empty_o;

// BroadcastMRBs-ToBeSetup-List ::= SEQUENCE (SIZE (1..32)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES :
// IEsSetParam}
using broadcast_m_rbs_to_be_setup_list_l =
    bounded_array<protocol_ie_single_container_s<broadcast_m_rbs_to_be_setup_item_ies_o>, 32>;

using mbs_session_id_ext_ies_container = protocol_ext_container_empty_l;

// MBS-Session-ID ::= SEQUENCE
struct mbs_session_id_s {
  bool                             ext             = false;
  bool                             nid_present     = false;
  bool                             ie_exts_present = false;
  fixed_octstring<6, true>         tmgi;
  fixed_bitstring<44, false, true> nid;
  mbs_session_id_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using snssai_ext_ies_container = protocol_ext_container_empty_l;

// SNSSAI ::= SEQUENCE
struct snssai_s {
  bool                     sd_present      = false;
  bool                     ie_exts_present = false;
  fixed_octstring<1, true> sst;
  fixed_octstring<3, true> sd;
  snssai_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// BroadcastContextSetupRequestIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct broadcast_context_setup_request_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options {
        gnb_cu_mbs_f1ap_id,
        mbs_session_id,
        mbs_service_area,
        mbs_cu_to_du_rrc_info,
        snssai,
        broadcast_m_rbs_to_be_setup_list,
        nulltype
      } value;
      typedef uint8_t number_type;

      const char* to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint64_t&                                 gnb_cu_mbs_f1ap_id();
    mbs_session_id_s&                         mbs_session_id();
    mbs_service_area_c&                       mbs_service_area();
    mbs_cu_to_du_rrc_info_s&                  mbs_cu_to_du_rrc_info();
    snssai_s&                                 snssai();
    broadcast_m_rbs_to_be_setup_list_l&       broadcast_m_rbs_to_be_setup_list();
    const uint64_t&                           gnb_cu_mbs_f1ap_id() const;
    const mbs_session_id_s&                   mbs_session_id() const;
    const mbs_service_area_c&                 mbs_service_area() const;
    const mbs_cu_to_du_rrc_info_s&            mbs_cu_to_du_rrc_info() const;
    const snssai_s&                           snssai() const;
    const broadcast_m_rbs_to_be_setup_list_l& broadcast_m_rbs_to_be_setup_list() const;

  private:
    types type_;
    choice_buffer_t<broadcast_m_rbs_to_be_setup_list_l,
                    mbs_cu_to_du_rrc_info_s,
                    mbs_service_area_c,
                    mbs_session_id_s,
                    snssai_s>
        c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

struct broadcast_context_setup_request_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                                      mbs_service_area_present = false;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_cu_mbs_f1ap_id;
  ie_field_s<mbs_session_id_s>                              mbs_session_id;
  ie_field_s<mbs_service_area_c>                            mbs_service_area;
  ie_field_s<mbs_cu_to_du_rrc_info_s>                       mbs_cu_to_du_rrc_info;
  ie_field_s<snssai_s>                                      snssai;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<broadcast_m_rbs_to_be_setup_item_ies_o>, 1, 32, true>>
      broadcast_m_rbs_to_be_setup_list;

  // sequence methods
  broadcast_context_setup_request_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// BroadcastContextSetupRequest ::= SEQUENCE
using broadcast_context_setup_request_s = elementary_procedure_option<broadcast_context_setup_request_ies_container>;

// BroadcastMRBs-FailedToBeSetup-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using broadcast_m_rbs_failed_to_be_setup_item_ext_ies_o = protocol_ext_empty_o;

// BroadcastMRBs-Setup-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using broadcast_m_rbs_setup_item_ext_ies_o = protocol_ext_empty_o;

using broadcast_m_rbs_failed_to_be_setup_item_ext_ies_container = protocol_ext_container_empty_l;

// BroadcastMRBs-FailedToBeSetup-Item ::= SEQUENCE
struct broadcast_m_rbs_failed_to_be_setup_item_s {
  bool                                                      ext             = false;
  bool                                                      cause_present   = false;
  bool                                                      ie_exts_present = false;
  uint16_t                                                  mrb_id          = 1;
  cause_c                                                   cause;
  broadcast_m_rbs_failed_to_be_setup_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using broadcast_m_rbs_setup_item_ext_ies_container = protocol_ext_container_empty_l;

// BroadcastMRBs-Setup-Item ::= SEQUENCE
struct broadcast_m_rbs_setup_item_s {
  bool                                         ext             = false;
  bool                                         ie_exts_present = false;
  uint16_t                                     mrb_id          = 1;
  bc_bearer_context_f1_u_tnl_info_c            bc_bearer_ctxt_f1_u_tnl_infoat_du;
  broadcast_m_rbs_setup_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// BroadcastMRBs-FailedToBeSetup-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct broadcast_m_rbs_failed_to_be_setup_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { broadcast_m_rbs_failed_to_be_setup_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::broadcast_m_rbs_failed_to_be_setup_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    broadcast_m_rbs_failed_to_be_setup_item_s&       broadcast_m_rbs_failed_to_be_setup_item() { return c; }
    const broadcast_m_rbs_failed_to_be_setup_item_s& broadcast_m_rbs_failed_to_be_setup_item() const { return c; }

  private:
    broadcast_m_rbs_failed_to_be_setup_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// BroadcastMRBs-Setup-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct broadcast_m_rbs_setup_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { broadcast_m_rbs_setup_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::broadcast_m_rbs_setup_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    broadcast_m_rbs_setup_item_s&       broadcast_m_rbs_setup_item() { return c; }
    const broadcast_m_rbs_setup_item_s& broadcast_m_rbs_setup_item() const { return c; }

  private:
    broadcast_m_rbs_setup_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// BroadcastMRBs-FailedToBeSetup-List ::= SEQUENCE (SIZE (1..32)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES :
// IEsSetParam}
using broadcast_m_rbs_failed_to_be_setup_list_l =
    bounded_array<protocol_ie_single_container_s<broadcast_m_rbs_failed_to_be_setup_item_ies_o>, 32>;

// BroadcastMRBs-Setup-List ::= SEQUENCE (SIZE (1..32)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES : IEsSetParam}
using broadcast_m_rbs_setup_list_l =
    bounded_array<protocol_ie_single_container_s<broadcast_m_rbs_setup_item_ies_o>, 32>;

// BroadcastContextSetupResponseIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct broadcast_context_setup_resp_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options {
        gnb_cu_mbs_f1ap_id,
        gnb_du_mbs_f1ap_id,
        broadcast_m_rbs_setup_list,
        broadcast_m_rbs_failed_to_be_setup_list,
        broadcast_area_scope,
        crit_diagnostics,
        nulltype
      } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint64_t&                                        gnb_cu_mbs_f1ap_id();
    uint64_t&                                        gnb_du_mbs_f1ap_id();
    broadcast_m_rbs_setup_list_l&                    broadcast_m_rbs_setup_list();
    broadcast_m_rbs_failed_to_be_setup_list_l&       broadcast_m_rbs_failed_to_be_setup_list();
    broadcast_area_scope_c&                          broadcast_area_scope();
    crit_diagnostics_s&                              crit_diagnostics();
    const uint64_t&                                  gnb_cu_mbs_f1ap_id() const;
    const uint64_t&                                  gnb_du_mbs_f1ap_id() const;
    const broadcast_m_rbs_setup_list_l&              broadcast_m_rbs_setup_list() const;
    const broadcast_m_rbs_failed_to_be_setup_list_l& broadcast_m_rbs_failed_to_be_setup_list() const;
    const broadcast_area_scope_c&                    broadcast_area_scope() const;
    const crit_diagnostics_s&                        crit_diagnostics() const;

  private:
    types type_;
    choice_buffer_t<broadcast_area_scope_c,
                    broadcast_m_rbs_failed_to_be_setup_list_l,
                    broadcast_m_rbs_setup_list_l,
                    crit_diagnostics_s>
        c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

struct broadcast_context_setup_resp_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                                      broadcast_m_rbs_failed_to_be_setup_list_present = false;
  bool                                                      broadcast_area_scope_present                    = false;
  bool                                                      crit_diagnostics_present                        = false;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_cu_mbs_f1ap_id;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_du_mbs_f1ap_id;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<broadcast_m_rbs_setup_item_ies_o>, 1, 32, true>>
      broadcast_m_rbs_setup_list;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<broadcast_m_rbs_failed_to_be_setup_item_ies_o>, 1, 32, true>>
                                     broadcast_m_rbs_failed_to_be_setup_list;
  ie_field_s<broadcast_area_scope_c> broadcast_area_scope;
  ie_field_s<crit_diagnostics_s>     crit_diagnostics;

  // sequence methods
  broadcast_context_setup_resp_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// BroadcastContextSetupResponse ::= SEQUENCE
using broadcast_context_setup_resp_s = elementary_procedure_option<broadcast_context_setup_resp_ies_container>;

// CCO-Assistance-Information-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using cco_assist_info_ext_ies_o = protocol_ext_empty_o;

// CCO-issue-detection ::= ENUMERATED
struct cco_issue_detection_opts {
  enum options { coverage, cell_edge_capacity, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<cco_issue_detection_opts, true> cco_issue_detection_e;

using cco_assist_info_ext_ies_container = protocol_ext_container_empty_l;

// CCO-Assistance-Information ::= SEQUENCE
struct cco_assist_info_s {
  bool                              ext                         = false;
  bool                              cco_issue_detection_present = false;
  bool                              ie_exts_present             = false;
  cco_issue_detection_e             cco_issue_detection;
  affected_cells_and_beams_list_l   affected_cells_and_beams_list;
  cco_assist_info_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CG-SDTSessionInfo-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using cg_sdt_session_info_ext_ies_o = protocol_ext_empty_o;

using cg_sdt_session_info_ext_ies_container = protocol_ext_container_empty_l;

// CG-SDTSessionInfo ::= SEQUENCE
struct cg_sdt_session_info_s {
  bool                                  ext               = false;
  bool                                  ie_exts_present   = false;
  uint64_t                              gnb_cu_ue_f1ap_id = 0;
  uint64_t                              gnb_du_ue_f1ap_id = 0;
  cg_sdt_session_info_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CNUEPagingIdentity-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
using cn_ue_paging_id_ext_ies_o = protocol_ies_empty_o;

// CNUEPagingIdentity ::= CHOICE
struct cn_ue_paging_id_c {
  struct types_opts {
    enum options { five_g_s_tmsi, choice_ext, nulltype } value;
    typedef uint8_t number_type;

    const char* to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  cn_ue_paging_id_c() = default;
  cn_ue_paging_id_c(const cn_ue_paging_id_c& other);
  cn_ue_paging_id_c& operator=(const cn_ue_paging_id_c& other);
  ~cn_ue_paging_id_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  fixed_bitstring<48, false, true>& five_g_s_tmsi()
  {
    assert_choice_type(types::five_g_s_tmsi, type_, "CNUEPagingIdentity");
    return c.get<fixed_bitstring<48, false, true>>();
  }
  protocol_ie_single_container_s<cn_ue_paging_id_ext_ies_o>& choice_ext()
  {
    assert_choice_type(types::choice_ext, type_, "CNUEPagingIdentity");
    return c.get<protocol_ie_single_container_s<cn_ue_paging_id_ext_ies_o>>();
  }
  const fixed_bitstring<48, false, true>& five_g_s_tmsi() const
  {
    assert_choice_type(types::five_g_s_tmsi, type_, "CNUEPagingIdentity");
    return c.get<fixed_bitstring<48, false, true>>();
  }
  const protocol_ie_single_container_s<cn_ue_paging_id_ext_ies_o>& choice_ext() const
  {
    assert_choice_type(types::choice_ext, type_, "CNUEPagingIdentity");
    return c.get<protocol_ie_single_container_s<cn_ue_paging_id_ext_ies_o>>();
  }
  fixed_bitstring<48, false, true>&                          set_five_g_s_tmsi();
  protocol_ie_single_container_s<cn_ue_paging_id_ext_ies_o>& set_choice_ext();

private:
  types                                                                                                        type_;
  choice_buffer_t<fixed_bitstring<48, false, true>, protocol_ie_single_container_s<cn_ue_paging_id_ext_ies_o>> c;

  void destroy_();
};

// Endpoint-IP-address-and-port-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
struct endpoint_ip_address_and_port_ext_ies_o {
  // Extension ::= OPEN TYPE
  struct ext_c {
    struct types_opts {
      enum options { port_num, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::port_num; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    fixed_bitstring<16, false, true>&       port_num() { return c; }
    const fixed_bitstring<16, false, true>& port_num() const { return c; }

  private:
    fixed_bitstring<16, false, true> c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static ext_c      get_ext(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// CP-TransportLayerAddress-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
using cp_transport_layer_address_ext_ies_o = protocol_ies_empty_o;

// Endpoint-IP-address-and-port ::= SEQUENCE
struct endpoint_ip_address_and_port_s {
  bounded_bitstring<1, 160, true, true>                            endpoint_ip_address;
  protocol_ext_container_l<endpoint_ip_address_and_port_ext_ies_o> ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CP-TransportLayerAddress ::= CHOICE
struct cp_transport_layer_address_c {
  struct types_opts {
    enum options { endpoint_ip_address, endpoint_ip_address_and_port, choice_ext, nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  cp_transport_layer_address_c() = default;
  cp_transport_layer_address_c(const cp_transport_layer_address_c& other);
  cp_transport_layer_address_c& operator=(const cp_transport_layer_address_c& other);
  ~cp_transport_layer_address_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  bounded_bitstring<1, 160, true, true>& endpoint_ip_address()
  {
    assert_choice_type(types::endpoint_ip_address, type_, "CP-TransportLayerAddress");
    return c.get<bounded_bitstring<1, 160, true, true>>();
  }
  endpoint_ip_address_and_port_s& endpoint_ip_address_and_port()
  {
    assert_choice_type(types::endpoint_ip_address_and_port, type_, "CP-TransportLayerAddress");
    return c.get<endpoint_ip_address_and_port_s>();
  }
  protocol_ie_single_container_s<cp_transport_layer_address_ext_ies_o>& choice_ext()
  {
    assert_choice_type(types::choice_ext, type_, "CP-TransportLayerAddress");
    return c.get<protocol_ie_single_container_s<cp_transport_layer_address_ext_ies_o>>();
  }
  const bounded_bitstring<1, 160, true, true>& endpoint_ip_address() const
  {
    assert_choice_type(types::endpoint_ip_address, type_, "CP-TransportLayerAddress");
    return c.get<bounded_bitstring<1, 160, true, true>>();
  }
  const endpoint_ip_address_and_port_s& endpoint_ip_address_and_port() const
  {
    assert_choice_type(types::endpoint_ip_address_and_port, type_, "CP-TransportLayerAddress");
    return c.get<endpoint_ip_address_and_port_s>();
  }
  const protocol_ie_single_container_s<cp_transport_layer_address_ext_ies_o>& choice_ext() const
  {
    assert_choice_type(types::choice_ext, type_, "CP-TransportLayerAddress");
    return c.get<protocol_ie_single_container_s<cp_transport_layer_address_ext_ies_o>>();
  }
  bounded_bitstring<1, 160, true, true>&                                set_endpoint_ip_address();
  endpoint_ip_address_and_port_s&                                       set_endpoint_ip_address_and_port();
  protocol_ie_single_container_s<cp_transport_layer_address_ext_ies_o>& set_choice_ext();

private:
  types type_;
  choice_buffer_t<bounded_bitstring<1, 160, true, true>,
                  endpoint_ip_address_and_port_s,
                  protocol_ie_single_container_s<cp_transport_layer_address_ext_ies_o>>
      c;

  void destroy_();
};

// CPAC-trigger ::= ENUMERATED
struct cp_ac_trigger_opts {
  enum options { cpac_prep, cpac_executed, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<cp_ac_trigger_opts, true> cp_ac_trigger_e;

// CPACMCGInformation-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using cp_acmcg_info_ext_ies_o = protocol_ext_empty_o;

using cp_acmcg_info_ext_ies_container = protocol_ext_container_empty_l;

// CPACMCGInformation ::= SEQUENCE
struct cp_acmcg_info_s {
  bool                            ext             = false;
  bool                            ie_exts_present = false;
  cp_ac_trigger_e                 cpac_trigger;
  nr_cgi_s                        pscellid;
  cp_acmcg_info_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CUDURIMInformation-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using cu_du_rim_info_ext_ies_o = protocol_ext_empty_o;

// RIMRSDetectionStatus ::= ENUMERATED
struct rimrs_detection_status_opts {
  enum options { rs_detected, rs_disappeared, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<rimrs_detection_status_opts, true> rimrs_detection_status_e;

using cu_du_rim_info_ext_ies_container = protocol_ext_container_empty_l;

// CUDURIMInformation ::= SEQUENCE
struct cu_du_rim_info_s {
  bool                             ie_exts_present = false;
  fixed_bitstring<22, false, true> victim_gnb_set_id;
  rimrs_detection_status_e         rimrs_detection_status;
  cu_du_rim_info_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CUDURadioInformationType-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
using cu_du_radio_info_type_ext_ies_o = protocol_ies_empty_o;

// CUDURadioInformationType ::= CHOICE
struct cu_du_radio_info_type_c {
  struct types_opts {
    enum options { rim, choice_ext, nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  cu_du_radio_info_type_c() = default;
  cu_du_radio_info_type_c(const cu_du_radio_info_type_c& other);
  cu_du_radio_info_type_c& operator=(const cu_du_radio_info_type_c& other);
  ~cu_du_radio_info_type_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  cu_du_rim_info_s& rim()
  {
    assert_choice_type(types::rim, type_, "CUDURadioInformationType");
    return c.get<cu_du_rim_info_s>();
  }
  protocol_ie_single_container_s<cu_du_radio_info_type_ext_ies_o>& choice_ext()
  {
    assert_choice_type(types::choice_ext, type_, "CUDURadioInformationType");
    return c.get<protocol_ie_single_container_s<cu_du_radio_info_type_ext_ies_o>>();
  }
  const cu_du_rim_info_s& rim() const
  {
    assert_choice_type(types::rim, type_, "CUDURadioInformationType");
    return c.get<cu_du_rim_info_s>();
  }
  const protocol_ie_single_container_s<cu_du_radio_info_type_ext_ies_o>& choice_ext() const
  {
    assert_choice_type(types::choice_ext, type_, "CUDURadioInformationType");
    return c.get<protocol_ie_single_container_s<cu_du_radio_info_type_ext_ies_o>>();
  }
  cu_du_rim_info_s&                                                set_rim();
  protocol_ie_single_container_s<cu_du_radio_info_type_ext_ies_o>& set_choice_ext();

private:
  types                                                                                              type_;
  choice_buffer_t<cu_du_rim_info_s, protocol_ie_single_container_s<cu_du_radio_info_type_ext_ies_o>> c;

  void destroy_();
};

// CUDURadioInformationTransferIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct cu_du_radio_info_transfer_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { transaction_id, cu_du_radio_info_type, nulltype } value;
      typedef uint8_t number_type;

      const char* to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint16_t&                      transaction_id();
    cu_du_radio_info_type_c&       cu_du_radio_info_type();
    const uint16_t&                transaction_id() const;
    const cu_du_radio_info_type_c& cu_du_radio_info_type() const;

  private:
    types                                    type_;
    choice_buffer_t<cu_du_radio_info_type_c> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

struct cu_du_radio_info_transfer_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  ie_field_s<integer<uint16_t, 0, 255, true, true>> transaction_id;
  ie_field_s<cu_du_radio_info_type_c>               cu_du_radio_info_type;

  // sequence methods
  cu_du_radio_info_transfer_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CUDURadioInformationTransfer ::= SEQUENCE
using cu_du_radio_info_transfer_s = elementary_procedure_option<cu_du_radio_info_transfer_ies_container>;

// CUtoDURRCInformation-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
struct cu_to_du_rrc_info_ext_ies_o {
  // Extension ::= OPEN TYPE
  struct ext_c {
    struct types_opts {
      enum options {
        ho_prep_info,
        cell_group_cfg,
        meas_timing_cfg,
        ue_assist_info,
        cg_cfg,
        ue_assist_info_eutra,
        location_meas_info,
        mu_si_m_gap_cfg,
        sdt_mac_phy_cg_cfg,
        mb_si_nterest_ind,
        need_for_gaps_info_nr,
        need_for_gap_ncsg_info_nr,
        need_for_gap_ncsg_info_eutra,
        cfg_restrict_info_daps,
        nulltype
      } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    ext_c() = default;
    ext_c(const ext_c& other);
    ext_c& operator=(const ext_c& other);
    ~ext_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    unbounded_octstring<true>&       ho_prep_info();
    unbounded_octstring<true>&       cell_group_cfg();
    unbounded_octstring<true>&       meas_timing_cfg();
    unbounded_octstring<true>&       ue_assist_info();
    unbounded_octstring<true>&       cg_cfg();
    unbounded_octstring<true>&       ue_assist_info_eutra();
    unbounded_octstring<true>&       location_meas_info();
    unbounded_octstring<true>&       mu_si_m_gap_cfg();
    unbounded_octstring<true>&       sdt_mac_phy_cg_cfg();
    unbounded_octstring<true>&       mb_si_nterest_ind();
    unbounded_octstring<true>&       need_for_gaps_info_nr();
    unbounded_octstring<true>&       need_for_gap_ncsg_info_nr();
    unbounded_octstring<true>&       need_for_gap_ncsg_info_eutra();
    unbounded_octstring<true>&       cfg_restrict_info_daps();
    const unbounded_octstring<true>& ho_prep_info() const;
    const unbounded_octstring<true>& cell_group_cfg() const;
    const unbounded_octstring<true>& meas_timing_cfg() const;
    const unbounded_octstring<true>& ue_assist_info() const;
    const unbounded_octstring<true>& cg_cfg() const;
    const unbounded_octstring<true>& ue_assist_info_eutra() const;
    const unbounded_octstring<true>& location_meas_info() const;
    const unbounded_octstring<true>& mu_si_m_gap_cfg() const;
    const unbounded_octstring<true>& sdt_mac_phy_cg_cfg() const;
    const unbounded_octstring<true>& mb_si_nterest_ind() const;
    const unbounded_octstring<true>& need_for_gaps_info_nr() const;
    const unbounded_octstring<true>& need_for_gap_ncsg_info_nr() const;
    const unbounded_octstring<true>& need_for_gap_ncsg_info_eutra() const;
    const unbounded_octstring<true>& cfg_restrict_info_daps() const;

  private:
    types                                      type_;
    choice_buffer_t<unbounded_octstring<true>> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static ext_c      get_ext(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

struct cu_to_du_rrc_info_ext_ies_container {
  template <class extT_>
  using ie_field_s = protocol_ext_container_item_s<extT_>;

  // member variables
  bool                                  ho_prep_info_present                 = false;
  bool                                  cell_group_cfg_present               = false;
  bool                                  meas_timing_cfg_present              = false;
  bool                                  ue_assist_info_present               = false;
  bool                                  cg_cfg_present                       = false;
  bool                                  ue_assist_info_eutra_present         = false;
  bool                                  location_meas_info_present           = false;
  bool                                  mu_si_m_gap_cfg_present              = false;
  bool                                  sdt_mac_phy_cg_cfg_present           = false;
  bool                                  mb_si_nterest_ind_present            = false;
  bool                                  need_for_gaps_info_nr_present        = false;
  bool                                  need_for_gap_ncsg_info_nr_present    = false;
  bool                                  need_for_gap_ncsg_info_eutra_present = false;
  bool                                  cfg_restrict_info_daps_present       = false;
  ie_field_s<unbounded_octstring<true>> ho_prep_info;
  ie_field_s<unbounded_octstring<true>> cell_group_cfg;
  ie_field_s<unbounded_octstring<true>> meas_timing_cfg;
  ie_field_s<unbounded_octstring<true>> ue_assist_info;
  ie_field_s<unbounded_octstring<true>> cg_cfg;
  ie_field_s<unbounded_octstring<true>> ue_assist_info_eutra;
  ie_field_s<unbounded_octstring<true>> location_meas_info;
  ie_field_s<unbounded_octstring<true>> mu_si_m_gap_cfg;
  ie_field_s<unbounded_octstring<true>> sdt_mac_phy_cg_cfg;
  ie_field_s<unbounded_octstring<true>> mb_si_nterest_ind;
  ie_field_s<unbounded_octstring<true>> need_for_gaps_info_nr;
  ie_field_s<unbounded_octstring<true>> need_for_gap_ncsg_info_nr;
  ie_field_s<unbounded_octstring<true>> need_for_gap_ncsg_info_eutra;
  ie_field_s<unbounded_octstring<true>> cfg_restrict_info_daps;

  // sequence methods
  cu_to_du_rrc_info_ext_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CUtoDURRCInformation ::= SEQUENCE
struct cu_to_du_rrc_info_s {
  bool                                ext             = false;
  bool                                ie_exts_present = false;
  unbounded_octstring<true>           cg_cfg_info;
  unbounded_octstring<true>           ue_cap_rat_container_list;
  unbounded_octstring<true>           meas_cfg;
  cu_to_du_rrc_info_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// Candidate-SpCell-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using candidate_sp_cell_item_ext_ies_o = protocol_ext_empty_o;

using candidate_sp_cell_item_ext_ies_container = protocol_ext_container_empty_l;

// Candidate-SpCell-Item ::= SEQUENCE
struct candidate_sp_cell_item_s {
  bool                                     ext             = false;
  bool                                     ie_exts_present = false;
  nr_cgi_s                                 candidate_sp_cell_id;
  candidate_sp_cell_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// Candidate-SpCell-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct candidate_sp_cell_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { candidate_sp_cell_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::candidate_sp_cell_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    candidate_sp_cell_item_s&       candidate_sp_cell_item() { return c; }
    const candidate_sp_cell_item_s& candidate_sp_cell_item() const { return c; }

  private:
    candidate_sp_cell_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// Candidate-SpCell-List ::= SEQUENCE (SIZE (1..64)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES : IEsSetParam}
using candidate_sp_cell_list_l = dyn_array<protocol_ie_single_container_s<candidate_sp_cell_item_ies_o>>;

// SSBAreaCapacityValueItem-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using ssb_area_capacity_value_item_ext_ies_o = protocol_ext_empty_o;

using ssb_area_capacity_value_item_ext_ies_container = protocol_ext_container_empty_l;

// SSBAreaCapacityValueItem ::= SEQUENCE
struct ssb_area_capacity_value_item_s {
  bool                                           ie_exts_present         = false;
  uint8_t                                        ssb_idx                 = 0;
  uint8_t                                        ssb_area_capacity_value = 0;
  ssb_area_capacity_value_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CapacityValue-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using capacity_value_ext_ies_o = protocol_ext_empty_o;

// SSBAreaCapacityValueList ::= SEQUENCE (SIZE (1..64)) OF SSBAreaCapacityValueItem
using ssb_area_capacity_value_list_l = dyn_array<ssb_area_capacity_value_item_s>;

using capacity_value_ext_ies_container = protocol_ext_container_empty_l;

// CapacityValue ::= SEQUENCE
struct capacity_value_s {
  bool                             ie_exts_present = false;
  uint8_t                          capacity_value  = 0;
  ssb_area_capacity_value_list_l   ssb_area_capacity_value_list;
  capacity_value_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SNSSAIRadioResourceStatus-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using snssai_rr_status_item_ext_ies_o = protocol_ext_empty_o;

using snssai_rr_status_item_ext_ies_container = protocol_ext_container_empty_l;

// SNSSAIRadioResourceStatus-Item ::= SEQUENCE
struct snssai_rr_status_item_s {
  bool                                    ie_exts_present = false;
  snssai_s                                snssai;
  uint8_t                                 snssai_dl_gbr_prb_usage     = 0;
  uint8_t                                 snssai_ul_gbr_prb_usage     = 0;
  uint8_t                                 snssai_dl_non_gbr_prb_usage = 0;
  uint8_t                                 snssai_ul_non_gbr_prb_usage = 0;
  uint8_t                                 snssai_dl_total_prb_alloc   = 0;
  uint8_t                                 snssai_ul_total_prb_alloc   = 0;
  snssai_rr_status_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SNSSAIAvailableCapacity-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using snssai_available_capacity_item_ext_ies_o = protocol_ext_empty_o;

// SNSSAIRadioResourceStatus-List ::= SEQUENCE (SIZE (1..1024)) OF SNSSAIRadioResourceStatus-Item
using snssai_rr_status_list_l = dyn_array<snssai_rr_status_item_s>;

// SliceRadioResourceStatus-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using slice_rr_status_item_ext_ies_o = protocol_ext_empty_o;

using snssai_available_capacity_item_ext_ies_container = protocol_ext_container_empty_l;

// SNSSAIAvailableCapacity-Item ::= SEQUENCE
struct snssai_available_capacity_item_s {
  bool                                             slice_available_capacity_value_dl_present = false;
  bool                                             slice_available_capacity_value_ul_present = false;
  bool                                             ie_exts_present                           = false;
  snssai_s                                         snssai;
  uint8_t                                          slice_available_capacity_value_dl = 0;
  uint8_t                                          slice_available_capacity_value_ul = 0;
  snssai_available_capacity_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using slice_rr_status_item_ext_ies_container = protocol_ext_container_empty_l;

// SliceRadioResourceStatus-Item ::= SEQUENCE
struct slice_rr_status_item_s {
  bool                                   ie_exts_present = false;
  fixed_octstring<3, true>               plmn_id;
  snssai_rr_status_list_l                snssai_rr_status_list;
  slice_rr_status_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CompositeAvailableCapacity-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using composite_available_capacity_ext_ies_o = protocol_ext_empty_o;

// MIMOPRBusageInformation-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using mimo_prb_usage_info_ext_ies_o = protocol_ext_empty_o;

// NR-U-Channel-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using nr_u_ch_item_ext_ies_o = protocol_ext_empty_o;

// SNSSAIAvailableCapacity-List ::= SEQUENCE (SIZE (1..1024)) OF SNSSAIAvailableCapacity-Item
using snssai_available_capacity_list_l = dyn_array<snssai_available_capacity_item_s>;

// SSBAreaRadioResourceStatusItem-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using ssb_area_rr_status_item_ext_ies_o = protocol_ext_empty_o;

// SliceAvailableCapacityItem-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using slice_available_capacity_item_ext_ies_o = protocol_ext_empty_o;

// SliceRadioResourceStatus-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using slice_rr_status_ext_ies_o = protocol_ext_empty_o;

// SliceRadioResourceStatus-List ::= SEQUENCE (SIZE (1..12)) OF SliceRadioResourceStatus-Item
using slice_rr_status_list_l = dyn_array<slice_rr_status_item_s>;

using composite_available_capacity_ext_ies_container = protocol_ext_container_empty_l;

// CompositeAvailableCapacity ::= SEQUENCE
struct composite_available_capacity_s {
  bool                                           cell_capacity_class_value_present = false;
  bool                                           ie_exts_present                   = false;
  uint8_t                                        cell_capacity_class_value         = 1;
  capacity_value_s                               capacity_value;
  composite_available_capacity_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using mimo_prb_usage_info_ext_ies_container = protocol_ext_container_empty_l;

// MIMOPRBusageInformation ::= SEQUENCE
struct mimo_prb_usage_info_s {
  bool                                  ext                           = false;
  bool                                  ie_exts_present               = false;
  uint8_t                               dl_gbr_prb_usage_for_mimo     = 0;
  uint8_t                               ul_gbr_prb_usage_for_mimo     = 0;
  uint8_t                               dl_non_gbr_prb_usage_for_mimo = 0;
  uint8_t                               ul_non_gbr_prb_usage_for_mimo = 0;
  uint8_t                               dl_total_prb_usage_for_mimo   = 0;
  uint8_t                               ul_total_prb_usage_for_mimo   = 0;
  mimo_prb_usage_info_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using nr_u_ch_item_ext_ies_container = protocol_ext_container_empty_l;

// NR-U-Channel-Item ::= SEQUENCE
struct nr_u_ch_item_s {
  bool                           ext                             = false;
  bool                           ie_exts_present                 = false;
  uint8_t                        nr_u_ch_id                      = 1;
  uint8_t                        ch_occupancy_time_percentage_dl = 0;
  int8_t                         energy_detection_thres          = -100;
  nr_u_ch_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using ssb_area_rr_status_item_ext_ies_container = protocol_ext_container_empty_l;

// SSBAreaRadioResourceStatusItem ::= SEQUENCE
struct ssb_area_rr_status_item_s {
  bool                                      dl_sched_pdcch_cc_eusage_present = false;
  bool                                      ul_sched_pdcch_cc_eusage_present = false;
  bool                                      ie_exts_present                  = false;
  uint8_t                                   ssb_idx                          = 0;
  uint8_t                                   ssb_area_dl_gbr_prb_usage        = 0;
  uint8_t                                   ssb_area_ul_gbr_prb_usage        = 0;
  uint8_t                                   ssb_area_dl_non_gbr_prb_usage    = 0;
  uint8_t                                   ssb_area_ul_non_gbr_prb_usage    = 0;
  uint8_t                                   ssb_area_dl_total_prb_usage      = 0;
  uint8_t                                   ssb_area_ul_total_prb_usage      = 0;
  uint8_t                                   dl_sched_pdcch_cc_eusage         = 0;
  uint8_t                                   ul_sched_pdcch_cc_eusage         = 0;
  ssb_area_rr_status_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using slice_available_capacity_item_ext_ies_container = protocol_ext_container_empty_l;

// SliceAvailableCapacityItem ::= SEQUENCE
struct slice_available_capacity_item_s {
  bool                                            ie_exts_present = false;
  fixed_octstring<3, true>                        plmn_id;
  snssai_available_capacity_list_l                snssai_available_capacity_list;
  slice_available_capacity_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using slice_rr_status_ext_ies_container = protocol_ext_container_empty_l;

// SliceRadioResourceStatus ::= SEQUENCE
struct slice_rr_status_s {
  bool                              ie_exts_present = false;
  slice_rr_status_list_l            slice_rr_status;
  slice_rr_status_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CompositeAvailableCapacityGroup-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
struct composite_available_capacity_group_ext_ies_o {
  // Extension ::= OPEN TYPE
  struct ext_c {
    struct types_opts {
      enum options { composite_available_capacity_sul, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::composite_available_capacity_sul; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    composite_available_capacity_s&       composite_available_capacity_sul() { return c; }
    const composite_available_capacity_s& composite_available_capacity_sul() const { return c; }

  private:
    composite_available_capacity_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static ext_c      get_ext(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// NR-U-Channel-List ::= SEQUENCE (SIZE (1..16)) OF NR-U-Channel-Item
using nr_u_ch_list_l = dyn_array<nr_u_ch_item_s>;

// RadioResourceStatus-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
struct rr_status_ext_ies_o {
  // Extension ::= OPEN TYPE
  struct ext_c {
    struct types_opts {
      enum options { slice_rr_status, mimo_prb_usage_info, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    ext_c() = default;
    ext_c(const ext_c& other);
    ext_c& operator=(const ext_c& other);
    ~ext_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    slice_rr_status_s&           slice_rr_status();
    mimo_prb_usage_info_s&       mimo_prb_usage_info();
    const slice_rr_status_s&     slice_rr_status() const;
    const mimo_prb_usage_info_s& mimo_prb_usage_info() const;

  private:
    types                                                     type_;
    choice_buffer_t<mimo_prb_usage_info_s, slice_rr_status_s> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static ext_c      get_ext(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// SSBAreaRadioResourceStatusList ::= SEQUENCE (SIZE (1..64)) OF SSBAreaRadioResourceStatusItem
using ssb_area_rr_status_list_l = dyn_array<ssb_area_rr_status_item_s>;

// SliceAvailableCapacity-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using slice_available_capacity_ext_ies_o = protocol_ext_empty_o;

// SliceAvailableCapacityList ::= SEQUENCE (SIZE (1..12)) OF SliceAvailableCapacityItem
using slice_available_capacity_list_l = dyn_array<slice_available_capacity_item_s>;

// CellMeasurementResultItem-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
struct cell_meas_result_item_ext_ies_o {
  // Extension ::= OPEN TYPE
  struct ext_c {
    struct types_opts {
      enum options { nr_u_ch_list, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::nr_u_ch_list; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    nr_u_ch_list_l&       nr_u_ch_list() { return c; }
    const nr_u_ch_list_l& nr_u_ch_list() const { return c; }

  private:
    nr_u_ch_list_l c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static ext_c      get_ext(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// CompositeAvailableCapacityGroup ::= SEQUENCE
struct composite_available_capacity_group_s {
  composite_available_capacity_s                                         composite_available_capacity_dl;
  composite_available_capacity_s                                         composite_available_capacity_ul;
  protocol_ext_container_l<composite_available_capacity_group_ext_ies_o> ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

struct rr_status_ext_ies_container {
  template <class extT_>
  using ie_field_s = protocol_ext_container_item_s<extT_>;

  // member variables
  bool                              slice_rr_status_present     = false;
  bool                              mimo_prb_usage_info_present = false;
  ie_field_s<slice_rr_status_s>     slice_rr_status;
  ie_field_s<mimo_prb_usage_info_s> mimo_prb_usage_info;

  // sequence methods
  rr_status_ext_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RadioResourceStatus ::= SEQUENCE
struct rr_status_s {
  bool                        ie_exts_present = false;
  ssb_area_rr_status_list_l   ssb_area_rr_status_list;
  rr_status_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using slice_available_capacity_ext_ies_container = protocol_ext_container_empty_l;

// SliceAvailableCapacity ::= SEQUENCE
struct slice_available_capacity_s {
  bool                                       ie_exts_present = false;
  slice_available_capacity_list_l            slice_available_capacity_list;
  slice_available_capacity_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CellMeasurementResultItem ::= SEQUENCE
struct cell_meas_result_item_s {
  bool                                                      rr_status_present                          = false;
  bool                                                      composite_available_capacity_group_present = false;
  bool                                                      slice_available_capacity_present           = false;
  bool                                                      numof_active_ues_present                   = false;
  nr_cgi_s                                                  cell_id;
  rr_status_s                                               rr_status;
  composite_available_capacity_group_s                      composite_available_capacity_group;
  slice_available_capacity_s                                slice_available_capacity;
  uint32_t                                                  numof_active_ues = 0;
  protocol_ext_container_l<cell_meas_result_item_ext_ies_o> ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CellMeasurementResultList ::= SEQUENCE (SIZE (1..512)) OF CellMeasurementResultItem
using cell_meas_result_list_l = dyn_array<cell_meas_result_item_s>;

// SNSSAI-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using snssai_item_ext_ies_o = protocol_ext_empty_o;

using snssai_item_ext_ies_container = protocol_ext_container_empty_l;

// SNSSAI-Item ::= SEQUENCE
struct snssai_item_s {
  bool                          ie_exts_present = false;
  snssai_s                      snssai;
  snssai_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SNSSAI-list ::= SEQUENCE (SIZE (1..1024)) OF SNSSAI-Item
using snssai_list_l = dyn_array<snssai_item_s>;

// SSBToReportItem-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using ssb_to_report_item_ext_ies_o = protocol_ext_empty_o;

// SliceToReportItem-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using slice_to_report_item_ext_ies_o = protocol_ext_empty_o;

using ssb_to_report_item_ext_ies_container = protocol_ext_container_empty_l;

// SSBToReportItem ::= SEQUENCE
struct ssb_to_report_item_s {
  bool                                 ie_exts_present = false;
  uint8_t                              ssb_idx         = 0;
  ssb_to_report_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using slice_to_report_item_ext_ies_container = protocol_ext_container_empty_l;

// SliceToReportItem ::= SEQUENCE
struct slice_to_report_item_s {
  bool                                   ie_exts_present = false;
  fixed_octstring<3, true>               plmn_id;
  snssai_list_l                          snssai_list;
  slice_to_report_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CellToReportItem-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using cell_to_report_item_ext_ies_o = protocol_ext_empty_o;

// SSBToReportList ::= SEQUENCE (SIZE (1..64)) OF SSBToReportItem
using ssb_to_report_list_l = dyn_array<ssb_to_report_item_s>;

// SliceToReportList ::= SEQUENCE (SIZE (1..12)) OF SliceToReportItem
using slice_to_report_list_l = dyn_array<slice_to_report_item_s>;

using cell_to_report_item_ext_ies_container = protocol_ext_container_empty_l;

// CellToReportItem ::= SEQUENCE
struct cell_to_report_item_s {
  bool                                  ie_exts_present = false;
  nr_cgi_s                              cell_id;
  ssb_to_report_list_l                  ssb_to_report_list;
  slice_to_report_list_l                slice_to_report_list;
  cell_to_report_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CellToReportList ::= SEQUENCE (SIZE (1..512)) OF CellToReportItem
using cell_to_report_list_l = dyn_array<cell_to_report_item_s>;

// PrivacyIndicator ::= ENUMERATED
struct privacy_ind_opts {
  enum options { immediate_mdt, logged_mdt, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<privacy_ind_opts, true> privacy_ind_e;

// CellTrafficTraceIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct cell_traffic_trace_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options {
        gnb_cu_ue_f1ap_id,
        gnb_du_ue_f1ap_id,
        trace_id,
        trace_collection_entity_ip_address,
        privacy_ind,
        trace_collection_entity_uri,
        nulltype
      } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint64_t&                                                    gnb_cu_ue_f1ap_id();
    uint64_t&                                                    gnb_du_ue_f1ap_id();
    fixed_octstring<8, true>&                                    trace_id();
    bounded_bitstring<1, 160, true, true>&                       trace_collection_entity_ip_address();
    privacy_ind_e&                                               privacy_ind();
    visible_string<0, MAX_ASN_STRING_LENGTH, false, true>&       trace_collection_entity_uri();
    const uint64_t&                                              gnb_cu_ue_f1ap_id() const;
    const uint64_t&                                              gnb_du_ue_f1ap_id() const;
    const fixed_octstring<8, true>&                              trace_id() const;
    const bounded_bitstring<1, 160, true, true>&                 trace_collection_entity_ip_address() const;
    const privacy_ind_e&                                         privacy_ind() const;
    const visible_string<0, MAX_ASN_STRING_LENGTH, false, true>& trace_collection_entity_uri() const;

  private:
    types type_;
    choice_buffer_t<bounded_bitstring<1, 160, true, true>,
                    fixed_octstring<8, true>,
                    visible_string<0, MAX_ASN_STRING_LENGTH, false, true>>
        c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

struct cell_traffic_trace_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                                              privacy_ind_present                 = false;
  bool                                                              trace_collection_entity_uri_present = false;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>>         gnb_cu_ue_f1ap_id;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>>         gnb_du_ue_f1ap_id;
  ie_field_s<fixed_octstring<8, true>>                              trace_id;
  ie_field_s<bounded_bitstring<1, 160, true, true>>                 trace_collection_entity_ip_address;
  ie_field_s<privacy_ind_e>                                         privacy_ind;
  ie_field_s<visible_string<0, MAX_ASN_STRING_LENGTH, false, true>> trace_collection_entity_uri;

  // sequence methods
  cell_traffic_trace_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CellTrafficTrace ::= SEQUENCE
using cell_traffic_trace_s = elementary_procedure_option<cell_traffic_trace_ies_container>;

// CellSize ::= ENUMERATED
struct cell_size_opts {
  enum options { verysmall, small, medium, large, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<cell_size_opts, true> cell_size_e;

// CellType-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using cell_type_ext_ies_o = protocol_ext_empty_o;

using cell_type_ext_ies_container = protocol_ext_container_empty_l;

// CellType ::= SEQUENCE
struct cell_type_s {
  bool                        ext             = false;
  bool                        ie_exts_present = false;
  cell_size_e                 cell_size;
  cell_type_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// Cells-Broadcast-Cancelled-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using cells_broadcast_cancelled_item_ext_ies_o = protocol_ext_empty_o;

using cells_broadcast_cancelled_item_ext_ies_container = protocol_ext_container_empty_l;

// Cells-Broadcast-Cancelled-Item ::= SEQUENCE
struct cells_broadcast_cancelled_item_s {
  bool                                             ext             = false;
  bool                                             ie_exts_present = false;
  nr_cgi_s                                         nr_cgi;
  uint32_t                                         nof_broadcasts = 0;
  cells_broadcast_cancelled_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// Cells-Broadcast-Cancelled-List-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct cells_broadcast_cancelled_list_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { cells_broadcast_cancelled_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::cells_broadcast_cancelled_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    cells_broadcast_cancelled_item_s&       cells_broadcast_cancelled_item() { return c; }
    const cells_broadcast_cancelled_item_s& cells_broadcast_cancelled_item() const { return c; }

  private:
    cells_broadcast_cancelled_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// Cells-Broadcast-Cancelled-List ::= SEQUENCE (SIZE (1..512)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES :
// IEsSetParam}
using cells_broadcast_cancelled_list_l =
    dyn_array<protocol_ie_single_container_s<cells_broadcast_cancelled_list_item_ies_o>>;

// Cells-Broadcast-Completed-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using cells_broadcast_completed_item_ext_ies_o = protocol_ext_empty_o;

using cells_broadcast_completed_item_ext_ies_container = protocol_ext_container_empty_l;

// Cells-Broadcast-Completed-Item ::= SEQUENCE
struct cells_broadcast_completed_item_s {
  bool                                             ext             = false;
  bool                                             ie_exts_present = false;
  nr_cgi_s                                         nr_cgi;
  cells_broadcast_completed_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// Cells-Broadcast-Completed-List-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct cells_broadcast_completed_list_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { cells_broadcast_completed_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::cells_broadcast_completed_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    cells_broadcast_completed_item_s&       cells_broadcast_completed_item() { return c; }
    const cells_broadcast_completed_item_s& cells_broadcast_completed_item() const { return c; }

  private:
    cells_broadcast_completed_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// Cells-Broadcast-Completed-List ::= SEQUENCE (SIZE (1..512)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES :
// IEsSetParam}
using cells_broadcast_completed_list_l =
    dyn_array<protocol_ie_single_container_s<cells_broadcast_completed_list_item_ies_o>>;

// Cells-Failed-to-be-Activated-List-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using cells_failed_to_be_activ_list_item_ext_ies_o = protocol_ext_empty_o;

using cells_failed_to_be_activ_list_item_ext_ies_container = protocol_ext_container_empty_l;

// Cells-Failed-to-be-Activated-List-Item ::= SEQUENCE
struct cells_failed_to_be_activ_list_item_s {
  bool                                                 ext             = false;
  bool                                                 ie_exts_present = false;
  nr_cgi_s                                             nr_cgi;
  cause_c                                              cause;
  cells_failed_to_be_activ_list_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// Cells-Failed-to-be-Activated-List-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct cells_failed_to_be_activ_list_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { cells_failed_to_be_activ_list_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::cells_failed_to_be_activ_list_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    cells_failed_to_be_activ_list_item_s&       cells_failed_to_be_activ_list_item() { return c; }
    const cells_failed_to_be_activ_list_item_s& cells_failed_to_be_activ_list_item() const { return c; }

  private:
    cells_failed_to_be_activ_list_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// Cells-Failed-to-be-Activated-List ::= SEQUENCE (SIZE (1..512)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES :
// IEsSetParam}
using cells_failed_to_be_activ_list_l =
    dyn_array<protocol_ie_single_container_s<cells_failed_to_be_activ_list_item_ies_o>>;

// Service-State ::= ENUMERATED
struct service_state_opts {
  enum options { in_service, out_of_service, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<service_state_opts, true> service_state_e;

// Service-Status-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using service_status_ext_ies_o = protocol_ext_empty_o;

// Cells-Status-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using cells_status_item_ext_ies_o = protocol_ext_empty_o;

using service_status_ext_ies_container = protocol_ext_container_empty_l;

// Service-Status ::= SEQUENCE
struct service_status_s {
  struct switching_off_ongoing_opts {
    enum options { true_value, /*...*/ nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<switching_off_ongoing_opts, true> switching_off_ongoing_e_;

  // member variables
  bool                             ext                           = false;
  bool                             switching_off_ongoing_present = false;
  bool                             ie_exts_present               = false;
  service_state_e                  service_state;
  switching_off_ongoing_e_         switching_off_ongoing;
  service_status_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using cells_status_item_ext_ies_container = protocol_ext_container_empty_l;

// Cells-Status-Item ::= SEQUENCE
struct cells_status_item_s {
  bool                                ext             = false;
  bool                                ie_exts_present = false;
  nr_cgi_s                            nr_cgi;
  service_status_s                    service_status;
  cells_status_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// Cells-Status-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct cells_status_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { cells_status_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::cells_status_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    cells_status_item_s&       cells_status_item() { return c; }
    const cells_status_item_s& cells_status_item() const { return c; }

  private:
    cells_status_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// Cells-Status-List ::= SEQUENCE (SIZE (0..512)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES : IEsSetParam}
using cells_status_list_l = dyn_array<protocol_ie_single_container_s<cells_status_item_ies_o>>;

// Cells-To-Be-Broadcast-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using cells_to_be_broadcast_item_ext_ies_o = protocol_ext_empty_o;

using cells_to_be_broadcast_item_ext_ies_container = protocol_ext_container_empty_l;

// Cells-To-Be-Broadcast-Item ::= SEQUENCE
struct cells_to_be_broadcast_item_s {
  bool                                         ext             = false;
  bool                                         ie_exts_present = false;
  nr_cgi_s                                     nr_cgi;
  cells_to_be_broadcast_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// Cells-To-Be-Broadcast-List-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct cells_to_be_broadcast_list_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { cells_to_be_broadcast_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::cells_to_be_broadcast_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    cells_to_be_broadcast_item_s&       cells_to_be_broadcast_item() { return c; }
    const cells_to_be_broadcast_item_s& cells_to_be_broadcast_item() const { return c; }

  private:
    cells_to_be_broadcast_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// Cells-To-Be-Broadcast-List ::= SEQUENCE (SIZE (1..512)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES :
// IEsSetParam}
using cells_to_be_broadcast_list_l = dyn_array<protocol_ie_single_container_s<cells_to_be_broadcast_list_item_ies_o>>;

// SSB-transmisisonBitmap-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
using ssb_transmisison_bitmap_ext_ies_o = protocol_ies_empty_o;

// IAB-STC-Info-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using iab_stc_info_item_ext_ies_o = protocol_ext_empty_o;

// SSB-subcarrierSpacing ::= ENUMERATED
struct ssb_subcarrier_spacing_opts {
  enum options { khz15, khz30, khz120, khz240, spare3, spare2, spare1, /*...*/ nulltype } value;
  typedef uint8_t number_type;

  const char* to_string() const;
  uint8_t     to_number() const;
};
typedef enumerated<ssb_subcarrier_spacing_opts, true> ssb_subcarrier_spacing_e;

// SSB-transmissionBitmap ::= CHOICE
struct ssb_tx_bitmap_c {
  struct types_opts {
    enum options { short_bitmap, medium_bitmap, long_bitmap, choice_ext, nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  ssb_tx_bitmap_c() = default;
  ssb_tx_bitmap_c(const ssb_tx_bitmap_c& other);
  ssb_tx_bitmap_c& operator=(const ssb_tx_bitmap_c& other);
  ~ssb_tx_bitmap_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  fixed_bitstring<4, false, true>& short_bitmap()
  {
    assert_choice_type(types::short_bitmap, type_, "SSB-transmissionBitmap");
    return c.get<fixed_bitstring<4, false, true>>();
  }
  fixed_bitstring<8, false, true>& medium_bitmap()
  {
    assert_choice_type(types::medium_bitmap, type_, "SSB-transmissionBitmap");
    return c.get<fixed_bitstring<8, false, true>>();
  }
  fixed_bitstring<64, false, true>& long_bitmap()
  {
    assert_choice_type(types::long_bitmap, type_, "SSB-transmissionBitmap");
    return c.get<fixed_bitstring<64, false, true>>();
  }
  protocol_ie_single_container_s<ssb_transmisison_bitmap_ext_ies_o>& choice_ext()
  {
    assert_choice_type(types::choice_ext, type_, "SSB-transmissionBitmap");
    return c.get<protocol_ie_single_container_s<ssb_transmisison_bitmap_ext_ies_o>>();
  }
  const fixed_bitstring<4, false, true>& short_bitmap() const
  {
    assert_choice_type(types::short_bitmap, type_, "SSB-transmissionBitmap");
    return c.get<fixed_bitstring<4, false, true>>();
  }
  const fixed_bitstring<8, false, true>& medium_bitmap() const
  {
    assert_choice_type(types::medium_bitmap, type_, "SSB-transmissionBitmap");
    return c.get<fixed_bitstring<8, false, true>>();
  }
  const fixed_bitstring<64, false, true>& long_bitmap() const
  {
    assert_choice_type(types::long_bitmap, type_, "SSB-transmissionBitmap");
    return c.get<fixed_bitstring<64, false, true>>();
  }
  const protocol_ie_single_container_s<ssb_transmisison_bitmap_ext_ies_o>& choice_ext() const
  {
    assert_choice_type(types::choice_ext, type_, "SSB-transmissionBitmap");
    return c.get<protocol_ie_single_container_s<ssb_transmisison_bitmap_ext_ies_o>>();
  }
  fixed_bitstring<4, false, true>&                                   set_short_bitmap();
  fixed_bitstring<8, false, true>&                                   set_medium_bitmap();
  fixed_bitstring<64, false, true>&                                  set_long_bitmap();
  protocol_ie_single_container_s<ssb_transmisison_bitmap_ext_ies_o>& set_choice_ext();

private:
  types type_;
  choice_buffer_t<fixed_bitstring<64, false, true>, protocol_ie_single_container_s<ssb_transmisison_bitmap_ext_ies_o>>
      c;

  void destroy_();
};

// SSB-transmissionPeriodicity ::= ENUMERATED
struct ssb_tx_periodicity_opts {
  enum options { sf10, sf20, sf40, sf80, sf160, sf320, sf640, /*...*/ nulltype } value;
  typedef uint16_t number_type;

  const char* to_string() const;
  uint16_t    to_number() const;
};
typedef enumerated<ssb_tx_periodicity_opts, true> ssb_tx_periodicity_e;

// AreaScope ::= ENUMERATED
struct area_scope_opts {
  enum options { true_value, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<area_scope_opts, true> area_scope_e;

using iab_stc_info_item_ext_ies_container = protocol_ext_container_empty_l;

// IAB-STC-Info-Item ::= SEQUENCE
struct iab_stc_info_item_s {
  bool                                ie_exts_present = false;
  uint32_t                            ssb_freq_info   = 0;
  ssb_subcarrier_spacing_e            ssb_subcarrier_spacing;
  ssb_tx_periodicity_e                ssb_tx_periodicity;
  uint8_t                             ssb_tx_timing_offset = 0;
  ssb_tx_bitmap_c                     ssb_tx_bitmap;
  iab_stc_info_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// IAB-STC-Info-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using iab_stc_info_ext_ies_o = protocol_ext_empty_o;

// IAB-STC-Info-List ::= SEQUENCE (SIZE (1..45)) OF IAB-STC-Info-Item
using iab_stc_info_list_l = dyn_array<iab_stc_info_item_s>;

// SibtypetobeupdatedListItem-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
struct sibtypetobeupd_list_item_ext_ies_o {
  // Extension ::= OPEN TYPE
  struct ext_c {
    struct types_opts {
      enum options { area_scope, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::area_scope; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    area_scope_e&       area_scope() { return c; }
    const area_scope_e& area_scope() const { return c; }

  private:
    area_scope_e c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static ext_c      get_ext(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// GNB-CUSystemInformation-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
struct gnb_cu_sys_info_ext_ies_o {
  // Extension ::= OPEN TYPE
  struct ext_c {
    struct types_opts {
      enum options { sys_info_area_id, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::sys_info_area_id; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    fixed_bitstring<24, false, true>&       sys_info_area_id() { return c; }
    const fixed_bitstring<24, false, true>& sys_info_area_id() const { return c; }

  private:
    fixed_bitstring<24, false, true> c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static ext_c      get_ext(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// IAB-Info-IAB-donor-CU-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using iab_info_iab_donor_cu_ext_ies_o = protocol_ext_empty_o;

using iab_stc_info_ext_ies_container = protocol_ext_container_empty_l;

// IAB-STC-Info ::= SEQUENCE
struct iab_stc_info_s {
  bool                           ie_exts_present = false;
  iab_stc_info_list_l            iab_stc_info_list;
  iab_stc_info_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SibtypetobeupdatedListItem ::= SEQUENCE
struct sibtypetobeupd_list_item_s {
  bool                                                         ext      = false;
  uint8_t                                                      sib_type = 2;
  unbounded_octstring<true>                                    sib_msg;
  uint8_t                                                      value_tag = 0;
  protocol_ext_container_l<sibtypetobeupd_list_item_ext_ies_o> ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// GNB-CUSystemInformation ::= SEQUENCE
struct gnb_cu_sys_info_s {
  using sibtypetobeupdlist_l_ = dyn_array<sibtypetobeupd_list_item_s>;

  // member variables
  bool                                                ext = false;
  sibtypetobeupdlist_l_                               sibtypetobeupdlist;
  protocol_ext_container_l<gnb_cu_sys_info_ext_ies_o> ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using iab_info_iab_donor_cu_ext_ies_container = protocol_ext_container_empty_l;

// IAB-Info-IAB-donor-CU ::= SEQUENCE
struct iab_info_iab_donor_cu_s {
  bool                                    iab_stc_info_present = false;
  bool                                    ie_exts_present      = false;
  iab_stc_info_s                          iab_stc_info;
  iab_info_iab_donor_cu_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// Cells-to-be-Activated-List-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
struct cells_to_be_activ_list_item_ext_ies_o {
  // Extension ::= OPEN TYPE
  struct ext_c {
    struct types_opts {
      enum options {
        gnb_cu_sys_info,
        available_plmn_list,
        extended_available_plmn_list,
        iab_info_iab_donor_cu,
        available_sn_pn_id_list,
        mbs_broadcast_neighbour_cell_list,
        nulltype
      } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    ext_c() = default;
    ext_c(const ext_c& other);
    ext_c& operator=(const ext_c& other);
    ~ext_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    gnb_cu_sys_info_s&                    gnb_cu_sys_info();
    available_plmn_list_l&                available_plmn_list();
    extended_available_plmn_list_l&       extended_available_plmn_list();
    iab_info_iab_donor_cu_s&              iab_info_iab_donor_cu();
    available_sn_pn_id_list_l&            available_sn_pn_id_list();
    unbounded_octstring<true>&            mbs_broadcast_neighbour_cell_list();
    const gnb_cu_sys_info_s&              gnb_cu_sys_info() const;
    const available_plmn_list_l&          available_plmn_list() const;
    const extended_available_plmn_list_l& extended_available_plmn_list() const;
    const iab_info_iab_donor_cu_s&        iab_info_iab_donor_cu() const;
    const available_sn_pn_id_list_l&      available_sn_pn_id_list() const;
    const unbounded_octstring<true>&      mbs_broadcast_neighbour_cell_list() const;

  private:
    types type_;
    choice_buffer_t<available_plmn_list_l,
                    available_sn_pn_id_list_l,
                    extended_available_plmn_list_l,
                    gnb_cu_sys_info_s,
                    iab_info_iab_donor_cu_s,
                    unbounded_octstring<true>>
        c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static ext_c      get_ext(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

struct cells_to_be_activ_list_item_ext_ies_container {
  template <class extT_>
  using ie_field_s = protocol_ext_container_item_s<extT_>;

  // member variables
  bool                                                                gnb_cu_sys_info_present                   = false;
  bool                                                                available_plmn_list_present               = false;
  bool                                                                extended_available_plmn_list_present      = false;
  bool                                                                iab_info_iab_donor_cu_present             = false;
  bool                                                                available_sn_pn_id_list_present           = false;
  bool                                                                mbs_broadcast_neighbour_cell_list_present = false;
  ie_field_s<gnb_cu_sys_info_s>                                       gnb_cu_sys_info;
  ie_field_s<dyn_seq_of<available_plmn_list_item_s, 1, 6, true>>      available_plmn_list;
  ie_field_s<dyn_seq_of<extended_available_plmn_item_s, 1, 6, true>>  extended_available_plmn_list;
  ie_field_s<iab_info_iab_donor_cu_s>                                 iab_info_iab_donor_cu;
  ie_field_s<dyn_seq_of<available_sn_pn_id_list_item_s, 1, 12, true>> available_sn_pn_id_list;
  ie_field_s<unbounded_octstring<true>>                               mbs_broadcast_neighbour_cell_list;

  // sequence methods
  cells_to_be_activ_list_item_ext_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// Cells-to-be-Activated-List-Item ::= SEQUENCE
struct cells_to_be_activ_list_item_s {
  bool                                          ext             = false;
  bool                                          nr_pci_present  = false;
  bool                                          ie_exts_present = false;
  nr_cgi_s                                      nr_cgi;
  uint16_t                                      nr_pci = 0;
  cells_to_be_activ_list_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// Cells-to-be-Activated-List-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct cells_to_be_activ_list_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { cells_to_be_activ_list_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::cells_to_be_activ_list_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    cells_to_be_activ_list_item_s&       cells_to_be_activ_list_item() { return c; }
    const cells_to_be_activ_list_item_s& cells_to_be_activ_list_item() const { return c; }

  private:
    cells_to_be_activ_list_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// Cells-to-be-Activated-List ::= SEQUENCE (SIZE (1..512)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES :
// IEsSetParam}
using cells_to_be_activ_list_l = dyn_array<protocol_ie_single_container_s<cells_to_be_activ_list_item_ies_o>>;

// IAB-Barred ::= ENUMERATED
struct iab_barred_opts {
  enum options { barred, not_barred, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<iab_barred_opts, true> iab_barred_e;

// CellBarred ::= ENUMERATED
struct cell_barred_opts {
  enum options { barred, not_barred, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<cell_barred_opts, true> cell_barred_e;

// Cells-to-be-Barred-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
struct cells_to_be_barred_item_ext_ies_o {
  // Extension ::= OPEN TYPE
  struct ext_c {
    struct types_opts {
      enum options { iab_barred, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::iab_barred; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    iab_barred_e&       iab_barred() { return c; }
    const iab_barred_e& iab_barred() const { return c; }

  private:
    iab_barred_e c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static ext_c      get_ext(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// Cells-to-be-Barred-Item ::= SEQUENCE
struct cells_to_be_barred_item_s {
  nr_cgi_s                                                    nr_cgi;
  cell_barred_e                                               cell_barred;
  protocol_ext_container_l<cells_to_be_barred_item_ext_ies_o> ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// Cells-to-be-Barred-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct cells_to_be_barred_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { cells_to_be_barred_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::cells_to_be_barred_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    cells_to_be_barred_item_s&       cells_to_be_barred_item() { return c; }
    const cells_to_be_barred_item_s& cells_to_be_barred_item() const { return c; }

  private:
    cells_to_be_barred_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// Cells-to-be-Barred-List ::= SEQUENCE (SIZE (1..512)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES : IEsSetParam}
using cells_to_be_barred_list_l = dyn_array<protocol_ie_single_container_s<cells_to_be_barred_item_ies_o>>;

// Cells-to-be-Deactivated-List-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using cells_to_be_deactiv_list_item_ext_ies_o = protocol_ext_empty_o;

using cells_to_be_deactiv_list_item_ext_ies_container = protocol_ext_container_empty_l;

// Cells-to-be-Deactivated-List-Item ::= SEQUENCE
struct cells_to_be_deactiv_list_item_s {
  bool                                            ext             = false;
  bool                                            ie_exts_present = false;
  nr_cgi_s                                        nr_cgi;
  cells_to_be_deactiv_list_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// Cells-to-be-Deactivated-List-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct cells_to_be_deactiv_list_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { cells_to_be_deactiv_list_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::cells_to_be_deactiv_list_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    cells_to_be_deactiv_list_item_s&       cells_to_be_deactiv_list_item() { return c; }
    const cells_to_be_deactiv_list_item_s& cells_to_be_deactiv_list_item() const { return c; }

  private:
    cells_to_be_deactiv_list_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// Cells-to-be-Deactivated-List ::= SEQUENCE (SIZE (1..512)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES :
// IEsSetParam}
using cells_to_be_deactiv_list_l = dyn_array<protocol_ie_single_container_s<cells_to_be_deactiv_list_item_ies_o>>;

// L1151Info-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using l1151_info_ext_ies_o = protocol_ext_empty_o;

// L571Info-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using l571_info_ext_ies_o = protocol_ext_empty_o;

using l1151_info_ext_ies_container = protocol_ext_container_empty_l;

// L1151Info ::= SEQUENCE
struct l1151_info_s {
  struct prach_scs_for_l1151_opts {
    enum options { scs15, scs120, /*...*/ nulltype } value;
    typedef uint8_t number_type;

    const char* to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<prach_scs_for_l1151_opts, true> prach_scs_for_l1151_e_;

  // member variables
  bool                         ext            = false;
  bool                         ie_ext_present = false;
  prach_scs_for_l1151_e_       prach_scs_for_l1151;
  uint16_t                     root_seq_idx = 0;
  l1151_info_ext_ies_container ie_ext;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// L139Info-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using l139_info_ext_ies_o = protocol_ext_empty_o;

using l571_info_ext_ies_container = protocol_ext_container_empty_l;

// L571Info ::= SEQUENCE
struct l571_info_s {
  struct prach_scs_for_l571_opts {
    enum options { scs30, scs120, /*...*/ scs480, nulltype } value;
    typedef uint16_t number_type;

    const char* to_string() const;
    uint16_t    to_number() const;
  };
  typedef enumerated<prach_scs_for_l571_opts, true, 1> prach_scs_for_l571_e_;

  // member variables
  bool                        ext            = false;
  bool                        ie_ext_present = false;
  prach_scs_for_l571_e_       prach_scs_for_l571;
  uint16_t                    root_seq_idx = 0;
  l571_info_ext_ies_container ie_ext;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// L839Info-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using l839_info_ext_ies_o = protocol_ext_empty_o;

// FreqDomainLength-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct freq_domain_len_ext_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { l571_info, l1151_info, nulltype } value;
      typedef uint16_t number_type;

      const char* to_string() const;
      uint16_t    to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    l571_info_s&        l571_info();
    l1151_info_s&       l1151_info();
    const l571_info_s&  l571_info() const;
    const l1151_info_s& l1151_info() const;

  private:
    types                                      type_;
    choice_buffer_t<l1151_info_s, l571_info_s> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

using l139_info_ext_ies_container = protocol_ext_container_empty_l;

// L139Info ::= SEQUENCE
struct l139_info_s {
  struct prach_scs_opts {
    enum options { scs15, scs30, scs60, scs120, /*...*/ scs480, scs960, nulltype } value;
    typedef uint16_t number_type;

    const char* to_string() const;
    uint16_t    to_number() const;
  };
  typedef enumerated<prach_scs_opts, true, 2> prach_scs_e_;

  // member variables
  bool                        ext                  = false;
  bool                        root_seq_idx_present = false;
  bool                        ie_ext_present       = false;
  prach_scs_e_                prach_scs;
  uint8_t                     root_seq_idx = 0;
  l139_info_ext_ies_container ie_ext;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using l839_info_ext_ies_container = protocol_ext_container_empty_l;

// L839Info ::= SEQUENCE
struct l839_info_s {
  struct restricted_set_cfg_opts {
    enum options { unrestricted_set, restricted_set_type_a, restricted_set_type_b, /*...*/ nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<restricted_set_cfg_opts, true> restricted_set_cfg_e_;

  // member variables
  bool                        ext            = false;
  bool                        ie_ext_present = false;
  uint16_t                    root_seq_idx   = 0;
  restricted_set_cfg_e_       restricted_set_cfg;
  l839_info_ext_ies_container ie_ext;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// FreqDomainLength ::= CHOICE
struct freq_domain_len_c {
  struct types_opts {
    enum options { l839, l139, choice_ext, nulltype } value;
    typedef uint16_t number_type;

    const char* to_string() const;
    uint16_t    to_number() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  freq_domain_len_c() = default;
  freq_domain_len_c(const freq_domain_len_c& other);
  freq_domain_len_c& operator=(const freq_domain_len_c& other);
  ~freq_domain_len_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  l839_info_s& l839()
  {
    assert_choice_type(types::l839, type_, "FreqDomainLength");
    return c.get<l839_info_s>();
  }
  l139_info_s& l139()
  {
    assert_choice_type(types::l139, type_, "FreqDomainLength");
    return c.get<l139_info_s>();
  }
  protocol_ie_single_container_s<freq_domain_len_ext_ies_o>& choice_ext()
  {
    assert_choice_type(types::choice_ext, type_, "FreqDomainLength");
    return c.get<protocol_ie_single_container_s<freq_domain_len_ext_ies_o>>();
  }
  const l839_info_s& l839() const
  {
    assert_choice_type(types::l839, type_, "FreqDomainLength");
    return c.get<l839_info_s>();
  }
  const l139_info_s& l139() const
  {
    assert_choice_type(types::l139, type_, "FreqDomainLength");
    return c.get<l139_info_s>();
  }
  const protocol_ie_single_container_s<freq_domain_len_ext_ies_o>& choice_ext() const
  {
    assert_choice_type(types::choice_ext, type_, "FreqDomainLength");
    return c.get<protocol_ie_single_container_s<freq_domain_len_ext_ies_o>>();
  }
  l839_info_s&                                               set_l839();
  l139_info_s&                                               set_l139();
  protocol_ie_single_container_s<freq_domain_len_ext_ies_o>& set_choice_ext();

private:
  types                                                                                                type_;
  choice_buffer_t<l139_info_s, l839_info_s, protocol_ie_single_container_s<freq_domain_len_ext_ies_o>> c;

  void destroy_();
};

// FreqInfoRel16-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using freq_info_rel16_ext_ies_o = protocol_ext_empty_o;

// NRPRACHConfigItem-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using nr_prach_cfg_item_ext_ies_o = protocol_ext_empty_o;

// FDD-InfoRel16-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using fdd_info_rel16_ext_ies_o = protocol_ext_empty_o;

using freq_info_rel16_ext_ies_container = protocol_ext_container_empty_l;

// FreqInfoRel16 ::= SEQUENCE
struct freq_info_rel16_s {
  bool                              ext                      = false;
  bool                              nr_arfcn_present         = false;
  bool                              freq_shift7p5khz_present = false;
  bool                              ie_exts_present          = false;
  uint32_t                          nr_arfcn                 = 0;
  freq_shift7p5khz_e                freq_shift7p5khz;
  nr_carrier_list_l                 carrier_list;
  freq_info_rel16_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using nr_prach_cfg_item_ext_ies_container = protocol_ext_container_empty_l;

// NRPRACHConfigItem ::= SEQUENCE
struct nr_prach_cfg_item_s {
  struct prach_fdm_opts {
    enum options { one, two, four, eight, /*...*/ nulltype } value;
    typedef uint8_t number_type;

    const char* to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<prach_fdm_opts, true> prach_fdm_e_;
  struct ssb_per_rach_occasion_opts {
    enum options { one_eighth, one_fourth, one_half, one, two, four, eight, sixteen, /*...*/ nulltype } value;
    typedef float number_type;

    const char* to_string() const;
    float       to_number() const;
    const char* to_number_string() const;
  };
  typedef enumerated<ssb_per_rach_occasion_opts, true> ssb_per_rach_occasion_e_;

  // member variables
  bool                                ext            = false;
  bool                                ie_ext_present = false;
  nr_scs_e                            nr_scs;
  uint16_t                            prach_freq_startfrom_carrier = 0;
  prach_fdm_e_                        prach_fdm;
  uint16_t                            prach_cfg_idx = 0;
  ssb_per_rach_occasion_e_            ssb_per_rach_occasion;
  freq_domain_len_c                   freq_domain_len;
  uint8_t                             zero_correl_zone_cfg = 0;
  nr_prach_cfg_item_ext_ies_container ie_ext;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// TDD-InfoRel16-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using tdd_info_rel16_ext_ies_o = protocol_ext_empty_o;

using fdd_info_rel16_ext_ies_container = protocol_ext_container_empty_l;

// FDD-InfoRel16 ::= SEQUENCE
struct fdd_info_rel16_s {
  bool                             ext                   = false;
  bool                             ul_freq_info_present  = false;
  bool                             sul_freq_info_present = false;
  bool                             ie_exts_present       = false;
  freq_info_rel16_s                ul_freq_info;
  freq_info_rel16_s                sul_freq_info;
  fdd_info_rel16_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// NR-ModeInfoRel16-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
using nr_mode_info_rel16_ext_ies_o = protocol_ies_empty_o;

// NRPRACHConfig-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using nr_prach_cfg_ext_ies_o = protocol_ext_empty_o;

// NRPRACHConfigList ::= SEQUENCE (SIZE (0..16)) OF NRPRACHConfigItem
using nr_prach_cfg_list_l = dyn_array<nr_prach_cfg_item_s>;

// SSB-PositionsInBurst-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
using ssb_positions_in_burst_ext_ies_o = protocol_ies_empty_o;

using tdd_info_rel16_ext_ies_container = protocol_ext_container_empty_l;

// TDD-InfoRel16 ::= SEQUENCE
struct tdd_info_rel16_s {
  bool                             ext                   = false;
  bool                             tdd_freq_info_present = false;
  bool                             sul_freq_info_present = false;
  bool                             ie_exts_present       = false;
  freq_info_rel16_s                tdd_freq_info;
  freq_info_rel16_s                sul_freq_info;
  unbounded_octstring<true>        tdd_ul_dl_cfg_common_nr;
  tdd_info_rel16_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// NR-ModeInfoRel16 ::= CHOICE
struct nr_mode_info_rel16_c {
  struct types_opts {
    enum options { fdd, tdd, choice_ext, nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  nr_mode_info_rel16_c() = default;
  nr_mode_info_rel16_c(const nr_mode_info_rel16_c& other);
  nr_mode_info_rel16_c& operator=(const nr_mode_info_rel16_c& other);
  ~nr_mode_info_rel16_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  fdd_info_rel16_s& fdd()
  {
    assert_choice_type(types::fdd, type_, "NR-ModeInfoRel16");
    return c.get<fdd_info_rel16_s>();
  }
  tdd_info_rel16_s& tdd()
  {
    assert_choice_type(types::tdd, type_, "NR-ModeInfoRel16");
    return c.get<tdd_info_rel16_s>();
  }
  protocol_ie_single_container_s<nr_mode_info_rel16_ext_ies_o>& choice_ext()
  {
    assert_choice_type(types::choice_ext, type_, "NR-ModeInfoRel16");
    return c.get<protocol_ie_single_container_s<nr_mode_info_rel16_ext_ies_o>>();
  }
  const fdd_info_rel16_s& fdd() const
  {
    assert_choice_type(types::fdd, type_, "NR-ModeInfoRel16");
    return c.get<fdd_info_rel16_s>();
  }
  const tdd_info_rel16_s& tdd() const
  {
    assert_choice_type(types::tdd, type_, "NR-ModeInfoRel16");
    return c.get<tdd_info_rel16_s>();
  }
  const protocol_ie_single_container_s<nr_mode_info_rel16_ext_ies_o>& choice_ext() const
  {
    assert_choice_type(types::choice_ext, type_, "NR-ModeInfoRel16");
    return c.get<protocol_ie_single_container_s<nr_mode_info_rel16_ext_ies_o>>();
  }
  fdd_info_rel16_s&                                             set_fdd();
  tdd_info_rel16_s&                                             set_tdd();
  protocol_ie_single_container_s<nr_mode_info_rel16_ext_ies_o>& set_choice_ext();

private:
  types type_;
  choice_buffer_t<fdd_info_rel16_s, protocol_ie_single_container_s<nr_mode_info_rel16_ext_ies_o>, tdd_info_rel16_s> c;

  void destroy_();
};

using nr_prach_cfg_ext_ies_container = protocol_ext_container_empty_l;

// NRPRACHConfig ::= SEQUENCE
struct nr_prach_cfg_s {
  bool                           ext                        = false;
  bool                           ul_prach_cfg_list_present  = false;
  bool                           sul_prach_cfg_list_present = false;
  bool                           ie_ext_present             = false;
  nr_prach_cfg_list_l            ul_prach_cfg_list;
  nr_prach_cfg_list_l            sul_prach_cfg_list;
  nr_prach_cfg_ext_ies_container ie_ext;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// NeighbourNR-CellsForSON-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using neighbour_nr_cells_for_son_item_ext_ies_o = protocol_ext_empty_o;

// SSB-PositionsInBurst ::= CHOICE
struct ssb_positions_in_burst_c {
  struct types_opts {
    enum options { short_bitmap, medium_bitmap, long_bitmap, choice_ext, nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  ssb_positions_in_burst_c() = default;
  ssb_positions_in_burst_c(const ssb_positions_in_burst_c& other);
  ssb_positions_in_burst_c& operator=(const ssb_positions_in_burst_c& other);
  ~ssb_positions_in_burst_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  fixed_bitstring<4, false, true>& short_bitmap()
  {
    assert_choice_type(types::short_bitmap, type_, "SSB-PositionsInBurst");
    return c.get<fixed_bitstring<4, false, true>>();
  }
  fixed_bitstring<8, false, true>& medium_bitmap()
  {
    assert_choice_type(types::medium_bitmap, type_, "SSB-PositionsInBurst");
    return c.get<fixed_bitstring<8, false, true>>();
  }
  fixed_bitstring<64, false, true>& long_bitmap()
  {
    assert_choice_type(types::long_bitmap, type_, "SSB-PositionsInBurst");
    return c.get<fixed_bitstring<64, false, true>>();
  }
  protocol_ie_single_container_s<ssb_positions_in_burst_ext_ies_o>& choice_ext()
  {
    assert_choice_type(types::choice_ext, type_, "SSB-PositionsInBurst");
    return c.get<protocol_ie_single_container_s<ssb_positions_in_burst_ext_ies_o>>();
  }
  const fixed_bitstring<4, false, true>& short_bitmap() const
  {
    assert_choice_type(types::short_bitmap, type_, "SSB-PositionsInBurst");
    return c.get<fixed_bitstring<4, false, true>>();
  }
  const fixed_bitstring<8, false, true>& medium_bitmap() const
  {
    assert_choice_type(types::medium_bitmap, type_, "SSB-PositionsInBurst");
    return c.get<fixed_bitstring<8, false, true>>();
  }
  const fixed_bitstring<64, false, true>& long_bitmap() const
  {
    assert_choice_type(types::long_bitmap, type_, "SSB-PositionsInBurst");
    return c.get<fixed_bitstring<64, false, true>>();
  }
  const protocol_ie_single_container_s<ssb_positions_in_burst_ext_ies_o>& choice_ext() const
  {
    assert_choice_type(types::choice_ext, type_, "SSB-PositionsInBurst");
    return c.get<protocol_ie_single_container_s<ssb_positions_in_burst_ext_ies_o>>();
  }
  fixed_bitstring<4, false, true>&                                  set_short_bitmap();
  fixed_bitstring<8, false, true>&                                  set_medium_bitmap();
  fixed_bitstring<64, false, true>&                                 set_long_bitmap();
  protocol_ie_single_container_s<ssb_positions_in_burst_ext_ies_o>& set_choice_ext();

private:
  types type_;
  choice_buffer_t<fixed_bitstring<64, false, true>, protocol_ie_single_container_s<ssb_positions_in_burst_ext_ies_o>> c;

  void destroy_();
};

using neighbour_nr_cells_for_son_item_ext_ies_container = protocol_ext_container_empty_l;

// NeighbourNR-CellsForSON-Item ::= SEQUENCE
struct neighbour_nr_cells_for_son_item_s {
  bool                                              ext                            = false;
  bool                                              nr_mode_info_rel16_present     = false;
  bool                                              ssb_positions_in_burst_present = false;
  bool                                              nr_prach_cfg_present           = false;
  bool                                              ie_exts_present                = false;
  nr_cgi_s                                          nr_cgi;
  nr_mode_info_rel16_c                              nr_mode_info_rel16;
  ssb_positions_in_burst_c                          ssb_positions_in_burst;
  nr_prach_cfg_s                                    nr_prach_cfg;
  neighbour_nr_cells_for_son_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CellsForSON-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using cells_for_son_item_ext_ies_o = protocol_ext_empty_o;

// NeighbourNR-CellsForSON-List ::= SEQUENCE (SIZE (1..32)) OF NeighbourNR-CellsForSON-Item
using neighbour_nr_cells_for_son_list_l = dyn_array<neighbour_nr_cells_for_son_item_s>;

using cells_for_son_item_ext_ies_container = protocol_ext_container_empty_l;

// CellsForSON-Item ::= SEQUENCE
struct cells_for_son_item_s {
  bool                                 ext             = false;
  bool                                 ie_exts_present = false;
  nr_cgi_s                             nr_cgi;
  neighbour_nr_cells_for_son_list_l    neighbour_nr_cells_for_son_list;
  cells_for_son_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CellsForSON-List ::= SEQUENCE (SIZE (1..256)) OF CellsForSON-Item
using cells_for_son_list_l = dyn_array<cells_for_son_item_s>;

// DU-RX-MT-RX-Extend ::= ENUMERATED
struct du_rx_mt_rx_extend_opts {
  enum options { supported, not_supported, supported_and_fdm_required, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<du_rx_mt_rx_extend_opts, true> du_rx_mt_rx_extend_e;

// DU-RX-MT-TX-Extend ::= ENUMERATED
struct du_rx_mt_tx_extend_opts {
  enum options { supported, not_supported, supported_and_fdm_required, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<du_rx_mt_tx_extend_opts, true> du_rx_mt_tx_extend_e;

// DU-TX-MT-RX-Extend ::= ENUMERATED
struct du_tx_mt_rx_extend_opts {
  enum options { supported, not_supported, supported_and_fdm_required, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<du_tx_mt_rx_extend_opts, true> du_tx_mt_rx_extend_e;

// DU-TX-MT-TX-Extend ::= ENUMERATED
struct du_tx_mt_tx_extend_opts {
  enum options { supported, not_supported, supported_and_fdm_required, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<du_tx_mt_tx_extend_opts, true> du_tx_mt_tx_extend_e;

// DU-RX-MT-RX ::= ENUMERATED
struct du_rx_mt_rx_opts {
  enum options { supported, not_supported, nulltype } value;

  const char* to_string() const;
};
typedef enumerated<du_rx_mt_rx_opts> du_rx_mt_rx_e;

// DU-RX-MT-TX ::= ENUMERATED
struct du_rx_mt_tx_opts {
  enum options { supported, not_supported, nulltype } value;

  const char* to_string() const;
};
typedef enumerated<du_rx_mt_tx_opts> du_rx_mt_tx_e;

// DU-TX-MT-RX ::= ENUMERATED
struct du_tx_mt_rx_opts {
  enum options { supported, not_supported, nulltype } value;

  const char* to_string() const;
};
typedef enumerated<du_tx_mt_rx_opts> du_tx_mt_rx_e;

// DU-TX-MT-TX ::= ENUMERATED
struct du_tx_mt_tx_opts {
  enum options { supported, not_supported, nulltype } value;

  const char* to_string() const;
};
typedef enumerated<du_tx_mt_tx_opts> du_tx_mt_tx_e;

// IAB-MT-Cell-List-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
struct iab_mt_cell_list_item_ext_ies_o {
  // Extension ::= OPEN TYPE
  struct ext_c {
    struct types_opts {
      enum options { du_rx_mt_rx_extend, du_tx_mt_tx_extend, du_rx_mt_tx_extend, du_tx_mt_rx_extend, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    ext_c() = default;
    ext_c(const ext_c& other);
    ext_c& operator=(const ext_c& other);
    ~ext_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    du_rx_mt_rx_extend_e&       du_rx_mt_rx_extend();
    du_tx_mt_tx_extend_e&       du_tx_mt_tx_extend();
    du_rx_mt_tx_extend_e&       du_rx_mt_tx_extend();
    du_tx_mt_rx_extend_e&       du_tx_mt_rx_extend();
    const du_rx_mt_rx_extend_e& du_rx_mt_rx_extend() const;
    const du_tx_mt_tx_extend_e& du_tx_mt_tx_extend() const;
    const du_rx_mt_tx_extend_e& du_rx_mt_tx_extend() const;
    const du_tx_mt_rx_extend_e& du_tx_mt_rx_extend() const;

  private:
    types               type_;
    pod_choice_buffer_t c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static ext_c      get_ext(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

struct iab_mt_cell_list_item_ext_ies_container {
  template <class extT_>
  using ie_field_s = protocol_ext_container_item_s<extT_>;

  // member variables
  bool                             du_rx_mt_rx_extend_present = false;
  bool                             du_tx_mt_tx_extend_present = false;
  bool                             du_rx_mt_tx_extend_present = false;
  bool                             du_tx_mt_rx_extend_present = false;
  ie_field_s<du_rx_mt_rx_extend_e> du_rx_mt_rx_extend;
  ie_field_s<du_tx_mt_tx_extend_e> du_tx_mt_tx_extend;
  ie_field_s<du_rx_mt_tx_extend_e> du_rx_mt_tx_extend;
  ie_field_s<du_tx_mt_rx_extend_e> du_tx_mt_rx_extend;

  // sequence methods
  iab_mt_cell_list_item_ext_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// IAB-MT-Cell-List-Item ::= SEQUENCE
struct iab_mt_cell_list_item_s {
  bool                                    ie_exts_present = false;
  fixed_bitstring<36, false, true>        nr_cell_id;
  du_rx_mt_rx_e                           du_rx_mt_rx;
  du_tx_mt_tx_e                           du_tx_mt_tx;
  du_rx_mt_tx_e                           du_rx_mt_tx;
  du_tx_mt_rx_e                           du_tx_mt_rx;
  iab_mt_cell_list_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// IAB-MT-Cell-List ::= SEQUENCE (SIZE (1..32)) OF IAB-MT-Cell-List-Item
using iab_mt_cell_list_l = dyn_array<iab_mt_cell_list_item_s>;

// MultiplexingInfo-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using mux_info_ext_ies_o = protocol_ext_empty_o;

// Child-Node-Cells-List-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using child_node_cells_list_item_ext_ies_o = protocol_ext_empty_o;

using mux_info_ext_ies_container = protocol_ext_container_empty_l;

// MultiplexingInfo ::= SEQUENCE
struct mux_info_s {
  bool                       ie_exts_present = false;
  iab_mt_cell_list_l         iab_mt_cell_list;
  mux_info_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using child_node_cells_list_item_ext_ies_container = protocol_ext_container_empty_l;

// Child-Node-Cells-List-Item ::= SEQUENCE
struct child_node_cells_list_item_s {
  bool                                         iab_du_cell_res_cfg_mode_info_present = false;
  bool                                         iab_stc_info_present                  = false;
  bool                                         mux_info_present                      = false;
  bool                                         ie_exts_present                       = false;
  nr_cgi_s                                     nr_cgi;
  iab_du_cell_res_cfg_mode_info_c              iab_du_cell_res_cfg_mode_info;
  iab_stc_info_s                               iab_stc_info;
  unbounded_octstring<true>                    rach_cfg_common;
  unbounded_octstring<true>                    rach_cfg_common_iab;
  unbounded_octstring<true>                    csi_rs_cfg;
  unbounded_octstring<true>                    sr_cfg;
  unbounded_octstring<true>                    pdcch_cfg_sib1;
  unbounded_octstring<true>                    scs_common;
  mux_info_s                                   mux_info;
  child_node_cells_list_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// Child-Node-Cells-List ::= SEQUENCE (SIZE (1..1024)) OF Child-Node-Cells-List-Item
using child_node_cells_list_l = dyn_array<child_node_cells_list_item_s>;

// Child-Nodes-List-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using child_nodes_list_item_ext_ies_o = protocol_ext_empty_o;

using child_nodes_list_item_ext_ies_container = protocol_ext_container_empty_l;

// Child-Nodes-List-Item ::= SEQUENCE
struct child_nodes_list_item_s {
  bool                                    ie_exts_present   = false;
  uint64_t                                gnb_cu_ue_f1ap_id = 0;
  uint64_t                                gnb_du_ue_f1ap_id = 0;
  child_node_cells_list_l                 child_node_cells_list;
  child_nodes_list_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// Child-Nodes-List ::= SEQUENCE (SIZE (1..1024)) OF Child-Nodes-List-Item
using child_nodes_list_l = dyn_array<child_nodes_list_item_s>;

// TRP-Beam-Power-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using trp_beam_pwr_item_ext_ies_o = protocol_ext_empty_o;

using trp_beam_pwr_item_ext_ies_container = protocol_ext_container_empty_l;

// TRP-Beam-Power-Item ::= SEQUENCE
struct trp_beam_pwr_item_s {
  bool                                ext                       = false;
  bool                                prs_res_set_id_present    = false;
  bool                                relative_pwr_fine_present = false;
  bool                                ie_exts_present           = false;
  uint8_t                             prs_res_set_id            = 0;
  uint8_t                             prs_res_id                = 0;
  uint8_t                             relative_pwr              = 0;
  uint8_t                             relative_pwr_fine         = 0;
  trp_beam_pwr_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// TRP-ElevationAngleList-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using trp_elevation_angle_list_item_ext_ies_o = protocol_ext_empty_o;

// TRP-BeamAntennaAnglesList-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using trp_beam_ant_angles_list_item_ext_ies_o = protocol_ext_empty_o;

using trp_elevation_angle_list_item_ext_ies_container = protocol_ext_container_empty_l;

// TRP-ElevationAngleList-Item ::= SEQUENCE
struct trp_elevation_angle_list_item_s {
  using trp_beam_pwr_list_l_ = dyn_array<trp_beam_pwr_item_s>;

  // member variables
  bool                                            ext                              = false;
  bool                                            trp_elevation_angle_fine_present = false;
  bool                                            ie_exts_present                  = false;
  uint8_t                                         trp_elevation_angle              = 0;
  uint8_t                                         trp_elevation_angle_fine         = 0;
  trp_beam_pwr_list_l_                            trp_beam_pwr_list;
  trp_elevation_angle_list_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using trp_beam_ant_angles_list_item_ext_ies_container = protocol_ext_container_empty_l;

// TRP-BeamAntennaAnglesList-Item ::= SEQUENCE
struct trp_beam_ant_angles_list_item_s {
  using trp_elevation_angle_list_l_ = dyn_array<trp_elevation_angle_list_item_s>;

  // member variables
  bool                                            ext                            = false;
  bool                                            trp_azimuth_angle_fine_present = false;
  bool                                            ie_exts_present                = false;
  uint16_t                                        trp_azimuth_angle              = 0;
  uint8_t                                         trp_azimuth_angle_fine         = 0;
  trp_elevation_angle_list_l_                     trp_elevation_angle_list;
  trp_beam_ant_angles_list_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// TRP-BeamAntennaAngles ::= SEQUENCE (SIZE (1..3600)) OF TRP-BeamAntennaAnglesList-Item
using trp_beam_ant_angles_l = dyn_array<trp_beam_ant_angles_list_item_s>;

// TRP-BeamAntennaExplicitInformation-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using trp_beam_ant_explicit_info_ext_ies_o = protocol_ext_empty_o;

// Choice-TRP-Beam-Info-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
using choice_trp_beam_info_item_ext_ies_o = protocol_ies_empty_o;

using trp_beam_ant_explicit_info_ext_ies_container = protocol_ext_container_empty_l;

// TRP-BeamAntennaExplicitInformation ::= SEQUENCE
struct trp_beam_ant_explicit_info_s {
  bool                                         ext                            = false;
  bool                                         lcs_to_gcs_translation_present = false;
  bool                                         ie_exts_present                = false;
  trp_beam_ant_angles_l                        trp_beam_ant_angles;
  lcs_to_gcs_translation_s                     lcs_to_gcs_translation;
  trp_beam_ant_explicit_info_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// Choice-TRP-Beam-Antenna-Info-Item ::= CHOICE
struct choice_trp_beam_ant_info_item_c {
  struct types_opts {
    enum options { ref, explicit_type, no_change, choice_ext, nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  choice_trp_beam_ant_info_item_c() = default;
  choice_trp_beam_ant_info_item_c(const choice_trp_beam_ant_info_item_c& other);
  choice_trp_beam_ant_info_item_c& operator=(const choice_trp_beam_ant_info_item_c& other);
  ~choice_trp_beam_ant_info_item_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  uint32_t& ref()
  {
    assert_choice_type(types::ref, type_, "Choice-TRP-Beam-Antenna-Info-Item");
    return c.get<uint32_t>();
  }
  trp_beam_ant_explicit_info_s& explicit_type()
  {
    assert_choice_type(types::explicit_type, type_, "Choice-TRP-Beam-Antenna-Info-Item");
    return c.get<trp_beam_ant_explicit_info_s>();
  }
  protocol_ie_single_container_s<choice_trp_beam_info_item_ext_ies_o>& choice_ext()
  {
    assert_choice_type(types::choice_ext, type_, "Choice-TRP-Beam-Antenna-Info-Item");
    return c.get<protocol_ie_single_container_s<choice_trp_beam_info_item_ext_ies_o>>();
  }
  const uint32_t& ref() const
  {
    assert_choice_type(types::ref, type_, "Choice-TRP-Beam-Antenna-Info-Item");
    return c.get<uint32_t>();
  }
  const trp_beam_ant_explicit_info_s& explicit_type() const
  {
    assert_choice_type(types::explicit_type, type_, "Choice-TRP-Beam-Antenna-Info-Item");
    return c.get<trp_beam_ant_explicit_info_s>();
  }
  const protocol_ie_single_container_s<choice_trp_beam_info_item_ext_ies_o>& choice_ext() const
  {
    assert_choice_type(types::choice_ext, type_, "Choice-TRP-Beam-Antenna-Info-Item");
    return c.get<protocol_ie_single_container_s<choice_trp_beam_info_item_ext_ies_o>>();
  }
  uint32_t&                                                            set_ref();
  trp_beam_ant_explicit_info_s&                                        set_explicit_type();
  void                                                                 set_no_change();
  protocol_ie_single_container_s<choice_trp_beam_info_item_ext_ies_o>& set_choice_ext();

private:
  types type_;
  choice_buffer_t<protocol_ie_single_container_s<choice_trp_beam_info_item_ext_ies_o>, trp_beam_ant_explicit_info_s> c;

  void destroy_();
};

// CHOtrigger-InterDU ::= ENUMERATED
struct ch_otrigger_inter_du_opts {
  enum options { cho_initiation, cho_replace, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<ch_otrigger_inter_du_opts, true> ch_otrigger_inter_du_e;

// ConditionalInterDUMobilityInformation-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
struct conditional_inter_du_mob_info_ext_ies_o {
  // Extension ::= OPEN TYPE
  struct ext_c {
    struct types_opts {
      enum options { estimated_arrival_probability, nulltype } value;
      typedef uint8_t number_type;

      const char* to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::estimated_arrival_probability; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint8_t&       estimated_arrival_probability() { return c; }
    const uint8_t& estimated_arrival_probability() const { return c; }

  private:
    uint8_t c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static ext_c      get_ext(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// ConditionalInterDUMobilityInformation ::= SEQUENCE
struct conditional_inter_du_mob_info_s {
  bool                                                              ext                              = false;
  bool                                                              target_gnb_du_ue_f1ap_id_present = false;
  ch_otrigger_inter_du_e                                            cho_trigger;
  uint64_t                                                          target_gnb_du_ue_f1ap_id = 0;
  protocol_ext_container_l<conditional_inter_du_mob_info_ext_ies_o> ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// TargetCellList-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using target_cell_list_item_ext_ies_o = protocol_ext_empty_o;

using target_cell_list_item_ext_ies_container = protocol_ext_container_empty_l;

// TargetCellList-Item ::= SEQUENCE
struct target_cell_list_item_s {
  bool                                    ie_exts_present = false;
  nr_cgi_s                                target_cell;
  target_cell_list_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// CHOtrigger-IntraDU ::= ENUMERATED
struct ch_otrigger_intra_du_opts {
  enum options { cho_initiation, cho_replace, cho_cancel, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<ch_otrigger_intra_du_opts, true> ch_otrigger_intra_du_e;

// ConditionalIntraDUMobilityInformation-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
struct conditional_intra_du_mob_info_ext_ies_o {
  // Extension ::= OPEN TYPE
  struct ext_c {
    struct types_opts {
      enum options { estimated_arrival_probability, nulltype } value;
      typedef uint8_t number_type;

      const char* to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::estimated_arrival_probability; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint8_t&       estimated_arrival_probability() { return c; }
    const uint8_t& estimated_arrival_probability() const { return c; }

  private:
    uint8_t c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static ext_c      get_ext(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// TargetCellList ::= SEQUENCE (SIZE (1..8)) OF TargetCellList-Item
using target_cell_list_l = dyn_array<target_cell_list_item_s>;

// ConditionalIntraDUMobilityInformation ::= SEQUENCE
struct conditional_intra_du_mob_info_s {
  bool                                                              ext = false;
  ch_otrigger_intra_du_e                                            cho_trigger;
  target_cell_list_l                                                target_cells_tocancel;
  protocol_ext_container_l<conditional_intra_du_mob_info_ext_ies_o> ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SSBCoverageModification-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using ssb_coverage_mod_item_ext_ies_o = protocol_ext_empty_o;

using ssb_coverage_mod_item_ext_ies_container = protocol_ext_container_empty_l;

// SSBCoverageModification-Item ::= SEQUENCE
struct ssb_coverage_mod_item_s {
  bool                                    ext                = false;
  bool                                    ie_exts_present    = false;
  uint8_t                                 ssb_idx            = 0;
  uint8_t                                 ssb_coverage_state = 0;
  ssb_coverage_mod_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// Coverage-Modification-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using coverage_mod_item_ext_ies_o = protocol_ext_empty_o;

// SSBCoverageModification-List ::= SEQUENCE (SIZE (1..64)) OF SSBCoverageModification-Item
using ssb_coverage_mod_list_l = dyn_array<ssb_coverage_mod_item_s>;

using coverage_mod_item_ext_ies_container = protocol_ext_container_empty_l;

// Coverage-Modification-Item ::= SEQUENCE
struct coverage_mod_item_s {
  bool                                ext            = false;
  bool                                ie_ext_present = false;
  nr_cgi_s                            nr_cgi;
  uint8_t                             cell_coverage_state = 0;
  ssb_coverage_mod_list_l             ssb_coverage_mod_list;
  coverage_mod_item_ext_ies_container ie_ext;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// Coverage-Modification-List ::= SEQUENCE (SIZE (1..512)) OF Coverage-Modification-Item
using coverage_mod_list_l = dyn_array<coverage_mod_item_s>;

// Coverage-Modification-Notification-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using coverage_mod_notif_ext_ies_o = protocol_ext_empty_o;

using coverage_mod_notif_ext_ies_container = protocol_ext_container_empty_l;

// Coverage-Modification-Notification ::= SEQUENCE
struct coverage_mod_notif_s {
  bool                                 ext             = false;
  bool                                 ie_exts_present = false;
  coverage_mod_list_l                  coverage_mod_list;
  coverage_mod_notif_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// DL-PRS-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using dl_prs_ext_ies_o = protocol_ext_empty_o;

using dl_prs_ext_ies_container = protocol_ext_container_empty_l;

// DL-PRS ::= SEQUENCE
struct dl_prs_s {
  bool                     dl_prs_res_id_present = false;
  bool                     ie_exts_present       = false;
  uint16_t                 prsid                 = 0;
  uint8_t                  dl_prs_res_set_id     = 0;
  uint8_t                  dl_prs_res_id         = 0;
  dl_prs_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// DL-PRSMutingPattern-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
using dl_prs_muting_pattern_ext_ies_o = protocol_ies_empty_o;

// DL-PRSMutingPattern ::= CHOICE
struct dl_prs_muting_pattern_c {
  struct types_opts {
    enum options { two, four, six, eight, sixteen, thirty_two, choice_ext, nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  dl_prs_muting_pattern_c() = default;
  dl_prs_muting_pattern_c(const dl_prs_muting_pattern_c& other);
  dl_prs_muting_pattern_c& operator=(const dl_prs_muting_pattern_c& other);
  ~dl_prs_muting_pattern_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  fixed_bitstring<2, false, true>& two()
  {
    assert_choice_type(types::two, type_, "DL-PRSMutingPattern");
    return c.get<fixed_bitstring<2, false, true>>();
  }
  fixed_bitstring<4, false, true>& four()
  {
    assert_choice_type(types::four, type_, "DL-PRSMutingPattern");
    return c.get<fixed_bitstring<4, false, true>>();
  }
  fixed_bitstring<6, false, true>& six()
  {
    assert_choice_type(types::six, type_, "DL-PRSMutingPattern");
    return c.get<fixed_bitstring<6, false, true>>();
  }
  fixed_bitstring<8, false, true>& eight()
  {
    assert_choice_type(types::eight, type_, "DL-PRSMutingPattern");
    return c.get<fixed_bitstring<8, false, true>>();
  }
  fixed_bitstring<16, false, true>& sixteen()
  {
    assert_choice_type(types::sixteen, type_, "DL-PRSMutingPattern");
    return c.get<fixed_bitstring<16, false, true>>();
  }
  fixed_bitstring<32, false, true>& thirty_two()
  {
    assert_choice_type(types::thirty_two, type_, "DL-PRSMutingPattern");
    return c.get<fixed_bitstring<32, false, true>>();
  }
  protocol_ie_single_container_s<dl_prs_muting_pattern_ext_ies_o>& choice_ext()
  {
    assert_choice_type(types::choice_ext, type_, "DL-PRSMutingPattern");
    return c.get<protocol_ie_single_container_s<dl_prs_muting_pattern_ext_ies_o>>();
  }
  const fixed_bitstring<2, false, true>& two() const
  {
    assert_choice_type(types::two, type_, "DL-PRSMutingPattern");
    return c.get<fixed_bitstring<2, false, true>>();
  }
  const fixed_bitstring<4, false, true>& four() const
  {
    assert_choice_type(types::four, type_, "DL-PRSMutingPattern");
    return c.get<fixed_bitstring<4, false, true>>();
  }
  const fixed_bitstring<6, false, true>& six() const
  {
    assert_choice_type(types::six, type_, "DL-PRSMutingPattern");
    return c.get<fixed_bitstring<6, false, true>>();
  }
  const fixed_bitstring<8, false, true>& eight() const
  {
    assert_choice_type(types::eight, type_, "DL-PRSMutingPattern");
    return c.get<fixed_bitstring<8, false, true>>();
  }
  const fixed_bitstring<16, false, true>& sixteen() const
  {
    assert_choice_type(types::sixteen, type_, "DL-PRSMutingPattern");
    return c.get<fixed_bitstring<16, false, true>>();
  }
  const fixed_bitstring<32, false, true>& thirty_two() const
  {
    assert_choice_type(types::thirty_two, type_, "DL-PRSMutingPattern");
    return c.get<fixed_bitstring<32, false, true>>();
  }
  const protocol_ie_single_container_s<dl_prs_muting_pattern_ext_ies_o>& choice_ext() const
  {
    assert_choice_type(types::choice_ext, type_, "DL-PRSMutingPattern");
    return c.get<protocol_ie_single_container_s<dl_prs_muting_pattern_ext_ies_o>>();
  }
  fixed_bitstring<2, false, true>&                                 set_two();
  fixed_bitstring<4, false, true>&                                 set_four();
  fixed_bitstring<6, false, true>&                                 set_six();
  fixed_bitstring<8, false, true>&                                 set_eight();
  fixed_bitstring<16, false, true>&                                set_sixteen();
  fixed_bitstring<32, false, true>&                                set_thirty_two();
  protocol_ie_single_container_s<dl_prs_muting_pattern_ext_ies_o>& set_choice_ext();

private:
  types type_;
  choice_buffer_t<fixed_bitstring<32, false, true>, protocol_ie_single_container_s<dl_prs_muting_pattern_ext_ies_o>> c;

  void destroy_();
};

// DL-PRSResourceARPLocation-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
using dl_prs_res_arp_location_ext_ies_o = protocol_ies_empty_o;

// DL-PRSResourceARPLocation ::= CHOICE
struct dl_prs_res_arp_location_c {
  struct types_opts {
    enum options { relative_geodetic_location, relative_cartesian_location, choice_ext, nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  dl_prs_res_arp_location_c() = default;
  dl_prs_res_arp_location_c(const dl_prs_res_arp_location_c& other);
  dl_prs_res_arp_location_c& operator=(const dl_prs_res_arp_location_c& other);
  ~dl_prs_res_arp_location_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  relative_geodetic_location_s& relative_geodetic_location()
  {
    assert_choice_type(types::relative_geodetic_location, type_, "DL-PRSResourceARPLocation");
    return c.get<relative_geodetic_location_s>();
  }
  relative_cartesian_location_s& relative_cartesian_location()
  {
    assert_choice_type(types::relative_cartesian_location, type_, "DL-PRSResourceARPLocation");
    return c.get<relative_cartesian_location_s>();
  }
  protocol_ie_single_container_s<dl_prs_res_arp_location_ext_ies_o>& choice_ext()
  {
    assert_choice_type(types::choice_ext, type_, "DL-PRSResourceARPLocation");
    return c.get<protocol_ie_single_container_s<dl_prs_res_arp_location_ext_ies_o>>();
  }
  const relative_geodetic_location_s& relative_geodetic_location() const
  {
    assert_choice_type(types::relative_geodetic_location, type_, "DL-PRSResourceARPLocation");
    return c.get<relative_geodetic_location_s>();
  }
  const relative_cartesian_location_s& relative_cartesian_location() const
  {
    assert_choice_type(types::relative_cartesian_location, type_, "DL-PRSResourceARPLocation");
    return c.get<relative_cartesian_location_s>();
  }
  const protocol_ie_single_container_s<dl_prs_res_arp_location_ext_ies_o>& choice_ext() const
  {
    assert_choice_type(types::choice_ext, type_, "DL-PRSResourceARPLocation");
    return c.get<protocol_ie_single_container_s<dl_prs_res_arp_location_ext_ies_o>>();
  }
  relative_geodetic_location_s&                                      set_relative_geodetic_location();
  relative_cartesian_location_s&                                     set_relative_cartesian_location();
  protocol_ie_single_container_s<dl_prs_res_arp_location_ext_ies_o>& set_choice_ext();

private:
  types type_;
  choice_buffer_t<protocol_ie_single_container_s<dl_prs_res_arp_location_ext_ies_o>,
                  relative_cartesian_location_s,
                  relative_geodetic_location_s>
      c;

  void destroy_();
};

// DL-PRSResourceSetARPLocation-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
using dl_prs_res_set_arp_location_ext_ies_o = protocol_ies_empty_o;

// DL-PRSResourceSetARPLocation ::= CHOICE
struct dl_prs_res_set_arp_location_c {
  struct types_opts {
    enum options { relative_geodetic_location, relative_cartesian_location, choice_ext, nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  dl_prs_res_set_arp_location_c() = default;
  dl_prs_res_set_arp_location_c(const dl_prs_res_set_arp_location_c& other);
  dl_prs_res_set_arp_location_c& operator=(const dl_prs_res_set_arp_location_c& other);
  ~dl_prs_res_set_arp_location_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  relative_geodetic_location_s& relative_geodetic_location()
  {
    assert_choice_type(types::relative_geodetic_location, type_, "DL-PRSResourceSetARPLocation");
    return c.get<relative_geodetic_location_s>();
  }
  relative_cartesian_location_s& relative_cartesian_location()
  {
    assert_choice_type(types::relative_cartesian_location, type_, "DL-PRSResourceSetARPLocation");
    return c.get<relative_cartesian_location_s>();
  }
  protocol_ie_single_container_s<dl_prs_res_set_arp_location_ext_ies_o>& choice_ext()
  {
    assert_choice_type(types::choice_ext, type_, "DL-PRSResourceSetARPLocation");
    return c.get<protocol_ie_single_container_s<dl_prs_res_set_arp_location_ext_ies_o>>();
  }
  const relative_geodetic_location_s& relative_geodetic_location() const
  {
    assert_choice_type(types::relative_geodetic_location, type_, "DL-PRSResourceSetARPLocation");
    return c.get<relative_geodetic_location_s>();
  }
  const relative_cartesian_location_s& relative_cartesian_location() const
  {
    assert_choice_type(types::relative_cartesian_location, type_, "DL-PRSResourceSetARPLocation");
    return c.get<relative_cartesian_location_s>();
  }
  const protocol_ie_single_container_s<dl_prs_res_set_arp_location_ext_ies_o>& choice_ext() const
  {
    assert_choice_type(types::choice_ext, type_, "DL-PRSResourceSetARPLocation");
    return c.get<protocol_ie_single_container_s<dl_prs_res_set_arp_location_ext_ies_o>>();
  }
  relative_geodetic_location_s&                                          set_relative_geodetic_location();
  relative_cartesian_location_s&                                         set_relative_cartesian_location();
  protocol_ie_single_container_s<dl_prs_res_set_arp_location_ext_ies_o>& set_choice_ext();

private:
  types type_;
  choice_buffer_t<protocol_ie_single_container_s<dl_prs_res_set_arp_location_ext_ies_o>,
                  relative_cartesian_location_s,
                  relative_geodetic_location_s>
      c;

  void destroy_();
};

// DL-UP-TNL-Address-to-Update-List-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using dl_up_tnl_address_to_upd_list_item_ext_ies_o = protocol_ext_empty_o;

using dl_up_tnl_address_to_upd_list_item_ext_ies_container = protocol_ext_container_empty_l;

// DL-UP-TNL-Address-to-Update-List-Item ::= SEQUENCE
struct dl_up_tnl_address_to_upd_list_item_s {
  bool                                                 ext             = false;
  bool                                                 ie_exts_present = false;
  bounded_bitstring<1, 160, true, true>                old_ip_adress;
  bounded_bitstring<1, 160, true, true>                new_ip_adress;
  dl_up_tnl_address_to_upd_list_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// DL-UP-TNL-Address-to-Update-List-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct dl_up_tnl_address_to_upd_list_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { dl_up_tnl_address_to_upd_list_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::dl_up_tnl_address_to_upd_list_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    dl_up_tnl_address_to_upd_list_item_s&       dl_up_tnl_address_to_upd_list_item() { return c; }
    const dl_up_tnl_address_to_upd_list_item_s& dl_up_tnl_address_to_upd_list_item() const { return c; }

  private:
    dl_up_tnl_address_to_upd_list_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// DL-UP-TNL-Address-to-Update-List ::= SEQUENCE (SIZE (1..8)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES :
// IEsSetParam}
using dl_up_tnl_address_to_upd_list_l =
    bounded_array<protocol_ie_single_container_s<dl_up_tnl_address_to_upd_list_item_ies_o>, 8>;

// DLPRSResource-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using dl_prs_res_item_ext_ies_o = protocol_ext_empty_o;

// DLPRSResourceARP-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using dl_prs_res_arp_ext_ies_o = protocol_ext_empty_o;

using dl_prs_res_arp_ext_ies_container = protocol_ext_container_empty_l;

// DLPRSResourceARP ::= SEQUENCE
struct dl_prs_res_arp_s {
  bool                             ie_exts_present = false;
  uint8_t                          dl_prs_res_id   = 0;
  dl_prs_res_arp_location_c        dl_prs_res_arp_location;
  dl_prs_res_arp_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// DLPRSResourceSetARP-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using dl_prs_res_set_arp_ext_ies_o = protocol_ext_empty_o;

// DLPRSResourceCoordinates-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using dl_prs_res_coordinates_ext_ies_o = protocol_ext_empty_o;

using dl_prs_res_set_arp_ext_ies_container = protocol_ext_container_empty_l;

// DLPRSResourceSetARP ::= SEQUENCE
struct dl_prs_res_set_arp_s {
  using listof_dl_prs_res_arp_l_ = dyn_array<dl_prs_res_arp_s>;

  // member variables
  bool                                 ie_exts_present   = false;
  uint8_t                              dl_prs_res_set_id = 0;
  dl_prs_res_set_arp_location_c        dl_prs_res_set_arp_location;
  listof_dl_prs_res_arp_l_             listof_dl_prs_res_arp;
  dl_prs_res_set_arp_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using dl_prs_res_coordinates_ext_ies_container = protocol_ext_container_empty_l;

// DLPRSResourceCoordinates ::= SEQUENCE
struct dl_prs_res_coordinates_s {
  using listof_dl_prs_res_set_arp_l_ = dyn_array<dl_prs_res_set_arp_s>;

  // member variables
  bool                                     ie_exts_present = false;
  listof_dl_prs_res_set_arp_l_             listof_dl_prs_res_set_arp;
  dl_prs_res_coordinates_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using dl_prs_res_item_ext_ies_container = protocol_ext_container_empty_l;

// DLPRSResourceID-Item ::= SEQUENCE
struct dl_prs_res_id_item_s {
  bool                              ext             = false;
  bool                              ie_exts_present = false;
  uint8_t                           dl_prs_res_id   = 0;
  dl_prs_res_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RAT-FrequencyPriorityInformation-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
using rat_freq_prio_info_ext_ies_o = protocol_ies_empty_o;

// ExecuteDuplication ::= ENUMERATED
struct execute_dupl_opts {
  enum options { true_value, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<execute_dupl_opts, true> execute_dupl_e;

// RAT-FrequencyPriorityInformation ::= CHOICE
struct rat_freq_prio_info_c {
  struct types_opts {
    enum options { endc, ngran, choice_ext, nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  rat_freq_prio_info_c() = default;
  rat_freq_prio_info_c(const rat_freq_prio_info_c& other);
  rat_freq_prio_info_c& operator=(const rat_freq_prio_info_c& other);
  ~rat_freq_prio_info_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  uint16_t& endc()
  {
    assert_choice_type(types::endc, type_, "RAT-FrequencyPriorityInformation");
    return c.get<uint16_t>();
  }
  uint16_t& ngran()
  {
    assert_choice_type(types::ngran, type_, "RAT-FrequencyPriorityInformation");
    return c.get<uint16_t>();
  }
  protocol_ie_single_container_s<rat_freq_prio_info_ext_ies_o>& choice_ext()
  {
    assert_choice_type(types::choice_ext, type_, "RAT-FrequencyPriorityInformation");
    return c.get<protocol_ie_single_container_s<rat_freq_prio_info_ext_ies_o>>();
  }
  const uint16_t& endc() const
  {
    assert_choice_type(types::endc, type_, "RAT-FrequencyPriorityInformation");
    return c.get<uint16_t>();
  }
  const uint16_t& ngran() const
  {
    assert_choice_type(types::ngran, type_, "RAT-FrequencyPriorityInformation");
    return c.get<uint16_t>();
  }
  const protocol_ie_single_container_s<rat_freq_prio_info_ext_ies_o>& choice_ext() const
  {
    assert_choice_type(types::choice_ext, type_, "RAT-FrequencyPriorityInformation");
    return c.get<protocol_ie_single_container_s<rat_freq_prio_info_ext_ies_o>>();
  }
  uint16_t&                                                     set_endc();
  uint16_t&                                                     set_ngran();
  protocol_ie_single_container_s<rat_freq_prio_info_ext_ies_o>& set_choice_ext();

private:
  types                                                                         type_;
  choice_buffer_t<protocol_ie_single_container_s<rat_freq_prio_info_ext_ies_o>> c;

  void destroy_();
};

// RRCDeliveryStatusRequest ::= ENUMERATED
struct rrc_delivery_status_request_opts {
  enum options { true_value, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<rrc_delivery_status_request_opts, true> rrc_delivery_status_request_e;

// UEContextNotRetrievable ::= ENUMERATED
struct ue_context_not_retrievable_opts {
  enum options { true_value, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<ue_context_not_retrievable_opts, true> ue_context_not_retrievable_e;

// DLRRCMessageTransferIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct dl_rrc_msg_transfer_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options {
        gnb_cu_ue_f1ap_id,
        gnb_du_ue_f1ap_id,
        old_gnb_du_ue_f1ap_id,
        srb_id,
        execute_dupl,
        rrc_container,
        rat_freq_prio_info,
        rrc_delivery_status_request,
        ue_context_not_retrievable,
        redirected_rrc_msg,
        plmn_assist_info_for_net_shar,
        new_gnb_cu_ue_f1ap_id,
        add_rrm_prio_idx,
        srb_map_info,
        nulltype
      } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint64_t&                               gnb_cu_ue_f1ap_id();
    uint64_t&                               gnb_du_ue_f1ap_id();
    uint64_t&                               old_gnb_du_ue_f1ap_id();
    uint8_t&                                srb_id();
    execute_dupl_e&                         execute_dupl();
    unbounded_octstring<true>&              rrc_container();
    rat_freq_prio_info_c&                   rat_freq_prio_info();
    rrc_delivery_status_request_e&          rrc_delivery_status_request();
    ue_context_not_retrievable_e&           ue_context_not_retrievable();
    unbounded_octstring<true>&              redirected_rrc_msg();
    fixed_octstring<3, true>&               plmn_assist_info_for_net_shar();
    uint64_t&                               new_gnb_cu_ue_f1ap_id();
    fixed_bitstring<32, false, true>&       add_rrm_prio_idx();
    fixed_bitstring<16, false, true>&       srb_map_info();
    const uint64_t&                         gnb_cu_ue_f1ap_id() const;
    const uint64_t&                         gnb_du_ue_f1ap_id() const;
    const uint64_t&                         old_gnb_du_ue_f1ap_id() const;
    const uint8_t&                          srb_id() const;
    const execute_dupl_e&                   execute_dupl() const;
    const unbounded_octstring<true>&        rrc_container() const;
    const rat_freq_prio_info_c&             rat_freq_prio_info() const;
    const rrc_delivery_status_request_e&    rrc_delivery_status_request() const;
    const ue_context_not_retrievable_e&     ue_context_not_retrievable() const;
    const unbounded_octstring<true>&        redirected_rrc_msg() const;
    const fixed_octstring<3, true>&         plmn_assist_info_for_net_shar() const;
    const uint64_t&                         new_gnb_cu_ue_f1ap_id() const;
    const fixed_bitstring<32, false, true>& add_rrm_prio_idx() const;
    const fixed_bitstring<16, false, true>& srb_map_info() const;

  private:
    types type_;
    choice_buffer_t<fixed_bitstring<32, false, true>,
                    fixed_octstring<3, true>,
                    rat_freq_prio_info_c,
                    unbounded_octstring<true>>
        c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

struct dl_rrc_msg_transfer_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                                      old_gnb_du_ue_f1ap_id_present         = false;
  bool                                                      execute_dupl_present                  = false;
  bool                                                      rat_freq_prio_info_present            = false;
  bool                                                      rrc_delivery_status_request_present   = false;
  bool                                                      ue_context_not_retrievable_present    = false;
  bool                                                      redirected_rrc_msg_present            = false;
  bool                                                      plmn_assist_info_for_net_shar_present = false;
  bool                                                      new_gnb_cu_ue_f1ap_id_present         = false;
  bool                                                      add_rrm_prio_idx_present              = false;
  bool                                                      srb_map_info_present                  = false;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_cu_ue_f1ap_id;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_du_ue_f1ap_id;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> old_gnb_du_ue_f1ap_id;
  ie_field_s<integer<uint8_t, 0, 3, true, true>>            srb_id;
  ie_field_s<execute_dupl_e>                                execute_dupl;
  ie_field_s<unbounded_octstring<true>>                     rrc_container;
  ie_field_s<rat_freq_prio_info_c>                          rat_freq_prio_info;
  ie_field_s<rrc_delivery_status_request_e>                 rrc_delivery_status_request;
  ie_field_s<ue_context_not_retrievable_e>                  ue_context_not_retrievable;
  ie_field_s<unbounded_octstring<true>>                     redirected_rrc_msg;
  ie_field_s<fixed_octstring<3, true>>                      plmn_assist_info_for_net_shar;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> new_gnb_cu_ue_f1ap_id;
  ie_field_s<fixed_bitstring<32, false, true>>              add_rrm_prio_idx;
  ie_field_s<fixed_bitstring<16, false, true>>              srb_map_info;

  // sequence methods
  dl_rrc_msg_transfer_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// DLRRCMessageTransfer ::= SEQUENCE
using dl_rrc_msg_transfer_s = elementary_procedure_option<dl_rrc_msg_transfer_ies_container>;

// DLUPTNLInformation-ToBeSetup-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using dl_up_tnl_info_to_be_setup_item_ext_ies_o = protocol_ext_empty_o;

using dl_up_tnl_info_to_be_setup_item_ext_ies_container = protocol_ext_container_empty_l;

// DLUPTNLInformation-ToBeSetup-Item ::= SEQUENCE
struct dl_up_tnl_info_to_be_setup_item_s {
  bool                                              ext             = false;
  bool                                              ie_exts_present = false;
  up_transport_layer_info_c                         dl_up_tnl_info;
  dl_up_tnl_info_to_be_setup_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// DLUPTNLInformation-ToBeSetup-List ::= SEQUENCE (SIZE (1..2)) OF DLUPTNLInformation-ToBeSetup-Item
using dl_up_tnl_info_to_be_setup_list_l = dyn_array<dl_up_tnl_info_to_be_setup_item_s>;

// DRB-Activity ::= ENUMERATED
struct drb_activity_opts {
  enum options { active, not_active, nulltype } value;

  const char* to_string() const;
};
typedef enumerated<drb_activity_opts> drb_activity_e;

// DRB-Activity-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using drb_activity_item_ext_ies_o = protocol_ext_empty_o;

using drb_activity_item_ext_ies_container = protocol_ext_container_empty_l;

// DRB-Activity-Item ::= SEQUENCE
struct drb_activity_item_s {
  bool                                ext                  = false;
  bool                                drb_activity_present = false;
  bool                                ie_exts_present      = false;
  uint8_t                             drb_id               = 1;
  drb_activity_e                      drb_activity;
  drb_activity_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// DRB-Activity-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct drb_activity_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { drb_activity_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::drb_activity_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    drb_activity_item_s&       drb_activity_item() { return c; }
    const drb_activity_item_s& drb_activity_item() const { return c; }

  private:
    drb_activity_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// DRB-Activity-List ::= SEQUENCE (SIZE (1..64)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES : IEsSetParam}
using drb_activity_list_l = dyn_array<protocol_ie_single_container_s<drb_activity_item_ies_o>>;

// TSCAssistanceInformation-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
struct tsc_assist_info_ext_ies_o {
  // Extension ::= OPEN TYPE
  struct ext_c {
    struct types_opts {
      enum options { survival_time, nulltype } value;
      typedef uint8_t number_type;

      const char* to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::survival_time; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint32_t&       survival_time() { return c; }
    const uint32_t& survival_time() const { return c; }

  private:
    uint32_t c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static ext_c      get_ext(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// TSCAssistanceInformation ::= SEQUENCE
struct tsc_assist_info_s {
  bool                                                ext         = false;
  uint32_t                                            periodicity = 0;
  unbounded_octstring<true>                           burst_arrival_time;
  protocol_ext_container_l<tsc_assist_info_ext_ies_o> ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// TSCTrafficCharacteristics-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using tsc_traffic_characteristics_ext_ies_o = protocol_ext_empty_o;

// QoSFlowMappingIndication ::= ENUMERATED
struct qos_flow_map_ind_opts {
  enum options { ul, dl, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<qos_flow_map_ind_opts, true> qos_flow_map_ind_e;

using tsc_traffic_characteristics_ext_ies_container = protocol_ext_container_empty_l;

// TSCTrafficCharacteristics ::= SEQUENCE
struct tsc_traffic_characteristics_s {
  bool                                          ext                        = false;
  bool                                          tsc_assist_info_dl_present = false;
  bool                                          tsc_assist_info_ul_present = false;
  bool                                          ie_exts_present            = false;
  tsc_assist_info_s                             tsc_assist_info_dl;
  tsc_assist_info_s                             tsc_assist_info_ul;
  tsc_traffic_characteristics_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// Flows-Mapped-To-DRB-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
struct flows_mapped_to_drb_item_ext_ies_o {
  // Extension ::= OPEN TYPE
  struct ext_c {
    struct types_opts {
      enum options { qos_flow_map_ind, tsc_traffic_characteristics, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    ext_c() = default;
    ext_c(const ext_c& other);
    ext_c& operator=(const ext_c& other);
    ~ext_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    qos_flow_map_ind_e&                  qos_flow_map_ind();
    tsc_traffic_characteristics_s&       tsc_traffic_characteristics();
    const qos_flow_map_ind_e&            qos_flow_map_ind() const;
    const tsc_traffic_characteristics_s& tsc_traffic_characteristics() const;

  private:
    types                                          type_;
    choice_buffer_t<tsc_traffic_characteristics_s> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static ext_c      get_ext(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

struct flows_mapped_to_drb_item_ext_ies_container {
  template <class extT_>
  using ie_field_s = protocol_ext_container_item_s<extT_>;

  // member variables
  bool                                      qos_flow_map_ind_present            = false;
  bool                                      tsc_traffic_characteristics_present = false;
  ie_field_s<qos_flow_map_ind_e>            qos_flow_map_ind;
  ie_field_s<tsc_traffic_characteristics_s> tsc_traffic_characteristics;

  // sequence methods
  flows_mapped_to_drb_item_ext_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// Flows-Mapped-To-DRB-Item ::= SEQUENCE
struct flows_mapped_to_drb_item_s {
  bool                                       ie_exts_present = false;
  uint8_t                                    qos_flow_id     = 0;
  qos_flow_level_qos_params_s                qos_flow_level_qos_params;
  flows_mapped_to_drb_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// DRB-Information-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using drb_info_item_ext_ies_o = protocol_ext_empty_o;

// Flows-Mapped-To-DRB-List ::= SEQUENCE (SIZE (1..64)) OF Flows-Mapped-To-DRB-Item
using flows_mapped_to_drb_list_l = dyn_array<flows_mapped_to_drb_item_s>;

// NotificationControl ::= ENUMERATED
struct notif_ctrl_opts {
  enum options { active, not_active, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<notif_ctrl_opts, true> notif_ctrl_e;

using drb_info_item_ext_ies_container = protocol_ext_container_empty_l;

// DRB-Information ::= SEQUENCE
struct drb_info_s {
  bool                            notif_ctrl_present = false;
  bool                            ie_exts_present    = false;
  qos_flow_level_qos_params_s     drb_qos;
  snssai_s                        snssai;
  notif_ctrl_e                    notif_ctrl;
  flows_mapped_to_drb_list_l      flows_mapped_to_drb_list;
  drb_info_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// DRB-Notify-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
struct drb_notify_item_ext_ies_o {
  // Extension ::= OPEN TYPE
  struct ext_c {
    struct types_opts {
      enum options { current_qos_para_set_idx, nulltype } value;
      typedef uint8_t number_type;

      const char* to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::current_qos_para_set_idx; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint8_t&       current_qos_para_set_idx() { return c; }
    const uint8_t& current_qos_para_set_idx() const { return c; }

  private:
    uint8_t c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static ext_c      get_ext(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// Notification-Cause ::= ENUMERATED
struct notif_cause_opts {
  enum options { fulfilled, not_fulfilled, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<notif_cause_opts, true> notif_cause_e;

// DRB-Notify-Item ::= SEQUENCE
struct drb_notify_item_s {
  bool                                                ext    = false;
  uint8_t                                             drb_id = 1;
  notif_cause_e                                       notif_cause;
  protocol_ext_container_l<drb_notify_item_ext_ies_o> ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// DRB-Notify-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct drb_notify_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { drb_notify_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::drb_notify_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    drb_notify_item_s&       drb_notify_item() { return c; }
    const drb_notify_item_s& drb_notify_item() const { return c; }

  private:
    drb_notify_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// DRB-Notify-List ::= SEQUENCE (SIZE (1..64)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES : IEsSetParam}
using drb_notify_list_l = dyn_array<protocol_ie_single_container_s<drb_notify_item_ies_o>>;

// DRBs-FailedToBeModified-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using drbs_failed_to_be_modified_item_ext_ies_o = protocol_ext_empty_o;

using drbs_failed_to_be_modified_item_ext_ies_container = protocol_ext_container_empty_l;

// DRBs-FailedToBeModified-Item ::= SEQUENCE
struct drbs_failed_to_be_modified_item_s {
  bool                                              ext             = false;
  bool                                              cause_present   = false;
  bool                                              ie_exts_present = false;
  uint8_t                                           drb_id          = 1;
  cause_c                                           cause;
  drbs_failed_to_be_modified_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// DRBs-FailedToBeModified-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct drbs_failed_to_be_modified_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { drbs_failed_to_be_modified_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::drbs_failed_to_be_modified_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    drbs_failed_to_be_modified_item_s&       drbs_failed_to_be_modified_item() { return c; }
    const drbs_failed_to_be_modified_item_s& drbs_failed_to_be_modified_item() const { return c; }

  private:
    drbs_failed_to_be_modified_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// DRBs-FailedToBeModified-List ::= SEQUENCE (SIZE (1..64)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES :
// IEsSetParam}
using drbs_failed_to_be_modified_list_l =
    dyn_array<protocol_ie_single_container_s<drbs_failed_to_be_modified_item_ies_o>>;

// DRBs-FailedToBeSetup-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using drbs_failed_to_be_setup_item_ext_ies_o = protocol_ext_empty_o;

using drbs_failed_to_be_setup_item_ext_ies_container = protocol_ext_container_empty_l;

// DRBs-FailedToBeSetup-Item ::= SEQUENCE
struct drbs_failed_to_be_setup_item_s {
  bool                                           ext             = false;
  bool                                           cause_present   = false;
  bool                                           ie_exts_present = false;
  uint8_t                                        drb_id          = 1;
  cause_c                                        cause;
  drbs_failed_to_be_setup_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// DRBs-FailedToBeSetup-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct drbs_failed_to_be_setup_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { drbs_failed_to_be_setup_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::drbs_failed_to_be_setup_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    drbs_failed_to_be_setup_item_s&       drbs_failed_to_be_setup_item() { return c; }
    const drbs_failed_to_be_setup_item_s& drbs_failed_to_be_setup_item() const { return c; }

  private:
    drbs_failed_to_be_setup_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// DRBs-FailedToBeSetup-List ::= SEQUENCE (SIZE (1..64)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES : IEsSetParam}
using drbs_failed_to_be_setup_list_l = dyn_array<protocol_ie_single_container_s<drbs_failed_to_be_setup_item_ies_o>>;

// DRBs-FailedToBeSetupMod-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using drbs_failed_to_be_setup_mod_item_ext_ies_o = protocol_ext_empty_o;

using drbs_failed_to_be_setup_mod_item_ext_ies_container = protocol_ext_container_empty_l;

// DRBs-FailedToBeSetupMod-Item ::= SEQUENCE
struct drbs_failed_to_be_setup_mod_item_s {
  bool                                               ext             = false;
  bool                                               cause_present   = false;
  bool                                               ie_exts_present = false;
  uint8_t                                            drb_id          = 1;
  cause_c                                            cause;
  drbs_failed_to_be_setup_mod_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// DRBs-FailedToBeSetupMod-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct drbs_failed_to_be_setup_mod_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { drbs_failed_to_be_setup_mod_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::drbs_failed_to_be_setup_mod_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    drbs_failed_to_be_setup_mod_item_s&       drbs_failed_to_be_setup_mod_item() { return c; }
    const drbs_failed_to_be_setup_mod_item_s& drbs_failed_to_be_setup_mod_item() const { return c; }

  private:
    drbs_failed_to_be_setup_mod_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// DRBs-FailedToBeSetupMod-List ::= SEQUENCE (SIZE (1..64)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES :
// IEsSetParam}
using drbs_failed_to_be_setup_mod_list_l =
    dyn_array<protocol_ie_single_container_s<drbs_failed_to_be_setup_mod_item_ies_o>>;

// RLC-Status-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using rlc_status_ext_ies_o = protocol_ext_empty_o;

// Reestablishment-Indication ::= ENUMERATED
struct reest_ind_opts {
  enum options { reestablished, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<reest_ind_opts, true> reest_ind_e;

using rlc_status_ext_ies_container = protocol_ext_container_empty_l;

// RLC-Status ::= SEQUENCE
struct rlc_status_s {
  bool                         ext             = false;
  bool                         ie_exts_present = false;
  reest_ind_e                  reest_ind;
  rlc_status_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// DRBs-Modified-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
struct drbs_modified_item_ext_ies_o {
  // Extension ::= OPEN TYPE
  struct ext_c {
    struct types_opts {
      enum options { rlc_status, add_pdcp_dupl_tnl_list, current_qos_para_set_idx, nulltype } value;
      typedef uint8_t number_type;

      const char* to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    ext_c() = default;
    ext_c(const ext_c& other);
    ext_c& operator=(const ext_c& other);
    ~ext_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    rlc_status_s&                   rlc_status();
    add_pdcp_dupl_tnl_list_l&       add_pdcp_dupl_tnl_list();
    uint8_t&                        current_qos_para_set_idx();
    const rlc_status_s&             rlc_status() const;
    const add_pdcp_dupl_tnl_list_l& add_pdcp_dupl_tnl_list() const;
    const uint8_t&                  current_qos_para_set_idx() const;

  private:
    types                                                   type_;
    choice_buffer_t<add_pdcp_dupl_tnl_list_l, rlc_status_s> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static ext_c      get_ext(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

struct drbs_modified_item_ext_ies_container {
  template <class extT_>
  using ie_field_s = protocol_ext_container_item_s<extT_>;

  // member variables
  bool                                                         rlc_status_present               = false;
  bool                                                         add_pdcp_dupl_tnl_list_present   = false;
  bool                                                         current_qos_para_set_idx_present = false;
  ie_field_s<rlc_status_s>                                     rlc_status;
  ie_field_s<dyn_seq_of<add_pdcp_dupl_tnl_item_s, 1, 2, true>> add_pdcp_dupl_tnl_list;
  ie_field_s<integer<uint8_t, 1, 8, true, true>>               current_qos_para_set_idx;

  // sequence methods
  drbs_modified_item_ext_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// DRBs-Modified-Item ::= SEQUENCE
struct drbs_modified_item_s {
  bool                                 ext             = false;
  bool                                 lcid_present    = false;
  bool                                 ie_exts_present = false;
  uint8_t                              drb_id          = 1;
  uint8_t                              lcid            = 1;
  dl_up_tnl_info_to_be_setup_list_l    dl_up_tnl_info_to_be_setup_list;
  drbs_modified_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// DRBs-Modified-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct drbs_modified_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { drbs_modified_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::drbs_modified_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    drbs_modified_item_s&       drbs_modified_item() { return c; }
    const drbs_modified_item_s& drbs_modified_item() const { return c; }

  private:
    drbs_modified_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// DRBs-Modified-List ::= SEQUENCE (SIZE (1..64)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES : IEsSetParam}
using drbs_modified_list_l = dyn_array<protocol_ie_single_container_s<drbs_modified_item_ies_o>>;

// ULUPTNLInformation-ToBeSetup-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
struct ul_up_tnl_info_to_be_setup_item_ext_ies_o {
  // Extension ::= OPEN TYPE
  struct ext_c {
    struct types_opts {
      enum options { bh_info, drb_map_info, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    ext_c() = default;
    ext_c(const ext_c& other);
    ext_c& operator=(const ext_c& other);
    ~ext_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    bh_info_s&                              bh_info();
    fixed_bitstring<16, false, true>&       drb_map_info();
    const bh_info_s&                        bh_info() const;
    const fixed_bitstring<16, false, true>& drb_map_info() const;

  private:
    types                                                        type_;
    choice_buffer_t<bh_info_s, fixed_bitstring<16, false, true>> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static ext_c      get_ext(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

struct ul_up_tnl_info_to_be_setup_item_ext_ies_container {
  template <class extT_>
  using ie_field_s = protocol_ext_container_item_s<extT_>;

  // member variables
  bool                                         bh_info_present      = false;
  bool                                         drb_map_info_present = false;
  ie_field_s<bh_info_s>                        bh_info;
  ie_field_s<fixed_bitstring<16, false, true>> drb_map_info;

  // sequence methods
  ul_up_tnl_info_to_be_setup_item_ext_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// ULUPTNLInformation-ToBeSetup-Item ::= SEQUENCE
struct ul_up_tnl_info_to_be_setup_item_s {
  bool                                              ext             = false;
  bool                                              ie_exts_present = false;
  up_transport_layer_info_c                         ul_up_tnl_info;
  ul_up_tnl_info_to_be_setup_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// DRBs-ModifiedConf-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
struct drbs_modified_conf_item_ext_ies_o {
  // Extension ::= OPEN TYPE
  struct ext_c {
    struct types_opts {
      enum options { add_pdcp_dupl_tnl_list, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::add_pdcp_dupl_tnl_list; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    add_pdcp_dupl_tnl_list_l&       add_pdcp_dupl_tnl_list() { return c; }
    const add_pdcp_dupl_tnl_list_l& add_pdcp_dupl_tnl_list() const { return c; }

  private:
    add_pdcp_dupl_tnl_list_l c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static ext_c      get_ext(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// ULUPTNLInformation-ToBeSetup-List ::= SEQUENCE (SIZE (1..2)) OF ULUPTNLInformation-ToBeSetup-Item
using ul_up_tnl_info_to_be_setup_list_l = dyn_array<ul_up_tnl_info_to_be_setup_item_s>;

// DRBs-ModifiedConf-Item ::= SEQUENCE
struct drbs_modified_conf_item_s {
  bool                                                        ext    = false;
  uint8_t                                                     drb_id = 1;
  ul_up_tnl_info_to_be_setup_list_l                           ul_up_tnl_info_to_be_setup_list;
  protocol_ext_container_l<drbs_modified_conf_item_ext_ies_o> ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// DRBs-ModifiedConf-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct drbs_modified_conf_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { drbs_modified_conf_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::drbs_modified_conf_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    drbs_modified_conf_item_s&       drbs_modified_conf_item() { return c; }
    const drbs_modified_conf_item_s& drbs_modified_conf_item() const { return c; }

  private:
    drbs_modified_conf_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// DRBs-ModifiedConf-List ::= SEQUENCE (SIZE (1..64)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES : IEsSetParam}
using drbs_modified_conf_list_l = dyn_array<protocol_ie_single_container_s<drbs_modified_conf_item_ies_o>>;

// DRBs-Required-ToBeModified-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
struct drbs_required_to_be_modified_item_ext_ies_o {
  // Extension ::= OPEN TYPE
  struct ext_c {
    struct types_opts {
      enum options { rlc_status, add_pdcp_dupl_tnl_list, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    ext_c() = default;
    ext_c(const ext_c& other);
    ext_c& operator=(const ext_c& other);
    ~ext_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    rlc_status_s&                   rlc_status();
    add_pdcp_dupl_tnl_list_l&       add_pdcp_dupl_tnl_list();
    const rlc_status_s&             rlc_status() const;
    const add_pdcp_dupl_tnl_list_l& add_pdcp_dupl_tnl_list() const;

  private:
    types                                                   type_;
    choice_buffer_t<add_pdcp_dupl_tnl_list_l, rlc_status_s> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static ext_c      get_ext(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

struct drbs_required_to_be_modified_item_ext_ies_container {
  template <class extT_>
  using ie_field_s = protocol_ext_container_item_s<extT_>;

  // member variables
  bool                                                         rlc_status_present             = false;
  bool                                                         add_pdcp_dupl_tnl_list_present = false;
  ie_field_s<rlc_status_s>                                     rlc_status;
  ie_field_s<dyn_seq_of<add_pdcp_dupl_tnl_item_s, 1, 2, true>> add_pdcp_dupl_tnl_list;

  // sequence methods
  drbs_required_to_be_modified_item_ext_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// DRBs-Required-ToBeModified-Item ::= SEQUENCE
struct drbs_required_to_be_modified_item_s {
  bool                                                ext             = false;
  bool                                                ie_exts_present = false;
  uint8_t                                             drb_id          = 1;
  dl_up_tnl_info_to_be_setup_list_l                   dl_up_tnl_info_to_be_setup_list;
  drbs_required_to_be_modified_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// DRBs-Required-ToBeModified-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct drbs_required_to_be_modified_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { drbs_required_to_be_modified_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::drbs_required_to_be_modified_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    drbs_required_to_be_modified_item_s&       drbs_required_to_be_modified_item() { return c; }
    const drbs_required_to_be_modified_item_s& drbs_required_to_be_modified_item() const { return c; }

  private:
    drbs_required_to_be_modified_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// DRBs-Required-ToBeModified-List ::= SEQUENCE (SIZE (1..64)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES :
// IEsSetParam}
using drbs_required_to_be_modified_list_l =
    dyn_array<protocol_ie_single_container_s<drbs_required_to_be_modified_item_ies_o>>;

// DRBs-Required-ToBeReleased-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using drbs_required_to_be_released_item_ext_ies_o = protocol_ext_empty_o;

using drbs_required_to_be_released_item_ext_ies_container = protocol_ext_container_empty_l;

// DRBs-Required-ToBeReleased-Item ::= SEQUENCE
struct drbs_required_to_be_released_item_s {
  bool                                                ext             = false;
  bool                                                ie_exts_present = false;
  uint8_t                                             drb_id          = 1;
  drbs_required_to_be_released_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// DRBs-Required-ToBeReleased-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct drbs_required_to_be_released_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { drbs_required_to_be_released_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::drbs_required_to_be_released_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    drbs_required_to_be_released_item_s&       drbs_required_to_be_released_item() { return c; }
    const drbs_required_to_be_released_item_s& drbs_required_to_be_released_item() const { return c; }

  private:
    drbs_required_to_be_released_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// DRBs-Required-ToBeReleased-List ::= SEQUENCE (SIZE (1..64)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES :
// IEsSetParam}
using drbs_required_to_be_released_list_l =
    dyn_array<protocol_ie_single_container_s<drbs_required_to_be_released_item_ies_o>>;

// DRBs-Setup-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
struct drbs_setup_item_ext_ies_o {
  // Extension ::= OPEN TYPE
  struct ext_c {
    struct types_opts {
      enum options { add_pdcp_dupl_tnl_list, current_qos_para_set_idx, nulltype } value;
      typedef uint8_t number_type;

      const char* to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    ext_c() = default;
    ext_c(const ext_c& other);
    ext_c& operator=(const ext_c& other);
    ~ext_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    add_pdcp_dupl_tnl_list_l&       add_pdcp_dupl_tnl_list();
    uint8_t&                        current_qos_para_set_idx();
    const add_pdcp_dupl_tnl_list_l& add_pdcp_dupl_tnl_list() const;
    const uint8_t&                  current_qos_para_set_idx() const;

  private:
    types                                     type_;
    choice_buffer_t<add_pdcp_dupl_tnl_list_l> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static ext_c      get_ext(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

struct drbs_setup_item_ext_ies_container {
  template <class extT_>
  using ie_field_s = protocol_ext_container_item_s<extT_>;

  // member variables
  bool                                                         add_pdcp_dupl_tnl_list_present   = false;
  bool                                                         current_qos_para_set_idx_present = false;
  ie_field_s<dyn_seq_of<add_pdcp_dupl_tnl_item_s, 1, 2, true>> add_pdcp_dupl_tnl_list;
  ie_field_s<integer<uint8_t, 1, 8, true, true>>               current_qos_para_set_idx;

  // sequence methods
  drbs_setup_item_ext_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// DRBs-Setup-Item ::= SEQUENCE
struct drbs_setup_item_s {
  bool                              ext             = false;
  bool                              lcid_present    = false;
  bool                              ie_exts_present = false;
  uint8_t                           drb_id          = 1;
  uint8_t                           lcid            = 1;
  dl_up_tnl_info_to_be_setup_list_l dl_up_tnl_info_to_be_setup_list;
  drbs_setup_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// DRBs-Setup-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct drbs_setup_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { drbs_setup_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::drbs_setup_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    drbs_setup_item_s&       drbs_setup_item() { return c; }
    const drbs_setup_item_s& drbs_setup_item() const { return c; }

  private:
    drbs_setup_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// DRBs-Setup-List ::= SEQUENCE (SIZE (1..64)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES : IEsSetParam}
using drbs_setup_list_l = dyn_array<protocol_ie_single_container_s<drbs_setup_item_ies_o>>;

// DRBs-SetupMod-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
struct drbs_setup_mod_item_ext_ies_o {
  // Extension ::= OPEN TYPE
  struct ext_c {
    struct types_opts {
      enum options { add_pdcp_dupl_tnl_list, current_qos_para_set_idx, nulltype } value;
      typedef uint8_t number_type;

      const char* to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    ext_c() = default;
    ext_c(const ext_c& other);
    ext_c& operator=(const ext_c& other);
    ~ext_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    add_pdcp_dupl_tnl_list_l&       add_pdcp_dupl_tnl_list();
    uint8_t&                        current_qos_para_set_idx();
    const add_pdcp_dupl_tnl_list_l& add_pdcp_dupl_tnl_list() const;
    const uint8_t&                  current_qos_para_set_idx() const;

  private:
    types                                     type_;
    choice_buffer_t<add_pdcp_dupl_tnl_list_l> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static ext_c      get_ext(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

struct drbs_setup_mod_item_ext_ies_container {
  template <class extT_>
  using ie_field_s = protocol_ext_container_item_s<extT_>;

  // member variables
  bool                                                         add_pdcp_dupl_tnl_list_present   = false;
  bool                                                         current_qos_para_set_idx_present = false;
  ie_field_s<dyn_seq_of<add_pdcp_dupl_tnl_item_s, 1, 2, true>> add_pdcp_dupl_tnl_list;
  ie_field_s<integer<uint8_t, 1, 8, true, true>>               current_qos_para_set_idx;

  // sequence methods
  drbs_setup_mod_item_ext_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// DRBs-SetupMod-Item ::= SEQUENCE
struct drbs_setup_mod_item_s {
  bool                                  ext             = false;
  bool                                  lcid_present    = false;
  bool                                  ie_exts_present = false;
  uint8_t                               drb_id          = 1;
  uint8_t                               lcid            = 1;
  dl_up_tnl_info_to_be_setup_list_l     dl_up_tnl_info_to_be_setup_list;
  drbs_setup_mod_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// DRBs-SetupMod-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct drbs_setup_mod_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { drbs_setup_mod_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::drbs_setup_mod_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    drbs_setup_mod_item_s&       drbs_setup_mod_item() { return c; }
    const drbs_setup_mod_item_s& drbs_setup_mod_item() const { return c; }

  private:
    drbs_setup_mod_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// DRBs-SetupMod-List ::= SEQUENCE (SIZE (1..64)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES : IEsSetParam}
using drbs_setup_mod_list_l = dyn_array<protocol_ie_single_container_s<drbs_setup_mod_item_ies_o>>;

// DuplicationState ::= ENUMERATED
struct dupl_state_opts {
  enum options { active, inactive, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<dupl_state_opts, true> dupl_state_e;

// RLCDuplicationState-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using rlc_dupl_state_item_ext_ies_o = protocol_ext_empty_o;

using rlc_dupl_state_item_ext_ies_container = protocol_ext_container_empty_l;

// RLCDuplicationState-Item ::= SEQUENCE
struct rlc_dupl_state_item_s {
  bool                                  ext             = false;
  bool                                  ie_exts_present = false;
  dupl_state_e                          dupl_state;
  rlc_dupl_state_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PrimaryPathIndication ::= ENUMERATED
struct primary_path_ind_opts {
  enum options { true_value, false_value, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<primary_path_ind_opts, true> primary_path_ind_e;

// RLCDuplicationInformation-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using rlc_dupl_info_ext_ies_o = protocol_ext_empty_o;

// RLCDuplicationStateList ::= SEQUENCE (SIZE (1..3)) OF RLCDuplicationState-Item
using rlc_dupl_state_list_l = dyn_array<rlc_dupl_state_item_s>;

// BearerTypeChange ::= ENUMERATED
struct bearer_type_change_opts {
  enum options { true_value, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<bearer_type_change_opts, true> bearer_type_change_e;

// CG-SDTindicatorMod ::= ENUMERATED
struct cg_sd_tind_mod_opts {
  enum options { true_value, false_value, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<cg_sd_tind_mod_opts, true> cg_sd_tind_mod_e;

// DCBasedDuplicationConfigured ::= ENUMERATED
struct dc_based_dupl_cfg_opts {
  enum options { true_value, /*...*/ false_value, nulltype } value;

  const char* to_string() const;
};
typedef enumerated<dc_based_dupl_cfg_opts, true, 1> dc_based_dupl_cfg_e;

// DuplicationActivation ::= ENUMERATED
struct dupl_activation_opts {
  enum options { active, inactive, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<dupl_activation_opts, true> dupl_activation_e;

// PDCPSNLength ::= ENUMERATED
struct pdcp_sn_len_opts {
  enum options { twelve_bits, eighteen_bits, /*...*/ nulltype } value;
  typedef uint8_t number_type;

  const char* to_string() const;
  uint8_t     to_number() const;
};
typedef enumerated<pdcp_sn_len_opts, true> pdcp_sn_len_e;

// QoSInformation-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct qos_info_ext_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { drb_info, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::drb_info; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    drb_info_s&       drb_info() { return c; }
    const drb_info_s& drb_info() const { return c; }

  private:
    drb_info_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

using rlc_dupl_info_ext_ies_container = protocol_ext_container_empty_l;

// RLCDuplicationInformation ::= SEQUENCE
struct rlc_dupl_info_s {
  bool                            primary_path_ind_present = false;
  bool                            ie_exts_present          = false;
  rlc_dupl_state_list_l           rlc_dupl_state_list;
  primary_path_ind_e              primary_path_ind;
  rlc_dupl_info_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// TransmissionStopIndicator ::= ENUMERATED
struct tx_stop_ind_opts {
  enum options { true_value, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<tx_stop_ind_opts, true> tx_stop_ind_e;

// ULConfigurationExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using ul_cfg_ext_ies_o = protocol_ext_empty_o;

// ULUEConfiguration ::= ENUMERATED
struct ul_ue_cfg_opts {
  enum options { no_data, shared, only, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<ul_ue_cfg_opts, true> ul_ue_cfg_e;

// DRBs-ToBeModified-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
struct drbs_to_be_modified_item_ext_ies_o {
  // Extension ::= OPEN TYPE
  struct ext_c {
    struct types_opts {
      enum options {
        dl_pdcp_sn_len,
        ul_pdcp_sn_len,
        bearer_type_change,
        rlc_mode,
        dupl_activation,
        dc_based_dupl_cfg,
        dc_based_dupl_activation,
        add_pdcp_dupl_tnl_list,
        rlc_dupl_info,
        tx_stop_ind,
        cg_sd_tind_mod,
        nulltype
      } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    ext_c() = default;
    ext_c(const ext_c& other);
    ext_c& operator=(const ext_c& other);
    ~ext_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    pdcp_sn_len_e&                  dl_pdcp_sn_len();
    pdcp_sn_len_e&                  ul_pdcp_sn_len();
    bearer_type_change_e&           bearer_type_change();
    rlc_mode_e&                     rlc_mode();
    dupl_activation_e&              dupl_activation();
    dc_based_dupl_cfg_e&            dc_based_dupl_cfg();
    dupl_activation_e&              dc_based_dupl_activation();
    add_pdcp_dupl_tnl_list_l&       add_pdcp_dupl_tnl_list();
    rlc_dupl_info_s&                rlc_dupl_info();
    tx_stop_ind_e&                  tx_stop_ind();
    cg_sd_tind_mod_e&               cg_sd_tind_mod();
    const pdcp_sn_len_e&            dl_pdcp_sn_len() const;
    const pdcp_sn_len_e&            ul_pdcp_sn_len() const;
    const bearer_type_change_e&     bearer_type_change() const;
    const rlc_mode_e&               rlc_mode() const;
    const dupl_activation_e&        dupl_activation() const;
    const dc_based_dupl_cfg_e&      dc_based_dupl_cfg() const;
    const dupl_activation_e&        dc_based_dupl_activation() const;
    const add_pdcp_dupl_tnl_list_l& add_pdcp_dupl_tnl_list() const;
    const rlc_dupl_info_s&          rlc_dupl_info() const;
    const tx_stop_ind_e&            tx_stop_ind() const;
    const cg_sd_tind_mod_e&         cg_sd_tind_mod() const;

  private:
    types                                                      type_;
    choice_buffer_t<add_pdcp_dupl_tnl_list_l, rlc_dupl_info_s> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static ext_c      get_ext(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// QoSInformation ::= CHOICE
struct qos_info_c {
  struct types_opts {
    enum options { eutran_qos, choice_ext, nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  qos_info_c() = default;
  qos_info_c(const qos_info_c& other);
  qos_info_c& operator=(const qos_info_c& other);
  ~qos_info_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  eutran_qos_s& eutran_qos()
  {
    assert_choice_type(types::eutran_qos, type_, "QoSInformation");
    return c.get<eutran_qos_s>();
  }
  protocol_ie_single_container_s<qos_info_ext_ies_o>& choice_ext()
  {
    assert_choice_type(types::choice_ext, type_, "QoSInformation");
    return c.get<protocol_ie_single_container_s<qos_info_ext_ies_o>>();
  }
  const eutran_qos_s& eutran_qos() const
  {
    assert_choice_type(types::eutran_qos, type_, "QoSInformation");
    return c.get<eutran_qos_s>();
  }
  const protocol_ie_single_container_s<qos_info_ext_ies_o>& choice_ext() const
  {
    assert_choice_type(types::choice_ext, type_, "QoSInformation");
    return c.get<protocol_ie_single_container_s<qos_info_ext_ies_o>>();
  }
  eutran_qos_s&                                       set_eutran_qos();
  protocol_ie_single_container_s<qos_info_ext_ies_o>& set_choice_ext();

private:
  types                                                                             type_;
  choice_buffer_t<eutran_qos_s, protocol_ie_single_container_s<qos_info_ext_ies_o>> c;

  void destroy_();
};

using ul_cfg_ext_ies_container = protocol_ext_container_empty_l;

// ULConfiguration ::= SEQUENCE
struct ul_cfg_s {
  bool                     ext             = false;
  bool                     ie_exts_present = false;
  ul_ue_cfg_e              ul_ue_cfg;
  ul_cfg_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

struct drbs_to_be_modified_item_ext_ies_container {
  template <class extT_>
  using ie_field_s = protocol_ext_container_item_s<extT_>;

  // member variables
  bool                                                         dl_pdcp_sn_len_present           = false;
  bool                                                         ul_pdcp_sn_len_present           = false;
  bool                                                         bearer_type_change_present       = false;
  bool                                                         rlc_mode_present                 = false;
  bool                                                         dupl_activation_present          = false;
  bool                                                         dc_based_dupl_cfg_present        = false;
  bool                                                         dc_based_dupl_activation_present = false;
  bool                                                         add_pdcp_dupl_tnl_list_present   = false;
  bool                                                         rlc_dupl_info_present            = false;
  bool                                                         tx_stop_ind_present              = false;
  bool                                                         cg_sd_tind_mod_present           = false;
  ie_field_s<pdcp_sn_len_e>                                    dl_pdcp_sn_len;
  ie_field_s<pdcp_sn_len_e>                                    ul_pdcp_sn_len;
  ie_field_s<bearer_type_change_e>                             bearer_type_change;
  ie_field_s<rlc_mode_e>                                       rlc_mode;
  ie_field_s<dupl_activation_e>                                dupl_activation;
  ie_field_s<dc_based_dupl_cfg_e>                              dc_based_dupl_cfg;
  ie_field_s<dupl_activation_e>                                dc_based_dupl_activation;
  ie_field_s<dyn_seq_of<add_pdcp_dupl_tnl_item_s, 1, 2, true>> add_pdcp_dupl_tnl_list;
  ie_field_s<rlc_dupl_info_s>                                  rlc_dupl_info;
  ie_field_s<tx_stop_ind_e>                                    tx_stop_ind;
  ie_field_s<cg_sd_tind_mod_e>                                 cg_sd_tind_mod;

  // sequence methods
  drbs_to_be_modified_item_ext_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// DRBs-ToBeModified-Item ::= SEQUENCE
struct drbs_to_be_modified_item_s {
  bool                                       ext              = false;
  bool                                       qos_info_present = false;
  bool                                       ul_cfg_present   = false;
  bool                                       ie_exts_present  = false;
  uint8_t                                    drb_id           = 1;
  qos_info_c                                 qos_info;
  ul_up_tnl_info_to_be_setup_list_l          ul_up_tnl_info_to_be_setup_list;
  ul_cfg_s                                   ul_cfg;
  drbs_to_be_modified_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// DRBs-ToBeModified-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct drbs_to_be_modified_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { drbs_to_be_modified_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::drbs_to_be_modified_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    drbs_to_be_modified_item_s&       drbs_to_be_modified_item() { return c; }
    const drbs_to_be_modified_item_s& drbs_to_be_modified_item() const { return c; }

  private:
    drbs_to_be_modified_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// DRBs-ToBeModified-List ::= SEQUENCE (SIZE (1..64)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES : IEsSetParam}
using drbs_to_be_modified_list_l = dyn_array<protocol_ie_single_container_s<drbs_to_be_modified_item_ies_o>>;

// DRBs-ToBeReleased-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using drbs_to_be_released_item_ext_ies_o = protocol_ext_empty_o;

using drbs_to_be_released_item_ext_ies_container = protocol_ext_container_empty_l;

// DRBs-ToBeReleased-Item ::= SEQUENCE
struct drbs_to_be_released_item_s {
  bool                                       ext             = false;
  bool                                       ie_exts_present = false;
  uint8_t                                    drb_id          = 1;
  drbs_to_be_released_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// DRBs-ToBeReleased-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct drbs_to_be_released_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { drbs_to_be_released_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::drbs_to_be_released_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    drbs_to_be_released_item_s&       drbs_to_be_released_item() { return c; }
    const drbs_to_be_released_item_s& drbs_to_be_released_item() const { return c; }

  private:
    drbs_to_be_released_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// DRBs-ToBeReleased-List ::= SEQUENCE (SIZE (1..64)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES : IEsSetParam}
using drbs_to_be_released_list_l = dyn_array<protocol_ie_single_container_s<drbs_to_be_released_item_ies_o>>;

// DRBs-ToBeSetup-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
struct drbs_to_be_setup_item_ext_ies_o {
  // Extension ::= OPEN TYPE
  struct ext_c {
    struct types_opts {
      enum options {
        dc_based_dupl_cfg,
        dc_based_dupl_activation,
        dl_pdcp_sn_len,
        ul_pdcp_sn_len,
        add_pdcp_dupl_tnl_list,
        rlc_dupl_info,
        sdt_rlc_bearer_cfg,
        nulltype
      } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    ext_c() = default;
    ext_c(const ext_c& other);
    ext_c& operator=(const ext_c& other);
    ~ext_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    dc_based_dupl_cfg_e&             dc_based_dupl_cfg();
    dupl_activation_e&               dc_based_dupl_activation();
    pdcp_sn_len_e&                   dl_pdcp_sn_len();
    pdcp_sn_len_e&                   ul_pdcp_sn_len();
    add_pdcp_dupl_tnl_list_l&        add_pdcp_dupl_tnl_list();
    rlc_dupl_info_s&                 rlc_dupl_info();
    unbounded_octstring<true>&       sdt_rlc_bearer_cfg();
    const dc_based_dupl_cfg_e&       dc_based_dupl_cfg() const;
    const dupl_activation_e&         dc_based_dupl_activation() const;
    const pdcp_sn_len_e&             dl_pdcp_sn_len() const;
    const pdcp_sn_len_e&             ul_pdcp_sn_len() const;
    const add_pdcp_dupl_tnl_list_l&  add_pdcp_dupl_tnl_list() const;
    const rlc_dupl_info_s&           rlc_dupl_info() const;
    const unbounded_octstring<true>& sdt_rlc_bearer_cfg() const;

  private:
    types                                                                                 type_;
    choice_buffer_t<add_pdcp_dupl_tnl_list_l, rlc_dupl_info_s, unbounded_octstring<true>> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static ext_c      get_ext(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

struct drbs_to_be_setup_item_ext_ies_container {
  template <class extT_>
  using ie_field_s = protocol_ext_container_item_s<extT_>;

  // member variables
  bool                                                         dc_based_dupl_cfg_present        = false;
  bool                                                         dc_based_dupl_activation_present = false;
  bool                                                         ul_pdcp_sn_len_present           = false;
  bool                                                         add_pdcp_dupl_tnl_list_present   = false;
  bool                                                         rlc_dupl_info_present            = false;
  bool                                                         sdt_rlc_bearer_cfg_present       = false;
  ie_field_s<dc_based_dupl_cfg_e>                              dc_based_dupl_cfg;
  ie_field_s<dupl_activation_e>                                dc_based_dupl_activation;
  ie_field_s<pdcp_sn_len_e>                                    dl_pdcp_sn_len;
  ie_field_s<pdcp_sn_len_e>                                    ul_pdcp_sn_len;
  ie_field_s<dyn_seq_of<add_pdcp_dupl_tnl_item_s, 1, 2, true>> add_pdcp_dupl_tnl_list;
  ie_field_s<rlc_dupl_info_s>                                  rlc_dupl_info;
  ie_field_s<unbounded_octstring<true>>                        sdt_rlc_bearer_cfg;

  // sequence methods
  drbs_to_be_setup_item_ext_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// DRBs-ToBeSetup-Item ::= SEQUENCE
struct drbs_to_be_setup_item_s {
  bool                                    ext                     = false;
  bool                                    ul_cfg_present          = false;
  bool                                    dupl_activation_present = false;
  bool                                    ie_exts_present         = false;
  uint8_t                                 drb_id                  = 1;
  qos_info_c                              qos_info;
  ul_up_tnl_info_to_be_setup_list_l       ul_up_tnl_info_to_be_setup_list;
  rlc_mode_e                              rlc_mode;
  ul_cfg_s                                ul_cfg;
  dupl_activation_e                       dupl_activation;
  drbs_to_be_setup_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// DRBs-ToBeSetup-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct drbs_to_be_setup_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { drbs_to_be_setup_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::drbs_to_be_setup_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    drbs_to_be_setup_item_s&       drbs_to_be_setup_item() { return c; }
    const drbs_to_be_setup_item_s& drbs_to_be_setup_item() const { return c; }

  private:
    drbs_to_be_setup_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// DRBs-ToBeSetup-List ::= SEQUENCE (SIZE (1..64)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES : IEsSetParam}
using drbs_to_be_setup_list_l = dyn_array<protocol_ie_single_container_s<drbs_to_be_setup_item_ies_o>>;

// CG-SDTindicatorSetup ::= ENUMERATED
struct cg_sd_tind_setup_opts {
  enum options { true_value, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<cg_sd_tind_setup_opts, true> cg_sd_tind_setup_e;

// DRBs-ToBeSetupMod-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
struct drbs_to_be_setup_mod_item_ext_ies_o {
  // Extension ::= OPEN TYPE
  struct ext_c {
    struct types_opts {
      enum options {
        dc_based_dupl_cfg,
        dc_based_dupl_activation,
        dl_pdcp_sn_len,
        ul_pdcp_sn_len,
        add_pdcp_dupl_tnl_list,
        rlc_dupl_info,
        cg_sd_tind_setup,
        nulltype
      } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    ext_c() = default;
    ext_c(const ext_c& other);
    ext_c& operator=(const ext_c& other);
    ~ext_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    dc_based_dupl_cfg_e&            dc_based_dupl_cfg();
    dupl_activation_e&              dc_based_dupl_activation();
    pdcp_sn_len_e&                  dl_pdcp_sn_len();
    pdcp_sn_len_e&                  ul_pdcp_sn_len();
    add_pdcp_dupl_tnl_list_l&       add_pdcp_dupl_tnl_list();
    rlc_dupl_info_s&                rlc_dupl_info();
    cg_sd_tind_setup_e&             cg_sd_tind_setup();
    const dc_based_dupl_cfg_e&      dc_based_dupl_cfg() const;
    const dupl_activation_e&        dc_based_dupl_activation() const;
    const pdcp_sn_len_e&            dl_pdcp_sn_len() const;
    const pdcp_sn_len_e&            ul_pdcp_sn_len() const;
    const add_pdcp_dupl_tnl_list_l& add_pdcp_dupl_tnl_list() const;
    const rlc_dupl_info_s&          rlc_dupl_info() const;
    const cg_sd_tind_setup_e&       cg_sd_tind_setup() const;

  private:
    types                                                      type_;
    choice_buffer_t<add_pdcp_dupl_tnl_list_l, rlc_dupl_info_s> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static ext_c      get_ext(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

struct drbs_to_be_setup_mod_item_ext_ies_container {
  template <class extT_>
  using ie_field_s = protocol_ext_container_item_s<extT_>;

  // member variables
  bool                                                         dc_based_dupl_cfg_present        = false;
  bool                                                         dc_based_dupl_activation_present = false;
  bool                                                         dl_pdcp_sn_len_present           = false;
  bool                                                         ul_pdcp_sn_len_present           = false;
  bool                                                         add_pdcp_dupl_tnl_list_present   = false;
  bool                                                         rlc_dupl_info_present            = false;
  bool                                                         cg_sd_tind_setup_present         = false;
  ie_field_s<dc_based_dupl_cfg_e>                              dc_based_dupl_cfg;
  ie_field_s<dupl_activation_e>                                dc_based_dupl_activation;
  ie_field_s<pdcp_sn_len_e>                                    dl_pdcp_sn_len;
  ie_field_s<pdcp_sn_len_e>                                    ul_pdcp_sn_len;
  ie_field_s<dyn_seq_of<add_pdcp_dupl_tnl_item_s, 1, 2, true>> add_pdcp_dupl_tnl_list;
  ie_field_s<rlc_dupl_info_s>                                  rlc_dupl_info;
  ie_field_s<cg_sd_tind_setup_e>                               cg_sd_tind_setup;

  // sequence methods
  drbs_to_be_setup_mod_item_ext_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// DRBs-ToBeSetupMod-Item ::= SEQUENCE
struct drbs_to_be_setup_mod_item_s {
  bool                                        ext                     = false;
  bool                                        ul_cfg_present          = false;
  bool                                        dupl_activation_present = false;
  bool                                        ie_exts_present         = false;
  uint8_t                                     drb_id                  = 1;
  qos_info_c                                  qos_info;
  ul_up_tnl_info_to_be_setup_list_l           ul_up_tnl_info_to_be_setup_list;
  rlc_mode_e                                  rlc_mode;
  ul_cfg_s                                    ul_cfg;
  dupl_activation_e                           dupl_activation;
  drbs_to_be_setup_mod_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// DRBs-ToBeSetupMod-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct drbs_to_be_setup_mod_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { drbs_to_be_setup_mod_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::drbs_to_be_setup_mod_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    drbs_to_be_setup_mod_item_s&       drbs_to_be_setup_mod_item() { return c; }
    const drbs_to_be_setup_mod_item_s& drbs_to_be_setup_mod_item() const { return c; }

  private:
    drbs_to_be_setup_mod_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// DRBs-ToBeSetupMod-List ::= SEQUENCE (SIZE (1..64)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES : IEsSetParam}
using drbs_to_be_setup_mod_list_l = dyn_array<protocol_ie_single_container_s<drbs_to_be_setup_mod_item_ies_o>>;

// DRXCycle-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using drx_cycle_ext_ies_o = protocol_ext_empty_o;

// LongDRXCycleLength ::= ENUMERATED
struct long_drx_cycle_len_opts {
  enum options {
    ms10,
    ms20,
    ms32,
    ms40,
    ms60,
    ms64,
    ms70,
    ms80,
    ms128,
    ms160,
    ms256,
    ms320,
    ms512,
    ms640,
    ms1024,
    ms1280,
    ms2048,
    ms2560,
    ms5120,
    ms10240,
    // ...
    nulltype
  } value;
  typedef uint16_t number_type;

  const char* to_string() const;
  uint16_t    to_number() const;
};
typedef enumerated<long_drx_cycle_len_opts, true> long_drx_cycle_len_e;

// ShortDRXCycleLength ::= ENUMERATED
struct short_drx_cycle_len_opts {
  enum options {
    ms2,
    ms3,
    ms4,
    ms5,
    ms6,
    ms7,
    ms8,
    ms10,
    ms14,
    ms16,
    ms20,
    ms30,
    ms32,
    ms35,
    ms40,
    ms64,
    ms80,
    ms128,
    ms160,
    ms256,
    ms320,
    ms512,
    ms640,
    // ...
    nulltype
  } value;
  typedef uint16_t number_type;

  const char* to_string() const;
  uint16_t    to_number() const;
};
typedef enumerated<short_drx_cycle_len_opts, true> short_drx_cycle_len_e;

using drx_cycle_ext_ies_container = protocol_ext_container_empty_l;

// DRXCycle ::= SEQUENCE
struct drx_cycle_s {
  bool                        ext                           = false;
  bool                        short_drx_cycle_len_present   = false;
  bool                        short_drx_cycle_timer_present = false;
  bool                        ie_exts_present               = false;
  long_drx_cycle_len_e        long_drx_cycle_len;
  short_drx_cycle_len_e       short_drx_cycle_len;
  uint8_t                     short_drx_cycle_timer = 1;
  drx_cycle_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// DUCURIMInformation-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using du_cu_rim_info_ext_ies_o = protocol_ext_empty_o;

using du_cu_rim_info_ext_ies_container = protocol_ext_container_empty_l;

// DUCURIMInformation ::= SEQUENCE
struct du_cu_rim_info_s {
  bool                             ie_exts_present = false;
  fixed_bitstring<22, false, true> victim_gnb_set_id;
  rimrs_detection_status_e         rimrs_detection_status;
  aggressor_cell_list_l            aggressor_cell_list;
  du_cu_rim_info_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// DUCURadioInformationType-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
using du_cu_radio_info_type_ext_ies_o = protocol_ies_empty_o;

// DUCURadioInformationType ::= CHOICE
struct du_cu_radio_info_type_c {
  struct types_opts {
    enum options { rim, choice_ext, nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  du_cu_radio_info_type_c() = default;
  du_cu_radio_info_type_c(const du_cu_radio_info_type_c& other);
  du_cu_radio_info_type_c& operator=(const du_cu_radio_info_type_c& other);
  ~du_cu_radio_info_type_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  du_cu_rim_info_s& rim()
  {
    assert_choice_type(types::rim, type_, "DUCURadioInformationType");
    return c.get<du_cu_rim_info_s>();
  }
  protocol_ie_single_container_s<du_cu_radio_info_type_ext_ies_o>& choice_ext()
  {
    assert_choice_type(types::choice_ext, type_, "DUCURadioInformationType");
    return c.get<protocol_ie_single_container_s<du_cu_radio_info_type_ext_ies_o>>();
  }
  const du_cu_rim_info_s& rim() const
  {
    assert_choice_type(types::rim, type_, "DUCURadioInformationType");
    return c.get<du_cu_rim_info_s>();
  }
  const protocol_ie_single_container_s<du_cu_radio_info_type_ext_ies_o>& choice_ext() const
  {
    assert_choice_type(types::choice_ext, type_, "DUCURadioInformationType");
    return c.get<protocol_ie_single_container_s<du_cu_radio_info_type_ext_ies_o>>();
  }
  du_cu_rim_info_s&                                                set_rim();
  protocol_ie_single_container_s<du_cu_radio_info_type_ext_ies_o>& set_choice_ext();

private:
  types                                                                                              type_;
  choice_buffer_t<du_cu_rim_info_s, protocol_ie_single_container_s<du_cu_radio_info_type_ext_ies_o>> c;

  void destroy_();
};

// DUCURadioInformationTransferIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct du_cu_radio_info_transfer_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { transaction_id, du_cu_radio_info_type, nulltype } value;
      typedef uint8_t number_type;

      const char* to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint16_t&                      transaction_id();
    du_cu_radio_info_type_c&       du_cu_radio_info_type();
    const uint16_t&                transaction_id() const;
    const du_cu_radio_info_type_c& du_cu_radio_info_type() const;

  private:
    types                                    type_;
    choice_buffer_t<du_cu_radio_info_type_c> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

struct du_cu_radio_info_transfer_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  ie_field_s<integer<uint16_t, 0, 255, true, true>> transaction_id;
  ie_field_s<du_cu_radio_info_type_c>               du_cu_radio_info_type;

  // sequence methods
  du_cu_radio_info_transfer_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// DUCURadioInformationTransfer ::= SEQUENCE
using du_cu_radio_info_transfer_s = elementary_procedure_option<du_cu_radio_info_transfer_ies_container>;

// InterFrequencyConfig-NoGap ::= ENUMERATED
struct interfreq_cfg_no_gap_opts {
  enum options { true_value, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<interfreq_cfg_no_gap_opts, true> interfreq_cfg_no_gap_e;

// TwoPHRModeMCG ::= ENUMERATED
struct two_phr_mode_mcg_opts {
  enum options { enabled, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<two_phr_mode_mcg_opts, true> two_phr_mode_mcg_e;

// TwoPHRModeSCG ::= ENUMERATED
struct two_phr_mode_scg_opts {
  enum options { enabled, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<two_phr_mode_scg_opts, true> two_phr_mode_scg_e;

// DUtoCURRCInformation-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
struct du_to_cu_rrc_info_ext_ies_o {
  // Extension ::= OPEN TYPE
  struct ext_c {
    struct types_opts {
      enum options {
        drx_long_cycle_start_offset,
        sel_band_combination_idx,
        sel_feature_set_entry_idx,
        ph_info_scg,
        requested_band_combination_idx,
        requested_feature_set_entry_idx,
        drx_cfg,
        pdcch_blind_detection_scg,
        requested_pdcch_blind_detection_scg,
        ph_info_mcg,
        meas_gap_sharing_cfg,
        sl_phy_mac_rlc_cfg,
        sl_cfg_ded_eutra_info,
        requested_p_max_fr2,
        sdt_mac_phy_cg_cfg,
        mu_si_m_gap_cfg,
        sl_rlc_ch_to_add_mod_list,
        interfreq_cfg_no_gap,
        ul_gap_fr2_cfg,
        two_phr_mode_mcg,
        two_phr_mode_scg,
        nulltype
      } value;
      typedef uint8_t number_type;

      const char* to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    ext_c() = default;
    ext_c(const ext_c& other);
    ext_c& operator=(const ext_c& other);
    ~ext_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint16_t&                        drx_long_cycle_start_offset();
    unbounded_octstring<true>&       sel_band_combination_idx();
    unbounded_octstring<true>&       sel_feature_set_entry_idx();
    unbounded_octstring<true>&       ph_info_scg();
    unbounded_octstring<true>&       requested_band_combination_idx();
    unbounded_octstring<true>&       requested_feature_set_entry_idx();
    unbounded_octstring<true>&       drx_cfg();
    unbounded_octstring<true>&       pdcch_blind_detection_scg();
    unbounded_octstring<true>&       requested_pdcch_blind_detection_scg();
    unbounded_octstring<true>&       ph_info_mcg();
    unbounded_octstring<true>&       meas_gap_sharing_cfg();
    unbounded_octstring<true>&       sl_phy_mac_rlc_cfg();
    unbounded_octstring<true>&       sl_cfg_ded_eutra_info();
    unbounded_octstring<true>&       requested_p_max_fr2();
    unbounded_octstring<true>&       sdt_mac_phy_cg_cfg();
    unbounded_octstring<true>&       mu_si_m_gap_cfg();
    unbounded_octstring<true>&       sl_rlc_ch_to_add_mod_list();
    interfreq_cfg_no_gap_e&          interfreq_cfg_no_gap();
    unbounded_octstring<true>&       ul_gap_fr2_cfg();
    two_phr_mode_mcg_e&              two_phr_mode_mcg();
    two_phr_mode_scg_e&              two_phr_mode_scg();
    const uint16_t&                  drx_long_cycle_start_offset() const;
    const unbounded_octstring<true>& sel_band_combination_idx() const;
    const unbounded_octstring<true>& sel_feature_set_entry_idx() const;
    const unbounded_octstring<true>& ph_info_scg() const;
    const unbounded_octstring<true>& requested_band_combination_idx() const;
    const unbounded_octstring<true>& requested_feature_set_entry_idx() const;
    const unbounded_octstring<true>& drx_cfg() const;
    const unbounded_octstring<true>& pdcch_blind_detection_scg() const;
    const unbounded_octstring<true>& requested_pdcch_blind_detection_scg() const;
    const unbounded_octstring<true>& ph_info_mcg() const;
    const unbounded_octstring<true>& meas_gap_sharing_cfg() const;
    const unbounded_octstring<true>& sl_phy_mac_rlc_cfg() const;
    const unbounded_octstring<true>& sl_cfg_ded_eutra_info() const;
    const unbounded_octstring<true>& requested_p_max_fr2() const;
    const unbounded_octstring<true>& sdt_mac_phy_cg_cfg() const;
    const unbounded_octstring<true>& mu_si_m_gap_cfg() const;
    const unbounded_octstring<true>& sl_rlc_ch_to_add_mod_list() const;
    const interfreq_cfg_no_gap_e&    interfreq_cfg_no_gap() const;
    const unbounded_octstring<true>& ul_gap_fr2_cfg() const;
    const two_phr_mode_mcg_e&        two_phr_mode_mcg() const;
    const two_phr_mode_scg_e&        two_phr_mode_scg() const;

  private:
    types                                      type_;
    choice_buffer_t<unbounded_octstring<true>> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static ext_c      get_ext(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

struct du_to_cu_rrc_info_ext_ies_container {
  template <class extT_>
  using ie_field_s = protocol_ext_container_item_s<extT_>;

  // member variables
  bool                                                 drx_long_cycle_start_offset_present         = false;
  bool                                                 sel_band_combination_idx_present            = false;
  bool                                                 sel_feature_set_entry_idx_present           = false;
  bool                                                 ph_info_scg_present                         = false;
  bool                                                 requested_band_combination_idx_present      = false;
  bool                                                 requested_feature_set_entry_idx_present     = false;
  bool                                                 drx_cfg_present                             = false;
  bool                                                 pdcch_blind_detection_scg_present           = false;
  bool                                                 requested_pdcch_blind_detection_scg_present = false;
  bool                                                 ph_info_mcg_present                         = false;
  bool                                                 meas_gap_sharing_cfg_present                = false;
  bool                                                 sl_phy_mac_rlc_cfg_present                  = false;
  bool                                                 sl_cfg_ded_eutra_info_present               = false;
  bool                                                 requested_p_max_fr2_present                 = false;
  bool                                                 sdt_mac_phy_cg_cfg_present                  = false;
  bool                                                 mu_si_m_gap_cfg_present                     = false;
  bool                                                 sl_rlc_ch_to_add_mod_list_present           = false;
  bool                                                 interfreq_cfg_no_gap_present                = false;
  bool                                                 ul_gap_fr2_cfg_present                      = false;
  bool                                                 two_phr_mode_mcg_present                    = false;
  bool                                                 two_phr_mode_scg_present                    = false;
  ie_field_s<integer<uint16_t, 0, 10239, false, true>> drx_long_cycle_start_offset;
  ie_field_s<unbounded_octstring<true>>                sel_band_combination_idx;
  ie_field_s<unbounded_octstring<true>>                sel_feature_set_entry_idx;
  ie_field_s<unbounded_octstring<true>>                ph_info_scg;
  ie_field_s<unbounded_octstring<true>>                requested_band_combination_idx;
  ie_field_s<unbounded_octstring<true>>                requested_feature_set_entry_idx;
  ie_field_s<unbounded_octstring<true>>                drx_cfg;
  ie_field_s<unbounded_octstring<true>>                pdcch_blind_detection_scg;
  ie_field_s<unbounded_octstring<true>>                requested_pdcch_blind_detection_scg;
  ie_field_s<unbounded_octstring<true>>                ph_info_mcg;
  ie_field_s<unbounded_octstring<true>>                meas_gap_sharing_cfg;
  ie_field_s<unbounded_octstring<true>>                sl_phy_mac_rlc_cfg;
  ie_field_s<unbounded_octstring<true>>                sl_cfg_ded_eutra_info;
  ie_field_s<unbounded_octstring<true>>                requested_p_max_fr2;
  ie_field_s<unbounded_octstring<true>>                sdt_mac_phy_cg_cfg;
  ie_field_s<unbounded_octstring<true>>                mu_si_m_gap_cfg;
  ie_field_s<unbounded_octstring<true>>                sl_rlc_ch_to_add_mod_list;
  ie_field_s<interfreq_cfg_no_gap_e>                   interfreq_cfg_no_gap;
  ie_field_s<unbounded_octstring<true>>                ul_gap_fr2_cfg;
  ie_field_s<two_phr_mode_mcg_e>                       two_phr_mode_mcg;
  ie_field_s<two_phr_mode_scg_e>                       two_phr_mode_scg;

  // sequence methods
  du_to_cu_rrc_info_ext_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// DUtoCURRCInformation ::= SEQUENCE
struct du_to_cu_rrc_info_s {
  bool                                ext             = false;
  bool                                ie_exts_present = false;
  unbounded_octstring<true>           cell_group_cfg;
  unbounded_octstring<true>           meas_gap_cfg;
  unbounded_octstring<true>           requested_p_max_fr1;
  du_to_cu_rrc_info_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// DeactivateTraceIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct deactiv_trace_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { gnb_cu_ue_f1ap_id, gnb_du_ue_f1ap_id, trace_id, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint64_t&                       gnb_cu_ue_f1ap_id();
    uint64_t&                       gnb_du_ue_f1ap_id();
    fixed_octstring<8, true>&       trace_id();
    const uint64_t&                 gnb_cu_ue_f1ap_id() const;
    const uint64_t&                 gnb_du_ue_f1ap_id() const;
    const fixed_octstring<8, true>& trace_id() const;

  private:
    types                                     type_;
    choice_buffer_t<fixed_octstring<8, true>> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

struct deactiv_trace_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_cu_ue_f1ap_id;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_du_ue_f1ap_id;
  ie_field_s<fixed_octstring<8, true>>                      trace_id;

  // sequence methods
  deactiv_trace_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// DeactivateTrace ::= SEQUENCE
using deactiv_trace_s = elementary_procedure_option<deactiv_trace_ies_container>;

// DedicatedSIDeliveryNeededUE-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using ded_si_delivery_needed_ue_item_ext_ies_o = protocol_ext_empty_o;

using ded_si_delivery_needed_ue_item_ext_ies_container = protocol_ext_container_empty_l;

// Dedicated-SIDelivery-NeededUE-Item ::= SEQUENCE
struct ded_si_delivery_needed_ue_item_s {
  bool                                             ext               = false;
  bool                                             ie_exts_present   = false;
  uint64_t                                         gnb_cu_ue_f1ap_id = 0;
  nr_cgi_s                                         nr_cgi;
  ded_si_delivery_needed_ue_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// Dedicated-SIDelivery-NeededUE-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct ded_si_delivery_needed_ue_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { ded_si_delivery_needed_ue_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::ded_si_delivery_needed_ue_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    ded_si_delivery_needed_ue_item_s&       ded_si_delivery_needed_ue_item() { return c; }
    const ded_si_delivery_needed_ue_item_s& ded_si_delivery_needed_ue_item() const { return c; }

  private:
    ded_si_delivery_needed_ue_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// Dedicated-SIDelivery-NeededUE-List ::= SEQUENCE (SIZE (1..65536)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES :
// IEsSetParam}
using ded_si_delivery_needed_ue_list_l =
    dyn_array<protocol_ie_single_container_s<ded_si_delivery_needed_ue_item_ies_o>>;

// DynamicPQIDescriptor-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using dyn_pq_id_escriptor_ext_ies_o = protocol_ext_empty_o;

using dyn_pq_id_escriptor_ext_ies_container = protocol_ext_container_empty_l;

// DynamicPQIDescriptor ::= SEQUENCE
struct dyn_pq_id_escriptor_s {
  struct res_type_opts {
    enum options { gbr, non_gbr, delay_crit_grb, /*...*/ nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<res_type_opts, true> res_type_e_;

  // member variables
  bool                                  res_type_present              = false;
  bool                                  averaging_win_present         = false;
  bool                                  max_data_burst_volume_present = false;
  bool                                  ie_exts_present               = false;
  res_type_e_                           res_type;
  uint8_t                               qos_prio_level      = 1;
  uint16_t                              packet_delay_budget = 0;
  packet_error_rate_s                   packet_error_rate;
  uint16_t                              averaging_win         = 0;
  uint16_t                              max_data_burst_volume = 0;
  dyn_pq_id_escriptor_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// E-CID-MeasuredResults-Value-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct e_c_id_measured_results_value_ext_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { nr_tadv, nulltype } value;
      typedef uint8_t number_type;

      const char* to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::nr_tadv; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint16_t&       nr_tadv() { return c; }
    const uint16_t& nr_tadv() const { return c; }

  private:
    uint16_t c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// E-CID-MeasuredResults-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using e_c_id_measured_results_item_ext_ies_o = protocol_ext_empty_o;

// E-CID-MeasuredResults-Value ::= CHOICE
struct e_c_id_measured_results_value_c {
  struct types_opts {
    enum options { value_angleof_arrival_nr, choice_ext, nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  e_c_id_measured_results_value_c() = default;
  e_c_id_measured_results_value_c(const e_c_id_measured_results_value_c& other);
  e_c_id_measured_results_value_c& operator=(const e_c_id_measured_results_value_c& other);
  ~e_c_id_measured_results_value_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  ul_ao_a_s& value_angleof_arrival_nr()
  {
    assert_choice_type(types::value_angleof_arrival_nr, type_, "E-CID-MeasuredResults-Value");
    return c.get<ul_ao_a_s>();
  }
  protocol_ie_single_container_s<e_c_id_measured_results_value_ext_ies_o>& choice_ext()
  {
    assert_choice_type(types::choice_ext, type_, "E-CID-MeasuredResults-Value");
    return c.get<protocol_ie_single_container_s<e_c_id_measured_results_value_ext_ies_o>>();
  }
  const ul_ao_a_s& value_angleof_arrival_nr() const
  {
    assert_choice_type(types::value_angleof_arrival_nr, type_, "E-CID-MeasuredResults-Value");
    return c.get<ul_ao_a_s>();
  }
  const protocol_ie_single_container_s<e_c_id_measured_results_value_ext_ies_o>& choice_ext() const
  {
    assert_choice_type(types::choice_ext, type_, "E-CID-MeasuredResults-Value");
    return c.get<protocol_ie_single_container_s<e_c_id_measured_results_value_ext_ies_o>>();
  }
  ul_ao_a_s&                                                               set_value_angleof_arrival_nr();
  protocol_ie_single_container_s<e_c_id_measured_results_value_ext_ies_o>& set_choice_ext();

private:
  types                                                                                               type_;
  choice_buffer_t<protocol_ie_single_container_s<e_c_id_measured_results_value_ext_ies_o>, ul_ao_a_s> c;

  void destroy_();
};

using e_c_id_measured_results_item_ext_ies_container = protocol_ext_container_empty_l;

// E-CID-MeasuredResults-Item ::= SEQUENCE
struct e_c_id_measured_results_item_s {
  bool                                           ie_exts_present = false;
  e_c_id_measured_results_value_c                e_c_id_measured_results_value;
  e_c_id_measured_results_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// E-CID-MeasuredResults-List ::= SEQUENCE (SIZE (1..64)) OF E-CID-MeasuredResults-Item
using e_c_id_measured_results_list_l = dyn_array<e_c_id_measured_results_item_s>;

// E-CID-MeasurementQuantitiesValue ::= ENUMERATED
struct e_c_id_meas_quantities_value_opts {
  enum options { default_value, angle_of_arrival_nr, /*...*/ timing_advance_nr, nulltype } value;

  const char* to_string() const;
};
typedef enumerated<e_c_id_meas_quantities_value_opts, true, 1> e_c_id_meas_quantities_value_e;

// E-CID-MeasurementQuantitiesValue-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using e_c_id_meas_quantities_value_ext_ies_o = protocol_ext_empty_o;

using e_c_id_meas_quantities_value_ext_ies_container = protocol_ext_container_empty_l;

// E-CID-MeasurementQuantities-Item ::= SEQUENCE
struct e_c_id_meas_quantities_item_s {
  bool                                           ie_exts_present = false;
  e_c_id_meas_quantities_value_e                 e_c_id_meas_quantities_value;
  e_c_id_meas_quantities_value_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// E-CID-MeasurementQuantities-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct e_c_id_meas_quantities_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { e_c_id_meas_quantities_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::e_c_id_meas_quantities_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    e_c_id_meas_quantities_item_s&       e_c_id_meas_quantities_item() { return c; }
    const e_c_id_meas_quantities_item_s& e_c_id_meas_quantities_item() const { return c; }

  private:
    e_c_id_meas_quantities_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// E-CID-MeasurementQuantities ::= SEQUENCE (SIZE (1..64)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES :
// IEsSetParam}
using e_c_id_meas_quantities_l = dyn_array<protocol_ie_single_container_s<e_c_id_meas_quantities_item_ies_o>>;

// NGRANHighAccuracyAccessPointPosition-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using ngran_high_accuracy_access_point_position_ext_ies_o = protocol_ext_empty_o;

using ngran_high_accuracy_access_point_position_ext_ies_container = protocol_ext_container_empty_l;

// NGRANHighAccuracyAccessPointPosition ::= SEQUENCE
struct ngran_high_accuracy_access_point_position_s {
  bool                                                        ie_exts_present           = false;
  int64_t                                                     latitude                  = -2147483648;
  int64_t                                                     longitude                 = -2147483648;
  int32_t                                                     altitude                  = -64000;
  uint16_t                                                    uncertainty_semi_major    = 0;
  uint16_t                                                    uncertainty_semi_minor    = 0;
  uint8_t                                                     orientation_of_major_axis = 0;
  uint8_t                                                     horizontal_confidence     = 0;
  uint16_t                                                    uncertainty_altitude      = 0;
  uint8_t                                                     vertical_confidence       = 0;
  ngran_high_accuracy_access_point_position_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// ReferencePoint-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
using ref_point_ext_ies_o = protocol_ies_empty_o;

// TRPPositionDirectAccuracy-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
using trp_position_direct_accuracy_ext_ies_o = protocol_ies_empty_o;

// TRPReferencePointType-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
using trp_ref_point_type_ext_ies_o = protocol_ies_empty_o;

// ReferencePoint ::= CHOICE
struct ref_point_c {
  struct types_opts {
    enum options { coordinate_id, ref_point_coordinate, ref_point_coordinate_ha, choice_ext, nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  ref_point_c() = default;
  ref_point_c(const ref_point_c& other);
  ref_point_c& operator=(const ref_point_c& other);
  ~ref_point_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  uint16_t& coordinate_id()
  {
    assert_choice_type(types::coordinate_id, type_, "ReferencePoint");
    return c.get<uint16_t>();
  }
  access_point_position_s& ref_point_coordinate()
  {
    assert_choice_type(types::ref_point_coordinate, type_, "ReferencePoint");
    return c.get<access_point_position_s>();
  }
  ngran_high_accuracy_access_point_position_s& ref_point_coordinate_ha()
  {
    assert_choice_type(types::ref_point_coordinate_ha, type_, "ReferencePoint");
    return c.get<ngran_high_accuracy_access_point_position_s>();
  }
  protocol_ie_single_container_s<ref_point_ext_ies_o>& choice_ext()
  {
    assert_choice_type(types::choice_ext, type_, "ReferencePoint");
    return c.get<protocol_ie_single_container_s<ref_point_ext_ies_o>>();
  }
  const uint16_t& coordinate_id() const
  {
    assert_choice_type(types::coordinate_id, type_, "ReferencePoint");
    return c.get<uint16_t>();
  }
  const access_point_position_s& ref_point_coordinate() const
  {
    assert_choice_type(types::ref_point_coordinate, type_, "ReferencePoint");
    return c.get<access_point_position_s>();
  }
  const ngran_high_accuracy_access_point_position_s& ref_point_coordinate_ha() const
  {
    assert_choice_type(types::ref_point_coordinate_ha, type_, "ReferencePoint");
    return c.get<ngran_high_accuracy_access_point_position_s>();
  }
  const protocol_ie_single_container_s<ref_point_ext_ies_o>& choice_ext() const
  {
    assert_choice_type(types::choice_ext, type_, "ReferencePoint");
    return c.get<protocol_ie_single_container_s<ref_point_ext_ies_o>>();
  }
  uint16_t&                                            set_coordinate_id();
  access_point_position_s&                             set_ref_point_coordinate();
  ngran_high_accuracy_access_point_position_s&         set_ref_point_coordinate_ha();
  protocol_ie_single_container_s<ref_point_ext_ies_o>& set_choice_ext();

private:
  types type_;
  choice_buffer_t<access_point_position_s,
                  ngran_high_accuracy_access_point_position_s,
                  protocol_ie_single_container_s<ref_point_ext_ies_o>>
      c;

  void destroy_();
};

// TRPPositionDirect-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using trp_position_direct_ext_ies_o = protocol_ext_empty_o;

// TRPPositionDirectAccuracy ::= CHOICE
struct trp_position_direct_accuracy_c {
  struct types_opts {
    enum options { trp_position, trph_aposition, choice_ext, nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  trp_position_direct_accuracy_c() = default;
  trp_position_direct_accuracy_c(const trp_position_direct_accuracy_c& other);
  trp_position_direct_accuracy_c& operator=(const trp_position_direct_accuracy_c& other);
  ~trp_position_direct_accuracy_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  access_point_position_s& trp_position()
  {
    assert_choice_type(types::trp_position, type_, "TRPPositionDirectAccuracy");
    return c.get<access_point_position_s>();
  }
  ngran_high_accuracy_access_point_position_s& trph_aposition()
  {
    assert_choice_type(types::trph_aposition, type_, "TRPPositionDirectAccuracy");
    return c.get<ngran_high_accuracy_access_point_position_s>();
  }
  protocol_ie_single_container_s<trp_position_direct_accuracy_ext_ies_o>& choice_ext()
  {
    assert_choice_type(types::choice_ext, type_, "TRPPositionDirectAccuracy");
    return c.get<protocol_ie_single_container_s<trp_position_direct_accuracy_ext_ies_o>>();
  }
  const access_point_position_s& trp_position() const
  {
    assert_choice_type(types::trp_position, type_, "TRPPositionDirectAccuracy");
    return c.get<access_point_position_s>();
  }
  const ngran_high_accuracy_access_point_position_s& trph_aposition() const
  {
    assert_choice_type(types::trph_aposition, type_, "TRPPositionDirectAccuracy");
    return c.get<ngran_high_accuracy_access_point_position_s>();
  }
  const protocol_ie_single_container_s<trp_position_direct_accuracy_ext_ies_o>& choice_ext() const
  {
    assert_choice_type(types::choice_ext, type_, "TRPPositionDirectAccuracy");
    return c.get<protocol_ie_single_container_s<trp_position_direct_accuracy_ext_ies_o>>();
  }
  access_point_position_s&                                                set_trp_position();
  ngran_high_accuracy_access_point_position_s&                            set_trph_aposition();
  protocol_ie_single_container_s<trp_position_direct_accuracy_ext_ies_o>& set_choice_ext();

private:
  types type_;
  choice_buffer_t<access_point_position_s,
                  ngran_high_accuracy_access_point_position_s,
                  protocol_ie_single_container_s<trp_position_direct_accuracy_ext_ies_o>>
      c;

  void destroy_();
};

// TRPPositionReferenced-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using trp_position_refd_ext_ies_o = protocol_ext_empty_o;

// TRPReferencePointType ::= CHOICE
struct trp_ref_point_type_c {
  struct types_opts {
    enum options { trp_position_relative_geodetic, trp_position_relative_cartesian, choice_ext, nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  trp_ref_point_type_c() = default;
  trp_ref_point_type_c(const trp_ref_point_type_c& other);
  trp_ref_point_type_c& operator=(const trp_ref_point_type_c& other);
  ~trp_ref_point_type_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  relative_geodetic_location_s& trp_position_relative_geodetic()
  {
    assert_choice_type(types::trp_position_relative_geodetic, type_, "TRPReferencePointType");
    return c.get<relative_geodetic_location_s>();
  }
  relative_cartesian_location_s& trp_position_relative_cartesian()
  {
    assert_choice_type(types::trp_position_relative_cartesian, type_, "TRPReferencePointType");
    return c.get<relative_cartesian_location_s>();
  }
  protocol_ie_single_container_s<trp_ref_point_type_ext_ies_o>& choice_ext()
  {
    assert_choice_type(types::choice_ext, type_, "TRPReferencePointType");
    return c.get<protocol_ie_single_container_s<trp_ref_point_type_ext_ies_o>>();
  }
  const relative_geodetic_location_s& trp_position_relative_geodetic() const
  {
    assert_choice_type(types::trp_position_relative_geodetic, type_, "TRPReferencePointType");
    return c.get<relative_geodetic_location_s>();
  }
  const relative_cartesian_location_s& trp_position_relative_cartesian() const
  {
    assert_choice_type(types::trp_position_relative_cartesian, type_, "TRPReferencePointType");
    return c.get<relative_cartesian_location_s>();
  }
  const protocol_ie_single_container_s<trp_ref_point_type_ext_ies_o>& choice_ext() const
  {
    assert_choice_type(types::choice_ext, type_, "TRPReferencePointType");
    return c.get<protocol_ie_single_container_s<trp_ref_point_type_ext_ies_o>>();
  }
  relative_geodetic_location_s&                                 set_trp_position_relative_geodetic();
  relative_cartesian_location_s&                                set_trp_position_relative_cartesian();
  protocol_ie_single_container_s<trp_ref_point_type_ext_ies_o>& set_choice_ext();

private:
  types type_;
  choice_buffer_t<protocol_ie_single_container_s<trp_ref_point_type_ext_ies_o>,
                  relative_cartesian_location_s,
                  relative_geodetic_location_s>
      c;

  void destroy_();
};

// TRPPositionDefinitionType-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
using trp_position_definition_type_ext_ies_o = protocol_ies_empty_o;

using trp_position_direct_ext_ies_container = protocol_ext_container_empty_l;

// TRPPositionDirect ::= SEQUENCE
struct trp_position_direct_s {
  bool                                  ie_exts_present = false;
  trp_position_direct_accuracy_c        accuracy;
  trp_position_direct_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using trp_position_refd_ext_ies_container = protocol_ext_container_empty_l;

// TRPPositionReferenced ::= SEQUENCE
struct trp_position_refd_s {
  bool                                ie_exts_present = false;
  ref_point_c                         ref_point;
  trp_ref_point_type_c                ref_point_type;
  trp_position_refd_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// GeographicalCoordinates-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
struct geographical_coordinates_ext_ies_o {
  // Extension ::= OPEN TYPE
  struct ext_c {
    struct types_opts {
      enum options { arp_location_info, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::arp_location_info; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    arp_location_info_l&       arp_location_info() { return c; }
    const arp_location_info_l& arp_location_info() const { return c; }

  private:
    arp_location_info_l c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static ext_c      get_ext(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// TRPPositionDefinitionType ::= CHOICE
struct trp_position_definition_type_c {
  struct types_opts {
    enum options { direct, refd, choice_ext, nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  trp_position_definition_type_c() = default;
  trp_position_definition_type_c(const trp_position_definition_type_c& other);
  trp_position_definition_type_c& operator=(const trp_position_definition_type_c& other);
  ~trp_position_definition_type_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  trp_position_direct_s& direct()
  {
    assert_choice_type(types::direct, type_, "TRPPositionDefinitionType");
    return c.get<trp_position_direct_s>();
  }
  trp_position_refd_s& refd()
  {
    assert_choice_type(types::refd, type_, "TRPPositionDefinitionType");
    return c.get<trp_position_refd_s>();
  }
  protocol_ie_single_container_s<trp_position_definition_type_ext_ies_o>& choice_ext()
  {
    assert_choice_type(types::choice_ext, type_, "TRPPositionDefinitionType");
    return c.get<protocol_ie_single_container_s<trp_position_definition_type_ext_ies_o>>();
  }
  const trp_position_direct_s& direct() const
  {
    assert_choice_type(types::direct, type_, "TRPPositionDefinitionType");
    return c.get<trp_position_direct_s>();
  }
  const trp_position_refd_s& refd() const
  {
    assert_choice_type(types::refd, type_, "TRPPositionDefinitionType");
    return c.get<trp_position_refd_s>();
  }
  const protocol_ie_single_container_s<trp_position_definition_type_ext_ies_o>& choice_ext() const
  {
    assert_choice_type(types::choice_ext, type_, "TRPPositionDefinitionType");
    return c.get<protocol_ie_single_container_s<trp_position_definition_type_ext_ies_o>>();
  }
  trp_position_direct_s&                                                  set_direct();
  trp_position_refd_s&                                                    set_refd();
  protocol_ie_single_container_s<trp_position_definition_type_ext_ies_o>& set_choice_ext();

private:
  types type_;
  choice_buffer_t<protocol_ie_single_container_s<trp_position_definition_type_ext_ies_o>,
                  trp_position_direct_s,
                  trp_position_refd_s>
      c;

  void destroy_();
};

// E-CID-MeasurementResult-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using e_c_id_meas_result_ext_ies_o = protocol_ext_empty_o;

// GeographicalCoordinates ::= SEQUENCE
struct geographical_coordinates_s {
  bool                                                         dl_prs_res_coordinates_present = false;
  trp_position_definition_type_c                               trp_position_definition_type;
  dl_prs_res_coordinates_s                                     dl_prs_res_coordinates;
  protocol_ext_container_l<geographical_coordinates_ext_ies_o> ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using e_c_id_meas_result_ext_ies_container = protocol_ext_container_empty_l;

// E-CID-MeasurementResult ::= SEQUENCE
struct e_c_id_meas_result_s {
  bool                                 geographical_coordinates_present = false;
  bool                                 ie_exts_present                  = false;
  geographical_coordinates_s           geographical_coordinates;
  e_c_id_measured_results_list_l       measured_results_list;
  e_c_id_meas_result_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// E-CIDMeasurementFailureIndication-IEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct e_c_id_meas_fail_ind_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { gnb_cu_ue_f1ap_id, gnb_du_ue_f1ap_id, lmf_ue_meas_id, ran_ue_meas_id, cause, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint64_t&       gnb_cu_ue_f1ap_id();
    uint64_t&       gnb_du_ue_f1ap_id();
    uint16_t&       lmf_ue_meas_id();
    uint16_t&       ran_ue_meas_id();
    cause_c&        cause();
    const uint64_t& gnb_cu_ue_f1ap_id() const;
    const uint64_t& gnb_du_ue_f1ap_id() const;
    const uint16_t& lmf_ue_meas_id() const;
    const uint16_t& ran_ue_meas_id() const;
    const cause_c&  cause() const;

  private:
    types                    type_;
    choice_buffer_t<cause_c> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

struct e_c_id_meas_fail_ind_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_cu_ue_f1ap_id;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_du_ue_f1ap_id;
  ie_field_s<integer<uint16_t, 1, 256, true, true>>         lmf_ue_meas_id;
  ie_field_s<integer<uint16_t, 1, 256, true, true>>         ran_ue_meas_id;
  ie_field_s<cause_c>                                       cause;

  // sequence methods
  e_c_id_meas_fail_ind_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// E-CIDMeasurementFailureIndication ::= SEQUENCE
using e_c_id_meas_fail_ind_s = elementary_procedure_option<e_c_id_meas_fail_ind_ies_container>;

// E-CIDMeasurementInitiationFailure-IEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct e_c_id_meas_initiation_fail_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options {
        gnb_cu_ue_f1ap_id,
        gnb_du_ue_f1ap_id,
        lmf_ue_meas_id,
        ran_ue_meas_id,
        cause,
        crit_diagnostics,
        nulltype
      } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint64_t&                 gnb_cu_ue_f1ap_id();
    uint64_t&                 gnb_du_ue_f1ap_id();
    uint16_t&                 lmf_ue_meas_id();
    uint16_t&                 ran_ue_meas_id();
    cause_c&                  cause();
    crit_diagnostics_s&       crit_diagnostics();
    const uint64_t&           gnb_cu_ue_f1ap_id() const;
    const uint64_t&           gnb_du_ue_f1ap_id() const;
    const uint16_t&           lmf_ue_meas_id() const;
    const uint16_t&           ran_ue_meas_id() const;
    const cause_c&            cause() const;
    const crit_diagnostics_s& crit_diagnostics() const;

  private:
    types                                        type_;
    choice_buffer_t<cause_c, crit_diagnostics_s> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

struct e_c_id_meas_initiation_fail_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                                      crit_diagnostics_present = false;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_cu_ue_f1ap_id;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_du_ue_f1ap_id;
  ie_field_s<integer<uint16_t, 1, 256, true, true>>         lmf_ue_meas_id;
  ie_field_s<integer<uint16_t, 1, 256, true, true>>         ran_ue_meas_id;
  ie_field_s<cause_c>                                       cause;
  ie_field_s<crit_diagnostics_s>                            crit_diagnostics;

  // sequence methods
  e_c_id_meas_initiation_fail_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// E-CIDMeasurementInitiationFailure ::= SEQUENCE
using e_c_id_meas_initiation_fail_s = elementary_procedure_option<e_c_id_meas_initiation_fail_ies_container>;

// E-CID-ReportCharacteristics ::= ENUMERATED
struct e_c_id_report_characteristics_opts {
  enum options { on_demand, periodic, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<e_c_id_report_characteristics_opts, true> e_c_id_report_characteristics_e;

// MeasurementPeriodicity ::= ENUMERATED
struct meas_periodicity_opts {
  enum options {
    ms120,
    ms240,
    ms480,
    ms640,
    ms1024,
    ms2048,
    ms5120,
    ms10240,
    min1,
    min6,
    min12,
    min30,
    // ...
    ms20480,
    ms40960,
    extended,
    nulltype
  } value;
  typedef uint16_t number_type;

  const char* to_string() const;
  uint16_t    to_number() const;
};
typedef enumerated<meas_periodicity_opts, true, 3> meas_periodicity_e;

// PosMeasurementPeriodicityNR-AoA ::= ENUMERATED
struct pos_meas_periodicity_nr_ao_a_opts {
  enum options {
    ms160,
    ms320,
    ms640,
    ms1280,
    ms2560,
    ms5120,
    ms10240,
    ms20480,
    ms40960,
    ms61440,
    ms81920,
    ms368640,
    ms737280,
    ms1843200,
    // ...
    nulltype
  } value;
  typedef uint32_t number_type;

  const char* to_string() const;
  uint32_t    to_number() const;
};
typedef enumerated<pos_meas_periodicity_nr_ao_a_opts, true> pos_meas_periodicity_nr_ao_a_e;

// E-CIDMeasurementInitiationRequest-IEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct e_c_id_meas_initiation_request_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options {
        gnb_cu_ue_f1ap_id,
        gnb_du_ue_f1ap_id,
        lmf_ue_meas_id,
        ran_ue_meas_id,
        e_c_id_report_characteristics,
        e_c_id_meas_periodicity,
        e_c_id_meas_quantities,
        pos_meas_periodicity_nr_ao_a,
        nulltype
      } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint64_t&                              gnb_cu_ue_f1ap_id();
    uint64_t&                              gnb_du_ue_f1ap_id();
    uint16_t&                              lmf_ue_meas_id();
    uint16_t&                              ran_ue_meas_id();
    e_c_id_report_characteristics_e&       e_c_id_report_characteristics();
    meas_periodicity_e&                    e_c_id_meas_periodicity();
    e_c_id_meas_quantities_l&              e_c_id_meas_quantities();
    pos_meas_periodicity_nr_ao_a_e&        pos_meas_periodicity_nr_ao_a();
    const uint64_t&                        gnb_cu_ue_f1ap_id() const;
    const uint64_t&                        gnb_du_ue_f1ap_id() const;
    const uint16_t&                        lmf_ue_meas_id() const;
    const uint16_t&                        ran_ue_meas_id() const;
    const e_c_id_report_characteristics_e& e_c_id_report_characteristics() const;
    const meas_periodicity_e&              e_c_id_meas_periodicity() const;
    const e_c_id_meas_quantities_l&        e_c_id_meas_quantities() const;
    const pos_meas_periodicity_nr_ao_a_e&  pos_meas_periodicity_nr_ao_a() const;

  private:
    types                                     type_;
    choice_buffer_t<e_c_id_meas_quantities_l> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

struct e_c_id_meas_initiation_request_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                                      e_c_id_meas_periodicity_present      = false;
  bool                                                      pos_meas_periodicity_nr_ao_a_present = false;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_cu_ue_f1ap_id;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_du_ue_f1ap_id;
  ie_field_s<integer<uint16_t, 1, 256, true, true>>         lmf_ue_meas_id;
  ie_field_s<integer<uint16_t, 1, 256, true, true>>         ran_ue_meas_id;
  ie_field_s<e_c_id_report_characteristics_e>               e_c_id_report_characteristics;
  ie_field_s<meas_periodicity_e>                            e_c_id_meas_periodicity;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<e_c_id_meas_quantities_item_ies_o>, 1, 64, true>>
                                             e_c_id_meas_quantities;
  ie_field_s<pos_meas_periodicity_nr_ao_a_e> pos_meas_periodicity_nr_ao_a;

  // sequence methods
  e_c_id_meas_initiation_request_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// E-CIDMeasurementInitiationRequest ::= SEQUENCE
using e_c_id_meas_initiation_request_s = elementary_procedure_option<e_c_id_meas_initiation_request_ies_container>;

// E-CIDMeasurementInitiationResponse-IEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct e_c_id_meas_initiation_resp_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options {
        gnb_cu_ue_f1ap_id,
        gnb_du_ue_f1ap_id,
        lmf_ue_meas_id,
        ran_ue_meas_id,
        e_c_id_meas_result,
        cell_portion_id,
        crit_diagnostics,
        nulltype
      } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint64_t&                   gnb_cu_ue_f1ap_id();
    uint64_t&                   gnb_du_ue_f1ap_id();
    uint16_t&                   lmf_ue_meas_id();
    uint16_t&                   ran_ue_meas_id();
    e_c_id_meas_result_s&       e_c_id_meas_result();
    uint16_t&                   cell_portion_id();
    crit_diagnostics_s&         crit_diagnostics();
    const uint64_t&             gnb_cu_ue_f1ap_id() const;
    const uint64_t&             gnb_du_ue_f1ap_id() const;
    const uint16_t&             lmf_ue_meas_id() const;
    const uint16_t&             ran_ue_meas_id() const;
    const e_c_id_meas_result_s& e_c_id_meas_result() const;
    const uint16_t&             cell_portion_id() const;
    const crit_diagnostics_s&   crit_diagnostics() const;

  private:
    types                                                     type_;
    choice_buffer_t<crit_diagnostics_s, e_c_id_meas_result_s> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

struct e_c_id_meas_initiation_resp_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                                      e_c_id_meas_result_present = false;
  bool                                                      cell_portion_id_present    = false;
  bool                                                      crit_diagnostics_present   = false;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_cu_ue_f1ap_id;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_du_ue_f1ap_id;
  ie_field_s<integer<uint16_t, 1, 256, true, true>>         lmf_ue_meas_id;
  ie_field_s<integer<uint16_t, 1, 256, true, true>>         ran_ue_meas_id;
  ie_field_s<e_c_id_meas_result_s>                          e_c_id_meas_result;
  ie_field_s<integer<uint16_t, 0, 4095, true, true>>        cell_portion_id;
  ie_field_s<crit_diagnostics_s>                            crit_diagnostics;

  // sequence methods
  e_c_id_meas_initiation_resp_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// E-CIDMeasurementInitiationResponse ::= SEQUENCE
using e_c_id_meas_initiation_resp_s = elementary_procedure_option<e_c_id_meas_initiation_resp_ies_container>;

// E-CIDMeasurementReport-IEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct e_c_id_meas_report_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options {
        gnb_cu_ue_f1ap_id,
        gnb_du_ue_f1ap_id,
        lmf_ue_meas_id,
        ran_ue_meas_id,
        e_c_id_meas_result,
        cell_portion_id,
        nulltype
      } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint64_t&                   gnb_cu_ue_f1ap_id();
    uint64_t&                   gnb_du_ue_f1ap_id();
    uint16_t&                   lmf_ue_meas_id();
    uint16_t&                   ran_ue_meas_id();
    e_c_id_meas_result_s&       e_c_id_meas_result();
    uint16_t&                   cell_portion_id();
    const uint64_t&             gnb_cu_ue_f1ap_id() const;
    const uint64_t&             gnb_du_ue_f1ap_id() const;
    const uint16_t&             lmf_ue_meas_id() const;
    const uint16_t&             ran_ue_meas_id() const;
    const e_c_id_meas_result_s& e_c_id_meas_result() const;
    const uint16_t&             cell_portion_id() const;

  private:
    types                                 type_;
    choice_buffer_t<e_c_id_meas_result_s> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

struct e_c_id_meas_report_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                                      cell_portion_id_present = false;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_cu_ue_f1ap_id;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_du_ue_f1ap_id;
  ie_field_s<integer<uint16_t, 1, 256, true, true>>         lmf_ue_meas_id;
  ie_field_s<integer<uint16_t, 1, 256, true, true>>         ran_ue_meas_id;
  ie_field_s<e_c_id_meas_result_s>                          e_c_id_meas_result;
  ie_field_s<integer<uint16_t, 0, 4095, true, true>>        cell_portion_id;

  // sequence methods
  e_c_id_meas_report_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// E-CIDMeasurementReport ::= SEQUENCE
using e_c_id_meas_report_s = elementary_procedure_option<e_c_id_meas_report_ies_container>;

// E-CIDMeasurementTerminationCommand-IEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct e_c_id_meas_termination_cmd_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { gnb_cu_ue_f1ap_id, gnb_du_ue_f1ap_id, lmf_ue_meas_id, ran_ue_meas_id, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint64_t&       gnb_cu_ue_f1ap_id();
    uint64_t&       gnb_du_ue_f1ap_id();
    uint16_t&       lmf_ue_meas_id();
    uint16_t&       ran_ue_meas_id();
    const uint64_t& gnb_cu_ue_f1ap_id() const;
    const uint64_t& gnb_du_ue_f1ap_id() const;
    const uint16_t& lmf_ue_meas_id() const;
    const uint16_t& ran_ue_meas_id() const;

  private:
    types               type_;
    pod_choice_buffer_t c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

struct e_c_id_meas_termination_cmd_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_cu_ue_f1ap_id;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_du_ue_f1ap_id;
  ie_field_s<integer<uint16_t, 1, 256, true, true>>         lmf_ue_meas_id;
  ie_field_s<integer<uint16_t, 1, 256, true, true>>         ran_ue_meas_id;

  // sequence methods
  e_c_id_meas_termination_cmd_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// E-CIDMeasurementTerminationCommand ::= SEQUENCE
using e_c_id_meas_termination_cmd_s = elementary_procedure_option<e_c_id_meas_termination_cmd_ies_container>;

// EUTRA-Coex-FDD-Info-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using eutra_coex_fdd_info_ext_ies_o = protocol_ext_empty_o;

// EUTRA-Transmission-Bandwidth ::= ENUMERATED
struct eutra_tx_bw_opts {
  enum options { bw6, bw15, bw25, bw50, bw75, bw100, /*...*/ nulltype } value;
  typedef uint8_t number_type;

  const char* to_string() const;
  uint8_t     to_number() const;
};
typedef enumerated<eutra_tx_bw_opts, true> eutra_tx_bw_e;

using eutra_coex_fdd_info_ext_ies_container = protocol_ext_container_empty_l;

// EUTRA-Coex-FDD-Info ::= SEQUENCE
struct eutra_coex_fdd_info_s {
  bool                                  ext               = false;
  bool                                  ul_earfcn_present = false;
  bool                                  ul_tx_bw_present  = false;
  bool                                  ie_exts_present   = false;
  uint32_t                              ul_earfcn         = 0;
  uint32_t                              dl_earfcn         = 0;
  eutra_tx_bw_e                         ul_tx_bw;
  eutra_tx_bw_e                         dl_tx_bw;
  eutra_coex_fdd_info_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// EUTRA-CyclicPrefixDL ::= ENUMERATED
struct eutra_cp_dl_opts {
  enum options { normal, extended, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<eutra_cp_dl_opts, true> eutra_cp_dl_e;

// EUTRA-CyclicPrefixUL ::= ENUMERATED
struct eutra_cp_ul_opts {
  enum options { normal, extended, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<eutra_cp_ul_opts, true> eutra_cp_ul_e;

// EUTRA-SpecialSubframe-Info-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using eutra_special_sf_info_ext_ies_o = protocol_ext_empty_o;

// EUTRA-SpecialSubframePatterns ::= ENUMERATED
struct eutra_special_sf_patterns_opts {
  enum options { ssp0, ssp1, ssp2, ssp3, ssp4, ssp5, ssp6, ssp7, ssp8, ssp9, ssp10, /*...*/ nulltype } value;
  typedef uint8_t number_type;

  const char* to_string() const;
  uint8_t     to_number() const;
};
typedef enumerated<eutra_special_sf_patterns_opts, true> eutra_special_sf_patterns_e;

// EUTRA-Coex-TDD-Info-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using eutra_coex_tdd_info_ext_ies_o = protocol_ext_empty_o;

using eutra_special_sf_info_ext_ies_container = protocol_ext_container_empty_l;

// EUTRA-SpecialSubframe-Info ::= SEQUENCE
struct eutra_special_sf_info_s {
  bool                                    ext             = false;
  bool                                    ie_exts_present = false;
  eutra_special_sf_patterns_e             special_sf_patterns;
  eutra_cp_dl_e                           cp_dl;
  eutra_cp_ul_e                           cp_ul;
  eutra_special_sf_info_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// EUTRA-SubframeAssignment ::= ENUMERATED
struct eutra_sf_assign_opts {
  enum options { sa0, sa1, sa2, sa3, sa4, sa5, sa6, /*...*/ nulltype } value;
  typedef uint8_t number_type;

  const char* to_string() const;
  uint8_t     to_number() const;
};
typedef enumerated<eutra_sf_assign_opts, true> eutra_sf_assign_e;

using eutra_coex_tdd_info_ext_ies_container = protocol_ext_container_empty_l;

// EUTRA-Coex-TDD-Info ::= SEQUENCE
struct eutra_coex_tdd_info_s {
  bool                                  ext             = false;
  bool                                  ie_exts_present = false;
  uint32_t                              earfcn          = 0;
  eutra_tx_bw_e                         tx_bw;
  eutra_sf_assign_e                     sf_assign;
  eutra_special_sf_info_s               special_sf_info;
  eutra_coex_tdd_info_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// EUTRA-Coex-Mode-Info ::= CHOICE
struct eutra_coex_mode_info_c {
  struct types_opts {
    enum options { fdd, tdd, /*...*/ nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<types_opts, true> types;

  // choice methods
  eutra_coex_mode_info_c() = default;
  eutra_coex_mode_info_c(const eutra_coex_mode_info_c& other);
  eutra_coex_mode_info_c& operator=(const eutra_coex_mode_info_c& other);
  ~eutra_coex_mode_info_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  eutra_coex_fdd_info_s& fdd()
  {
    assert_choice_type(types::fdd, type_, "EUTRA-Coex-Mode-Info");
    return c.get<eutra_coex_fdd_info_s>();
  }
  eutra_coex_tdd_info_s& tdd()
  {
    assert_choice_type(types::tdd, type_, "EUTRA-Coex-Mode-Info");
    return c.get<eutra_coex_tdd_info_s>();
  }
  const eutra_coex_fdd_info_s& fdd() const
  {
    assert_choice_type(types::fdd, type_, "EUTRA-Coex-Mode-Info");
    return c.get<eutra_coex_fdd_info_s>();
  }
  const eutra_coex_tdd_info_s& tdd() const
  {
    assert_choice_type(types::tdd, type_, "EUTRA-Coex-Mode-Info");
    return c.get<eutra_coex_tdd_info_s>();
  }
  eutra_coex_fdd_info_s& set_fdd();
  eutra_coex_tdd_info_s& set_tdd();

private:
  types                                                         type_;
  choice_buffer_t<eutra_coex_fdd_info_s, eutra_coex_tdd_info_s> c;

  void destroy_();
};

// EUTRA-FDD-Info-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using eutra_fdd_info_ext_ies_o = protocol_ext_empty_o;

using eutra_fdd_info_ext_ies_container = protocol_ext_container_empty_l;

// EUTRA-FDD-Info ::= SEQUENCE
struct eutra_fdd_info_s {
  bool                             ext                  = false;
  bool                             ie_exts_present      = false;
  uint16_t                         ul_offset_to_point_a = 0;
  uint16_t                         dl_offset_to_point_a = 0;
  eutra_fdd_info_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// EUTRA-TDD-Info-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using eutra_tdd_info_ext_ies_o = protocol_ext_empty_o;

// EUTRA-Mode-Info-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
using eutra_mode_info_ext_ies_o = protocol_ies_empty_o;

using eutra_tdd_info_ext_ies_container = protocol_ext_container_empty_l;

// EUTRA-TDD-Info ::= SEQUENCE
struct eutra_tdd_info_s {
  bool                             ext               = false;
  bool                             ie_exts_present   = false;
  uint16_t                         offset_to_point_a = 0;
  eutra_tdd_info_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// EUTRA-Mode-Info ::= CHOICE
struct eutra_mode_info_c {
  struct types_opts {
    enum options { eutra_fdd, eutra_tdd, choice_ext, nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  eutra_mode_info_c() = default;
  eutra_mode_info_c(const eutra_mode_info_c& other);
  eutra_mode_info_c& operator=(const eutra_mode_info_c& other);
  ~eutra_mode_info_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  eutra_fdd_info_s& eutra_fdd()
  {
    assert_choice_type(types::eutra_fdd, type_, "EUTRA-Mode-Info");
    return c.get<eutra_fdd_info_s>();
  }
  eutra_tdd_info_s& eutra_tdd()
  {
    assert_choice_type(types::eutra_tdd, type_, "EUTRA-Mode-Info");
    return c.get<eutra_tdd_info_s>();
  }
  protocol_ie_single_container_s<eutra_mode_info_ext_ies_o>& choice_ext()
  {
    assert_choice_type(types::choice_ext, type_, "EUTRA-Mode-Info");
    return c.get<protocol_ie_single_container_s<eutra_mode_info_ext_ies_o>>();
  }
  const eutra_fdd_info_s& eutra_fdd() const
  {
    assert_choice_type(types::eutra_fdd, type_, "EUTRA-Mode-Info");
    return c.get<eutra_fdd_info_s>();
  }
  const eutra_tdd_info_s& eutra_tdd() const
  {
    assert_choice_type(types::eutra_tdd, type_, "EUTRA-Mode-Info");
    return c.get<eutra_tdd_info_s>();
  }
  const protocol_ie_single_container_s<eutra_mode_info_ext_ies_o>& choice_ext() const
  {
    assert_choice_type(types::choice_ext, type_, "EUTRA-Mode-Info");
    return c.get<protocol_ie_single_container_s<eutra_mode_info_ext_ies_o>>();
  }
  eutra_fdd_info_s&                                          set_eutra_fdd();
  eutra_tdd_info_s&                                          set_eutra_tdd();
  protocol_ie_single_container_s<eutra_mode_info_ext_ies_o>& set_choice_ext();

private:
  types                                                                                                          type_;
  choice_buffer_t<eutra_fdd_info_s, eutra_tdd_info_s, protocol_ie_single_container_s<eutra_mode_info_ext_ies_o>> c;

  void destroy_();
};

// EUTRA-PRACH-Configuration-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using eutra_prach_cfg_ext_ies_o = protocol_ext_empty_o;

using eutra_prach_cfg_ext_ies_container = protocol_ext_container_empty_l;

// EUTRA-PRACH-Configuration ::= SEQUENCE
struct eutra_prach_cfg_s {
  bool                              ext                   = false;
  bool                              prach_cfg_idx_present = false;
  bool                              ie_exts_present       = false;
  uint16_t                          root_seq_idx          = 0;
  uint8_t                           zero_correlation_idx  = 0;
  bool                              high_speed_flag       = false;
  uint8_t                           prach_freq_offset     = 0;
  uint8_t                           prach_cfg_idx         = 0;
  eutra_prach_cfg_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// Served-EUTRA-Cell-Information-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using served_eutra_cell_info_ext_ies_o = protocol_ext_empty_o;

// EUTRACells-List-itemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using eutra_cells_list_item_ext_ies_o = protocol_ext_empty_o;

using served_eutra_cell_info_ext_ies_container = protocol_ext_container_empty_l;

// Served-EUTRA-Cells-Information ::= SEQUENCE
struct served_eutra_cells_info_s {
  bool                                     ext             = false;
  bool                                     ie_exts_present = false;
  eutra_mode_info_c                        eutra_mode_info;
  unbounded_octstring<true>                protected_eutra_res_ind;
  served_eutra_cell_info_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using eutra_cells_list_item_ext_ies_container = protocol_ext_container_empty_l;

// EUTRACells-List-item ::= SEQUENCE
struct eutra_cells_list_item_s {
  bool                                    ie_exts_present = false;
  fixed_bitstring<28, false, true>        eutra_cell_id;
  served_eutra_cells_info_s               served_eutra_cells_info;
  eutra_cells_list_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// EUTRACells-List ::= SEQUENCE (SIZE (1..256)) OF EUTRACells-List-item
using eutra_cells_list_l = dyn_array<eutra_cells_list_item_s>;

// ErrorIndicationIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct error_ind_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { transaction_id, gnb_cu_ue_f1ap_id, gnb_du_ue_f1ap_id, cause, crit_diagnostics, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint16_t&                 transaction_id();
    uint64_t&                 gnb_cu_ue_f1ap_id();
    uint64_t&                 gnb_du_ue_f1ap_id();
    cause_c&                  cause();
    crit_diagnostics_s&       crit_diagnostics();
    const uint16_t&           transaction_id() const;
    const uint64_t&           gnb_cu_ue_f1ap_id() const;
    const uint64_t&           gnb_du_ue_f1ap_id() const;
    const cause_c&            cause() const;
    const crit_diagnostics_s& crit_diagnostics() const;

  private:
    types                                        type_;
    choice_buffer_t<cause_c, crit_diagnostics_s> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

struct error_ind_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                                      gnb_cu_ue_f1ap_id_present = false;
  bool                                                      gnb_du_ue_f1ap_id_present = false;
  bool                                                      cause_present             = false;
  bool                                                      crit_diagnostics_present  = false;
  ie_field_s<integer<uint16_t, 0, 255, true, true>>         transaction_id;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_cu_ue_f1ap_id;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_du_ue_f1ap_id;
  ie_field_s<cause_c>                                       cause;
  ie_field_s<crit_diagnostics_s>                            crit_diagnostics;

  // sequence methods
  error_ind_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// ErrorIndication ::= SEQUENCE
using error_ind_s = elementary_procedure_option<error_ind_ies_container>;

// Extended-GNB-CU-Name-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using extended_gnb_cu_name_ext_ies_o = protocol_ext_empty_o;

using extended_gnb_cu_name_ext_ies_container = protocol_ext_container_empty_l;

// Extended-GNB-CU-Name ::= SEQUENCE
struct extended_gnb_cu_name_s {
  bool                                   ext                                = false;
  bool                                   gnb_cu_name_visible_string_present = false;
  bool                                   gnb_cu_name_utf8_string_present    = false;
  bool                                   ie_exts_present                    = false;
  visible_string<1, 150, true, true>     gnb_cu_name_visible_string;
  utf8_string<1, 150, true, true>        gnb_cu_name_utf8_string;
  extended_gnb_cu_name_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// Extended-GNB-DU-Name-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using extended_gnb_du_name_ext_ies_o = protocol_ext_empty_o;

using extended_gnb_du_name_ext_ies_container = protocol_ext_container_empty_l;

// Extended-GNB-DU-Name ::= SEQUENCE
struct extended_gnb_du_name_s {
  bool                                   ext                                = false;
  bool                                   gnb_du_name_visible_string_present = false;
  bool                                   gnb_du_name_utf8_string_present    = false;
  bool                                   ie_exts_present                    = false;
  visible_string<1, 150, true, true>     gnb_du_name_visible_string;
  utf8_string<1, 150, true, true>        gnb_du_name_utf8_string;
  extended_gnb_du_name_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// ExtendedAdditionalPathList-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using extended_add_path_list_item_ext_ies_o = protocol_ext_empty_o;

using extended_add_path_list_item_ext_ies_container = protocol_ext_container_empty_l;

// ExtendedAdditionalPathList-Item ::= SEQUENCE
struct extended_add_path_list_item_s {
  bool                                          ext                      = false;
  bool                                          path_quality_present     = false;
  bool                                          multiple_ul_ao_a_present = false;
  bool                                          path_pwr_present         = false;
  bool                                          ie_exts_present          = false;
  relative_path_delay_c                         relative_time_of_path;
  trp_meas_quality_s                            path_quality;
  multiple_ul_ao_a_s                            multiple_ul_ao_a;
  ul_srs_rsrp_p_s                               path_pwr;
  extended_add_path_list_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// ExtendedAdditionalPathList ::= SEQUENCE (SIZE (1..8)) OF ExtendedAdditionalPathList-Item
using extended_add_path_list_l = dyn_array<extended_add_path_list_item_s>;

// SliceSupportItem-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using slice_support_item_ext_ies_o = protocol_ext_empty_o;

using slice_support_item_ext_ies_container = protocol_ext_container_empty_l;

// SliceSupportItem ::= SEQUENCE
struct slice_support_item_s {
  bool                                 ie_exts_present = false;
  snssai_s                             snssai;
  slice_support_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// ExtendedSliceSupportList ::= SEQUENCE (SIZE (1..65535)) OF SliceSupportItem
using extended_slice_support_list_l = dyn_array<slice_support_item_s>;

// NSAGSupportItem-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using nsag_support_item_ext_ies_o = protocol_ext_empty_o;

// NPNSupportInfo-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
using npn_support_info_ext_ies_o = protocol_ies_empty_o;

using nsag_support_item_ext_ies_container = protocol_ext_container_empty_l;

// NSAGSupportItem ::= SEQUENCE
struct nsag_support_item_s {
  bool                                ext             = false;
  bool                                ie_exts_present = false;
  uint16_t                            nsag_id         = 0;
  extended_slice_support_list_l       nsag_slice_support;
  nsag_support_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// NPNSupportInfo ::= CHOICE
struct npn_support_info_c {
  struct types_opts {
    enum options { sn_pn_info, choice_ext, nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  npn_support_info_c() = default;
  npn_support_info_c(const npn_support_info_c& other);
  npn_support_info_c& operator=(const npn_support_info_c& other);
  ~npn_support_info_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  fixed_bitstring<44, false, true>& sn_pn_info()
  {
    assert_choice_type(types::sn_pn_info, type_, "NPNSupportInfo");
    return c.get<fixed_bitstring<44, false, true>>();
  }
  protocol_ie_single_container_s<npn_support_info_ext_ies_o>& choice_ext()
  {
    assert_choice_type(types::choice_ext, type_, "NPNSupportInfo");
    return c.get<protocol_ie_single_container_s<npn_support_info_ext_ies_o>>();
  }
  const fixed_bitstring<44, false, true>& sn_pn_info() const
  {
    assert_choice_type(types::sn_pn_info, type_, "NPNSupportInfo");
    return c.get<fixed_bitstring<44, false, true>>();
  }
  const protocol_ie_single_container_s<npn_support_info_ext_ies_o>& choice_ext() const
  {
    assert_choice_type(types::choice_ext, type_, "NPNSupportInfo");
    return c.get<protocol_ie_single_container_s<npn_support_info_ext_ies_o>>();
  }
  fixed_bitstring<44, false, true>&                           set_sn_pn_info();
  protocol_ie_single_container_s<npn_support_info_ext_ies_o>& set_choice_ext();

private:
  types                                                                                                         type_;
  choice_buffer_t<fixed_bitstring<44, false, true>, protocol_ie_single_container_s<npn_support_info_ext_ies_o>> c;

  void destroy_();
};

// NSAGSupportList ::= SEQUENCE (SIZE (1..256)) OF NSAGSupportItem
using nsag_support_list_l = dyn_array<nsag_support_item_s>;

// ExtendedServedPLMNs-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
struct extended_served_plmns_item_ext_ies_o {
  // Extension ::= OPEN TYPE
  struct ext_c {
    struct types_opts {
      enum options { npn_support_info, extended_tai_slice_support_list, tai_nsag_support_list, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    ext_c() = default;
    ext_c(const ext_c& other);
    ext_c& operator=(const ext_c& other);
    ~ext_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    npn_support_info_c&                  npn_support_info();
    extended_slice_support_list_l&       extended_tai_slice_support_list();
    nsag_support_list_l&                 tai_nsag_support_list();
    const npn_support_info_c&            npn_support_info() const;
    const extended_slice_support_list_l& extended_tai_slice_support_list() const;
    const nsag_support_list_l&           tai_nsag_support_list() const;

  private:
    types                                                                                   type_;
    choice_buffer_t<extended_slice_support_list_l, npn_support_info_c, nsag_support_list_l> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static ext_c      get_ext(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// SliceSupportList ::= SEQUENCE (SIZE (1..1024)) OF SliceSupportItem
using slice_support_list_l = dyn_array<slice_support_item_s>;

struct extended_served_plmns_item_ext_ies_container {
  template <class extT_>
  using ie_field_s = protocol_ext_container_item_s<extT_>;

  // member variables
  bool                                                         npn_support_info_present                = false;
  bool                                                         extended_tai_slice_support_list_present = false;
  bool                                                         tai_nsag_support_list_present           = false;
  ie_field_s<npn_support_info_c>                               npn_support_info;
  ie_field_s<dyn_seq_of<slice_support_item_s, 1, 65535, true>> extended_tai_slice_support_list;
  ie_field_s<dyn_seq_of<nsag_support_item_s, 1, 256, true>>    tai_nsag_support_list;

  // sequence methods
  extended_served_plmns_item_ext_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// ExtendedServedPLMNs-Item ::= SEQUENCE
struct extended_served_plmns_item_s {
  bool                                         ext             = false;
  bool                                         ie_exts_present = false;
  fixed_octstring<3, true>                     plmn_id;
  slice_support_list_l                         tai_slice_support_list;
  extended_served_plmns_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// ExtendedServedPLMNs-List ::= SEQUENCE (SIZE (1..6)) OF ExtendedServedPLMNs-Item
using extended_served_plmns_list_l = dyn_array<extended_served_plmns_item_s>;

// PRSResource-QCLSourcePRS-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using prs_res_qcl_source_prs_ext_ies_o = protocol_ext_empty_o;

// PRSResource-QCLSourceSSB-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using prs_res_qcl_source_ssb_ext_ies_o = protocol_ext_empty_o;

// NumDLULSymbols-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
struct num_dl_ul_symbols_ext_ies_o {
  // Extension ::= OPEN TYPE
  struct ext_c {
    struct types_opts {
      enum options { permutation, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::permutation; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    permutation_e&       permutation() { return c; }
    const permutation_e& permutation() const { return c; }

  private:
    permutation_e c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static ext_c      get_ext(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// PRSAngleItem-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
struct prs_angle_item_item_ext_ies_o {
  // Extension ::= OPEN TYPE
  struct ext_c {
    struct types_opts {
      enum options { prs_res_id, nulltype } value;
      typedef uint8_t number_type;

      const char* to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::prs_res_id; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint8_t&       prs_res_id() { return c; }
    const uint8_t& prs_res_id() const { return c; }

  private:
    uint8_t c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static ext_c      get_ext(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// PRSResource-QCLInfo-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
using prs_res_qcl_info_ext_ies_o = protocol_ies_empty_o;

using prs_res_qcl_source_prs_ext_ies_container = protocol_ext_container_empty_l;

// PRSResource-QCLSourcePRS ::= SEQUENCE
struct prs_res_qcl_source_prs_s {
  bool                                     qcl_source_prs_res_id_present = false;
  bool                                     ie_exts_present               = false;
  uint8_t                                  qcl_source_prs_res_set_id     = 0;
  uint8_t                                  qcl_source_prs_res_id         = 0;
  prs_res_qcl_source_prs_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using prs_res_qcl_source_ssb_ext_ies_container = protocol_ext_container_empty_l;

// PRSResource-QCLSourceSSB ::= SEQUENCE
struct prs_res_qcl_source_ssb_s {
  bool                                     ext             = false;
  bool                                     ssb_idx_present = false;
  bool                                     ie_exts_present = false;
  uint16_t                                 pci_nr          = 0;
  uint8_t                                  ssb_idx         = 0;
  prs_res_qcl_source_ssb_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// NumDLULSymbols ::= SEQUENCE
struct num_dl_ul_symbols_s {
  uint8_t                                               num_dl_symbols = 0;
  uint8_t                                               num_ul_symbols = 0;
  protocol_ext_container_l<num_dl_ul_symbols_ext_ies_o> ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PRSAngleItem ::= SEQUENCE
struct prs_angle_item_s {
  uint16_t                                                nr_prs_azimuth        = 0;
  uint8_t                                                 nr_prs_azimuth_fine   = 0;
  uint8_t                                                 nr_prs_elevation      = 0;
  uint8_t                                                 nr_prs_elevation_fine = 0;
  protocol_ext_container_l<prs_angle_item_item_ext_ies_o> ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PRSMutingOption1-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using prs_muting_option1_ext_ies_o = protocol_ext_empty_o;

// PRSMutingOption2-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using prs_muting_option2_ext_ies_o = protocol_ext_empty_o;

// PRSResource-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using prs_res_item_ext_ies_o = protocol_ext_empty_o;

// PRSResource-QCLInfo ::= CHOICE
struct prs_res_qcl_info_c {
  struct types_opts {
    enum options { qcl_source_ssb, qcl_source_prs, choice_ext, nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  prs_res_qcl_info_c() = default;
  prs_res_qcl_info_c(const prs_res_qcl_info_c& other);
  prs_res_qcl_info_c& operator=(const prs_res_qcl_info_c& other);
  ~prs_res_qcl_info_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  prs_res_qcl_source_ssb_s& qcl_source_ssb()
  {
    assert_choice_type(types::qcl_source_ssb, type_, "PRSResource-QCLInfo");
    return c.get<prs_res_qcl_source_ssb_s>();
  }
  prs_res_qcl_source_prs_s& qcl_source_prs()
  {
    assert_choice_type(types::qcl_source_prs, type_, "PRSResource-QCLInfo");
    return c.get<prs_res_qcl_source_prs_s>();
  }
  protocol_ie_single_container_s<prs_res_qcl_info_ext_ies_o>& choice_ext()
  {
    assert_choice_type(types::choice_ext, type_, "PRSResource-QCLInfo");
    return c.get<protocol_ie_single_container_s<prs_res_qcl_info_ext_ies_o>>();
  }
  const prs_res_qcl_source_ssb_s& qcl_source_ssb() const
  {
    assert_choice_type(types::qcl_source_ssb, type_, "PRSResource-QCLInfo");
    return c.get<prs_res_qcl_source_ssb_s>();
  }
  const prs_res_qcl_source_prs_s& qcl_source_prs() const
  {
    assert_choice_type(types::qcl_source_prs, type_, "PRSResource-QCLInfo");
    return c.get<prs_res_qcl_source_prs_s>();
  }
  const protocol_ie_single_container_s<prs_res_qcl_info_ext_ies_o>& choice_ext() const
  {
    assert_choice_type(types::choice_ext, type_, "PRSResource-QCLInfo");
    return c.get<protocol_ie_single_container_s<prs_res_qcl_info_ext_ies_o>>();
  }
  prs_res_qcl_source_ssb_s&                                   set_qcl_source_ssb();
  prs_res_qcl_source_prs_s&                                   set_qcl_source_prs();
  protocol_ie_single_container_s<prs_res_qcl_info_ext_ies_o>& set_choice_ext();

private:
  types type_;
  choice_buffer_t<protocol_ie_single_container_s<prs_res_qcl_info_ext_ies_o>,
                  prs_res_qcl_source_prs_s,
                  prs_res_qcl_source_ssb_s>
      c;

  void destroy_();
};

// SymbolAllocInSlot-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
using symbol_alloc_in_slot_ext_ies_o = protocol_ies_empty_o;

// LCStoGCSTranslation-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using lc_sto_gcs_translation_ext_ies_o = protocol_ext_empty_o;

// NR-PRSBeamInformationItem-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using nr_prs_beam_info_item_ext_ies_o = protocol_ext_empty_o;

// PRSAngleList ::= SEQUENCE (SIZE (1..64)) OF PRSAngleItem
using prs_angle_list_l = dyn_array<prs_angle_item_s>;

// PRSMuting-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using prs_muting_ext_ies_o = protocol_ext_empty_o;

using prs_muting_option1_ext_ies_container = protocol_ext_container_empty_l;

// PRSMutingOption1 ::= SEQUENCE
struct prs_muting_option1_s {
  struct muting_bit_repeat_factor_opts {
    enum options { rf1, rf2, rf4, rf8, /*...*/ nulltype } value;
    typedef uint8_t number_type;

    const char* to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<muting_bit_repeat_factor_opts, true> muting_bit_repeat_factor_e_;

  // member variables
  bool                                 ie_exts_present = false;
  dl_prs_muting_pattern_c              muting_pattern;
  muting_bit_repeat_factor_e_          muting_bit_repeat_factor;
  prs_muting_option1_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using prs_muting_option2_ext_ies_container = protocol_ext_container_empty_l;

// PRSMutingOption2 ::= SEQUENCE
struct prs_muting_option2_s {
  bool                                 ie_exts_present = false;
  dl_prs_muting_pattern_c              muting_pattern;
  prs_muting_option2_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using prs_res_item_ext_ies_container = protocol_ext_container_empty_l;

// PRSResource-Item ::= SEQUENCE
struct prs_res_item_s {
  bool                           qcl_info_present  = false;
  bool                           ie_exts_present   = false;
  uint8_t                        prs_res_id        = 0;
  uint16_t                       seq_id            = 0;
  uint8_t                        re_offset         = 0;
  uint16_t                       res_slot_offset   = 0;
  uint8_t                        res_symbol_offset = 0;
  prs_res_qcl_info_c             qcl_info;
  prs_res_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RxTxTimingErrorMargin ::= ENUMERATED
struct rx_tx_timing_error_margin_opts {
  enum options {
    tc0dot5,
    tc1,
    tc2,
    tc4,
    tc8,
    tc12,
    tc16,
    tc20,
    tc24,
    tc32,
    tc40,
    tc48,
    tc64,
    tc80,
    tc96,
    tc128,
    // ...
    nulltype
  } value;
  typedef float number_type;

  const char* to_string() const;
  float       to_number() const;
  const char* to_number_string() const;
};
typedef enumerated<rx_tx_timing_error_margin_opts, true> rx_tx_timing_error_margin_e;

// SSB-TF-Configuration-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using ssb_tf_cfg_ext_ies_o = protocol_ext_empty_o;

// Slot-Configuration-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using slot_cfg_item_ext_ies_o = protocol_ext_empty_o;

// SymbolAllocInSlot ::= CHOICE
struct symbol_alloc_in_slot_c {
  struct types_opts {
    enum options { all_dl, all_ul, both_dl_and_ul, choice_ext, nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  symbol_alloc_in_slot_c() = default;
  symbol_alloc_in_slot_c(const symbol_alloc_in_slot_c& other);
  symbol_alloc_in_slot_c& operator=(const symbol_alloc_in_slot_c& other);
  ~symbol_alloc_in_slot_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  num_dl_ul_symbols_s& both_dl_and_ul()
  {
    assert_choice_type(types::both_dl_and_ul, type_, "SymbolAllocInSlot");
    return c.get<num_dl_ul_symbols_s>();
  }
  protocol_ie_single_container_s<symbol_alloc_in_slot_ext_ies_o>& choice_ext()
  {
    assert_choice_type(types::choice_ext, type_, "SymbolAllocInSlot");
    return c.get<protocol_ie_single_container_s<symbol_alloc_in_slot_ext_ies_o>>();
  }
  const num_dl_ul_symbols_s& both_dl_and_ul() const
  {
    assert_choice_type(types::both_dl_and_ul, type_, "SymbolAllocInSlot");
    return c.get<num_dl_ul_symbols_s>();
  }
  const protocol_ie_single_container_s<symbol_alloc_in_slot_ext_ies_o>& choice_ext() const
  {
    assert_choice_type(types::choice_ext, type_, "SymbolAllocInSlot");
    return c.get<protocol_ie_single_container_s<symbol_alloc_in_slot_ext_ies_o>>();
  }
  void                                                            set_all_dl();
  void                                                            set_all_ul();
  num_dl_ul_symbols_s&                                            set_both_dl_and_ul();
  protocol_ie_single_container_s<symbol_alloc_in_slot_ext_ies_o>& set_choice_ext();

private:
  types                                                                                                type_;
  choice_buffer_t<num_dl_ul_symbols_s, protocol_ie_single_container_s<symbol_alloc_in_slot_ext_ies_o>> c;

  void destroy_();
};

// TRP-Rx-TEGInformation-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using trp_rx_teg_info_ext_ies_o = protocol_ext_empty_o;

// TRP-RxTx-TEGInformation-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using trp_rx_tx_teg_info_ext_ies_o = protocol_ext_empty_o;

// TRP-Tx-TEGInformation-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using trp_tx_teg_info_ext_ies_o = protocol_ext_empty_o;

// TimingErrorMargin ::= ENUMERATED
struct timing_error_margin_opts {
  enum options {
    m0_tc,
    m2_tc,
    m4_tc,
    m6_tc,
    m8_tc,
    m12_tc,
    m16_tc,
    m20_tc,
    m24_tc,
    m32_tc,
    m40_tc,
    m48_tc,
    m56_tc,
    m64_tc,
    m72_tc,
    m80_tc,
    // ...
    nulltype
  } value;
  typedef uint8_t number_type;

  const char* to_string() const;
  uint8_t     to_number() const;
};
typedef enumerated<timing_error_margin_opts, true> timing_error_margin_e;

using lc_sto_gcs_translation_ext_ies_container = protocol_ext_container_empty_l;

// LCStoGCSTranslation ::= SEQUENCE
struct lc_sto_gcs_translation_s {
  bool                                     alpha_fine_present = false;
  bool                                     beta_fine_present  = false;
  bool                                     gamma_fine_present = false;
  bool                                     ie_exts_present    = false;
  uint16_t                                 alpha              = 0;
  uint8_t                                  alpha_fine         = 0;
  uint16_t                                 beta               = 0;
  uint8_t                                  beta_fine          = 0;
  uint16_t                                 gamma              = 0;
  uint8_t                                  gamma_fine         = 0;
  lc_sto_gcs_translation_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using nr_prs_beam_info_item_ext_ies_container = protocol_ext_container_empty_l;

// NR-PRSBeamInformationItem ::= SEQUENCE
struct nr_prs_beam_info_item_s {
  bool                                    ie_exts_present = false;
  uint8_t                                 prs_res_set_id  = 0;
  prs_angle_list_l                        prs_angle_list;
  nr_prs_beam_info_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using prs_muting_ext_ies_container = protocol_ext_container_empty_l;

// PRSMuting ::= SEQUENCE
struct prs_muting_s {
  bool                         prs_muting_option1_present = false;
  bool                         prs_muting_option2_present = false;
  bool                         ie_exts_present            = false;
  prs_muting_option1_s         prs_muting_option1;
  prs_muting_option2_s         prs_muting_option2;
  prs_muting_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PRSResource-List ::= SEQUENCE (SIZE (1..64)) OF PRSResource-Item
using prs_res_list_l = dyn_array<prs_res_item_s>;

// PRSResourceSet-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using prs_res_set_item_ext_ies_o = protocol_ext_empty_o;

// RxTEG-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using rx_teg_ext_ies_o = protocol_ext_empty_o;

// RxTxTEG-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using rx_tx_teg_ext_ies_o = protocol_ext_empty_o;

using ssb_tf_cfg_ext_ies_container = protocol_ext_container_empty_l;

// SSB-TF-Configuration ::= SEQUENCE
struct ssb_tf_cfg_s {
  struct ssb_subcarrier_spacing_opts {
    enum options { khz15, khz30, khz60, khz120, khz240, /*...*/ nulltype } value;
    typedef uint8_t number_type;

    const char* to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<ssb_subcarrier_spacing_opts, true> ssb_subcarrier_spacing_e_;
  struct ssb_periodicity_opts {
    enum options { ms5, ms10, ms20, ms40, ms80, ms160, /*...*/ nulltype } value;
    typedef uint8_t number_type;

    const char* to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<ssb_periodicity_opts, true> ssb_periodicity_e_;

  // member variables
  bool                             ssb_position_in_burst_present = false;
  bool                             sfn_initisation_time_present  = false;
  bool                             ie_exts_present               = false;
  uint32_t                         ssb_freq                      = 0;
  ssb_subcarrier_spacing_e_        ssb_subcarrier_spacing;
  int8_t                           ssb_tx_pwr = -60;
  ssb_periodicity_e_               ssb_periodicity;
  uint8_t                          ssb_half_frame_offset = 0;
  uint8_t                          ssb_sfn_offset        = 0;
  ssb_positions_in_burst_c         ssb_position_in_burst;
  fixed_bitstring<64, false, true> sfn_initisation_time;
  ssb_tf_cfg_ext_ies_container     ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SSBInformationItem-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using ssb_info_item_ext_ies_o = protocol_ext_empty_o;

using slot_cfg_item_ext_ies_container = protocol_ext_container_empty_l;

// Slot-Configuration-Item ::= SEQUENCE
struct slot_cfg_item_s {
  bool                            ie_exts_present = false;
  uint16_t                        slot_idx        = 0;
  symbol_alloc_in_slot_c          symbol_alloc_in_slot;
  slot_cfg_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using trp_rx_teg_info_ext_ies_container = protocol_ext_container_empty_l;

// TRP-Rx-TEGInformation ::= SEQUENCE
struct trp_rx_teg_info_s {
  bool                              ext             = false;
  bool                              ie_exts_present = false;
  uint8_t                           trp_rx_teg_id   = 0;
  timing_error_margin_e             trp_rx_timing_error_margin;
  trp_rx_teg_info_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using trp_rx_tx_teg_info_ext_ies_container = protocol_ext_container_empty_l;

// TRP-RxTx-TEGInformation ::= SEQUENCE
struct trp_rx_tx_teg_info_s {
  bool                                 ext              = false;
  bool                                 ie_exts_present  = false;
  uint16_t                             trp_rx_tx_teg_id = 0;
  rx_tx_timing_error_margin_e          trp_rx_tx_timing_error_margin;
  trp_rx_tx_teg_info_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using trp_tx_teg_info_ext_ies_container = protocol_ext_container_empty_l;

// TRP-Tx-TEGInformation ::= SEQUENCE
struct trp_tx_teg_info_s {
  bool                              ext             = false;
  bool                              ie_exts_present = false;
  uint8_t                           trp_tx_teg_id   = 0;
  timing_error_margin_e             trp_tx_timing_error_margin;
  trp_tx_teg_info_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// TRPTEGItem-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using trpteg_item_ext_ies_o = protocol_ext_empty_o;

// IntendedTDD-DL-ULConfig-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using intended_tdd_dl_ul_cfg_ext_ies_o = protocol_ext_empty_o;

// LCStoGCSTranslationList ::= SEQUENCE (SIZE (1..3)) OF LCStoGCSTranslation
using lc_sto_gcs_translation_list_l = dyn_array<lc_sto_gcs_translation_s>;

// NR-PRSBeamInformation-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using nr_prs_beam_info_ext_ies_o = protocol_ext_empty_o;

// NR-PRSBeamInformationList ::= SEQUENCE (SIZE (1..2)) OF NR-PRSBeamInformationItem
using nr_prs_beam_info_list_l = dyn_array<nr_prs_beam_info_item_s>;

// NR-U-Channel-Info-List-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using nr_u_ch_info_list_ext_ies_o = protocol_ext_empty_o;

// OnDemandPRS-Info-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using on_demand_prs_info_ext_ies_o = protocol_ext_empty_o;

using prs_res_set_item_ext_ies_container = protocol_ext_container_empty_l;

// PRSResourceSet-Item ::= SEQUENCE
struct prs_res_set_item_s {
  struct subcarrier_spacing_opts {
    enum options { khz15, khz30, khz60, khz120, /*...*/ nulltype } value;
    typedef uint8_t number_type;

    const char* to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<subcarrier_spacing_opts, true> subcarrier_spacing_e_;
  struct comb_size_opts {
    enum options { n2, n4, n6, n12, /*...*/ nulltype } value;
    typedef uint8_t number_type;

    const char* to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<comb_size_opts, true> comb_size_e_;
  struct cp_type_opts {
    enum options { normal, extended, /*...*/ nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<cp_type_opts, true> cp_type_e_;
  struct res_set_periodicity_opts {
    enum options {
      n4,
      n5,
      n8,
      n10,
      n16,
      n20,
      n32,
      n40,
      n64,
      n80,
      n160,
      n320,
      n640,
      n1280,
      n2560,
      n5120,
      n10240,
      n20480,
      n40960,
      n81920,
      // ...
      nulltype
    } value;
    typedef uint32_t number_type;

    const char* to_string() const;
    uint32_t    to_number() const;
  };
  typedef enumerated<res_set_periodicity_opts, true> res_set_periodicity_e_;
  struct res_repeat_factor_opts {
    enum options { rf1, rf2, rf4, rf6, rf8, rf16, rf32, /*...*/ nulltype } value;
    typedef uint8_t number_type;

    const char* to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<res_repeat_factor_opts, true> res_repeat_factor_e_;
  struct res_time_gap_opts {
    enum options { tg1, tg2, tg4, tg8, tg16, tg32, /*...*/ nulltype } value;
    typedef uint8_t number_type;

    const char* to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<res_time_gap_opts, true> res_time_gap_e_;
  struct res_numof_symbols_opts {
    enum options { n2, n4, n6, n12, /*...*/ nulltype } value;
    typedef uint8_t number_type;

    const char* to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<res_numof_symbols_opts, true> res_numof_symbols_e_;

  // member variables
  bool                               prs_muting_present = false;
  bool                               ie_exts_present    = false;
  uint8_t                            prs_res_set_id     = 0;
  subcarrier_spacing_e_              subcarrier_spacing;
  uint8_t                            pr_sbw    = 1;
  uint16_t                           start_prb = 0;
  uint32_t                           point_a   = 0;
  comb_size_e_                       comb_size;
  cp_type_e_                         cp_type;
  res_set_periodicity_e_             res_set_periodicity;
  uint32_t                           res_set_slot_offset = 0;
  res_repeat_factor_e_               res_repeat_factor;
  res_time_gap_e_                    res_time_gap;
  res_numof_symbols_e_               res_numof_symbols;
  prs_muting_s                       prs_muting;
  int8_t                             prs_res_tx_pwr = -60;
  prs_res_list_l                     prs_res_list;
  prs_res_set_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// ReferenceSignal-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
using ref_sig_ext_ies_o = protocol_ies_empty_o;

using rx_teg_ext_ies_container = protocol_ext_container_empty_l;

// RxTEG ::= SEQUENCE
struct rx_teg_s {
  bool                     ext             = false;
  bool                     ie_exts_present = false;
  trp_rx_teg_info_s        trp_rx_teg_info;
  trp_tx_teg_info_s        trp_tx_teg_info;
  rx_teg_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using rx_tx_teg_ext_ies_container = protocol_ext_container_empty_l;

// RxTxTEG ::= SEQUENCE
struct rx_tx_teg_s {
  bool                        ext                     = false;
  bool                        trp_tx_teg_info_present = false;
  bool                        ie_exts_present         = false;
  trp_rx_tx_teg_info_s        trp_rx_tx_teg_info;
  trp_tx_teg_info_s           trp_tx_teg_info;
  rx_tx_teg_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using ssb_info_item_ext_ies_container = protocol_ext_container_empty_l;

// SSBInformationItem ::= SEQUENCE
struct ssb_info_item_s {
  bool                            ie_exts_present = false;
  ssb_tf_cfg_s                    ssb_cfg;
  uint16_t                        pci_nr = 0;
  ssb_info_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// Slot-Configuration-List ::= SEQUENCE (SIZE (1..5120)) OF Slot-Configuration-Item
using slot_cfg_list_l = dyn_array<slot_cfg_item_s>;

// TRPBeamAntennaInformation-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using trp_beam_ant_info_ext_ies_o = protocol_ext_empty_o;

using trpteg_item_ext_ies_container = protocol_ext_container_empty_l;

// TRPTEG-Item ::= SEQUENCE
struct trpteg_item_s {
  using dl_prs_res_id_list_l_ = dyn_array<dl_prs_res_id_item_s>;

  // member variables
  bool                          ext             = false;
  bool                          ie_exts_present = false;
  trp_tx_teg_info_s             trp_tx_teg_info;
  uint8_t                       dl_prs_res_set_id = 0;
  dl_prs_res_id_list_l_         dl_prs_res_id_list;
  trpteg_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// TRPTEGInformation-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
using trpteg_info_ext_ies_o = protocol_ies_empty_o;

// GNBRxTxTimeDiffMeas-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
using gnb_rx_tx_time_diff_meas_ext_ies_o = protocol_ies_empty_o;

using intended_tdd_dl_ul_cfg_ext_ies_container = protocol_ext_container_empty_l;

// IntendedTDD-DL-ULConfig ::= SEQUENCE
struct intended_tdd_dl_ul_cfg_s {
  struct nr_scs_opts {
    enum options { scs15, scs30, scs60, scs120, /*...*/ scs480, scs960, nulltype } value;
    typedef uint16_t number_type;

    const char* to_string() const;
    uint16_t    to_number() const;
  };
  typedef enumerated<nr_scs_opts, true, 2> nr_scs_e_;
  struct nr_cp_opts {
    enum options { normal, extended, /*...*/ nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<nr_cp_opts, true> nr_cp_e_;
  struct nr_dl_ul_tx_periodicity_opts {
    enum options {
      ms0p5,
      ms0p625,
      ms1,
      ms1p25,
      ms2,
      ms2p5,
      ms3,
      ms4,
      ms5,
      ms10,
      ms20,
      ms40,
      ms60,
      ms80,
      ms100,
      ms120,
      ms140,
      ms160,
      // ...
      nulltype
    } value;

    const char* to_string() const;
  };
  typedef enumerated<nr_dl_ul_tx_periodicity_opts, true> nr_dl_ul_tx_periodicity_e_;

  // member variables
  bool                                     ie_exts_present = false;
  nr_scs_e_                                nr_scs;
  nr_cp_e_                                 nr_cp;
  nr_dl_ul_tx_periodicity_e_               nr_dl_ul_tx_periodicity;
  slot_cfg_list_l                          slot_cfg_list;
  intended_tdd_dl_ul_cfg_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using nr_prs_beam_info_ext_ies_container = protocol_ext_container_empty_l;

// NR-PRSBeamInformation ::= SEQUENCE
struct nr_prs_beam_info_s {
  bool                               ie_exts_present = false;
  nr_prs_beam_info_list_l            nr_prs_beam_info_list;
  lc_sto_gcs_translation_list_l      lc_sto_gcs_translation_list;
  nr_prs_beam_info_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using nr_u_ch_info_list_ext_ies_container = protocol_ext_container_empty_l;

// NR-U-Channel-Info-Item ::= SEQUENCE
struct nr_u_ch_info_item_s {
  struct bw_opts {
    enum options { mhz_neg10, mhz_neg20, mhz_neg40, mhz_neg60, mhz_neg80, /*...*/ nulltype } value;
    typedef int8_t number_type;

    const char* to_string() const;
    int8_t      to_number() const;
  };
  typedef enumerated<bw_opts, true> bw_e_;

  // member variables
  bool                                ext             = false;
  bool                                ie_exts_present = false;
  uint8_t                             nr_u_ch_id      = 1;
  uint32_t                            nr_arfcn        = 0;
  bw_e_                               bw;
  nr_u_ch_info_list_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// NonDynamicPQIDescriptor-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using non_dyn_pq_id_escriptor_ext_ies_o = protocol_ext_empty_o;

using on_demand_prs_info_ext_ies_container = protocol_ext_container_empty_l;

// OnDemandPRS-Info ::= SEQUENCE
struct on_demand_prs_info_s {
  bool                                 ext                                        = false;
  bool                                 allowed_res_set_periodicity_values_present = false;
  bool                                 allowed_prs_bw_values_present              = false;
  bool                                 allowed_res_repeat_factor_values_present   = false;
  bool                                 allowed_res_nof_symbols_values_present     = false;
  bool                                 allowed_comb_size_values_present           = false;
  bool                                 ie_exts_present                            = false;
  fixed_bitstring<16, false, true>     on_demand_prs_request_allowed;
  fixed_bitstring<24, false, true>     allowed_res_set_periodicity_values;
  fixed_bitstring<64, false, true>     allowed_prs_bw_values;
  fixed_bitstring<8, false, true>      allowed_res_repeat_factor_values;
  fixed_bitstring<8, false, true>      allowed_res_nof_symbols_values;
  fixed_bitstring<8, false, true>      allowed_comb_size_values;
  on_demand_prs_info_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PRSConfiguration-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using prs_cfg_ext_ies_o = protocol_ext_empty_o;

// PRSResourceSet-List ::= SEQUENCE (SIZE (1..8)) OF PRSResourceSet-Item
using prs_res_set_list_l = dyn_array<prs_res_set_item_s>;

// PRSTransmissionOffIndicationPerResource-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using prs_tx_off_ind_per_res_item_ext_ies_o = protocol_ext_empty_o;

// PosSRSInfo ::= SEQUENCE
struct pos_srs_info_s {
  bool    ext            = false;
  uint8_t pos_srs_res_id = 0;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// ReferenceSignal ::= CHOICE
struct ref_sig_c {
  struct types_opts {
    enum options { nzp_csi_rs, ssb, srs, positioning_srs, dl_prs, choice_ext, nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  ref_sig_c() = default;
  ref_sig_c(const ref_sig_c& other);
  ref_sig_c& operator=(const ref_sig_c& other);
  ~ref_sig_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  uint8_t& nzp_csi_rs()
  {
    assert_choice_type(types::nzp_csi_rs, type_, "ReferenceSignal");
    return c.get<uint8_t>();
  }
  ssb_s& ssb()
  {
    assert_choice_type(types::ssb, type_, "ReferenceSignal");
    return c.get<ssb_s>();
  }
  uint8_t& srs()
  {
    assert_choice_type(types::srs, type_, "ReferenceSignal");
    return c.get<uint8_t>();
  }
  uint8_t& positioning_srs()
  {
    assert_choice_type(types::positioning_srs, type_, "ReferenceSignal");
    return c.get<uint8_t>();
  }
  dl_prs_s& dl_prs()
  {
    assert_choice_type(types::dl_prs, type_, "ReferenceSignal");
    return c.get<dl_prs_s>();
  }
  protocol_ie_single_container_s<ref_sig_ext_ies_o>& choice_ext()
  {
    assert_choice_type(types::choice_ext, type_, "ReferenceSignal");
    return c.get<protocol_ie_single_container_s<ref_sig_ext_ies_o>>();
  }
  const uint8_t& nzp_csi_rs() const
  {
    assert_choice_type(types::nzp_csi_rs, type_, "ReferenceSignal");
    return c.get<uint8_t>();
  }
  const ssb_s& ssb() const
  {
    assert_choice_type(types::ssb, type_, "ReferenceSignal");
    return c.get<ssb_s>();
  }
  const uint8_t& srs() const
  {
    assert_choice_type(types::srs, type_, "ReferenceSignal");
    return c.get<uint8_t>();
  }
  const uint8_t& positioning_srs() const
  {
    assert_choice_type(types::positioning_srs, type_, "ReferenceSignal");
    return c.get<uint8_t>();
  }
  const dl_prs_s& dl_prs() const
  {
    assert_choice_type(types::dl_prs, type_, "ReferenceSignal");
    return c.get<dl_prs_s>();
  }
  const protocol_ie_single_container_s<ref_sig_ext_ies_o>& choice_ext() const
  {
    assert_choice_type(types::choice_ext, type_, "ReferenceSignal");
    return c.get<protocol_ie_single_container_s<ref_sig_ext_ies_o>>();
  }
  uint8_t&                                           set_nzp_csi_rs();
  ssb_s&                                             set_ssb();
  uint8_t&                                           set_srs();
  uint8_t&                                           set_positioning_srs();
  dl_prs_s&                                          set_dl_prs();
  protocol_ie_single_container_s<ref_sig_ext_ies_o>& set_choice_ext();

private:
  types                                                                               type_;
  choice_buffer_t<dl_prs_s, protocol_ie_single_container_s<ref_sig_ext_ies_o>, ssb_s> c;

  void destroy_();
};

// RequestedDLPRSResource-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using requested_dl_prs_res_item_ext_ies_o = protocol_ext_empty_o;

// SRSInfo ::= SEQUENCE
struct srs_info_s {
  bool    ext     = false;
  uint8_t srs_res = 0;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SRSPortIndex ::= ENUMERATED
struct srs_port_idx_opts {
  enum options { id1000, id1001, id1002, id1003, /*...*/ nulltype } value;
  typedef uint16_t number_type;

  const char* to_string() const;
  uint16_t    to_number() const;
};
typedef enumerated<srs_port_idx_opts, true> srs_port_idx_e;

// SRSResourceTypeChoice-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
using srs_res_type_choice_ext_ies_o = protocol_ies_empty_o;

// SSBInformation-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using ssb_info_ext_ies_o = protocol_ext_empty_o;

// SSBInformationList ::= SEQUENCE (SIZE (1..255)) OF SSBInformationItem
using ssb_info_list_l = dyn_array<ssb_info_item_s>;

// SpatialDirectionInformation-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using spatial_direction_info_ext_ies_o = protocol_ext_empty_o;

// SpatialRelationPerSRSResourceItem-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using spatial_relation_per_srs_res_item_ext_ies_o = protocol_ext_empty_o;

using trp_beam_ant_info_ext_ies_container = protocol_ext_container_empty_l;

// TRPBeamAntennaInformation ::= SEQUENCE
struct trp_beam_ant_info_s {
  bool                                ext             = false;
  bool                                ie_exts_present = false;
  choice_trp_beam_ant_info_item_c     choice_trp_beam_ant_info_item;
  trp_beam_ant_info_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// TRPTEGInformation ::= CHOICE
struct trpteg_info_c {
  struct types_opts {
    enum options { rx_tx_teg, rx_teg, choice_ext, nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  trpteg_info_c() = default;
  trpteg_info_c(const trpteg_info_c& other);
  trpteg_info_c& operator=(const trpteg_info_c& other);
  ~trpteg_info_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  rx_tx_teg_s& rx_tx_teg()
  {
    assert_choice_type(types::rx_tx_teg, type_, "TRPTEGInformation");
    return c.get<rx_tx_teg_s>();
  }
  rx_teg_s& rx_teg()
  {
    assert_choice_type(types::rx_teg, type_, "TRPTEGInformation");
    return c.get<rx_teg_s>();
  }
  protocol_ie_single_container_s<trpteg_info_ext_ies_o>& choice_ext()
  {
    assert_choice_type(types::choice_ext, type_, "TRPTEGInformation");
    return c.get<protocol_ie_single_container_s<trpteg_info_ext_ies_o>>();
  }
  const rx_tx_teg_s& rx_tx_teg() const
  {
    assert_choice_type(types::rx_tx_teg, type_, "TRPTEGInformation");
    return c.get<rx_tx_teg_s>();
  }
  const rx_teg_s& rx_teg() const
  {
    assert_choice_type(types::rx_teg, type_, "TRPTEGInformation");
    return c.get<rx_teg_s>();
  }
  const protocol_ie_single_container_s<trpteg_info_ext_ies_o>& choice_ext() const
  {
    assert_choice_type(types::choice_ext, type_, "TRPTEGInformation");
    return c.get<protocol_ie_single_container_s<trpteg_info_ext_ies_o>>();
  }
  rx_tx_teg_s&                                           set_rx_tx_teg();
  rx_teg_s&                                              set_rx_teg();
  protocol_ie_single_container_s<trpteg_info_ext_ies_o>& set_choice_ext();

private:
  types                                                                                         type_;
  choice_buffer_t<protocol_ie_single_container_s<trpteg_info_ext_ies_o>, rx_teg_s, rx_tx_teg_s> c;

  void destroy_();
};

// TRPTxTEGAssociation ::= SEQUENCE (SIZE (1..8)) OF TRPTEG-Item
using trp_tx_teg_assoc_l = dyn_array<trpteg_item_s>;

// TRPType ::= ENUMERATED
struct trp_type_opts {
  enum options { prs_only_tp, srs_only_rp, tp, rp, trp, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<trp_type_opts, true> trp_type_e;

// UACOperatorDefined-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using uac_operator_defined_ext_ies_o = protocol_ext_empty_o;

// UL-RTOA-MeasurementItem-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
using ul_rtoa_meas_item_ext_ies_o = protocol_ies_empty_o;

// FDD-Info-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
struct fdd_info_ext_ies_o {
  // Extension ::= OPEN TYPE
  struct ext_c {
    struct types_opts {
      enum options { ul_carrier_list, dl_carrier_list, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    ext_c() = default;
    ext_c(const ext_c& other);
    ext_c& operator=(const ext_c& other);
    ~ext_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    nr_carrier_list_l&       ul_carrier_list();
    nr_carrier_list_l&       dl_carrier_list();
    const nr_carrier_list_l& ul_carrier_list() const;
    const nr_carrier_list_l& dl_carrier_list() const;

  private:
    types                              type_;
    choice_buffer_t<nr_carrier_list_l> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static ext_c      get_ext(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// FlowsMappedToSLDRB-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using flows_mapped_to_sl_drb_item_ext_ies_o = protocol_ext_empty_o;

// GNB-RxTxTimeDiff-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
struct gnb_rx_tx_time_diff_ext_ies_o {
  // Extension ::= OPEN TYPE
  struct ext_c {
    struct types_opts {
      enum options { extended_add_path_list, trpteg_info, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    ext_c() = default;
    ext_c(const ext_c& other);
    ext_c& operator=(const ext_c& other);
    ~ext_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    extended_add_path_list_l&       extended_add_path_list();
    trpteg_info_c&                  trpteg_info();
    const extended_add_path_list_l& extended_add_path_list() const;
    const trpteg_info_c&            trpteg_info() const;

  private:
    types                                                    type_;
    choice_buffer_t<extended_add_path_list_l, trpteg_info_c> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static ext_c      get_ext(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// GNBRxTxTimeDiffMeas ::= CHOICE
struct gnb_rx_tx_time_diff_meas_c {
  struct types_opts {
    enum options { k0, k1, k2, k3, k4, k5, choice_ext, nulltype } value;
    typedef uint8_t number_type;

    const char* to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  gnb_rx_tx_time_diff_meas_c() = default;
  gnb_rx_tx_time_diff_meas_c(const gnb_rx_tx_time_diff_meas_c& other);
  gnb_rx_tx_time_diff_meas_c& operator=(const gnb_rx_tx_time_diff_meas_c& other);
  ~gnb_rx_tx_time_diff_meas_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  uint32_t& k0()
  {
    assert_choice_type(types::k0, type_, "GNBRxTxTimeDiffMeas");
    return c.get<uint32_t>();
  }
  uint32_t& k1()
  {
    assert_choice_type(types::k1, type_, "GNBRxTxTimeDiffMeas");
    return c.get<uint32_t>();
  }
  uint32_t& k2()
  {
    assert_choice_type(types::k2, type_, "GNBRxTxTimeDiffMeas");
    return c.get<uint32_t>();
  }
  uint32_t& k3()
  {
    assert_choice_type(types::k3, type_, "GNBRxTxTimeDiffMeas");
    return c.get<uint32_t>();
  }
  uint32_t& k4()
  {
    assert_choice_type(types::k4, type_, "GNBRxTxTimeDiffMeas");
    return c.get<uint32_t>();
  }
  uint16_t& k5()
  {
    assert_choice_type(types::k5, type_, "GNBRxTxTimeDiffMeas");
    return c.get<uint16_t>();
  }
  protocol_ie_single_container_s<gnb_rx_tx_time_diff_meas_ext_ies_o>& choice_ext()
  {
    assert_choice_type(types::choice_ext, type_, "GNBRxTxTimeDiffMeas");
    return c.get<protocol_ie_single_container_s<gnb_rx_tx_time_diff_meas_ext_ies_o>>();
  }
  const uint32_t& k0() const
  {
    assert_choice_type(types::k0, type_, "GNBRxTxTimeDiffMeas");
    return c.get<uint32_t>();
  }
  const uint32_t& k1() const
  {
    assert_choice_type(types::k1, type_, "GNBRxTxTimeDiffMeas");
    return c.get<uint32_t>();
  }
  const uint32_t& k2() const
  {
    assert_choice_type(types::k2, type_, "GNBRxTxTimeDiffMeas");
    return c.get<uint32_t>();
  }
  const uint32_t& k3() const
  {
    assert_choice_type(types::k3, type_, "GNBRxTxTimeDiffMeas");
    return c.get<uint32_t>();
  }
  const uint32_t& k4() const
  {
    assert_choice_type(types::k4, type_, "GNBRxTxTimeDiffMeas");
    return c.get<uint32_t>();
  }
  const uint16_t& k5() const
  {
    assert_choice_type(types::k5, type_, "GNBRxTxTimeDiffMeas");
    return c.get<uint16_t>();
  }
  const protocol_ie_single_container_s<gnb_rx_tx_time_diff_meas_ext_ies_o>& choice_ext() const
  {
    assert_choice_type(types::choice_ext, type_, "GNBRxTxTimeDiffMeas");
    return c.get<protocol_ie_single_container_s<gnb_rx_tx_time_diff_meas_ext_ies_o>>();
  }
  uint32_t&                                                           set_k0();
  uint32_t&                                                           set_k1();
  uint32_t&                                                           set_k2();
  uint32_t&                                                           set_k3();
  uint32_t&                                                           set_k4();
  uint16_t&                                                           set_k5();
  protocol_ie_single_container_s<gnb_rx_tx_time_diff_meas_ext_ies_o>& set_choice_ext();

private:
  types                                                                               type_;
  choice_buffer_t<protocol_ie_single_container_s<gnb_rx_tx_time_diff_meas_ext_ies_o>> c;

  void destroy_();
};

// IAB-Info-IAB-DU-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using iab_info_iab_du_ext_ies_o = protocol_ext_empty_o;

// LoS-NLoSIndicatorHard ::= ENUMERATED
struct lo_s_n_lo_si_ndicator_hard_opts {
  enum options { nlo_s, lo_s, nulltype } value;

  const char* to_string() const;
};
typedef enumerated<lo_s_n_lo_si_ndicator_hard_opts> lo_s_n_lo_si_ndicator_hard_e;

// LoS-NLoSInformation-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
using lo_s_n_lo_si_nformation_ext_ies_o = protocol_ies_empty_o;

// NR-U-Channel-Info-List ::= SEQUENCE (SIZE (1..16)) OF NR-U-Channel-Info-Item
using nr_u_ch_info_list_l = dyn_array<nr_u_ch_info_item_s>;

using non_dyn_pq_id_escriptor_ext_ies_container = protocol_ext_container_empty_l;

// NonDynamicPQIDescriptor ::= SEQUENCE
struct non_dyn_pq_id_escriptor_s {
  bool                                      qos_prio_level_present        = false;
  bool                                      averaging_win_present         = false;
  bool                                      max_data_burst_volume_present = false;
  bool                                      ie_exts_present               = false;
  uint16_t                                  five_qi                       = 0;
  uint8_t                                   qos_prio_level                = 1;
  uint16_t                                  averaging_win                 = 0;
  uint16_t                                  max_data_burst_volume         = 0;
  non_dyn_pq_id_escriptor_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PC5-QoS-Characteristics-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
using pc5_qos_characteristics_ext_ies_o = protocol_ies_empty_o;

// PC5FlowBitRates-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using pc5_flow_bit_rates_ext_ies_o = protocol_ext_empty_o;

using prs_cfg_ext_ies_container = protocol_ext_container_empty_l;

// PRSConfiguration ::= SEQUENCE
struct prs_cfg_s {
  bool                      ie_exts_present = false;
  prs_res_set_list_l        prs_res_set_list;
  prs_cfg_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using prs_tx_off_ind_per_res_item_ext_ies_container = protocol_ext_container_empty_l;

// PRSTransmissionOffIndicationPerResource-Item ::= SEQUENCE
struct prs_tx_off_ind_per_res_item_s {
  bool                                          ext             = false;
  bool                                          ie_exts_present = false;
  uint8_t                                       prs_res_id      = 0;
  prs_tx_off_ind_per_res_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PRSTransmissionOffPerResource-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using prs_tx_off_per_res_item_ext_ies_o = protocol_ext_empty_o;

// PRSTransmissionOffPerResourceSet-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using prs_tx_off_per_res_set_item_ext_ies_o = protocol_ext_empty_o;

using requested_dl_prs_res_item_ext_ies_container = protocol_ext_container_empty_l;

// RequestedDLPRSResource-Item ::= SEQUENCE
struct requested_dl_prs_res_item_s {
  bool                                        ext              = false;
  bool                                        qcl_info_present = false;
  bool                                        ie_exts_present  = false;
  prs_res_qcl_info_c                          qcl_info;
  requested_dl_prs_res_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SFN-Offset-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using sfn_offset_ext_ies_o = protocol_ext_empty_o;

// SRSResourceTypeChoice ::= CHOICE
struct srs_res_type_choice_c {
  struct types_opts {
    enum options { srs_res_info, pos_srs_res_info, choice_ext, nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  srs_res_type_choice_c() = default;
  srs_res_type_choice_c(const srs_res_type_choice_c& other);
  srs_res_type_choice_c& operator=(const srs_res_type_choice_c& other);
  ~srs_res_type_choice_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  srs_info_s& srs_res_info()
  {
    assert_choice_type(types::srs_res_info, type_, "SRSResourceTypeChoice");
    return c.get<srs_info_s>();
  }
  pos_srs_info_s& pos_srs_res_info()
  {
    assert_choice_type(types::pos_srs_res_info, type_, "SRSResourceTypeChoice");
    return c.get<pos_srs_info_s>();
  }
  protocol_ie_single_container_s<srs_res_type_choice_ext_ies_o>& choice_ext()
  {
    assert_choice_type(types::choice_ext, type_, "SRSResourceTypeChoice");
    return c.get<protocol_ie_single_container_s<srs_res_type_choice_ext_ies_o>>();
  }
  const srs_info_s& srs_res_info() const
  {
    assert_choice_type(types::srs_res_info, type_, "SRSResourceTypeChoice");
    return c.get<srs_info_s>();
  }
  const pos_srs_info_s& pos_srs_res_info() const
  {
    assert_choice_type(types::pos_srs_res_info, type_, "SRSResourceTypeChoice");
    return c.get<pos_srs_info_s>();
  }
  const protocol_ie_single_container_s<srs_res_type_choice_ext_ies_o>& choice_ext() const
  {
    assert_choice_type(types::choice_ext, type_, "SRSResourceTypeChoice");
    return c.get<protocol_ie_single_container_s<srs_res_type_choice_ext_ies_o>>();
  }
  srs_info_s&                                                    set_srs_res_info();
  pos_srs_info_s&                                                set_pos_srs_res_info();
  protocol_ie_single_container_s<srs_res_type_choice_ext_ies_o>& set_choice_ext();

private:
  types                                                                                                      type_;
  choice_buffer_t<pos_srs_info_s, protocol_ie_single_container_s<srs_res_type_choice_ext_ies_o>, srs_info_s> c;

  void destroy_();
};

// SRSResourcetype-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
struct srs_restype_ext_ies_o {
  // Extension ::= OPEN TYPE
  struct ext_c {
    struct types_opts {
      enum options { srs_port_idx, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::srs_port_idx; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    srs_port_idx_e&       srs_port_idx() { return c; }
    const srs_port_idx_e& srs_port_idx() const { return c; }

  private:
    srs_port_idx_e c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static ext_c      get_ext(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

using ssb_info_ext_ies_container = protocol_ext_container_empty_l;

// SSBInformation ::= SEQUENCE
struct ssb_info_s {
  bool                       ie_exts_present = false;
  ssb_info_list_l            ssb_info_list;
  ssb_info_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// ServedPLMNs-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
struct served_plmns_item_ext_ies_o {
  // Extension ::= OPEN TYPE
  struct ext_c {
    struct types_opts {
      enum options {
        tai_slice_support_list,
        npn_support_info,
        extended_tai_slice_support_list,
        tai_nsag_support_list,
        nulltype
      } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    ext_c() = default;
    ext_c(const ext_c& other);
    ext_c& operator=(const ext_c& other);
    ~ext_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    slice_support_list_l&                tai_slice_support_list();
    npn_support_info_c&                  npn_support_info();
    extended_slice_support_list_l&       extended_tai_slice_support_list();
    nsag_support_list_l&                 tai_nsag_support_list();
    const slice_support_list_l&          tai_slice_support_list() const;
    const npn_support_info_c&            npn_support_info() const;
    const extended_slice_support_list_l& extended_tai_slice_support_list() const;
    const nsag_support_list_l&           tai_nsag_support_list() const;

  private:
    types                                                                                                         type_;
    choice_buffer_t<extended_slice_support_list_l, npn_support_info_c, nsag_support_list_l, slice_support_list_l> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static ext_c      get_ext(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

using spatial_direction_info_ext_ies_container = protocol_ext_container_empty_l;

// SpatialDirectionInformation ::= SEQUENCE
struct spatial_direction_info_s {
  bool                                     ie_exts_present = false;
  nr_prs_beam_info_s                       nr_prs_beam_info;
  spatial_direction_info_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using spatial_relation_per_srs_res_item_ext_ies_container = protocol_ext_container_empty_l;

// SpatialRelationPerSRSResourceItem ::= SEQUENCE
struct spatial_relation_per_srs_res_item_s {
  bool                                                ext             = false;
  bool                                                ie_exts_present = false;
  ref_sig_c                                           ref_sig;
  spatial_relation_per_srs_res_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SpatialRelationforResourceIDItem-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using spatial_relationfor_res_id_item_ext_ies_o = protocol_ext_empty_o;

// StartTimeAndDuration-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using start_time_and_dur_ext_ies_o = protocol_ext_empty_o;

// TDD-Info-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
struct tdd_info_ext_ies_o {
  // Extension ::= OPEN TYPE
  struct ext_c {
    struct types_opts {
      enum options { intended_tdd_dl_ul_cfg, tdd_ul_dl_cfg_common_nr, carrier_list, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    ext_c() = default;
    ext_c(const ext_c& other);
    ext_c& operator=(const ext_c& other);
    ~ext_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    intended_tdd_dl_ul_cfg_s&        intended_tdd_dl_ul_cfg();
    unbounded_octstring<true>&       tdd_ul_dl_cfg_common_nr();
    nr_carrier_list_l&               carrier_list();
    const intended_tdd_dl_ul_cfg_s&  intended_tdd_dl_ul_cfg() const;
    const unbounded_octstring<true>& tdd_ul_dl_cfg_common_nr() const;
    const nr_carrier_list_l&         carrier_list() const;

  private:
    types                                                                                   type_;
    choice_buffer_t<intended_tdd_dl_ul_cfg_s, nr_carrier_list_l, unbounded_octstring<true>> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static ext_c      get_ext(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// TRPInformationTypeResponseItem-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct trp_info_type_resp_item_ext_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { trp_type, on_demand_prs, trp_tx_teg_assoc, trp_beam_ant_info, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    trp_type_e&                 trp_type();
    on_demand_prs_info_s&       on_demand_prs();
    trp_tx_teg_assoc_l&         trp_tx_teg_assoc();
    trp_beam_ant_info_s&        trp_beam_ant_info();
    const trp_type_e&           trp_type() const;
    const on_demand_prs_info_s& on_demand_prs() const;
    const trp_tx_teg_assoc_l&   trp_tx_teg_assoc() const;
    const trp_beam_ant_info_s&  trp_beam_ant_info() const;

  private:
    types                                                                          type_;
    choice_buffer_t<on_demand_prs_info_s, trp_beam_ant_info_s, trp_tx_teg_assoc_l> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// TimeStampSlotIndex-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct time_stamp_slot_idx_ext_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { scs_480, scs_960, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint16_t&       scs_480();
    uint16_t&       scs_960();
    const uint16_t& scs_480() const;
    const uint16_t& scs_960() const;

  private:
    types               type_;
    pod_choice_buffer_t c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// UACAction ::= ENUMERATED
struct uac_action_opts {
  enum options {
    reject_non_emergency_mo_dt,
    reject_rrc_cr_sig,
    permit_emergency_sessions_and_mobile_terminated_services_only,
    permit_high_prio_sessions_and_mobile_terminated_services_only,
    // ...
    nulltype
  } value;

  const char* to_string() const;
};
typedef enumerated<uac_action_opts, true> uac_action_e;

// UACCategoryType-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
using uac_category_type_ext_ies_o = protocol_ies_empty_o;

using uac_operator_defined_ext_ies_container = protocol_ext_container_empty_l;

// UACOperatorDefined ::= SEQUENCE
struct uac_operator_defined_s {
  bool                                   ie_exts_present = false;
  uint8_t                                access_category = 32;
  fixed_bitstring<7, false, true>        access_id;
  uac_operator_defined_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UL-RTOA-Measurement-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
struct ul_rtoa_meas_ext_ies_o {
  // Extension ::= OPEN TYPE
  struct ext_c {
    struct types_opts {
      enum options { extended_add_path_list, trp_rx_teg_info, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    ext_c() = default;
    ext_c(const ext_c& other);
    ext_c& operator=(const ext_c& other);
    ~ext_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    extended_add_path_list_l&       extended_add_path_list();
    trp_rx_teg_info_s&              trp_rx_teg_info();
    const extended_add_path_list_l& extended_add_path_list() const;
    const trp_rx_teg_info_s&        trp_rx_teg_info() const;

  private:
    types                                                        type_;
    choice_buffer_t<extended_add_path_list_l, trp_rx_teg_info_s> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static ext_c      get_ext(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// UL-RTOA-MeasurementItem ::= CHOICE
struct ul_rtoa_meas_item_c {
  struct types_opts {
    enum options { k0, k1, k2, k3, k4, k5, choice_ext, nulltype } value;
    typedef uint8_t number_type;

    const char* to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  ul_rtoa_meas_item_c() = default;
  ul_rtoa_meas_item_c(const ul_rtoa_meas_item_c& other);
  ul_rtoa_meas_item_c& operator=(const ul_rtoa_meas_item_c& other);
  ~ul_rtoa_meas_item_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  uint32_t& k0()
  {
    assert_choice_type(types::k0, type_, "UL-RTOA-MeasurementItem");
    return c.get<uint32_t>();
  }
  uint32_t& k1()
  {
    assert_choice_type(types::k1, type_, "UL-RTOA-MeasurementItem");
    return c.get<uint32_t>();
  }
  uint32_t& k2()
  {
    assert_choice_type(types::k2, type_, "UL-RTOA-MeasurementItem");
    return c.get<uint32_t>();
  }
  uint32_t& k3()
  {
    assert_choice_type(types::k3, type_, "UL-RTOA-MeasurementItem");
    return c.get<uint32_t>();
  }
  uint32_t& k4()
  {
    assert_choice_type(types::k4, type_, "UL-RTOA-MeasurementItem");
    return c.get<uint32_t>();
  }
  uint16_t& k5()
  {
    assert_choice_type(types::k5, type_, "UL-RTOA-MeasurementItem");
    return c.get<uint16_t>();
  }
  protocol_ie_single_container_s<ul_rtoa_meas_item_ext_ies_o>& choice_ext()
  {
    assert_choice_type(types::choice_ext, type_, "UL-RTOA-MeasurementItem");
    return c.get<protocol_ie_single_container_s<ul_rtoa_meas_item_ext_ies_o>>();
  }
  const uint32_t& k0() const
  {
    assert_choice_type(types::k0, type_, "UL-RTOA-MeasurementItem");
    return c.get<uint32_t>();
  }
  const uint32_t& k1() const
  {
    assert_choice_type(types::k1, type_, "UL-RTOA-MeasurementItem");
    return c.get<uint32_t>();
  }
  const uint32_t& k2() const
  {
    assert_choice_type(types::k2, type_, "UL-RTOA-MeasurementItem");
    return c.get<uint32_t>();
  }
  const uint32_t& k3() const
  {
    assert_choice_type(types::k3, type_, "UL-RTOA-MeasurementItem");
    return c.get<uint32_t>();
  }
  const uint32_t& k4() const
  {
    assert_choice_type(types::k4, type_, "UL-RTOA-MeasurementItem");
    return c.get<uint32_t>();
  }
  const uint16_t& k5() const
  {
    assert_choice_type(types::k5, type_, "UL-RTOA-MeasurementItem");
    return c.get<uint16_t>();
  }
  const protocol_ie_single_container_s<ul_rtoa_meas_item_ext_ies_o>& choice_ext() const
  {
    assert_choice_type(types::choice_ext, type_, "UL-RTOA-MeasurementItem");
    return c.get<protocol_ie_single_container_s<ul_rtoa_meas_item_ext_ies_o>>();
  }
  uint32_t&                                                    set_k0();
  uint32_t&                                                    set_k1();
  uint32_t&                                                    set_k2();
  uint32_t&                                                    set_k3();
  uint32_t&                                                    set_k4();
  uint16_t&                                                    set_k5();
  protocol_ie_single_container_s<ul_rtoa_meas_item_ext_ies_o>& set_choice_ext();

private:
  types                                                                        type_;
  choice_buffer_t<protocol_ie_single_container_s<ul_rtoa_meas_item_ext_ies_o>> c;

  void destroy_();
};

// VictimgNBSetID-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using victim_gnb_set_id_ext_ies_o = protocol_ext_empty_o;

// Cell-Direction ::= ENUMERATED
struct cell_direction_opts {
  enum options { dl_only, ul_only, nulltype } value;

  const char* to_string() const;
};
typedef enumerated<cell_direction_opts> cell_direction_e;

struct fdd_info_ext_ies_container {
  template <class extT_>
  using ie_field_s = protocol_ext_container_item_s<extT_>;

  // member variables
  bool                                                  ul_carrier_list_present = false;
  bool                                                  dl_carrier_list_present = false;
  ie_field_s<dyn_seq_of<nr_carrier_item_s, 1, 5, true>> ul_carrier_list;
  ie_field_s<dyn_seq_of<nr_carrier_item_s, 1, 5, true>> dl_carrier_list;

  // sequence methods
  fdd_info_ext_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// FDD-Info ::= SEQUENCE
struct fdd_info_s {
  bool                       ext             = false;
  bool                       ie_exts_present = false;
  nr_freq_info_s             ul_nr_freq_info;
  nr_freq_info_s             dl_nr_freq_info;
  tx_bw_s                    ul_tx_bw;
  tx_bw_s                    dl_tx_bw;
  fdd_info_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using flows_mapped_to_sl_drb_item_ext_ies_container = protocol_ext_container_empty_l;

// FlowsMappedToSLDRB-Item ::= SEQUENCE
struct flows_mapped_to_sl_drb_item_s {
  bool                                          ext             = false;
  bool                                          ie_exts_present = false;
  uint16_t                                      pc5_qos_flow_id = 1;
  flows_mapped_to_sl_drb_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

struct gnb_rx_tx_time_diff_ext_ies_container {
  template <class extT_>
  using ie_field_s = protocol_ext_container_item_s<extT_>;

  // member variables
  bool                                                              extended_add_path_list_present = false;
  bool                                                              trpteg_info_present            = false;
  ie_field_s<dyn_seq_of<extended_add_path_list_item_s, 1, 8, true>> extended_add_path_list;
  ie_field_s<trpteg_info_c>                                         trpteg_info;

  // sequence methods
  gnb_rx_tx_time_diff_ext_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// GNB-RxTxTimeDiff ::= SEQUENCE
struct gnb_rx_tx_time_diff_s {
  bool                                  ie_exts_present = false;
  gnb_rx_tx_time_diff_meas_c            rx_tx_time_diff;
  add_path_list_l                       add_path_list;
  gnb_rx_tx_time_diff_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// GTPTLA-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using gtp_tla_item_ext_ies_o = protocol_ext_empty_o;

using iab_info_iab_du_ext_ies_container = protocol_ext_container_empty_l;

// IAB-Info-IAB-DU ::= SEQUENCE
struct iab_info_iab_du_s {
  bool                              mux_info_present     = false;
  bool                              iab_stc_info_present = false;
  bool                              ie_exts_present      = false;
  mux_info_s                        mux_info;
  iab_stc_info_s                    iab_stc_info;
  iab_info_iab_du_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// LoS-NLoSInformation ::= CHOICE
struct lo_s_n_lo_si_nformation_c {
  struct types_opts {
    enum options { lo_s_n_lo_si_ndicator_soft, lo_s_n_lo_si_ndicator_hard, choice_ext, nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  lo_s_n_lo_si_nformation_c() = default;
  lo_s_n_lo_si_nformation_c(const lo_s_n_lo_si_nformation_c& other);
  lo_s_n_lo_si_nformation_c& operator=(const lo_s_n_lo_si_nformation_c& other);
  ~lo_s_n_lo_si_nformation_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  uint8_t& lo_s_n_lo_si_ndicator_soft()
  {
    assert_choice_type(types::lo_s_n_lo_si_ndicator_soft, type_, "LoS-NLoSInformation");
    return c.get<uint8_t>();
  }
  lo_s_n_lo_si_ndicator_hard_e& lo_s_n_lo_si_ndicator_hard()
  {
    assert_choice_type(types::lo_s_n_lo_si_ndicator_hard, type_, "LoS-NLoSInformation");
    return c.get<lo_s_n_lo_si_ndicator_hard_e>();
  }
  protocol_ie_single_container_s<lo_s_n_lo_si_nformation_ext_ies_o>& choice_ext()
  {
    assert_choice_type(types::choice_ext, type_, "LoS-NLoSInformation");
    return c.get<protocol_ie_single_container_s<lo_s_n_lo_si_nformation_ext_ies_o>>();
  }
  const uint8_t& lo_s_n_lo_si_ndicator_soft() const
  {
    assert_choice_type(types::lo_s_n_lo_si_ndicator_soft, type_, "LoS-NLoSInformation");
    return c.get<uint8_t>();
  }
  const lo_s_n_lo_si_ndicator_hard_e& lo_s_n_lo_si_ndicator_hard() const
  {
    assert_choice_type(types::lo_s_n_lo_si_ndicator_hard, type_, "LoS-NLoSInformation");
    return c.get<lo_s_n_lo_si_ndicator_hard_e>();
  }
  const protocol_ie_single_container_s<lo_s_n_lo_si_nformation_ext_ies_o>& choice_ext() const
  {
    assert_choice_type(types::choice_ext, type_, "LoS-NLoSInformation");
    return c.get<protocol_ie_single_container_s<lo_s_n_lo_si_nformation_ext_ies_o>>();
  }
  uint8_t&                                                           set_lo_s_n_lo_si_ndicator_soft();
  lo_s_n_lo_si_ndicator_hard_e&                                      set_lo_s_n_lo_si_ndicator_hard();
  protocol_ie_single_container_s<lo_s_n_lo_si_nformation_ext_ies_o>& set_choice_ext();

private:
  types                                                                              type_;
  choice_buffer_t<protocol_ie_single_container_s<lo_s_n_lo_si_nformation_ext_ies_o>> c;

  void destroy_();
};

// M5ReportAmount ::= ENUMERATED
struct m5_report_amount_opts {
  enum options { r1, r2, r4, r8, r16, r32, r64, infinity, /*...*/ nulltype } value;
  typedef int8_t number_type;

  const char* to_string() const;
  int8_t      to_number() const;
};
typedef enumerated<m5_report_amount_opts, true> m5_report_amount_e;

// M6ReportAmount ::= ENUMERATED
struct m6_report_amount_opts {
  enum options { r1, r2, r4, r8, r16, r32, r64, infinity, /*...*/ nulltype } value;
  typedef int8_t number_type;

  const char* to_string() const;
  int8_t      to_number() const;
};
typedef enumerated<m6_report_amount_opts, true> m6_report_amount_e;

// M7ReportAmount ::= ENUMERATED
struct m7_report_amount_opts {
  enum options { r1, r2, r4, r8, r16, r32, r64, infinity, /*...*/ nulltype } value;
  typedef int8_t number_type;

  const char* to_string() const;
  int8_t      to_number() const;
};
typedef enumerated<m7_report_amount_opts, true> m7_report_amount_e;

// MeasuredResultsValue-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct measured_results_value_ext_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { zo_a_info, multiple_ul_ao_a, ul_srs_rsrp_p, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    zo_a_info_s&              zo_a_info();
    multiple_ul_ao_a_s&       multiple_ul_ao_a();
    ul_srs_rsrp_p_s&          ul_srs_rsrp_p();
    const zo_a_info_s&        zo_a_info() const;
    const multiple_ul_ao_a_s& multiple_ul_ao_a() const;
    const ul_srs_rsrp_p_s&    ul_srs_rsrp_p() const;

  private:
    types                                                             type_;
    choice_buffer_t<multiple_ul_ao_a_s, ul_srs_rsrp_p_s, zo_a_info_s> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// MeasurementBeamInfo-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using meas_beam_info_ext_ies_o = protocol_ext_empty_o;

// NR-Mode-Info-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct nr_mode_info_ext_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { nr_u, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::nr_u; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    nr_u_ch_info_list_l&       nr_u() { return c; }
    const nr_u_ch_info_list_l& nr_u() const { return c; }

  private:
    nr_u_ch_info_list_l c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// PC5-QoS-Characteristics ::= CHOICE
struct pc5_qos_characteristics_c {
  struct types_opts {
    enum options { non_dyn_pqi, dyn_pqi, choice_ext, nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  pc5_qos_characteristics_c() = default;
  pc5_qos_characteristics_c(const pc5_qos_characteristics_c& other);
  pc5_qos_characteristics_c& operator=(const pc5_qos_characteristics_c& other);
  ~pc5_qos_characteristics_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  non_dyn_pq_id_escriptor_s& non_dyn_pqi()
  {
    assert_choice_type(types::non_dyn_pqi, type_, "PC5-QoS-Characteristics");
    return c.get<non_dyn_pq_id_escriptor_s>();
  }
  dyn_pq_id_escriptor_s& dyn_pqi()
  {
    assert_choice_type(types::dyn_pqi, type_, "PC5-QoS-Characteristics");
    return c.get<dyn_pq_id_escriptor_s>();
  }
  protocol_ie_single_container_s<pc5_qos_characteristics_ext_ies_o>& choice_ext()
  {
    assert_choice_type(types::choice_ext, type_, "PC5-QoS-Characteristics");
    return c.get<protocol_ie_single_container_s<pc5_qos_characteristics_ext_ies_o>>();
  }
  const non_dyn_pq_id_escriptor_s& non_dyn_pqi() const
  {
    assert_choice_type(types::non_dyn_pqi, type_, "PC5-QoS-Characteristics");
    return c.get<non_dyn_pq_id_escriptor_s>();
  }
  const dyn_pq_id_escriptor_s& dyn_pqi() const
  {
    assert_choice_type(types::dyn_pqi, type_, "PC5-QoS-Characteristics");
    return c.get<dyn_pq_id_escriptor_s>();
  }
  const protocol_ie_single_container_s<pc5_qos_characteristics_ext_ies_o>& choice_ext() const
  {
    assert_choice_type(types::choice_ext, type_, "PC5-QoS-Characteristics");
    return c.get<protocol_ie_single_container_s<pc5_qos_characteristics_ext_ies_o>>();
  }
  non_dyn_pq_id_escriptor_s&                                         set_non_dyn_pqi();
  dyn_pq_id_escriptor_s&                                             set_dyn_pqi();
  protocol_ie_single_container_s<pc5_qos_characteristics_ext_ies_o>& set_choice_ext();

private:
  types type_;
  choice_buffer_t<dyn_pq_id_escriptor_s,
                  non_dyn_pq_id_escriptor_s,
                  protocol_ie_single_container_s<pc5_qos_characteristics_ext_ies_o>>
      c;

  void destroy_();
};

using pc5_flow_bit_rates_ext_ies_container = protocol_ext_container_empty_l;

// PC5FlowBitRates ::= SEQUENCE
struct pc5_flow_bit_rates_s {
  bool                                 ext                      = false;
  bool                                 ie_exts_present          = false;
  uint64_t                             guaranteed_flow_bit_rate = 0;
  uint64_t                             max_flow_bit_rate        = 0;
  pc5_flow_bit_rates_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PC5QoSParameters-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using pc5_qos_params_ext_ies_o = protocol_ext_empty_o;

using prs_tx_off_per_res_item_ext_ies_container = protocol_ext_container_empty_l;

// PRSTransmissionOffPerResource-Item ::= SEQUENCE
struct prs_tx_off_per_res_item_s {
  using prs_tx_off_ind_per_res_list_l_ = dyn_array<prs_tx_off_ind_per_res_item_s>;

  // member variables
  bool                                      ext             = false;
  bool                                      ie_exts_present = false;
  uint8_t                                   prs_res_set_id  = 0;
  prs_tx_off_ind_per_res_list_l_            prs_tx_off_ind_per_res_list;
  prs_tx_off_per_res_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using prs_tx_off_per_res_set_item_ext_ies_container = protocol_ext_container_empty_l;

// PRSTransmissionOffPerResourceSet-Item ::= SEQUENCE
struct prs_tx_off_per_res_set_item_s {
  bool                                          ext             = false;
  bool                                          ie_exts_present = false;
  uint8_t                                       prs_res_set_id  = 0;
  prs_tx_off_per_res_set_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PathlossReferenceSignal-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
using pathloss_ref_sig_ext_ies_o = protocol_ies_empty_o;

// PeriodicityList-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using periodicity_list_item_ext_ies_o = protocol_ext_empty_o;

// PeriodicitySRS ::= ENUMERATED
struct periodicity_srs_opts {
  enum options {
    ms0p125,
    ms0p25,
    ms0p5,
    ms0p625,
    ms1,
    ms1p25,
    ms2,
    ms2p5,
    ms4,
    ms5,
    ms8,
    ms10,
    ms16,
    ms20,
    ms32,
    ms40,
    ms64,
    ms80,
    ms160,
    ms320,
    ms640,
    ms1280,
    ms2560,
    ms5120,
    ms10240,
    // ...
    nulltype
  } value;

  const char* to_string() const;
};
typedef enumerated<periodicity_srs_opts, true> periodicity_srs_e;

// RequestedDLPRSResource-List ::= SEQUENCE (SIZE (1..64)) OF RequestedDLPRSResource-Item
using requested_dl_prs_res_list_l = dyn_array<requested_dl_prs_res_item_s>;

// RequestedDLPRSResourceSet-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using requested_dl_prs_res_set_item_ext_ies_o = protocol_ext_empty_o;

// SCS-SpecificCarrier-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using scs_specific_carrier_ext_ies_o = protocol_ext_empty_o;

using sfn_offset_ext_ies_container = protocol_ext_container_empty_l;

// SFN-Offset ::= SEQUENCE
struct sfn_offset_s {
  bool                             ext             = false;
  bool                             ie_exts_present = false;
  fixed_bitstring<24, false, true> sfn_time_offset;
  sfn_offset_ext_ies_container     ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SRSResourcetype ::= SEQUENCE
struct srs_restype_s {
  bool                                            ext = false;
  srs_res_type_choice_c                           srs_res_type_choice;
  protocol_ext_container_l<srs_restype_ext_ies_o> ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

struct served_plmns_item_ext_ies_container {
  template <class extT_>
  using ie_field_s = protocol_ext_container_item_s<extT_>;

  // member variables
  bool                                                         tai_slice_support_list_present          = false;
  bool                                                         npn_support_info_present                = false;
  bool                                                         extended_tai_slice_support_list_present = false;
  bool                                                         tai_nsag_support_list_present           = false;
  ie_field_s<dyn_seq_of<slice_support_item_s, 1, 1024, true>>  tai_slice_support_list;
  ie_field_s<npn_support_info_c>                               npn_support_info;
  ie_field_s<dyn_seq_of<slice_support_item_s, 1, 65535, true>> extended_tai_slice_support_list;
  ie_field_s<dyn_seq_of<nsag_support_item_s, 1, 256, true>>    tai_nsag_support_list;

  // sequence methods
  served_plmns_item_ext_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// ServedPLMNs-Item ::= SEQUENCE
struct served_plmns_item_s {
  bool                                ext             = false;
  bool                                ie_exts_present = false;
  fixed_octstring<3, true>            plmn_id;
  served_plmns_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SpatialRelationPerSRSResource-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using spatial_relation_per_srs_res_ext_ies_o = protocol_ext_empty_o;

// SpatialRelationPerSRSResource-List ::= SEQUENCE (SIZE (1..16)) OF SpatialRelationPerSRSResourceItem
using spatial_relation_per_srs_res_list_l = dyn_array<spatial_relation_per_srs_res_item_s>;

using spatial_relationfor_res_id_item_ext_ies_container = protocol_ext_container_empty_l;

// SpatialRelationforResourceIDItem ::= SEQUENCE
struct spatial_relationfor_res_id_item_s {
  bool                                              ie_exts_present = false;
  ref_sig_c                                         ref_sig;
  spatial_relationfor_res_id_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using start_time_and_dur_ext_ies_container = protocol_ext_container_empty_l;

// StartTimeAndDuration ::= SEQUENCE
struct start_time_and_dur_s {
  bool                                 ext                = false;
  bool                                 start_time_present = false;
  bool                                 dur_present        = false;
  bool                                 ie_exts_present    = false;
  fixed_bitstring<64, false, true>     start_time;
  uint32_t                             dur = 0;
  start_time_and_dur_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// Supported-MBS-FSA-ID-List ::= SEQUENCE (SIZE (1..256)) OF OCTET STRING (SIZE (3))
using supported_mbs_fsa_id_list_l = dyn_array<fixed_octstring<3, true>>;

struct tdd_info_ext_ies_container {
  template <class extT_>
  using ie_field_s = protocol_ext_container_item_s<extT_>;

  // member variables
  bool                                                  intended_tdd_dl_ul_cfg_present  = false;
  bool                                                  tdd_ul_dl_cfg_common_nr_present = false;
  bool                                                  carrier_list_present            = false;
  ie_field_s<intended_tdd_dl_ul_cfg_s>                  intended_tdd_dl_ul_cfg;
  ie_field_s<unbounded_octstring<true>>                 tdd_ul_dl_cfg_common_nr;
  ie_field_s<dyn_seq_of<nr_carrier_item_s, 1, 5, true>> carrier_list;

  // sequence methods
  tdd_info_ext_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// TDD-Info ::= SEQUENCE
struct tdd_info_s {
  bool                       ext             = false;
  bool                       ie_exts_present = false;
  nr_freq_info_s             nr_freq_info;
  tx_bw_s                    tx_bw;
  tdd_info_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// TRPInformationTypeResponseItem ::= CHOICE
struct trp_info_type_resp_item_c {
  struct types_opts {
    enum options {
      pci_nr,
      ng_ran_cgi,
      nr_arfcn,
      prs_cfg,
      ss_binfo,
      sfn_initisation_time,
      spatial_direction_info,
      geographical_coordinates,
      choice_ext,
      nulltype
    } value;

    const char* to_string() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  trp_info_type_resp_item_c() = default;
  trp_info_type_resp_item_c(const trp_info_type_resp_item_c& other);
  trp_info_type_resp_item_c& operator=(const trp_info_type_resp_item_c& other);
  ~trp_info_type_resp_item_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  uint16_t& pci_nr()
  {
    assert_choice_type(types::pci_nr, type_, "TRPInformationTypeResponseItem");
    return c.get<uint16_t>();
  }
  nr_cgi_s& ng_ran_cgi()
  {
    assert_choice_type(types::ng_ran_cgi, type_, "TRPInformationTypeResponseItem");
    return c.get<nr_cgi_s>();
  }
  uint32_t& nr_arfcn()
  {
    assert_choice_type(types::nr_arfcn, type_, "TRPInformationTypeResponseItem");
    return c.get<uint32_t>();
  }
  prs_cfg_s& prs_cfg()
  {
    assert_choice_type(types::prs_cfg, type_, "TRPInformationTypeResponseItem");
    return c.get<prs_cfg_s>();
  }
  ssb_info_s& ss_binfo()
  {
    assert_choice_type(types::ss_binfo, type_, "TRPInformationTypeResponseItem");
    return c.get<ssb_info_s>();
  }
  fixed_bitstring<64, false, true>& sfn_initisation_time()
  {
    assert_choice_type(types::sfn_initisation_time, type_, "TRPInformationTypeResponseItem");
    return c.get<fixed_bitstring<64, false, true>>();
  }
  spatial_direction_info_s& spatial_direction_info()
  {
    assert_choice_type(types::spatial_direction_info, type_, "TRPInformationTypeResponseItem");
    return c.get<spatial_direction_info_s>();
  }
  geographical_coordinates_s& geographical_coordinates()
  {
    assert_choice_type(types::geographical_coordinates, type_, "TRPInformationTypeResponseItem");
    return c.get<geographical_coordinates_s>();
  }
  protocol_ie_single_container_s<trp_info_type_resp_item_ext_ies_o>& choice_ext()
  {
    assert_choice_type(types::choice_ext, type_, "TRPInformationTypeResponseItem");
    return c.get<protocol_ie_single_container_s<trp_info_type_resp_item_ext_ies_o>>();
  }
  const uint16_t& pci_nr() const
  {
    assert_choice_type(types::pci_nr, type_, "TRPInformationTypeResponseItem");
    return c.get<uint16_t>();
  }
  const nr_cgi_s& ng_ran_cgi() const
  {
    assert_choice_type(types::ng_ran_cgi, type_, "TRPInformationTypeResponseItem");
    return c.get<nr_cgi_s>();
  }
  const uint32_t& nr_arfcn() const
  {
    assert_choice_type(types::nr_arfcn, type_, "TRPInformationTypeResponseItem");
    return c.get<uint32_t>();
  }
  const prs_cfg_s& prs_cfg() const
  {
    assert_choice_type(types::prs_cfg, type_, "TRPInformationTypeResponseItem");
    return c.get<prs_cfg_s>();
  }
  const ssb_info_s& ss_binfo() const
  {
    assert_choice_type(types::ss_binfo, type_, "TRPInformationTypeResponseItem");
    return c.get<ssb_info_s>();
  }
  const fixed_bitstring<64, false, true>& sfn_initisation_time() const
  {
    assert_choice_type(types::sfn_initisation_time, type_, "TRPInformationTypeResponseItem");
    return c.get<fixed_bitstring<64, false, true>>();
  }
  const spatial_direction_info_s& spatial_direction_info() const
  {
    assert_choice_type(types::spatial_direction_info, type_, "TRPInformationTypeResponseItem");
    return c.get<spatial_direction_info_s>();
  }
  const geographical_coordinates_s& geographical_coordinates() const
  {
    assert_choice_type(types::geographical_coordinates, type_, "TRPInformationTypeResponseItem");
    return c.get<geographical_coordinates_s>();
  }
  const protocol_ie_single_container_s<trp_info_type_resp_item_ext_ies_o>& choice_ext() const
  {
    assert_choice_type(types::choice_ext, type_, "TRPInformationTypeResponseItem");
    return c.get<protocol_ie_single_container_s<trp_info_type_resp_item_ext_ies_o>>();
  }
  uint16_t&                                                          set_pci_nr();
  nr_cgi_s&                                                          set_ng_ran_cgi();
  uint32_t&                                                          set_nr_arfcn();
  prs_cfg_s&                                                         set_prs_cfg();
  ssb_info_s&                                                        set_ss_binfo();
  fixed_bitstring<64, false, true>&                                  set_sfn_initisation_time();
  spatial_direction_info_s&                                          set_spatial_direction_info();
  geographical_coordinates_s&                                        set_geographical_coordinates();
  protocol_ie_single_container_s<trp_info_type_resp_item_ext_ies_o>& set_choice_ext();

private:
  types type_;
  choice_buffer_t<fixed_bitstring<64, false, true>,
                  geographical_coordinates_s,
                  nr_cgi_s,
                  protocol_ie_single_container_s<trp_info_type_resp_item_ext_ies_o>,
                  prs_cfg_s,
                  spatial_direction_info_s,
                  ssb_info_s>
      c;

  void destroy_();
};

// TimeStamp-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using time_stamp_ext_ies_o = protocol_ext_empty_o;

// TimeStampSlotIndex ::= CHOICE
struct time_stamp_slot_idx_c {
  struct types_opts {
    enum options { scs_15, scs_30, scs_60, scs_120, choice_ext, nulltype } value;
    typedef int8_t number_type;

    const char* to_string() const;
    int8_t      to_number() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  time_stamp_slot_idx_c() = default;
  time_stamp_slot_idx_c(const time_stamp_slot_idx_c& other);
  time_stamp_slot_idx_c& operator=(const time_stamp_slot_idx_c& other);
  ~time_stamp_slot_idx_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  uint8_t& scs_15()
  {
    assert_choice_type(types::scs_15, type_, "TimeStampSlotIndex");
    return c.get<uint8_t>();
  }
  uint8_t& scs_30()
  {
    assert_choice_type(types::scs_30, type_, "TimeStampSlotIndex");
    return c.get<uint8_t>();
  }
  uint8_t& scs_60()
  {
    assert_choice_type(types::scs_60, type_, "TimeStampSlotIndex");
    return c.get<uint8_t>();
  }
  uint8_t& scs_120()
  {
    assert_choice_type(types::scs_120, type_, "TimeStampSlotIndex");
    return c.get<uint8_t>();
  }
  protocol_ie_single_container_s<time_stamp_slot_idx_ext_ies_o>& choice_ext()
  {
    assert_choice_type(types::choice_ext, type_, "TimeStampSlotIndex");
    return c.get<protocol_ie_single_container_s<time_stamp_slot_idx_ext_ies_o>>();
  }
  const uint8_t& scs_15() const
  {
    assert_choice_type(types::scs_15, type_, "TimeStampSlotIndex");
    return c.get<uint8_t>();
  }
  const uint8_t& scs_30() const
  {
    assert_choice_type(types::scs_30, type_, "TimeStampSlotIndex");
    return c.get<uint8_t>();
  }
  const uint8_t& scs_60() const
  {
    assert_choice_type(types::scs_60, type_, "TimeStampSlotIndex");
    return c.get<uint8_t>();
  }
  const uint8_t& scs_120() const
  {
    assert_choice_type(types::scs_120, type_, "TimeStampSlotIndex");
    return c.get<uint8_t>();
  }
  const protocol_ie_single_container_s<time_stamp_slot_idx_ext_ies_o>& choice_ext() const
  {
    assert_choice_type(types::choice_ext, type_, "TimeStampSlotIndex");
    return c.get<protocol_ie_single_container_s<time_stamp_slot_idx_ext_ies_o>>();
  }
  uint8_t&                                                       set_scs_15();
  uint8_t&                                                       set_scs_30();
  uint8_t&                                                       set_scs_60();
  uint8_t&                                                       set_scs_120();
  protocol_ie_single_container_s<time_stamp_slot_idx_ext_ies_o>& set_choice_ext();

private:
  types                                                                          type_;
  choice_buffer_t<protocol_ie_single_container_s<time_stamp_slot_idx_ext_ies_o>> c;

  void destroy_();
};

// UACCategoryType ::= CHOICE
struct uac_category_type_c {
  struct types_opts {
    enum options { uac_standardized, uac_operator_defined, choice_ext, nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  uac_category_type_c() = default;
  uac_category_type_c(const uac_category_type_c& other);
  uac_category_type_c& operator=(const uac_category_type_c& other);
  ~uac_category_type_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  uac_action_e& uac_standardized()
  {
    assert_choice_type(types::uac_standardized, type_, "UACCategoryType");
    return c.get<uac_action_e>();
  }
  uac_operator_defined_s& uac_operator_defined()
  {
    assert_choice_type(types::uac_operator_defined, type_, "UACCategoryType");
    return c.get<uac_operator_defined_s>();
  }
  protocol_ie_single_container_s<uac_category_type_ext_ies_o>& choice_ext()
  {
    assert_choice_type(types::choice_ext, type_, "UACCategoryType");
    return c.get<protocol_ie_single_container_s<uac_category_type_ext_ies_o>>();
  }
  const uac_action_e& uac_standardized() const
  {
    assert_choice_type(types::uac_standardized, type_, "UACCategoryType");
    return c.get<uac_action_e>();
  }
  const uac_operator_defined_s& uac_operator_defined() const
  {
    assert_choice_type(types::uac_operator_defined, type_, "UACCategoryType");
    return c.get<uac_operator_defined_s>();
  }
  const protocol_ie_single_container_s<uac_category_type_ext_ies_o>& choice_ext() const
  {
    assert_choice_type(types::choice_ext, type_, "UACCategoryType");
    return c.get<protocol_ie_single_container_s<uac_category_type_ext_ies_o>>();
  }
  uac_action_e&                                                set_uac_standardized();
  uac_operator_defined_s&                                      set_uac_operator_defined();
  protocol_ie_single_container_s<uac_category_type_ext_ies_o>& set_choice_ext();

private:
  types                                                                                                type_;
  choice_buffer_t<protocol_ie_single_container_s<uac_category_type_ext_ies_o>, uac_operator_defined_s> c;

  void destroy_();
};

// UACType-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using uac_type_item_ext_ies_o = protocol_ext_empty_o;

struct ul_rtoa_meas_ext_ies_container {
  template <class extT_>
  using ie_field_s = protocol_ext_container_item_s<extT_>;

  // member variables
  bool                                                              extended_add_path_list_present = false;
  bool                                                              trp_rx_teg_info_present        = false;
  ie_field_s<dyn_seq_of<extended_add_path_list_item_s, 1, 8, true>> extended_add_path_list;
  ie_field_s<trp_rx_teg_info_s>                                     trp_rx_teg_info;

  // sequence methods
  ul_rtoa_meas_ext_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UL-RTOA-Measurement ::= SEQUENCE
struct ul_rtoa_meas_s {
  bool                           ie_exts_present = false;
  ul_rtoa_meas_item_c            ul_rtoa_meas_item;
  add_path_list_l                add_path_list;
  ul_rtoa_meas_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using victim_gnb_set_id_ext_ies_container = protocol_ext_container_empty_l;

// VictimgNBSetID ::= SEQUENCE
struct victim_gnb_set_id_s {
  bool                                ie_exts_present = false;
  fixed_bitstring<22, false, true>    victim_gnb_set_id;
  victim_gnb_set_id_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// AdditionalDuplicationIndication ::= ENUMERATED
struct add_dupl_ind_opts {
  enum options { three, four, /*...*/ nulltype } value;
  typedef uint8_t number_type;

  const char* to_string() const;
  uint8_t     to_number() const;
};
typedef enumerated<add_dupl_ind_opts, true> add_dupl_ind_e;

// FlowsMappedToSLDRB-List ::= SEQUENCE (SIZE (1..2048)) OF FlowsMappedToSLDRB-Item
using flows_mapped_to_sl_drb_list_l = dyn_array<flows_mapped_to_sl_drb_item_s>;

// GNB-DU-System-Information-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
struct gnb_du_sys_info_ext_ies_o {
  // Extension ::= OPEN TYPE
  struct ext_c {
    struct types_opts {
      enum options { sib12_msg, sib13_msg, sib14_msg, sib10_msg, sib17_msg, sib20_msg, sib15_msg, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    ext_c() = default;
    ext_c(const ext_c& other);
    ext_c& operator=(const ext_c& other);
    ~ext_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    unbounded_octstring<true>&       sib12_msg();
    unbounded_octstring<true>&       sib13_msg();
    unbounded_octstring<true>&       sib14_msg();
    unbounded_octstring<true>&       sib10_msg();
    unbounded_octstring<true>&       sib17_msg();
    unbounded_octstring<true>&       sib20_msg();
    unbounded_octstring<true>&       sib15_msg();
    const unbounded_octstring<true>& sib12_msg() const;
    const unbounded_octstring<true>& sib13_msg() const;
    const unbounded_octstring<true>& sib14_msg() const;
    const unbounded_octstring<true>& sib10_msg() const;
    const unbounded_octstring<true>& sib17_msg() const;
    const unbounded_octstring<true>& sib20_msg() const;
    const unbounded_octstring<true>& sib15_msg() const;

  private:
    types                                      type_;
    choice_buffer_t<unbounded_octstring<true>> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static ext_c      get_ext(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

using gtp_tla_item_ext_ies_container = protocol_ext_container_empty_l;

// GTPTLA-Item ::= SEQUENCE
struct gtp_tla_item_s {
  bool                                  ie_exts_present = false;
  bounded_bitstring<1, 160, true, true> gtp_transport_layer_address;
  gtp_tla_item_ext_ies_container        ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// IAB-MT-Cell-NA-Resource-Configuration-FDD-Info-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using iab_mt_cell_na_res_cfg_fdd_info_ext_ies_o = protocol_ext_empty_o;

// IAB-MT-Cell-NA-Resource-Configuration-TDD-Info-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using iab_mt_cell_na_res_cfg_tdd_info_ext_ies_o = protocol_ext_empty_o;

// LastUsedCellIndication ::= ENUMERATED
struct last_used_cell_ind_opts {
  enum options { true_value, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<last_used_cell_ind_opts, true> last_used_cell_ind_e;

// M5-Links-to-log ::= ENUMERATED
struct m5_links_to_log_opts {
  enum options { ul, dl, both_ul_and_dl, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<m5_links_to_log_opts, true> m5_links_to_log_e;

// M5Configuration-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
struct m5_cfg_ext_ies_o {
  // Extension ::= OPEN TYPE
  struct ext_c {
    struct types_opts {
      enum options { m5_report_amount, nulltype } value;
      typedef uint8_t number_type;

      const char* to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::m5_report_amount; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    m5_report_amount_e&       m5_report_amount() { return c; }
    const m5_report_amount_e& m5_report_amount() const { return c; }

  private:
    m5_report_amount_e c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static ext_c      get_ext(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// M5period ::= ENUMERATED
struct m5period_opts {
  enum options { ms1024, ms2048, ms5120, ms10240, min1, /*...*/ nulltype } value;
  typedef uint16_t number_type;

  const char* to_string() const;
  uint16_t    to_number() const;
};
typedef enumerated<m5period_opts, true> m5period_e;

// M6-Links-to-log ::= ENUMERATED
struct m6_links_to_log_opts {
  enum options { ul, dl, both_ul_and_dl, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<m6_links_to_log_opts, true> m6_links_to_log_e;

// M6Configuration-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
struct m6_cfg_ext_ies_o {
  // Extension ::= OPEN TYPE
  struct ext_c {
    struct types_opts {
      enum options { m6_report_amount, nulltype } value;
      typedef uint8_t number_type;

      const char* to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::m6_report_amount; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    m6_report_amount_e&       m6_report_amount() { return c; }
    const m6_report_amount_e& m6_report_amount() const { return c; }

  private:
    m6_report_amount_e c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static ext_c      get_ext(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// M6report-Interval ::= ENUMERATED
struct m6report_interv_opts {
  enum options {
    ms120,
    ms240,
    ms640,
    ms1024,
    ms2048,
    ms5120,
    ms10240,
    ms20480,
    ms40960,
    min1,
    min6,
    min12,
    min30,
    // ...
    ms480,
    nulltype
  } value;
  typedef uint16_t number_type;

  const char* to_string() const;
  uint16_t    to_number() const;
};
typedef enumerated<m6report_interv_opts, true, 1> m6report_interv_e;

// M7-Links-to-log ::= ENUMERATED
struct m7_links_to_log_opts {
  enum options { dl, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<m7_links_to_log_opts, true> m7_links_to_log_e;

// M7Configuration-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
struct m7_cfg_ext_ies_o {
  // Extension ::= OPEN TYPE
  struct ext_c {
    struct types_opts {
      enum options { m7_report_amount, nulltype } value;
      typedef uint8_t number_type;

      const char* to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::m7_report_amount; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    m7_report_amount_e&       m7_report_amount() { return c; }
    const m7_report_amount_e& m7_report_amount() const { return c; }

  private:
    m7_report_amount_e c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static ext_c      get_ext(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// MRB-ProgressInformation-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
using mrb_progress_info_ext_ies_o = protocol_ies_empty_o;

// MeasuredResultsValue ::= CHOICE
struct measured_results_value_c {
  struct types_opts {
    enum options { ul_angle_of_arrival, ul_srs_rsrp, ul_rtoa, gnb_rx_tx_time_diff, choice_ext, nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  measured_results_value_c() = default;
  measured_results_value_c(const measured_results_value_c& other);
  measured_results_value_c& operator=(const measured_results_value_c& other);
  ~measured_results_value_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  ul_ao_a_s& ul_angle_of_arrival()
  {
    assert_choice_type(types::ul_angle_of_arrival, type_, "MeasuredResultsValue");
    return c.get<ul_ao_a_s>();
  }
  uint8_t& ul_srs_rsrp()
  {
    assert_choice_type(types::ul_srs_rsrp, type_, "MeasuredResultsValue");
    return c.get<uint8_t>();
  }
  ul_rtoa_meas_s& ul_rtoa()
  {
    assert_choice_type(types::ul_rtoa, type_, "MeasuredResultsValue");
    return c.get<ul_rtoa_meas_s>();
  }
  gnb_rx_tx_time_diff_s& gnb_rx_tx_time_diff()
  {
    assert_choice_type(types::gnb_rx_tx_time_diff, type_, "MeasuredResultsValue");
    return c.get<gnb_rx_tx_time_diff_s>();
  }
  protocol_ie_single_container_s<measured_results_value_ext_ies_o>& choice_ext()
  {
    assert_choice_type(types::choice_ext, type_, "MeasuredResultsValue");
    return c.get<protocol_ie_single_container_s<measured_results_value_ext_ies_o>>();
  }
  const ul_ao_a_s& ul_angle_of_arrival() const
  {
    assert_choice_type(types::ul_angle_of_arrival, type_, "MeasuredResultsValue");
    return c.get<ul_ao_a_s>();
  }
  const uint8_t& ul_srs_rsrp() const
  {
    assert_choice_type(types::ul_srs_rsrp, type_, "MeasuredResultsValue");
    return c.get<uint8_t>();
  }
  const ul_rtoa_meas_s& ul_rtoa() const
  {
    assert_choice_type(types::ul_rtoa, type_, "MeasuredResultsValue");
    return c.get<ul_rtoa_meas_s>();
  }
  const gnb_rx_tx_time_diff_s& gnb_rx_tx_time_diff() const
  {
    assert_choice_type(types::gnb_rx_tx_time_diff, type_, "MeasuredResultsValue");
    return c.get<gnb_rx_tx_time_diff_s>();
  }
  const protocol_ie_single_container_s<measured_results_value_ext_ies_o>& choice_ext() const
  {
    assert_choice_type(types::choice_ext, type_, "MeasuredResultsValue");
    return c.get<protocol_ie_single_container_s<measured_results_value_ext_ies_o>>();
  }
  ul_ao_a_s&                                                        set_ul_angle_of_arrival();
  uint8_t&                                                          set_ul_srs_rsrp();
  ul_rtoa_meas_s&                                                   set_ul_rtoa();
  gnb_rx_tx_time_diff_s&                                            set_gnb_rx_tx_time_diff();
  protocol_ie_single_container_s<measured_results_value_ext_ies_o>& set_choice_ext();

private:
  types type_;
  choice_buffer_t<gnb_rx_tx_time_diff_s,
                  protocol_ie_single_container_s<measured_results_value_ext_ies_o>,
                  ul_ao_a_s,
                  ul_rtoa_meas_s>
      c;

  void destroy_();
};

using meas_beam_info_ext_ies_container = protocol_ext_container_empty_l;

// MeasurementBeamInfo ::= SEQUENCE
struct meas_beam_info_s {
  bool                             prs_res_id_present     = false;
  bool                             prs_res_set_id_present = false;
  bool                             ssb_idx_present        = false;
  bool                             ie_exts_present        = false;
  uint8_t                          prs_res_id             = 0;
  uint8_t                          prs_res_set_id         = 0;
  uint8_t                          ssb_idx                = 0;
  meas_beam_info_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// NR-Mode-Info ::= CHOICE
struct nr_mode_info_c {
  struct types_opts {
    enum options { fdd, tdd, choice_ext, nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  nr_mode_info_c() = default;
  nr_mode_info_c(const nr_mode_info_c& other);
  nr_mode_info_c& operator=(const nr_mode_info_c& other);
  ~nr_mode_info_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  fdd_info_s& fdd()
  {
    assert_choice_type(types::fdd, type_, "NR-Mode-Info");
    return c.get<fdd_info_s>();
  }
  tdd_info_s& tdd()
  {
    assert_choice_type(types::tdd, type_, "NR-Mode-Info");
    return c.get<tdd_info_s>();
  }
  protocol_ie_single_container_s<nr_mode_info_ext_ies_o>& choice_ext()
  {
    assert_choice_type(types::choice_ext, type_, "NR-Mode-Info");
    return c.get<protocol_ie_single_container_s<nr_mode_info_ext_ies_o>>();
  }
  const fdd_info_s& fdd() const
  {
    assert_choice_type(types::fdd, type_, "NR-Mode-Info");
    return c.get<fdd_info_s>();
  }
  const tdd_info_s& tdd() const
  {
    assert_choice_type(types::tdd, type_, "NR-Mode-Info");
    return c.get<tdd_info_s>();
  }
  const protocol_ie_single_container_s<nr_mode_info_ext_ies_o>& choice_ext() const
  {
    assert_choice_type(types::choice_ext, type_, "NR-Mode-Info");
    return c.get<protocol_ie_single_container_s<nr_mode_info_ext_ies_o>>();
  }
  fdd_info_s&                                             set_fdd();
  tdd_info_s&                                             set_tdd();
  protocol_ie_single_container_s<nr_mode_info_ext_ies_o>& set_choice_ext();

private:
  types                                                                                           type_;
  choice_buffer_t<fdd_info_s, protocol_ie_single_container_s<nr_mode_info_ext_ies_o>, tdd_info_s> c;

  void destroy_();
};

using pc5_qos_params_ext_ies_container = protocol_ext_container_empty_l;

// PC5QoSParameters ::= SEQUENCE
struct pc5_qos_params_s {
  bool                             ext                            = false;
  bool                             pc5_qos_flow_bit_rates_present = false;
  bool                             ie_exts_present                = false;
  pc5_qos_characteristics_c        pc5_qos_characteristics;
  pc5_flow_bit_rates_s             pc5_qos_flow_bit_rates;
  pc5_qos_params_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PDCMeasuredResults-Value-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
using pdc_measured_results_value_ext_ies_o = protocol_ies_empty_o;

// PEISubgroupingSupportIndication ::= ENUMERATED
struct pei_subgrouping_support_ind_opts {
  enum options { true_value, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<pei_subgrouping_support_ind_opts, true> pei_subgrouping_support_ind_e;

// PRSTransmissionOffIndication-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
using prs_tx_off_ind_ext_ies_o = protocol_ies_empty_o;

// PRSTransmissionOffPerResource ::= SEQUENCE (SIZE (1..8)) OF PRSTransmissionOffPerResource-Item
using prs_tx_off_per_res_l = dyn_array<prs_tx_off_per_res_item_s>;

// PRSTransmissionOffPerResourceSet ::= SEQUENCE (SIZE (1..8)) OF PRSTransmissionOffPerResourceSet-Item
using prs_tx_off_per_res_set_l = dyn_array<prs_tx_off_per_res_set_item_s>;

// PathlossReferenceInfo-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using pathloss_ref_info_ext_ies_o = protocol_ext_empty_o;

// PathlossReferenceSignal ::= CHOICE
struct pathloss_ref_sig_c {
  struct types_opts {
    enum options { ssb, dl_prs, choice_ext, nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  pathloss_ref_sig_c() = default;
  pathloss_ref_sig_c(const pathloss_ref_sig_c& other);
  pathloss_ref_sig_c& operator=(const pathloss_ref_sig_c& other);
  ~pathloss_ref_sig_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  ssb_s& ssb()
  {
    assert_choice_type(types::ssb, type_, "PathlossReferenceSignal");
    return c.get<ssb_s>();
  }
  dl_prs_s& dl_prs()
  {
    assert_choice_type(types::dl_prs, type_, "PathlossReferenceSignal");
    return c.get<dl_prs_s>();
  }
  protocol_ie_single_container_s<pathloss_ref_sig_ext_ies_o>& choice_ext()
  {
    assert_choice_type(types::choice_ext, type_, "PathlossReferenceSignal");
    return c.get<protocol_ie_single_container_s<pathloss_ref_sig_ext_ies_o>>();
  }
  const ssb_s& ssb() const
  {
    assert_choice_type(types::ssb, type_, "PathlossReferenceSignal");
    return c.get<ssb_s>();
  }
  const dl_prs_s& dl_prs() const
  {
    assert_choice_type(types::dl_prs, type_, "PathlossReferenceSignal");
    return c.get<dl_prs_s>();
  }
  const protocol_ie_single_container_s<pathloss_ref_sig_ext_ies_o>& choice_ext() const
  {
    assert_choice_type(types::choice_ext, type_, "PathlossReferenceSignal");
    return c.get<protocol_ie_single_container_s<pathloss_ref_sig_ext_ies_o>>();
  }
  ssb_s&                                                      set_ssb();
  dl_prs_s&                                                   set_dl_prs();
  protocol_ie_single_container_s<pathloss_ref_sig_ext_ies_o>& set_choice_ext();

private:
  types                                                                                        type_;
  choice_buffer_t<dl_prs_s, protocol_ie_single_container_s<pathloss_ref_sig_ext_ies_o>, ssb_s> c;

  void destroy_();
};

using periodicity_list_item_ext_ies_container = protocol_ext_container_empty_l;

// PeriodicityList-Item ::= SEQUENCE
struct periodicity_list_item_s {
  bool                                    ie_exts_present = false;
  periodicity_srs_e                       periodicity_srs;
  periodicity_list_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PosMeasurementResultItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
struct pos_meas_result_item_ext_ies_o {
  // Extension ::= OPEN TYPE
  struct ext_c {
    struct types_opts {
      enum options { arp_id, srs_restype, lo_s_n_lo_si_nformation, nulltype } value;
      typedef uint8_t number_type;

      const char* to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    ext_c() = default;
    ext_c(const ext_c& other);
    ext_c& operator=(const ext_c& other);
    ~ext_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint8_t&                         arp_id();
    srs_restype_s&                   srs_restype();
    lo_s_n_lo_si_nformation_c&       lo_s_n_lo_si_nformation();
    const uint8_t&                   arp_id() const;
    const srs_restype_s&             srs_restype() const;
    const lo_s_n_lo_si_nformation_c& lo_s_n_lo_si_nformation() const;

  private:
    types                                                     type_;
    choice_buffer_t<lo_s_n_lo_si_nformation_c, srs_restype_s> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static ext_c      get_ext(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// QoEMetrics-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using qo_e_metrics_ext_ies_o = protocol_ext_empty_o;

using requested_dl_prs_res_set_item_ext_ies_container = protocol_ext_container_empty_l;

// RequestedDLPRSResourceSet-Item ::= SEQUENCE
struct requested_dl_prs_res_set_item_s {
  struct comb_size_opts {
    enum options { n2, n4, n6, n12, /*...*/ nulltype } value;
    typedef uint8_t number_type;

    const char* to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<comb_size_opts, true> comb_size_e_;
  struct res_set_periodicity_opts {
    enum options {
      n4,
      n5,
      n8,
      n10,
      n16,
      n20,
      n32,
      n40,
      n64,
      n80,
      n160,
      n320,
      n640,
      n1280,
      n2560,
      n5120,
      n10240,
      n20480,
      n40960,
      n81920,
      // ...
      nulltype
    } value;
    typedef uint32_t number_type;

    const char* to_string() const;
    uint32_t    to_number() const;
  };
  typedef enumerated<res_set_periodicity_opts, true> res_set_periodicity_e_;
  struct res_repeat_factor_opts {
    enum options { rf1, rf2, rf4, rf6, rf8, rf16, rf32, /*...*/ nulltype } value;
    typedef uint8_t number_type;

    const char* to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<res_repeat_factor_opts, true> res_repeat_factor_e_;
  struct res_numof_symbols_opts {
    enum options { n2, n4, n6, n12, /*...*/ nulltype } value;
    typedef uint8_t number_type;

    const char* to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<res_numof_symbols_opts, true> res_numof_symbols_e_;

  // member variables
  bool                                            ext                                = false;
  bool                                            comb_size_present                  = false;
  bool                                            res_set_periodicity_present        = false;
  bool                                            res_repeat_factor_present          = false;
  bool                                            res_numof_symbols_present          = false;
  bool                                            res_set_start_time_and_dur_present = false;
  bool                                            ie_exts_present                    = false;
  uint8_t                                         pr_sbw                             = 1;
  comb_size_e_                                    comb_size;
  res_set_periodicity_e_                          res_set_periodicity;
  res_repeat_factor_e_                            res_repeat_factor;
  res_numof_symbols_e_                            res_numof_symbols;
  requested_dl_prs_res_list_l                     requested_dl_prs_res_list;
  start_time_and_dur_s                            res_set_start_time_and_dur;
  requested_dl_prs_res_set_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using scs_specific_carrier_ext_ies_container = protocol_ext_container_empty_l;

// SCS-SpecificCarrier ::= SEQUENCE
struct scs_specific_carrier_s {
  struct subcarrier_spacing_opts {
    enum options { khz15, khz30, khz60, khz120, /*...*/ khz480, khz960, nulltype } value;
    typedef uint16_t number_type;

    const char* to_string() const;
    uint16_t    to_number() const;
  };
  typedef enumerated<subcarrier_spacing_opts, true, 2> subcarrier_spacing_e_;

  // member variables
  bool                                   ie_exts_present   = false;
  uint16_t                               offset_to_carrier = 0;
  subcarrier_spacing_e_                  subcarrier_spacing;
  uint16_t                               carrier_bw = 1;
  scs_specific_carrier_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SDTBearerType-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
using sdt_bearer_type_ext_ies_o = protocol_ies_empty_o;

// Served-Cell-Information-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
struct served_cell_info_ext_ies_o {
  // Extension ::= OPEN TYPE
  struct ext_c {
    struct types_opts {
      enum options {
        ranac,
        extended_served_plmns_list,
        cell_direction,
        bplmn_id_info_list,
        cell_type,
        cfg_tac_ind,
        aggressor_gnb_set_id,
        victim_gnb_set_id,
        iab_info_iab_du,
        ssb_positions_in_burst,
        nr_prach_cfg,
        sfn_offset,
        npn_broadcast_info,
        supported_mbs_fsa_id_list,
        redcap_bcast_info,
        nulltype
      } value;
      typedef uint8_t number_type;

      const char* to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    ext_c() = default;
    ext_c(const ext_c& other);
    ext_c& operator=(const ext_c& other);
    ~ext_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint16_t&                              ranac();
    extended_served_plmns_list_l&          extended_served_plmns_list();
    cell_direction_e&                      cell_direction();
    bplmn_id_info_list_l&                  bplmn_id_info_list();
    cell_type_s&                           cell_type();
    cfg_tac_ind_e&                         cfg_tac_ind();
    aggressor_gnb_set_id_s&                aggressor_gnb_set_id();
    victim_gnb_set_id_s&                   victim_gnb_set_id();
    iab_info_iab_du_s&                     iab_info_iab_du();
    ssb_positions_in_burst_c&              ssb_positions_in_burst();
    nr_prach_cfg_s&                        nr_prach_cfg();
    sfn_offset_s&                          sfn_offset();
    npn_broadcast_info_c&                  npn_broadcast_info();
    supported_mbs_fsa_id_list_l&           supported_mbs_fsa_id_list();
    fixed_bitstring<8, false, true>&       redcap_bcast_info();
    const uint16_t&                        ranac() const;
    const extended_served_plmns_list_l&    extended_served_plmns_list() const;
    const cell_direction_e&                cell_direction() const;
    const bplmn_id_info_list_l&            bplmn_id_info_list() const;
    const cell_type_s&                     cell_type() const;
    const cfg_tac_ind_e&                   cfg_tac_ind() const;
    const aggressor_gnb_set_id_s&          aggressor_gnb_set_id() const;
    const victim_gnb_set_id_s&             victim_gnb_set_id() const;
    const iab_info_iab_du_s&               iab_info_iab_du() const;
    const ssb_positions_in_burst_c&        ssb_positions_in_burst() const;
    const nr_prach_cfg_s&                  nr_prach_cfg() const;
    const sfn_offset_s&                    sfn_offset() const;
    const npn_broadcast_info_c&            npn_broadcast_info() const;
    const supported_mbs_fsa_id_list_l&     supported_mbs_fsa_id_list() const;
    const fixed_bitstring<8, false, true>& redcap_bcast_info() const;

  private:
    types type_;
    choice_buffer_t<aggressor_gnb_set_id_s,
                    bplmn_id_info_list_l,
                    cell_type_s,
                    extended_served_plmns_list_l,
                    fixed_bitstring<8, false, true>,
                    iab_info_iab_du_s,
                    npn_broadcast_info_c,
                    nr_prach_cfg_s,
                    sfn_offset_s,
                    ssb_positions_in_burst_c,
                    supported_mbs_fsa_id_list_l,
                    victim_gnb_set_id_s>
        c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static ext_c      get_ext(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// ServedPLMNs-List ::= SEQUENCE (SIZE (1..6)) OF ServedPLMNs-Item
using served_plmns_list_l = dyn_array<served_plmns_item_s>;

// SpatialRelationInfo-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using spatial_relation_info_ext_ies_o = protocol_ext_empty_o;

using spatial_relation_per_srs_res_ext_ies_container = protocol_ext_container_empty_l;

// SpatialRelationPerSRSResource ::= SEQUENCE
struct spatial_relation_per_srs_res_s {
  bool                                           ext             = false;
  bool                                           ie_exts_present = false;
  spatial_relation_per_srs_res_list_l            spatial_relation_per_srs_res_list;
  spatial_relation_per_srs_res_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SpatialRelationforResourceID ::= SEQUENCE (SIZE (1..64)) OF SpatialRelationforResourceIDItem
using spatial_relationfor_res_id_l = dyn_array<spatial_relationfor_res_id_item_s>;

// TRPInformation-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using trp_info_ext_ies_o = protocol_ext_empty_o;

// TRPInformationTypeResponseList ::= SEQUENCE (SIZE (1..64)) OF TRPInformationTypeResponseItem
using trp_info_type_resp_list_l = dyn_array<trp_info_type_resp_item_c>;

using time_stamp_ext_ies_container = protocol_ext_container_empty_l;

// TimeStamp ::= SEQUENCE
struct time_stamp_s {
  bool                             meas_time_present = false;
  bool                             ie_ext_present    = false;
  uint16_t                         sys_frame_num     = 0;
  time_stamp_slot_idx_c            slot_idx;
  fixed_bitstring<64, false, true> meas_time;
  time_stamp_ext_ies_container     ie_ext;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using uac_type_item_ext_ies_container = protocol_ext_container_empty_l;

// UACType-Item ::= SEQUENCE
struct uac_type_item_s {
  bool                            ie_exts_present   = false;
  uint8_t                         uac_reduction_ind = 0;
  uac_category_type_c             uac_category_type;
  uac_type_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UE-associatedLogicalF1-ConnectionItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using ue_associated_lc_f1_conn_item_ext_ies_o = protocol_ext_empty_o;

// UEIdentityIndexValueChoice-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
using ue_id_idx_value_choice_ext_ies_o = protocol_ies_empty_o;

// CellULConfigured ::= ENUMERATED
struct cell_ul_cfg_opts {
  enum options { none, ul, sul, ul_and_sul, /*...*/ nulltype } value;
  typedef uint8_t number_type;

  const char* to_string() const;
  uint8_t     to_number() const;
};
typedef enumerated<cell_ul_cfg_opts, true> cell_ul_cfg_e;

// DuplicationIndication ::= ENUMERATED
struct dupl_ind_opts {
  enum options { true_value, /*...*/ false_value, nulltype } value;

  const char* to_string() const;
};
typedef enumerated<dupl_ind_opts, true, 1> dupl_ind_e;

// GNB-CU-TNL-Association-Failed-To-Setup-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using gnb_cu_tnl_assoc_failed_to_setup_item_ext_ies_o = protocol_ext_empty_o;

// GNB-CU-TNL-Association-Setup-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using gnb_cu_tnl_assoc_setup_item_ext_ies_o = protocol_ext_empty_o;

// GNB-CU-TNL-Association-To-Add-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using gnb_cu_tnl_assoc_to_add_item_ext_ies_o = protocol_ext_empty_o;

// GNB-CU-TNL-Association-To-Remove-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
struct gnb_cu_tnl_assoc_to_rem_item_ext_ies_o {
  // Extension ::= OPEN TYPE
  struct ext_c {
    struct types_opts {
      enum options { tnl_assoc_transport_layer_address_gnb_du, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::tnl_assoc_transport_layer_address_gnb_du; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    cp_transport_layer_address_c&       tnl_assoc_transport_layer_address_gnb_du() { return c; }
    const cp_transport_layer_address_c& tnl_assoc_transport_layer_address_gnb_du() const { return c; }

  private:
    cp_transport_layer_address_c c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static ext_c      get_ext(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// GNB-CU-TNL-Association-To-Update-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using gnb_cu_tnl_assoc_to_upd_item_ext_ies_o = protocol_ext_empty_o;

// GNB-DU-Served-Cells-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using gnb_du_served_cells_item_ext_ies_o = protocol_ext_empty_o;

struct gnb_du_sys_info_ext_ies_container {
  template <class extT_>
  using ie_field_s = protocol_ext_container_item_s<extT_>;

  // member variables
  bool                                  sib12_msg_present = false;
  bool                                  sib13_msg_present = false;
  bool                                  sib14_msg_present = false;
  bool                                  sib10_msg_present = false;
  bool                                  sib17_msg_present = false;
  bool                                  sib20_msg_present = false;
  bool                                  sib15_msg_present = false;
  ie_field_s<unbounded_octstring<true>> sib12_msg;
  ie_field_s<unbounded_octstring<true>> sib13_msg;
  ie_field_s<unbounded_octstring<true>> sib14_msg;
  ie_field_s<unbounded_octstring<true>> sib10_msg;
  ie_field_s<unbounded_octstring<true>> sib17_msg;
  ie_field_s<unbounded_octstring<true>> sib20_msg;
  ie_field_s<unbounded_octstring<true>> sib15_msg;

  // sequence methods
  gnb_du_sys_info_ext_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// GNB-DU-System-Information ::= SEQUENCE
struct gnb_du_sys_info_s {
  bool                              ext             = false;
  bool                              ie_exts_present = false;
  unbounded_octstring<true>         mib_msg;
  unbounded_octstring<true>         sib1_msg;
  gnb_du_sys_info_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// GNB-DU-TNL-Association-To-Remove-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using gnb_du_tnl_assoc_to_rem_item_ext_ies_o = protocol_ext_empty_o;

// GTPTLAs ::= SEQUENCE (SIZE (1..16)) OF GTPTLA-Item
using gtp_tlas_l = dyn_array<gtp_tla_item_s>;

// IAB-Allocated-TNL-Address-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using iab_allocated_tnl_address_item_ext_ies_o = protocol_ext_empty_o;

// IAB-Congestion-Indication-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using iab_congestion_ind_item_ext_ies_o = protocol_ext_empty_o;

using iab_mt_cell_na_res_cfg_fdd_info_ext_ies_container = protocol_ext_container_empty_l;

// IAB-MT-Cell-NA-Resource-Configuration-FDD-Info ::= SEQUENCE
struct iab_mt_cell_na_res_cfg_fdd_info_s {
  bool                                              ext                  = false;
  bool                                              ul_freq_info_present = false;
  bool                                              ul_tx_bw_present     = false;
  bool                                              dl_freq_info_present = false;
  bool                                              dl_tx_bw_present     = false;
  bool                                              ie_exts_present      = false;
  gnb_du_cell_res_cfg_s                             gnb_du_cell_na_res_cfg_fdd_ul;
  gnb_du_cell_res_cfg_s                             gnb_du_cell_na_res_cfg_fdd_dl;
  nr_freq_info_s                                    ul_freq_info;
  tx_bw_s                                           ul_tx_bw;
  nr_carrier_list_l                                 ul_nr_carrier_list;
  nr_freq_info_s                                    dl_freq_info;
  tx_bw_s                                           dl_tx_bw;
  nr_carrier_list_l                                 dl_nr_carrier_list;
  iab_mt_cell_na_res_cfg_fdd_info_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// IAB-MT-Cell-NA-Resource-Configuration-Mode-Info-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
using iab_mt_cell_na_res_cfg_mode_info_ext_ies_o = protocol_ies_empty_o;

using iab_mt_cell_na_res_cfg_tdd_info_ext_ies_container = protocol_ext_container_empty_l;

// IAB-MT-Cell-NA-Resource-Configuration-TDD-Info ::= SEQUENCE
struct iab_mt_cell_na_res_cfg_tdd_info_s {
  bool                                              ext                  = false;
  bool                                              nr_freq_info_present = false;
  bool                                              tx_bw_present        = false;
  bool                                              ie_exts_present      = false;
  gnb_du_cell_res_cfg_s                             gnb_du_cell_na_resourc_cfg_tdd;
  nr_freq_info_s                                    nr_freq_info;
  tx_bw_s                                           tx_bw;
  nr_carrier_list_l                                 nr_carrier_list;
  iab_mt_cell_na_res_cfg_tdd_info_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// IAB-TNL-Addresses-To-Remove-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using iab_tnl_addresses_to_rem_item_ext_ies_o = protocol_ext_empty_o;

// IABTNLAddress-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using iab_tnl_address_item_ext_ies_o = protocol_ext_empty_o;

// IABTNLAddressUsage ::= ENUMERATED
struct iab_tnl_address_usage_opts {
  enum options { f1_c, f1_u, non_f1, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<iab_tnl_address_usage_opts, true> iab_tnl_address_usage_e;

// IgnorePRACHConfiguration ::= ENUMERATED
struct ignore_prach_cfg_opts {
  enum options { true_value, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<ignore_prach_cfg_opts, true> ignore_prach_cfg_e;

// M2Configuration ::= ENUMERATED
struct m2_cfg_opts {
  enum options { true_value, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<m2_cfg_opts, true> m2_cfg_e;

// M5Configuration ::= SEQUENCE
struct m5_cfg_s {
  bool                                       ext = false;
  m5period_e                                 m5period;
  m5_links_to_log_e                          m5_links_to_log;
  protocol_ext_container_l<m5_cfg_ext_ies_o> ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// M6Configuration ::= SEQUENCE
struct m6_cfg_s {
  bool                                       ext = false;
  m6report_interv_e                          m6report_interv;
  m6_links_to_log_e                          m6_links_to_log;
  protocol_ext_container_l<m6_cfg_ext_ies_o> ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// M7Configuration ::= SEQUENCE
struct m7_cfg_s {
  bool                                       ext      = false;
  uint8_t                                    m7period = 1;
  m7_links_to_log_e                          m7_links_to_log;
  protocol_ext_container_l<m7_cfg_ext_ies_o> ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MBSPTPRetransmissionTunnelRequired ::= ENUMERATED
struct mbsptp_retx_tunnel_required_opts {
  enum options { true_value, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<mbsptp_retx_tunnel_required_opts, true> mbsptp_retx_tunnel_required_e;

// MC-PagingCell-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using mc_paging_cell_item_ext_ies_o = protocol_ext_empty_o;

// MDT-Activation ::= ENUMERATED
struct mdt_activation_opts {
  enum options { immediate_mdt_only, immediate_mdt_and_trace, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<mdt_activation_opts, true> mdt_activation_e;

// MDTConfiguration-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using mdt_cfg_ext_ies_o = protocol_ext_empty_o;

// MRB-ProgressInformation ::= CHOICE
struct mrb_progress_info_c {
  struct types_opts {
    enum options { pdcp_sn12, pdcp_sn18, choice_ext, nulltype } value;
    typedef uint8_t number_type;

    const char* to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  mrb_progress_info_c() = default;
  mrb_progress_info_c(const mrb_progress_info_c& other);
  mrb_progress_info_c& operator=(const mrb_progress_info_c& other);
  ~mrb_progress_info_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  uint16_t& pdcp_sn12()
  {
    assert_choice_type(types::pdcp_sn12, type_, "MRB-ProgressInformation");
    return c.get<uint16_t>();
  }
  uint32_t& pdcp_sn18()
  {
    assert_choice_type(types::pdcp_sn18, type_, "MRB-ProgressInformation");
    return c.get<uint32_t>();
  }
  protocol_ie_single_container_s<mrb_progress_info_ext_ies_o>& choice_ext()
  {
    assert_choice_type(types::choice_ext, type_, "MRB-ProgressInformation");
    return c.get<protocol_ie_single_container_s<mrb_progress_info_ext_ies_o>>();
  }
  const uint16_t& pdcp_sn12() const
  {
    assert_choice_type(types::pdcp_sn12, type_, "MRB-ProgressInformation");
    return c.get<uint16_t>();
  }
  const uint32_t& pdcp_sn18() const
  {
    assert_choice_type(types::pdcp_sn18, type_, "MRB-ProgressInformation");
    return c.get<uint32_t>();
  }
  const protocol_ie_single_container_s<mrb_progress_info_ext_ies_o>& choice_ext() const
  {
    assert_choice_type(types::choice_ext, type_, "MRB-ProgressInformation");
    return c.get<protocol_ie_single_container_s<mrb_progress_info_ext_ies_o>>();
  }
  uint16_t&                                                    set_pdcp_sn12();
  uint32_t&                                                    set_pdcp_sn18();
  protocol_ie_single_container_s<mrb_progress_info_ext_ies_o>& set_choice_ext();

private:
  types                                                                        type_;
  choice_buffer_t<protocol_ie_single_container_s<mrb_progress_info_ext_ies_o>> c;

  void destroy_();
};

// MulticastF1UContext-FailedToBeSetup-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using multicast_f1_u_context_failed_to_be_setup_item_ext_ies_o = protocol_ext_empty_o;

// MulticastF1UContext-Setup-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using multicast_f1_u_context_setup_item_ext_ies_o = protocol_ext_empty_o;

// MulticastF1UContext-ToBeSetup-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using multicast_f1_u_context_to_be_setup_item_ext_ies_o = protocol_ext_empty_o;

// MulticastMRBs-FailedToBeSetup-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using multicast_m_rbs_failed_to_be_setup_item_ext_ies_o = protocol_ext_empty_o;

// MulticastMRBs-FailedToBeSetupMod-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using multicast_m_rbs_failed_to_be_setup_mod_item_ext_ies_o = protocol_ext_empty_o;

// MulticastMRBs-FailedtoBeModified-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using multicast_m_rbs_failedto_be_modified_item_ext_ies_o = protocol_ext_empty_o;

// MulticastMRBs-Modified-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using multicast_m_rbs_modified_item_ext_ies_o = protocol_ext_empty_o;

// MulticastMRBs-Setup-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using multicast_m_rbs_setup_item_ext_ies_o = protocol_ext_empty_o;

// MulticastMRBs-SetupMod-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using multicast_m_rbs_setup_mod_item_ext_ies_o = protocol_ext_empty_o;

// MulticastMRBs-ToBeModified-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using multicast_m_rbs_to_be_modified_item_ext_ies_o = protocol_ext_empty_o;

// MulticastMRBs-ToBeReleased-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using multicast_m_rbs_to_be_released_item_ext_ies_o = protocol_ext_empty_o;

// MulticastMRBs-ToBeSetup-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using multicast_m_rbs_to_be_setup_item_ext_ies_o = protocol_ext_empty_o;

// MulticastMRBs-ToBeSetupMod-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using multicast_m_rbs_to_be_setup_mod_item_ext_ies_o = protocol_ext_empty_o;

// NR-CGI-List-For-Restart-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using nr_cgi_list_for_restart_item_ext_ies_o = protocol_ext_empty_o;

// Neighbour-Cell-Information-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using neighbour_cell_info_item_ext_ies_o = protocol_ext_empty_o;

// NonUPTrafficType ::= ENUMERATED
struct non_up_traffic_type_opts {
  enum options { ue_associated, non_ue_associated, non_f1, bap_ctrl_pdu, /*...*/ nulltype } value;
  typedef uint8_t number_type;

  const char* to_string() const;
  uint8_t     to_number() const;
};
typedef enumerated<non_up_traffic_type_opts, true> non_up_traffic_type_e;

// NotificationInformationExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using notif_info_ext_ies_o = protocol_ext_empty_o;

// NumberOfTRPRxTEG ::= ENUMERATED
struct nof_trp_rx_teg_opts {
  enum options { two, three, four, six, eight, /*...*/ nulltype } value;
  typedef uint8_t number_type;

  const char* to_string() const;
  uint8_t     to_number() const;
};
typedef enumerated<nof_trp_rx_teg_opts, true> nof_trp_rx_teg_e;

// NumberOfTRPRxTxTEG ::= ENUMERATED
struct nof_trp_rx_tx_teg_opts {
  enum options { wo, three, four, six, eight, /*...*/ nulltype } value;
  typedef uint8_t number_type;

  const char* to_string() const;
  uint8_t     to_number() const;
};
typedef enumerated<nof_trp_rx_tx_teg_opts, true> nof_trp_rx_tx_teg_e;

// PC5RLCChannelQoSInformation-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
using pc5_rlc_ch_qos_info_ext_ies_o = protocol_ies_empty_o;

// PDCMeasuredResults-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using pdc_measured_results_item_ext_ies_o = protocol_ext_empty_o;

// PDCMeasuredResults-Value ::= CHOICE
struct pdc_measured_results_value_c {
  struct types_opts {
    enum options { pdc_tadv_nr, pdc_rx_tx_time_diff, choice_ext, nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  pdc_measured_results_value_c() = default;
  pdc_measured_results_value_c(const pdc_measured_results_value_c& other);
  pdc_measured_results_value_c& operator=(const pdc_measured_results_value_c& other);
  ~pdc_measured_results_value_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  uint16_t& pdc_tadv_nr()
  {
    assert_choice_type(types::pdc_tadv_nr, type_, "PDCMeasuredResults-Value");
    return c.get<uint16_t>();
  }
  uint16_t& pdc_rx_tx_time_diff()
  {
    assert_choice_type(types::pdc_rx_tx_time_diff, type_, "PDCMeasuredResults-Value");
    return c.get<uint16_t>();
  }
  protocol_ie_single_container_s<pdc_measured_results_value_ext_ies_o>& choice_ext()
  {
    assert_choice_type(types::choice_ext, type_, "PDCMeasuredResults-Value");
    return c.get<protocol_ie_single_container_s<pdc_measured_results_value_ext_ies_o>>();
  }
  const uint16_t& pdc_tadv_nr() const
  {
    assert_choice_type(types::pdc_tadv_nr, type_, "PDCMeasuredResults-Value");
    return c.get<uint16_t>();
  }
  const uint16_t& pdc_rx_tx_time_diff() const
  {
    assert_choice_type(types::pdc_rx_tx_time_diff, type_, "PDCMeasuredResults-Value");
    return c.get<uint16_t>();
  }
  const protocol_ie_single_container_s<pdc_measured_results_value_ext_ies_o>& choice_ext() const
  {
    assert_choice_type(types::choice_ext, type_, "PDCMeasuredResults-Value");
    return c.get<protocol_ie_single_container_s<pdc_measured_results_value_ext_ies_o>>();
  }
  uint16_t&                                                             set_pdc_tadv_nr();
  uint16_t&                                                             set_pdc_rx_tx_time_diff();
  protocol_ie_single_container_s<pdc_measured_results_value_ext_ies_o>& set_choice_ext();

private:
  types                                                                                 type_;
  choice_buffer_t<protocol_ie_single_container_s<pdc_measured_results_value_ext_ies_o>> c;

  void destroy_();
};

// PDCMeasurementQuantitiesValue ::= ENUMERATED
struct pdc_meas_quantities_value_opts {
  enum options { nr_pdc_tadv, gnb_rx_tx, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<pdc_meas_quantities_value_opts, true> pdc_meas_quantities_value_e;

// PDCMeasurementQuantitiesValue-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using pdc_meas_quantities_value_ext_ies_o = protocol_ext_empty_o;

// PRSTransmissionOffIndication ::= CHOICE
struct prs_tx_off_ind_c {
  struct types_opts {
    enum options { prs_tx_off_per_trp, prs_tx_off_per_res_set, prs_tx_off_per_res, choice_ext, nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  prs_tx_off_ind_c() = default;
  prs_tx_off_ind_c(const prs_tx_off_ind_c& other);
  prs_tx_off_ind_c& operator=(const prs_tx_off_ind_c& other);
  ~prs_tx_off_ind_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  prs_tx_off_per_res_set_l& prs_tx_off_per_res_set()
  {
    assert_choice_type(types::prs_tx_off_per_res_set, type_, "PRSTransmissionOffIndication");
    return c.get<prs_tx_off_per_res_set_l>();
  }
  prs_tx_off_per_res_l& prs_tx_off_per_res()
  {
    assert_choice_type(types::prs_tx_off_per_res, type_, "PRSTransmissionOffIndication");
    return c.get<prs_tx_off_per_res_l>();
  }
  protocol_ie_single_container_s<prs_tx_off_ind_ext_ies_o>& choice_ext()
  {
    assert_choice_type(types::choice_ext, type_, "PRSTransmissionOffIndication");
    return c.get<protocol_ie_single_container_s<prs_tx_off_ind_ext_ies_o>>();
  }
  const prs_tx_off_per_res_set_l& prs_tx_off_per_res_set() const
  {
    assert_choice_type(types::prs_tx_off_per_res_set, type_, "PRSTransmissionOffIndication");
    return c.get<prs_tx_off_per_res_set_l>();
  }
  const prs_tx_off_per_res_l& prs_tx_off_per_res() const
  {
    assert_choice_type(types::prs_tx_off_per_res, type_, "PRSTransmissionOffIndication");
    return c.get<prs_tx_off_per_res_l>();
  }
  const protocol_ie_single_container_s<prs_tx_off_ind_ext_ies_o>& choice_ext() const
  {
    assert_choice_type(types::choice_ext, type_, "PRSTransmissionOffIndication");
    return c.get<protocol_ie_single_container_s<prs_tx_off_ind_ext_ies_o>>();
  }
  void                                                      set_prs_tx_off_per_trp();
  prs_tx_off_per_res_set_l&                                 set_prs_tx_off_per_res_set();
  prs_tx_off_per_res_l&                                     set_prs_tx_off_per_res();
  protocol_ie_single_container_s<prs_tx_off_ind_ext_ies_o>& set_choice_ext();

private:
  types type_;
  choice_buffer_t<protocol_ie_single_container_s<prs_tx_off_ind_ext_ies_o>,
                  prs_tx_off_per_res_l,
                  prs_tx_off_per_res_set_l>
      c;

  void destroy_();
};

// PRSTransmissionOffInformation-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using prs_tx_off_info_ext_ies_o = protocol_ext_empty_o;

// PWS-Failed-NR-CGI-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using pws_failed_nr_cgi_item_ext_ies_o = protocol_ext_empty_o;

// PagingCell-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
struct paging_cell_item_ext_ies_o {
  // Extension ::= OPEN TYPE
  struct ext_c {
    struct types_opts {
      enum options { last_used_cell_ind, pei_subgrouping_support_ind, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    ext_c() = default;
    ext_c(const ext_c& other);
    ext_c& operator=(const ext_c& other);
    ~ext_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    last_used_cell_ind_e&                last_used_cell_ind();
    pei_subgrouping_support_ind_e&       pei_subgrouping_support_ind();
    const last_used_cell_ind_e&          last_used_cell_ind() const;
    const pei_subgrouping_support_ind_e& pei_subgrouping_support_ind() const;

  private:
    types               type_;
    pod_choice_buffer_t c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static ext_c      get_ext(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// PagingDRX ::= ENUMERATED
struct paging_drx_opts {
  enum options { v32, v64, v128, v256, /*...*/ nulltype } value;
  typedef uint16_t number_type;

  const char* to_string() const;
  uint16_t    to_number() const;
};
typedef enumerated<paging_drx_opts, true> paging_drx_e;

using pathloss_ref_info_ext_ies_container = protocol_ext_container_empty_l;

// PathlossReferenceInfo ::= SEQUENCE
struct pathloss_ref_info_s {
  bool                                ie_exts_present = false;
  pathloss_ref_sig_c                  pathloss_ref_sig;
  pathloss_ref_info_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PeriodicityList ::= SEQUENCE (SIZE (1..16)) OF PeriodicityList-Item
using periodicity_list_l = dyn_array<periodicity_list_item_s>;

struct pos_meas_result_item_ext_ies_container {
  template <class extT_>
  using ie_field_s = protocol_ext_container_item_s<extT_>;

  // member variables
  bool                                            arp_id_present                  = false;
  bool                                            srs_restype_present             = false;
  bool                                            lo_s_n_lo_si_nformation_present = false;
  ie_field_s<integer<uint8_t, 1, 16, true, true>> arp_id;
  ie_field_s<srs_restype_s>                       srs_restype;
  ie_field_s<lo_s_n_lo_si_nformation_c>           lo_s_n_lo_si_nformation;

  // sequence methods
  pos_meas_result_item_ext_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PosMeasurementResultItem ::= SEQUENCE
struct pos_meas_result_item_s {
  bool                                   meas_quality_present   = false;
  bool                                   meas_beam_info_present = false;
  bool                                   ie_exts_present        = false;
  measured_results_value_c               measured_results_value;
  time_stamp_s                           time_stamp;
  trp_meas_quality_s                     meas_quality;
  meas_beam_info_s                       meas_beam_info;
  pos_meas_result_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// Potential-SpCell-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using potential_sp_cell_item_ext_ies_o = protocol_ext_empty_o;

// Protected-EUTRA-Resources-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using protected_eutra_res_item_ext_ies_o = protocol_ext_empty_o;

// QoEInformationList-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using qo_e_info_list_item_ext_ies_o = protocol_ext_empty_o;

using qo_e_metrics_ext_ies_container = protocol_ext_container_empty_l;

// QoEMetrics ::= SEQUENCE
struct qo_e_metrics_s {
  bool                           ext             = false;
  bool                           ie_exts_present = false;
  unbounded_octstring<true>      app_layer_buffer_level_list;
  unbounded_octstring<true>      playout_delay_for_media_startup;
  qo_e_metrics_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RequestedDLPRSResourceSet-List ::= SEQUENCE (SIZE (1..8)) OF RequestedDLPRSResourceSet-Item
using requested_dl_prs_res_set_list_l = dyn_array<requested_dl_prs_res_set_item_s>;

// RequestedDLPRSTransmissionCharacteristics-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using requested_dl_prs_tx_characteristics_ext_ies_o = protocol_ext_empty_o;

// SCell-FailedtoSetup-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using scell_failedto_setup_item_ext_ies_o = protocol_ext_empty_o;

// SCell-FailedtoSetupMod-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using scell_failedto_setup_mod_item_ext_ies_o = protocol_ext_empty_o;

// SCell-ToBeRemoved-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using scell_to_be_remd_item_ext_ies_o = protocol_ext_empty_o;

// SCell-ToBeSetup-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
struct scell_to_be_setup_item_ext_ies_o {
  // Extension ::= OPEN TYPE
  struct ext_c {
    struct types_opts {
      enum options { serving_cell_mo, nulltype } value;
      typedef uint8_t number_type;

      const char* to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::serving_cell_mo; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint8_t&       serving_cell_mo() { return c; }
    const uint8_t& serving_cell_mo() const { return c; }

  private:
    uint8_t c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static ext_c      get_ext(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// SCell-ToBeSetupMod-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
struct scell_to_be_setup_mod_item_ext_ies_o {
  // Extension ::= OPEN TYPE
  struct ext_c {
    struct types_opts {
      enum options { serving_cell_mo, nulltype } value;
      typedef uint8_t number_type;

      const char* to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::serving_cell_mo; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint8_t&       serving_cell_mo() { return c; }
    const uint8_t& serving_cell_mo() const { return c; }

  private:
    uint8_t c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static ext_c      get_ext(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// SDTBearerConfig-List-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using sdt_bearer_cfg_list_item_ext_ies_o = protocol_ext_empty_o;

// SDTBearerType ::= CHOICE
struct sdt_bearer_type_c {
  struct types_opts {
    enum options { srb, drb, choice_ext, nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  sdt_bearer_type_c() = default;
  sdt_bearer_type_c(const sdt_bearer_type_c& other);
  sdt_bearer_type_c& operator=(const sdt_bearer_type_c& other);
  ~sdt_bearer_type_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  uint8_t& srb()
  {
    assert_choice_type(types::srb, type_, "SDTBearerType");
    return c.get<uint8_t>();
  }
  uint8_t& drb()
  {
    assert_choice_type(types::drb, type_, "SDTBearerType");
    return c.get<uint8_t>();
  }
  protocol_ie_single_container_s<sdt_bearer_type_ext_ies_o>& choice_ext()
  {
    assert_choice_type(types::choice_ext, type_, "SDTBearerType");
    return c.get<protocol_ie_single_container_s<sdt_bearer_type_ext_ies_o>>();
  }
  const uint8_t& srb() const
  {
    assert_choice_type(types::srb, type_, "SDTBearerType");
    return c.get<uint8_t>();
  }
  const uint8_t& drb() const
  {
    assert_choice_type(types::drb, type_, "SDTBearerType");
    return c.get<uint8_t>();
  }
  const protocol_ie_single_container_s<sdt_bearer_type_ext_ies_o>& choice_ext() const
  {
    assert_choice_type(types::choice_ext, type_, "SDTBearerType");
    return c.get<protocol_ie_single_container_s<sdt_bearer_type_ext_ies_o>>();
  }
  uint8_t&                                                   set_srb();
  uint8_t&                                                   set_drb();
  protocol_ie_single_container_s<sdt_bearer_type_ext_ies_o>& set_choice_ext();

private:
  types                                                                      type_;
  choice_buffer_t<protocol_ie_single_container_s<sdt_bearer_type_ext_ies_o>> c;

  void destroy_();
};

// SLDRBInformation ::= SEQUENCE
struct sl_drb_info_s {
  bool                          ext = false;
  pc5_qos_params_s              sl_drb_qos;
  flows_mapped_to_sl_drb_list_l flows_mapped_to_sl_drb_list;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SLDRBs-FailedToBeModified-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using sl_drbs_failed_to_be_modified_item_ext_ies_o = protocol_ext_empty_o;

// SLDRBs-FailedToBeSetup-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using sl_drbs_failed_to_be_setup_item_ext_ies_o = protocol_ext_empty_o;

// SLDRBs-FailedToBeSetupMod-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using sl_drbs_failed_to_be_setup_mod_item_ext_ies_o = protocol_ext_empty_o;

// SLDRBs-Modified-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using sl_drbs_modified_item_ext_ies_o = protocol_ext_empty_o;

// SLDRBs-ModifiedConf-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using sl_drbs_modified_conf_item_ext_ies_o = protocol_ext_empty_o;

// SLDRBs-Required-ToBeModified-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using sl_drbs_required_to_be_modified_item_ext_ies_o = protocol_ext_empty_o;

// SLDRBs-Required-ToBeReleased-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using sl_drbs_required_to_be_released_item_ext_ies_o = protocol_ext_empty_o;

// SLDRBs-Setup-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using sl_drbs_setup_item_ext_ies_o = protocol_ext_empty_o;

// SLDRBs-SetupMod-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using sl_drbs_setup_mod_item_ext_ies_o = protocol_ext_empty_o;

// SLDRBs-ToBeModified-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using sl_drbs_to_be_modified_item_ext_ies_o = protocol_ext_empty_o;

// SLDRBs-ToBeReleased-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using sl_drbs_to_be_released_item_ext_ies_o = protocol_ext_empty_o;

// SLDRBs-ToBeSetup-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using sl_drbs_to_be_setup_item_ext_ies_o = protocol_ext_empty_o;

// SLDRBs-ToBeSetupMod-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using sl_drbs_to_be_setup_mod_item_ext_ies_o = protocol_ext_empty_o;

// SLDRXConfigurationIndicator ::= ENUMERATED
struct sldrx_cfg_ind_opts {
  enum options { release, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<sldrx_cfg_ind_opts, true> sldrx_cfg_ind_e;

// SLDRXCycleLength ::= ENUMERATED
struct sldrx_cycle_len_opts {
  enum options {
    ms10,
    ms20,
    ms32,
    ms40,
    ms60,
    ms64,
    ms70,
    ms80,
    ms128,
    ms160,
    ms256,
    ms320,
    ms512,
    ms640,
    ms1024,
    ms1280,
    ms2048,
    ms2560,
    ms5120,
    ms10240,
    // ...
    nulltype
  } value;
  typedef uint16_t number_type;

  const char* to_string() const;
  uint16_t    to_number() const;
};
typedef enumerated<sldrx_cycle_len_opts, true> sldrx_cycle_len_e;

// SLDRXInformation-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
using sldrx_info_ext_ies_o = protocol_ies_empty_o;

// SRBs-FailedToBeSetup-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using srbs_failed_to_be_setup_item_ext_ies_o = protocol_ext_empty_o;

// SRBs-FailedToBeSetupMod-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using srbs_failed_to_be_setup_mod_item_ext_ies_o = protocol_ext_empty_o;

// SRBs-Modified-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using srbs_modified_item_ext_ies_o = protocol_ext_empty_o;

// SRBs-Required-ToBeReleased-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using srbs_required_to_be_released_item_ext_ies_o = protocol_ext_empty_o;

// SRBs-Setup-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using srbs_setup_item_ext_ies_o = protocol_ext_empty_o;

// SRBs-SetupMod-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using srbs_setup_mod_item_ext_ies_o = protocol_ext_empty_o;

// SRBs-ToBeReleased-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using srbs_to_be_released_item_ext_ies_o = protocol_ext_empty_o;

// SRBs-ToBeSetup-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
struct srbs_to_be_setup_item_ext_ies_o {
  // Extension ::= OPEN TYPE
  struct ext_c {
    struct types_opts {
      enum options { add_dupl_ind, sdt_rlc_bearer_cfg, srb_map_info, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    ext_c() = default;
    ext_c(const ext_c& other);
    ext_c& operator=(const ext_c& other);
    ~ext_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    add_dupl_ind_e&                         add_dupl_ind();
    unbounded_octstring<true>&              sdt_rlc_bearer_cfg();
    fixed_bitstring<16, false, true>&       srb_map_info();
    const add_dupl_ind_e&                   add_dupl_ind() const;
    const unbounded_octstring<true>&        sdt_rlc_bearer_cfg() const;
    const fixed_bitstring<16, false, true>& srb_map_info() const;

  private:
    types                                                                        type_;
    choice_buffer_t<fixed_bitstring<16, false, true>, unbounded_octstring<true>> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static ext_c      get_ext(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// SRBs-ToBeSetupMod-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
struct srbs_to_be_setup_mod_item_ext_ies_o {
  // Extension ::= OPEN TYPE
  struct ext_c {
    struct types_opts {
      enum options { add_dupl_ind, srb_map_info, cg_sd_tind_setup, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    ext_c() = default;
    ext_c(const ext_c& other);
    ext_c& operator=(const ext_c& other);
    ~ext_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    add_dupl_ind_e&                         add_dupl_ind();
    fixed_bitstring<16, false, true>&       srb_map_info();
    cg_sd_tind_setup_e&                     cg_sd_tind_setup();
    const add_dupl_ind_e&                   add_dupl_ind() const;
    const fixed_bitstring<16, false, true>& srb_map_info() const;
    const cg_sd_tind_setup_e&               cg_sd_tind_setup() const;

  private:
    types                                             type_;
    choice_buffer_t<fixed_bitstring<16, false, true>> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static ext_c      get_ext(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// SRSCarrier-List-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using srs_carrier_list_item_ext_ies_o = protocol_ext_empty_o;

// SRSResourceSetItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
struct srs_res_set_item_ext_ies_o {
  // Extension ::= OPEN TYPE
  struct ext_c {
    struct types_opts {
      enum options { srs_spatial_relation_per_srs_res, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::srs_spatial_relation_per_srs_res; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    spatial_relation_per_srs_res_s&       srs_spatial_relation_per_srs_res() { return c; }
    const spatial_relation_per_srs_res_s& srs_spatial_relation_per_srs_res() const { return c; }

  private:
    spatial_relation_per_srs_res_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static ext_c      get_ext(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// Search-window-information-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using search_win_info_ext_ies_o = protocol_ext_empty_o;

struct served_cell_info_ext_ies_container {
  template <class extT_>
  using ie_field_s = protocol_ext_container_item_s<extT_>;

  // member variables
  bool                                                             ranac_present                      = false;
  bool                                                             extended_served_plmns_list_present = false;
  bool                                                             cell_direction_present             = false;
  bool                                                             bplmn_id_info_list_present         = false;
  bool                                                             cell_type_present                  = false;
  bool                                                             cfg_tac_ind_present                = false;
  bool                                                             aggressor_gnb_set_id_present       = false;
  bool                                                             victim_gnb_set_id_present          = false;
  bool                                                             iab_info_iab_du_present            = false;
  bool                                                             ssb_positions_in_burst_present     = false;
  bool                                                             nr_prach_cfg_present               = false;
  bool                                                             sfn_offset_present                 = false;
  bool                                                             npn_broadcast_info_present         = false;
  bool                                                             supported_mbs_fsa_id_list_present  = false;
  bool                                                             redcap_bcast_info_present          = false;
  ie_field_s<integer<uint16_t, 0, 255, false, true>>               ranac;
  ie_field_s<dyn_seq_of<extended_served_plmns_item_s, 1, 6, true>> extended_served_plmns_list;
  ie_field_s<cell_direction_e>                                     cell_direction;
  ie_field_s<dyn_seq_of<bplmn_id_info_item_s, 1, 12, true>>        bplmn_id_info_list;
  ie_field_s<cell_type_s>                                          cell_type;
  ie_field_s<cfg_tac_ind_e>                                        cfg_tac_ind;
  ie_field_s<aggressor_gnb_set_id_s>                               aggressor_gnb_set_id;
  ie_field_s<victim_gnb_set_id_s>                                  victim_gnb_set_id;
  ie_field_s<iab_info_iab_du_s>                                    iab_info_iab_du;
  ie_field_s<ssb_positions_in_burst_c>                             ssb_positions_in_burst;
  ie_field_s<nr_prach_cfg_s>                                       nr_prach_cfg;
  ie_field_s<sfn_offset_s>                                         sfn_offset;
  ie_field_s<npn_broadcast_info_c>                                 npn_broadcast_info;
  ie_field_s<dyn_seq_of<fixed_octstring<3, true>, 1, 256, true>>   supported_mbs_fsa_id_list;
  ie_field_s<fixed_bitstring<8, false, true>>                      redcap_bcast_info;

  // sequence methods
  served_cell_info_ext_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// Served-Cell-Information ::= SEQUENCE
struct served_cell_info_s {
  bool                               ext                 = false;
  bool                               five_gs_tac_present = false;
  bool                               cfg_eps_tac_present = false;
  bool                               ie_exts_present     = false;
  nr_cgi_s                           nr_cgi;
  uint16_t                           nr_pci = 0;
  fixed_octstring<3, true>           five_gs_tac;
  fixed_octstring<2, true>           cfg_eps_tac;
  served_plmns_list_l                served_plmns;
  nr_mode_info_c                     nr_mode_info;
  unbounded_octstring<true>          meas_timing_cfg;
  served_cell_info_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// Served-Cells-To-Add-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using served_cells_to_add_item_ext_ies_o = protocol_ext_empty_o;

// Served-Cells-To-Delete-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using served_cells_to_delete_item_ext_ies_o = protocol_ext_empty_o;

// Served-Cells-To-Modify-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using served_cells_to_modify_item_ext_ies_o = protocol_ext_empty_o;

// ServingCellMO-List-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using serving_cell_mo_list_item_ext_ies_o = protocol_ext_empty_o;

using spatial_relation_info_ext_ies_container = protocol_ext_container_empty_l;

// SpatialRelationInfo ::= SEQUENCE
struct spatial_relation_info_s {
  bool                                    ie_exts_present = false;
  spatial_relationfor_res_id_l            spatial_relationfor_res_id;
  spatial_relation_info_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// TNLAssociationUsage ::= ENUMERATED
struct tnl_assoc_usage_opts {
  enum options { ue, non_ue, both, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<tnl_assoc_usage_opts, true> tnl_assoc_usage_e;

using trp_info_ext_ies_container = protocol_ext_container_empty_l;

// TRPInformation ::= SEQUENCE
struct trp_info_s {
  bool                       ie_exts_present = false;
  uint32_t                   trp_id          = 0;
  trp_info_type_resp_list_l  trp_info_type_resp_list;
  trp_info_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// TRPInformationItem-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using trp_info_item_ext_ies_o = protocol_ext_empty_o;

// Transport-UP-Layer-Address-Info-To-Add-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using transport_up_layer_address_info_to_add_item_ext_ies_o = protocol_ext_empty_o;

// Transport-UP-Layer-Address-Info-To-Remove-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using transport_up_layer_address_info_to_rem_item_ext_ies_o = protocol_ext_empty_o;

// UACPLMN-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
struct uac_plmn_item_ext_ies_o {
  // Extension ::= OPEN TYPE
  struct ext_c {
    struct types_opts {
      enum options { n_id, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::n_id; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    fixed_bitstring<44, false, true>&       n_id() { return c; }
    const fixed_bitstring<44, false, true>& n_id() const { return c; }

  private:
    fixed_bitstring<44, false, true> c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static ext_c      get_ext(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// UACType-List ::= SEQUENCE (SIZE (1..64)) OF UACType-Item
using uac_type_list_l = dyn_array<uac_type_item_s>;

// UE-MulticastMRBs-ConfirmedToBeModified-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using ue_multicast_m_rbs_confirmed_to_be_modified_item_ext_ies_o = protocol_ext_empty_o;

// UE-MulticastMRBs-RequiredToBeModified-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
struct ue_multicast_m_rbs_required_to_be_modified_item_ext_ies_o {
  // Extension ::= OPEN TYPE
  struct ext_c {
    struct types_opts {
      enum options { multicast_f1_u_context_ref_cu, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::multicast_f1_u_context_ref_cu; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    fixed_octstring<4, true>&       multicast_f1_u_context_ref_cu() { return c; }
    const fixed_octstring<4, true>& multicast_f1_u_context_ref_cu() const { return c; }

  private:
    fixed_octstring<4, true> c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static ext_c      get_ext(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// UE-MulticastMRBs-RequiredToBeReleased-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using ue_multicast_m_rbs_required_to_be_released_item_ext_ies_o = protocol_ext_empty_o;

// UE-MulticastMRBs-Setup-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using ue_multicast_m_rbs_setup_item_ext_ies_o = protocol_ext_empty_o;

// UE-MulticastMRBs-ToBeReleased-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using ue_multicast_m_rbs_to_be_released_item_ext_ies_o = protocol_ext_empty_o;

// UE-MulticastMRBs-ToBeSetup-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
struct ue_multicast_m_rbs_to_be_setup_item_ext_ies_o {
  // Extension ::= OPEN TYPE
  struct ext_c {
    struct types_opts {
      enum options { source_mrb_id, nulltype } value;
      typedef uint8_t number_type;

      const char* to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::source_mrb_id; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint16_t&       source_mrb_id() { return c; }
    const uint16_t& source_mrb_id() const { return c; }

  private:
    uint16_t c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static ext_c      get_ext(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// UE-MulticastMRBs-ToBeSetup-atModify-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using ue_multicast_m_rbs_to_be_setup_at_modify_item_ext_ies_o = protocol_ext_empty_o;

using ue_associated_lc_f1_conn_item_ext_ies_container = protocol_ext_container_empty_l;

// UE-associatedLogicalF1-ConnectionItem ::= SEQUENCE
struct ue_associated_lc_f1_conn_item_s {
  bool                                            ext                       = false;
  bool                                            gnb_cu_ue_f1ap_id_present = false;
  bool                                            gnb_du_ue_f1ap_id_present = false;
  bool                                            ie_exts_present           = false;
  uint64_t                                        gnb_cu_ue_f1ap_id         = 0;
  uint64_t                                        gnb_du_ue_f1ap_id         = 0;
  ue_associated_lc_f1_conn_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UEIdentity-List-For-Paging-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using ue_id_list_for_paging_item_ext_ies_o = protocol_ext_empty_o;

// UEIdentityIndexValue ::= CHOICE
struct ue_id_idx_value_c {
  struct types_opts {
    enum options { idx_len10, choice_ext, nulltype } value;
    typedef uint8_t number_type;

    const char* to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  ue_id_idx_value_c() = default;
  ue_id_idx_value_c(const ue_id_idx_value_c& other);
  ue_id_idx_value_c& operator=(const ue_id_idx_value_c& other);
  ~ue_id_idx_value_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  fixed_bitstring<10, false, true>& idx_len10()
  {
    assert_choice_type(types::idx_len10, type_, "UEIdentityIndexValue");
    return c.get<fixed_bitstring<10, false, true>>();
  }
  protocol_ie_single_container_s<ue_id_idx_value_choice_ext_ies_o>& choice_ext()
  {
    assert_choice_type(types::choice_ext, type_, "UEIdentityIndexValue");
    return c.get<protocol_ie_single_container_s<ue_id_idx_value_choice_ext_ies_o>>();
  }
  const fixed_bitstring<10, false, true>& idx_len10() const
  {
    assert_choice_type(types::idx_len10, type_, "UEIdentityIndexValue");
    return c.get<fixed_bitstring<10, false, true>>();
  }
  const protocol_ie_single_container_s<ue_id_idx_value_choice_ext_ies_o>& choice_ext() const
  {
    assert_choice_type(types::choice_ext, type_, "UEIdentityIndexValue");
    return c.get<protocol_ie_single_container_s<ue_id_idx_value_choice_ext_ies_o>>();
  }
  fixed_bitstring<10, false, true>&                                 set_idx_len10();
  protocol_ie_single_container_s<ue_id_idx_value_choice_ext_ies_o>& set_choice_ext();

private:
  types type_;
  choice_buffer_t<fixed_bitstring<10, false, true>, protocol_ie_single_container_s<ue_id_idx_value_choice_ext_ies_o>> c;

  void destroy_();
};

// UL-BH-Non-UP-Traffic-Mapping-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using ul_bh_non_up_traffic_map_item_ext_ies_o = protocol_ext_empty_o;

// UL-UP-TNL-Address-to-Update-List-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using ul_up_tnl_address_to_upd_list_item_ext_ies_o = protocol_ext_empty_o;

// UL-UP-TNL-Information-to-Update-List-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using ul_up_tnl_info_to_upd_list_item_ext_ies_o = protocol_ext_empty_o;

// UplinkChannelBW-PerSCS-List ::= SEQUENCE (SIZE (1..5)) OF SCS-SpecificCarrier
using ul_ch_bw_per_scs_list_l = dyn_array<scs_specific_carrier_s>;

// UuRLCChannelQoSInformation-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
using uu_rlc_ch_qos_info_ext_ies_o = protocol_ies_empty_o;

using gnb_cu_tnl_assoc_failed_to_setup_item_ext_ies_container = protocol_ext_container_empty_l;

// GNB-CU-TNL-Association-Failed-To-Setup-Item ::= SEQUENCE
struct gnb_cu_tnl_assoc_failed_to_setup_item_s {
  bool                                                    ie_exts_present = false;
  cp_transport_layer_address_c                            tnl_assoc_transport_layer_address;
  cause_c                                                 cause;
  gnb_cu_tnl_assoc_failed_to_setup_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using gnb_cu_tnl_assoc_setup_item_ext_ies_container = protocol_ext_container_empty_l;

// GNB-CU-TNL-Association-Setup-Item ::= SEQUENCE
struct gnb_cu_tnl_assoc_setup_item_s {
  bool                                          ie_exts_present = false;
  cp_transport_layer_address_c                  tnl_assoc_transport_layer_address;
  gnb_cu_tnl_assoc_setup_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using gnb_cu_tnl_assoc_to_add_item_ext_ies_container = protocol_ext_container_empty_l;

// GNB-CU-TNL-Association-To-Add-Item ::= SEQUENCE
struct gnb_cu_tnl_assoc_to_add_item_s {
  bool                                           ie_exts_present = false;
  cp_transport_layer_address_c                   tnl_assoc_transport_layer_address;
  tnl_assoc_usage_e                              tnl_assoc_usage;
  gnb_cu_tnl_assoc_to_add_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// GNB-CU-TNL-Association-To-Remove-Item ::= SEQUENCE
struct gnb_cu_tnl_assoc_to_rem_item_s {
  cp_transport_layer_address_c                                     tnl_assoc_transport_layer_address;
  protocol_ext_container_l<gnb_cu_tnl_assoc_to_rem_item_ext_ies_o> ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using gnb_cu_tnl_assoc_to_upd_item_ext_ies_container = protocol_ext_container_empty_l;

// GNB-CU-TNL-Association-To-Update-Item ::= SEQUENCE
struct gnb_cu_tnl_assoc_to_upd_item_s {
  bool                                           tnl_assoc_usage_present = false;
  bool                                           ie_exts_present         = false;
  cp_transport_layer_address_c                   tnl_assoc_transport_layer_address;
  tnl_assoc_usage_e                              tnl_assoc_usage;
  gnb_cu_tnl_assoc_to_upd_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using gnb_du_served_cells_item_ext_ies_container = protocol_ext_container_empty_l;

// GNB-DU-Served-Cells-Item ::= SEQUENCE
struct gnb_du_served_cells_item_s {
  bool                                       ext                     = false;
  bool                                       gnb_du_sys_info_present = false;
  bool                                       ie_exts_present         = false;
  served_cell_info_s                         served_cell_info;
  gnb_du_sys_info_s                          gnb_du_sys_info;
  gnb_du_served_cells_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using gnb_du_tnl_assoc_to_rem_item_ext_ies_container = protocol_ext_container_empty_l;

// GNB-DU-TNL-Association-To-Remove-Item ::= SEQUENCE
struct gnb_du_tnl_assoc_to_rem_item_s {
  bool                                           tnl_assoc_transport_layer_address_gnb_cu_present = false;
  bool                                           ie_exts_present                                  = false;
  cp_transport_layer_address_c                   tnl_assoc_transport_layer_address;
  cp_transport_layer_address_c                   tnl_assoc_transport_layer_address_gnb_cu;
  gnb_du_tnl_assoc_to_rem_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// GNBDUUESliceMaximumBitRateItem-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using gnb_du_ue_slice_max_bit_rate_item_ext_ies_o = protocol_ext_empty_o;

using iab_allocated_tnl_address_item_ext_ies_container = protocol_ext_container_empty_l;

// IAB-Allocated-TNL-Address-Item ::= SEQUENCE
struct iab_allocated_tnl_address_item_s {
  bool                                             iab_tnl_address_usage_present = false;
  bool                                             ie_exts_present               = false;
  iab_tnl_address_c                                iab_tnl_address;
  iab_tnl_address_usage_e                          iab_tnl_address_usage;
  iab_allocated_tnl_address_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using iab_congestion_ind_item_ext_ies_container = protocol_ext_container_empty_l;

// IAB-Congestion-Indication-Item ::= SEQUENCE
struct iab_congestion_ind_item_s {
  bool                                      ie_exts_present = false;
  fixed_bitstring<10, false, true>          child_node_id;
  bh_rlc_ch_list_l                          bh_rlc_ch_list;
  iab_congestion_ind_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// IAB-MT-Cell-NA-Resource-Configuration-Mode-Info ::= CHOICE
struct iab_mt_cell_na_res_cfg_mode_info_c {
  struct types_opts {
    enum options { fdd, tdd, choice_ext, nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  iab_mt_cell_na_res_cfg_mode_info_c() = default;
  iab_mt_cell_na_res_cfg_mode_info_c(const iab_mt_cell_na_res_cfg_mode_info_c& other);
  iab_mt_cell_na_res_cfg_mode_info_c& operator=(const iab_mt_cell_na_res_cfg_mode_info_c& other);
  ~iab_mt_cell_na_res_cfg_mode_info_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  iab_mt_cell_na_res_cfg_fdd_info_s& fdd()
  {
    assert_choice_type(types::fdd, type_, "IAB-MT-Cell-NA-Resource-Configuration-Mode-Info");
    return c.get<iab_mt_cell_na_res_cfg_fdd_info_s>();
  }
  iab_mt_cell_na_res_cfg_tdd_info_s& tdd()
  {
    assert_choice_type(types::tdd, type_, "IAB-MT-Cell-NA-Resource-Configuration-Mode-Info");
    return c.get<iab_mt_cell_na_res_cfg_tdd_info_s>();
  }
  protocol_ie_single_container_s<iab_mt_cell_na_res_cfg_mode_info_ext_ies_o>& choice_ext()
  {
    assert_choice_type(types::choice_ext, type_, "IAB-MT-Cell-NA-Resource-Configuration-Mode-Info");
    return c.get<protocol_ie_single_container_s<iab_mt_cell_na_res_cfg_mode_info_ext_ies_o>>();
  }
  const iab_mt_cell_na_res_cfg_fdd_info_s& fdd() const
  {
    assert_choice_type(types::fdd, type_, "IAB-MT-Cell-NA-Resource-Configuration-Mode-Info");
    return c.get<iab_mt_cell_na_res_cfg_fdd_info_s>();
  }
  const iab_mt_cell_na_res_cfg_tdd_info_s& tdd() const
  {
    assert_choice_type(types::tdd, type_, "IAB-MT-Cell-NA-Resource-Configuration-Mode-Info");
    return c.get<iab_mt_cell_na_res_cfg_tdd_info_s>();
  }
  const protocol_ie_single_container_s<iab_mt_cell_na_res_cfg_mode_info_ext_ies_o>& choice_ext() const
  {
    assert_choice_type(types::choice_ext, type_, "IAB-MT-Cell-NA-Resource-Configuration-Mode-Info");
    return c.get<protocol_ie_single_container_s<iab_mt_cell_na_res_cfg_mode_info_ext_ies_o>>();
  }
  iab_mt_cell_na_res_cfg_fdd_info_s&                                          set_fdd();
  iab_mt_cell_na_res_cfg_tdd_info_s&                                          set_tdd();
  protocol_ie_single_container_s<iab_mt_cell_na_res_cfg_mode_info_ext_ies_o>& set_choice_ext();

private:
  types type_;
  choice_buffer_t<iab_mt_cell_na_res_cfg_fdd_info_s,
                  iab_mt_cell_na_res_cfg_tdd_info_s,
                  protocol_ie_single_container_s<iab_mt_cell_na_res_cfg_mode_info_ext_ies_o>>
      c;

  void destroy_();
};

using iab_tnl_addresses_to_rem_item_ext_ies_container = protocol_ext_container_empty_l;

// IAB-TNL-Addresses-To-Remove-Item ::= SEQUENCE
struct iab_tnl_addresses_to_rem_item_s {
  bool                                            ie_exts_present = false;
  iab_tnl_address_c                               iab_tnl_address;
  iab_tnl_addresses_to_rem_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using iab_tnl_address_item_ext_ies_container = protocol_ext_container_empty_l;

// IABTNLAddress-Item ::= SEQUENCE
struct iab_tnl_address_item_s {
  bool                                   ie_exts_present = false;
  iab_tnl_address_c                      iab_tnl_address;
  iab_tnl_address_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// IABTNLAddressesRequested-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using iab_tnl_addresses_requested_ext_ies_o = protocol_ext_empty_o;

using mc_paging_cell_item_ext_ies_container = protocol_ext_container_empty_l;

// MC-PagingCell-Item ::= SEQUENCE
struct mc_paging_cell_item_s {
  bool                                  ie_exts_present = false;
  nr_cgi_s                              nr_cgi;
  mc_paging_cell_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using mdt_cfg_ext_ies_container = protocol_ext_container_empty_l;

// MDTConfiguration ::= SEQUENCE
struct mdt_cfg_s {
  bool                            ext             = false;
  bool                            m2_cfg_present  = false;
  bool                            m5_cfg_present  = false;
  bool                            m6_cfg_present  = false;
  bool                            m7_cfg_present  = false;
  bool                            ie_exts_present = false;
  mdt_activation_e                mdt_activation;
  fixed_bitstring<8, false, true> meass_to_activ;
  m2_cfg_e                        m2_cfg;
  m5_cfg_s                        m5_cfg;
  m6_cfg_s                        m6_cfg;
  m7_cfg_s                        m7_cfg;
  mdt_cfg_ext_ies_container       ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using multicast_f1_u_context_failed_to_be_setup_item_ext_ies_container = protocol_ext_container_empty_l;

// MulticastF1UContext-FailedToBeSetup-Item ::= SEQUENCE
struct multicast_f1_u_context_failed_to_be_setup_item_s {
  bool                                                             ext             = false;
  bool                                                             cause_present   = false;
  bool                                                             ie_exts_present = false;
  uint16_t                                                         mrb_id          = 1;
  cause_c                                                          cause;
  multicast_f1_u_context_failed_to_be_setup_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using multicast_f1_u_context_setup_item_ext_ies_container = protocol_ext_container_empty_l;

// MulticastF1UContext-Setup-Item ::= SEQUENCE
struct multicast_f1_u_context_setup_item_s {
  bool                                                ext             = false;
  bool                                                ie_exts_present = false;
  uint16_t                                            mrb_id          = 1;
  up_transport_layer_info_c                           mbs_f1u_info_at_cu;
  multicast_f1_u_context_setup_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using multicast_f1_u_context_to_be_setup_item_ext_ies_container = protocol_ext_container_empty_l;

// MulticastF1UContext-ToBeSetup-Item ::= SEQUENCE
struct multicast_f1_u_context_to_be_setup_item_s {
  bool                                                      ext                       = false;
  bool                                                      mbs_progress_info_present = false;
  bool                                                      ie_exts_present           = false;
  uint16_t                                                  mrb_id                    = 1;
  up_transport_layer_info_c                                 mbs_f1u_info_at_du;
  mrb_progress_info_c                                       mbs_progress_info;
  multicast_f1_u_context_to_be_setup_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MulticastMBSSessionList-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using multicast_mbs_session_list_item_ext_ies_o = protocol_ext_empty_o;

using multicast_m_rbs_failedto_be_modified_item_ext_ies_container = protocol_ext_container_empty_l;

// MulticastMRBs-FailedToBeModified-Item ::= SEQUENCE
struct multicast_m_rbs_failed_to_be_modified_item_s {
  bool                                                        ext             = false;
  bool                                                        cause_present   = false;
  bool                                                        ie_exts_present = false;
  uint16_t                                                    mrb_id          = 1;
  cause_c                                                     cause;
  multicast_m_rbs_failedto_be_modified_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using multicast_m_rbs_failed_to_be_setup_item_ext_ies_container = protocol_ext_container_empty_l;

// MulticastMRBs-FailedToBeSetup-Item ::= SEQUENCE
struct multicast_m_rbs_failed_to_be_setup_item_s {
  bool                                                      ext             = false;
  bool                                                      cause_present   = false;
  bool                                                      ie_exts_present = false;
  uint16_t                                                  mrb_id          = 1;
  cause_c                                                   cause;
  multicast_m_rbs_failed_to_be_setup_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using multicast_m_rbs_failed_to_be_setup_mod_item_ext_ies_container = protocol_ext_container_empty_l;

// MulticastMRBs-FailedToBeSetupMod-Item ::= SEQUENCE
struct multicast_m_rbs_failed_to_be_setup_mod_item_s {
  bool                                                          ext             = false;
  bool                                                          cause_present   = false;
  bool                                                          ie_exts_present = false;
  uint16_t                                                      mrb_id          = 1;
  cause_c                                                       cause;
  multicast_m_rbs_failed_to_be_setup_mod_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using multicast_m_rbs_modified_item_ext_ies_container = protocol_ext_container_empty_l;

// MulticastMRBs-Modified-Item ::= SEQUENCE
struct multicast_m_rbs_modified_item_s {
  bool                                            ext             = false;
  bool                                            ie_exts_present = false;
  uint16_t                                        mrb_id          = 1;
  multicast_m_rbs_modified_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using multicast_m_rbs_setup_item_ext_ies_container = protocol_ext_container_empty_l;

// MulticastMRBs-Setup-Item ::= SEQUENCE
struct multicast_m_rbs_setup_item_s {
  bool                                         ext             = false;
  bool                                         ie_exts_present = false;
  uint16_t                                     mrb_id          = 1;
  multicast_m_rbs_setup_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using multicast_m_rbs_setup_mod_item_ext_ies_container = protocol_ext_container_empty_l;

// MulticastMRBs-SetupMod-Item ::= SEQUENCE
struct multicast_m_rbs_setup_mod_item_s {
  bool                                             ext             = false;
  bool                                             ie_exts_present = false;
  uint16_t                                         mrb_id          = 1;
  multicast_m_rbs_setup_mod_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using multicast_m_rbs_to_be_modified_item_ext_ies_container = protocol_ext_container_empty_l;

// MulticastMRBs-ToBeModified-Item ::= SEQUENCE
struct multicast_m_rbs_to_be_modified_item_s {
  bool                                                  ext                        = false;
  bool                                                  mrb_qos_info_present       = false;
  bool                                                  mbs_dl_pdcp_sn_len_present = false;
  bool                                                  ie_exts_present            = false;
  uint16_t                                              mrb_id                     = 1;
  qos_flow_level_qos_params_s                           mrb_qos_info;
  mbs_flows_mapped_to_mrb_list_l                        mbs_flows_mapped_to_mrb_list;
  pdcp_sn_len_e                                         mbs_dl_pdcp_sn_len;
  multicast_m_rbs_to_be_modified_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using multicast_m_rbs_to_be_released_item_ext_ies_container = protocol_ext_container_empty_l;

// MulticastMRBs-ToBeReleased-Item ::= SEQUENCE
struct multicast_m_rbs_to_be_released_item_s {
  bool                                                  ext             = false;
  bool                                                  ie_exts_present = false;
  uint16_t                                              mrb_id          = 1;
  multicast_m_rbs_to_be_released_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using multicast_m_rbs_to_be_setup_item_ext_ies_container = protocol_ext_container_empty_l;

// MulticastMRBs-ToBeSetup-Item ::= SEQUENCE
struct multicast_m_rbs_to_be_setup_item_s {
  bool                                               ext    = false;
  uint16_t                                           mrb_id = 1;
  qos_flow_level_qos_params_s                        mrb_qos_info;
  mbs_flows_mapped_to_mrb_list_l                     mbs_flows_mapped_to_mrb_list;
  pdcp_sn_len_e                                      mbs_dl_pdcp_sn_len;
  multicast_m_rbs_to_be_setup_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using multicast_m_rbs_to_be_setup_mod_item_ext_ies_container = protocol_ext_container_empty_l;

// MulticastMRBs-ToBeSetupMod-Item ::= SEQUENCE
struct multicast_m_rbs_to_be_setup_mod_item_s {
  bool                                                   ext    = false;
  uint16_t                                               mrb_id = 1;
  qos_flow_level_qos_params_s                            mrb_qos_info;
  mbs_flows_mapped_to_mrb_list_l                         mbs_flows_mapped_to_mrb_list;
  pdcp_sn_len_e                                          mbs_dl_pdcp_sn_len;
  multicast_m_rbs_to_be_setup_mod_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using nr_cgi_list_for_restart_item_ext_ies_container = protocol_ext_container_empty_l;

// NR-CGI-List-For-Restart-Item ::= SEQUENCE
struct nr_cgi_list_for_restart_item_s {
  bool                                           ext             = false;
  bool                                           ie_exts_present = false;
  nr_cgi_s                                       nr_cgi;
  nr_cgi_list_for_restart_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using neighbour_cell_info_item_ext_ies_container = protocol_ext_container_empty_l;

// Neighbour-Cell-Information-Item ::= SEQUENCE
struct neighbour_cell_info_item_s {
  bool                                       intended_tdd_dl_ul_cfg_present = false;
  bool                                       ie_exts_present                = false;
  nr_cgi_s                                   nr_cgi;
  intended_tdd_dl_ul_cfg_s                   intended_tdd_dl_ul_cfg;
  neighbour_cell_info_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// Neighbour-Node-Cells-List-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using neighbour_node_cells_list_item_ext_ies_o = protocol_ext_empty_o;

using notif_info_ext_ies_container = protocol_ext_container_empty_l;

// NotificationInformation ::= SEQUENCE
struct notif_info_s {
  bool                             ext             = false;
  bool                             ie_exts_present = false;
  fixed_bitstring<16, false, true> msg_id;
  fixed_bitstring<16, false, true> serial_num;
  notif_info_ext_ies_container     ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PC5RLCChannelFailedToBeModifiedItem-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using pc5_rlc_ch_failed_to_be_modified_item_ext_ies_o = protocol_ext_empty_o;

// PC5RLCChannelFailedToBeSetupItem-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using pc5_rlc_ch_failed_to_be_setup_item_ext_ies_o = protocol_ext_empty_o;

// PC5RLCChannelModifiedItem-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using pc5_rlc_ch_modified_item_ext_ies_o = protocol_ext_empty_o;

// PC5RLCChannelQoSInformation ::= CHOICE
struct pc5_rlc_ch_qos_info_c {
  struct pc5_ctrl_plane_traffic_type_opts {
    enum options { srb1, srb2, /*...*/ nulltype } value;
    typedef uint8_t number_type;

    const char* to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<pc5_ctrl_plane_traffic_type_opts, true> pc5_ctrl_plane_traffic_type_e_;
  struct types_opts {
    enum options { pc5_rlc_ch_qos, pc5_ctrl_plane_traffic_type, choice_ext, nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  pc5_rlc_ch_qos_info_c() = default;
  pc5_rlc_ch_qos_info_c(const pc5_rlc_ch_qos_info_c& other);
  pc5_rlc_ch_qos_info_c& operator=(const pc5_rlc_ch_qos_info_c& other);
  ~pc5_rlc_ch_qos_info_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  qos_flow_level_qos_params_s& pc5_rlc_ch_qos()
  {
    assert_choice_type(types::pc5_rlc_ch_qos, type_, "PC5RLCChannelQoSInformation");
    return c.get<qos_flow_level_qos_params_s>();
  }
  pc5_ctrl_plane_traffic_type_e_& pc5_ctrl_plane_traffic_type()
  {
    assert_choice_type(types::pc5_ctrl_plane_traffic_type, type_, "PC5RLCChannelQoSInformation");
    return c.get<pc5_ctrl_plane_traffic_type_e_>();
  }
  protocol_ie_single_container_s<pc5_rlc_ch_qos_info_ext_ies_o>& choice_ext()
  {
    assert_choice_type(types::choice_ext, type_, "PC5RLCChannelQoSInformation");
    return c.get<protocol_ie_single_container_s<pc5_rlc_ch_qos_info_ext_ies_o>>();
  }
  const qos_flow_level_qos_params_s& pc5_rlc_ch_qos() const
  {
    assert_choice_type(types::pc5_rlc_ch_qos, type_, "PC5RLCChannelQoSInformation");
    return c.get<qos_flow_level_qos_params_s>();
  }
  const pc5_ctrl_plane_traffic_type_e_& pc5_ctrl_plane_traffic_type() const
  {
    assert_choice_type(types::pc5_ctrl_plane_traffic_type, type_, "PC5RLCChannelQoSInformation");
    return c.get<pc5_ctrl_plane_traffic_type_e_>();
  }
  const protocol_ie_single_container_s<pc5_rlc_ch_qos_info_ext_ies_o>& choice_ext() const
  {
    assert_choice_type(types::choice_ext, type_, "PC5RLCChannelQoSInformation");
    return c.get<protocol_ie_single_container_s<pc5_rlc_ch_qos_info_ext_ies_o>>();
  }
  qos_flow_level_qos_params_s&                                   set_pc5_rlc_ch_qos();
  pc5_ctrl_plane_traffic_type_e_&                                set_pc5_ctrl_plane_traffic_type();
  protocol_ie_single_container_s<pc5_rlc_ch_qos_info_ext_ies_o>& set_choice_ext();

private:
  types                                                                                                       type_;
  choice_buffer_t<protocol_ie_single_container_s<pc5_rlc_ch_qos_info_ext_ies_o>, qos_flow_level_qos_params_s> c;

  void destroy_();
};

// PC5RLCChannelRequiredToBeModifiedItem-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using pc5_rlc_ch_required_to_be_modified_item_ext_ies_o = protocol_ext_empty_o;

// PC5RLCChannelRequiredToBeReleasedItem-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using pc5_rlc_ch_required_to_be_released_item_ext_ies_o = protocol_ext_empty_o;

// PC5RLCChannelSetupItem-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using pc5_rlc_ch_setup_item_ext_ies_o = protocol_ext_empty_o;

// PC5RLCChannelToBeModifiedItem-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using pc5_rlc_ch_to_be_modified_item_ext_ies_o = protocol_ext_empty_o;

// PC5RLCChannelToBeReleasedItem-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using pc5_rlc_ch_to_be_released_item_ext_ies_o = protocol_ext_empty_o;

// PC5RLCChannelToBeSetupItem-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using pc5_rlc_ch_to_be_setup_item_ext_ies_o = protocol_ext_empty_o;

using pdc_measured_results_item_ext_ies_container = protocol_ext_container_empty_l;

// PDCMeasuredResults-Item ::= SEQUENCE
struct pdc_measured_results_item_s {
  bool                                        ie_exts_present = false;
  pdc_measured_results_value_c                pdc_measured_results_value;
  pdc_measured_results_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using pdc_meas_quantities_value_ext_ies_container = protocol_ext_container_empty_l;

// PDCMeasurementQuantities-Item ::= SEQUENCE
struct pdc_meas_quantities_item_s {
  bool                                        ie_exts_present = false;
  pdc_meas_quantities_value_e                 pd_cmeas_quantities_value;
  pdc_meas_quantities_value_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PRS-Measurement-Info-List-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using prs_meas_info_list_item_ext_ies_o = protocol_ext_empty_o;

// PRSTRPItem-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using prstrp_item_ext_ies_o = protocol_ext_empty_o;

using prs_tx_off_info_ext_ies_container = protocol_ext_container_empty_l;

// PRSTransmissionOffInformation ::= SEQUENCE
struct prs_tx_off_info_s {
  bool                              ext             = false;
  bool                              ie_exts_present = false;
  prs_tx_off_ind_c                  prs_tx_off_ind;
  prs_tx_off_info_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PRSTransmissionTRPItem-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using prs_tx_trp_item_ext_ies_o = protocol_ext_empty_o;

using pws_failed_nr_cgi_item_ext_ies_container = protocol_ext_container_empty_l;

// PWS-Failed-NR-CGI-Item ::= SEQUENCE
struct pws_failed_nr_cgi_item_s {
  bool                                     ext             = false;
  bool                                     ie_exts_present = false;
  nr_cgi_s                                 nr_cgi;
  uint32_t                                 nof_broadcasts = 0;
  pws_failed_nr_cgi_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

struct paging_cell_item_ext_ies_container {
  template <class extT_>
  using ie_field_s = protocol_ext_container_item_s<extT_>;

  // member variables
  bool                                      last_used_cell_ind_present          = false;
  bool                                      pei_subgrouping_support_ind_present = false;
  ie_field_s<last_used_cell_ind_e>          last_used_cell_ind;
  ie_field_s<pei_subgrouping_support_ind_e> pei_subgrouping_support_ind;

  // sequence methods
  paging_cell_item_ext_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PagingCell-Item ::= SEQUENCE
struct paging_cell_item_s {
  bool                               ie_exts_present = false;
  nr_cgi_s                           nr_cgi;
  paging_cell_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PosMeasurementQuantities-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using pos_meas_quantities_item_ext_ies_o = protocol_ext_empty_o;

// PosMeasurementResult ::= SEQUENCE (SIZE (1..16384)) OF PosMeasurementResultItem
using pos_meas_result_l = dyn_array<pos_meas_result_item_s>;

// PosMeasurementResultList-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
struct pos_meas_result_list_item_ext_ies_o {
  // Extension ::= OPEN TYPE
  struct ext_c {
    struct types_opts {
      enum options { nr_cgi, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::nr_cgi; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    nr_cgi_s&       nr_cgi() { return c; }
    const nr_cgi_s& nr_cgi() const { return c; }

  private:
    nr_cgi_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static ext_c      get_ext(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// PosMeasurementType ::= ENUMERATED
struct pos_meas_type_opts {
  enum options { gnb_rx_tx, ul_srs_rsrp, ul_aoa, ul_rtoa, /*...*/ multiple_ul_aoa, ul_srs_rsrpp, nulltype } value;

  const char* to_string() const;
};
typedef enumerated<pos_meas_type_opts, true, 2> pos_meas_type_e;

// PosSItype-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using pos_sitype_item_ext_ies_o = protocol_ext_empty_o;

using potential_sp_cell_item_ext_ies_container = protocol_ext_container_empty_l;

// Potential-SpCell-Item ::= SEQUENCE
struct potential_sp_cell_item_s {
  bool                                     ext             = false;
  bool                                     ie_exts_present = false;
  nr_cgi_s                                 potential_sp_cell_id;
  potential_sp_cell_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PrivateIE-ID ::= CHOICE
struct private_ie_id_c {
  struct types_opts {
    enum options { local, global, nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  private_ie_id_c() = default;
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  uint32_t& local()
  {
    assert_choice_type(types::local, type_, "PrivateIE-ID");
    return c;
  }
  const uint32_t& local() const
  {
    assert_choice_type(types::local, type_, "PrivateIE-ID");
    return c;
  }
  uint32_t& set_local();
  void      set_global();

private:
  types    type_;
  uint32_t c;
};

using protected_eutra_res_item_ext_ies_container = protocol_ext_container_empty_l;

// Protected-EUTRA-Resources-Item ::= SEQUENCE
struct protected_eutra_res_item_s {
  bool                                       ie_exts_present       = false;
  uint16_t                                   spec_sharing_group_id = 1;
  eutra_cells_list_l                         eutra_cells_list;
  protected_eutra_res_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using qo_e_info_list_item_ext_ies_container = protocol_ext_container_empty_l;

// QoEInformationList-Item ::= SEQUENCE
struct qo_e_info_list_item_s {
  bool                                  qo_e_metrics_present = false;
  bool                                  ie_exts_present      = false;
  qo_e_metrics_s                        qo_e_metrics;
  qo_e_info_list_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RANUEPagingIdentity-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using ran_ue_paging_id_ext_ies_o = protocol_ext_empty_o;

// RedCapIndication ::= ENUMERATED
struct red_cap_ind_opts {
  enum options { true_value, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<red_cap_ind_opts, true> red_cap_ind_e;

using requested_dl_prs_tx_characteristics_ext_ies_container = protocol_ext_container_empty_l;

// RequestedDLPRSTransmissionCharacteristics ::= SEQUENCE
struct requested_dl_prs_tx_characteristics_s {
  bool                                                  ext                        = false;
  bool                                                  numof_freq_layers_present  = false;
  bool                                                  start_time_and_dur_present = false;
  bool                                                  ie_exts_present            = false;
  requested_dl_prs_res_set_list_l                       requested_dl_prs_res_set_list;
  uint8_t                                               numof_freq_layers = 1;
  start_time_and_dur_s                                  start_time_and_dur;
  requested_dl_prs_tx_characteristics_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// ResourceCoordinationEUTRACellInfo-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
struct res_coordination_eutra_cell_info_ext_ies_o {
  // Extension ::= OPEN TYPE
  struct ext_c {
    struct types_opts {
      enum options { ignore_prach_cfg, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::ignore_prach_cfg; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    ignore_prach_cfg_e&       ignore_prach_cfg() { return c; }
    const ignore_prach_cfg_e& ignore_prach_cfg() const { return c; }

  private:
    ignore_prach_cfg_e c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static ext_c      get_ext(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

using scell_failedto_setup_item_ext_ies_container = protocol_ext_container_empty_l;

// SCell-FailedtoSetup-Item ::= SEQUENCE
struct scell_failedto_setup_item_s {
  bool                                        ext             = false;
  bool                                        cause_present   = false;
  bool                                        ie_exts_present = false;
  nr_cgi_s                                    scell_id;
  cause_c                                     cause;
  scell_failedto_setup_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using scell_failedto_setup_mod_item_ext_ies_container = protocol_ext_container_empty_l;

// SCell-FailedtoSetupMod-Item ::= SEQUENCE
struct scell_failedto_setup_mod_item_s {
  bool                                            ext             = false;
  bool                                            cause_present   = false;
  bool                                            ie_exts_present = false;
  nr_cgi_s                                        scell_id;
  cause_c                                         cause;
  scell_failedto_setup_mod_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using scell_to_be_remd_item_ext_ies_container = protocol_ext_container_empty_l;

// SCell-ToBeRemoved-Item ::= SEQUENCE
struct scell_to_be_remd_item_s {
  bool                                    ext             = false;
  bool                                    ie_exts_present = false;
  nr_cgi_s                                scell_id;
  scell_to_be_remd_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SCell-ToBeSetup-Item ::= SEQUENCE
struct scell_to_be_setup_item_s {
  bool                                                       ext                  = false;
  bool                                                       scell_ul_cfg_present = false;
  nr_cgi_s                                                   scell_id;
  uint8_t                                                    scell_idx = 1;
  cell_ul_cfg_e                                              scell_ul_cfg;
  protocol_ext_container_l<scell_to_be_setup_item_ext_ies_o> ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SCell-ToBeSetupMod-Item ::= SEQUENCE
struct scell_to_be_setup_mod_item_s {
  bool                                                           ext                  = false;
  bool                                                           scell_ul_cfg_present = false;
  nr_cgi_s                                                       scell_id;
  uint8_t                                                        scell_idx = 1;
  cell_ul_cfg_e                                                  scell_ul_cfg;
  protocol_ext_container_l<scell_to_be_setup_mod_item_ext_ies_o> ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using sdt_bearer_cfg_list_item_ext_ies_container = protocol_ext_container_empty_l;

// SDTBearerConfig-List-Item ::= SEQUENCE
struct sdt_bearer_cfg_list_item_s {
  bool                                       ie_exts_present = false;
  sdt_bearer_type_c                          sdt_bearer_type;
  unbounded_octstring<true>                  sdt_rlc_bearer_cfg;
  sdt_bearer_cfg_list_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SItype-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using sitype_item_ext_ies_o = protocol_ext_empty_o;

using sl_drbs_failed_to_be_modified_item_ext_ies_container = protocol_ext_container_empty_l;

// SLDRBs-FailedToBeModified-Item ::= SEQUENCE
struct sl_drbs_failed_to_be_modified_item_s {
  bool                                                 cause_present   = false;
  bool                                                 ie_exts_present = false;
  uint16_t                                             sl_drb_id       = 1;
  cause_c                                              cause;
  sl_drbs_failed_to_be_modified_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using sl_drbs_failed_to_be_setup_item_ext_ies_container = protocol_ext_container_empty_l;

// SLDRBs-FailedToBeSetup-Item ::= SEQUENCE
struct sl_drbs_failed_to_be_setup_item_s {
  bool                                              cause_present   = false;
  bool                                              ie_exts_present = false;
  uint16_t                                          sl_drb_id       = 1;
  cause_c                                           cause;
  sl_drbs_failed_to_be_setup_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using sl_drbs_failed_to_be_setup_mod_item_ext_ies_container = protocol_ext_container_empty_l;

// SLDRBs-FailedToBeSetupMod-Item ::= SEQUENCE
struct sl_drbs_failed_to_be_setup_mod_item_s {
  bool                                                  cause_present   = false;
  bool                                                  ie_exts_present = false;
  uint16_t                                              sl_drb_id       = 1;
  cause_c                                               cause;
  sl_drbs_failed_to_be_setup_mod_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using sl_drbs_modified_item_ext_ies_container = protocol_ext_container_empty_l;

// SLDRBs-Modified-Item ::= SEQUENCE
struct sl_drbs_modified_item_s {
  bool                                    ie_exts_present = false;
  uint16_t                                sl_drb_id       = 1;
  sl_drbs_modified_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using sl_drbs_modified_conf_item_ext_ies_container = protocol_ext_container_empty_l;

// SLDRBs-ModifiedConf-Item ::= SEQUENCE
struct sl_drbs_modified_conf_item_s {
  bool                                         ie_exts_present = false;
  uint16_t                                     sl_drb_id       = 1;
  sl_drbs_modified_conf_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using sl_drbs_required_to_be_modified_item_ext_ies_container = protocol_ext_container_empty_l;

// SLDRBs-Required-ToBeModified-Item ::= SEQUENCE
struct sl_drbs_required_to_be_modified_item_s {
  bool                                                   ie_exts_present = false;
  uint16_t                                               sl_drb_id       = 1;
  sl_drbs_required_to_be_modified_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using sl_drbs_required_to_be_released_item_ext_ies_container = protocol_ext_container_empty_l;

// SLDRBs-Required-ToBeReleased-Item ::= SEQUENCE
struct sl_drbs_required_to_be_released_item_s {
  bool                                                   ie_exts_present = false;
  uint16_t                                               sl_drb_id       = 1;
  sl_drbs_required_to_be_released_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using sl_drbs_setup_item_ext_ies_container = protocol_ext_container_empty_l;

// SLDRBs-Setup-Item ::= SEQUENCE
struct sl_drbs_setup_item_s {
  bool                                 ie_exts_present = false;
  uint16_t                             sl_drb_id       = 1;
  sl_drbs_setup_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using sl_drbs_setup_mod_item_ext_ies_container = protocol_ext_container_empty_l;

// SLDRBs-SetupMod-Item ::= SEQUENCE
struct sl_drbs_setup_mod_item_s {
  bool                                     ie_exts_present = false;
  uint16_t                                 sl_drb_id       = 1;
  sl_drbs_setup_mod_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using sl_drbs_to_be_modified_item_ext_ies_container = protocol_ext_container_empty_l;

// SLDRBs-ToBeModified-Item ::= SEQUENCE
struct sl_drbs_to_be_modified_item_s {
  bool                                          sl_drb_info_present = false;
  bool                                          rlc_mode_present    = false;
  bool                                          ie_exts_present     = false;
  uint16_t                                      sl_drb_id           = 1;
  sl_drb_info_s                                 sl_drb_info;
  rlc_mode_e                                    rlc_mode;
  sl_drbs_to_be_modified_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using sl_drbs_to_be_released_item_ext_ies_container = protocol_ext_container_empty_l;

// SLDRBs-ToBeReleased-Item ::= SEQUENCE
struct sl_drbs_to_be_released_item_s {
  bool                                          ie_exts_present = false;
  uint16_t                                      sl_drb_id       = 1;
  sl_drbs_to_be_released_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using sl_drbs_to_be_setup_item_ext_ies_container = protocol_ext_container_empty_l;

// SLDRBs-ToBeSetup-Item ::= SEQUENCE
struct sl_drbs_to_be_setup_item_s {
  bool                                       ie_exts_present = false;
  uint16_t                                   sl_drb_id       = 1;
  sl_drb_info_s                              sl_drb_info;
  rlc_mode_e                                 rlc_mode;
  sl_drbs_to_be_setup_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using sl_drbs_to_be_setup_mod_item_ext_ies_container = protocol_ext_container_empty_l;

// SLDRBs-ToBeSetupMod-Item ::= SEQUENCE
struct sl_drbs_to_be_setup_mod_item_s {
  bool                                           rlc_mode_present = false;
  bool                                           ie_exts_present  = false;
  uint16_t                                       sl_drb_id        = 1;
  sl_drb_info_s                                  sl_drb_info;
  rlc_mode_e                                     rlc_mode;
  sl_drbs_to_be_setup_mod_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SLDRXCycleItem-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using sldrx_cycle_item_ext_ies_o = protocol_ext_empty_o;

// SLDRXInformation ::= CHOICE
struct sldrx_info_c {
  struct types_opts {
    enum options { sldrx_cycle, nos_ldrx, choice_ext, nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  sldrx_info_c() = default;
  sldrx_info_c(const sldrx_info_c& other);
  sldrx_info_c& operator=(const sldrx_info_c& other);
  ~sldrx_info_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  sldrx_cycle_len_e& sldrx_cycle()
  {
    assert_choice_type(types::sldrx_cycle, type_, "SLDRXInformation");
    return c.get<sldrx_cycle_len_e>();
  }
  sldrx_cfg_ind_e& nos_ldrx()
  {
    assert_choice_type(types::nos_ldrx, type_, "SLDRXInformation");
    return c.get<sldrx_cfg_ind_e>();
  }
  protocol_ie_single_container_s<sldrx_info_ext_ies_o>& choice_ext()
  {
    assert_choice_type(types::choice_ext, type_, "SLDRXInformation");
    return c.get<protocol_ie_single_container_s<sldrx_info_ext_ies_o>>();
  }
  const sldrx_cycle_len_e& sldrx_cycle() const
  {
    assert_choice_type(types::sldrx_cycle, type_, "SLDRXInformation");
    return c.get<sldrx_cycle_len_e>();
  }
  const sldrx_cfg_ind_e& nos_ldrx() const
  {
    assert_choice_type(types::nos_ldrx, type_, "SLDRXInformation");
    return c.get<sldrx_cfg_ind_e>();
  }
  const protocol_ie_single_container_s<sldrx_info_ext_ies_o>& choice_ext() const
  {
    assert_choice_type(types::choice_ext, type_, "SLDRXInformation");
    return c.get<protocol_ie_single_container_s<sldrx_info_ext_ies_o>>();
  }
  sldrx_cycle_len_e&                                    set_sldrx_cycle();
  sldrx_cfg_ind_e&                                      set_nos_ldrx();
  protocol_ie_single_container_s<sldrx_info_ext_ies_o>& set_choice_ext();

private:
  types                                                                 type_;
  choice_buffer_t<protocol_ie_single_container_s<sldrx_info_ext_ies_o>> c;

  void destroy_();
};

using srbs_failed_to_be_setup_item_ext_ies_container = protocol_ext_container_empty_l;

// SRBs-FailedToBeSetup-Item ::= SEQUENCE
struct srbs_failed_to_be_setup_item_s {
  bool                                           ext             = false;
  bool                                           cause_present   = false;
  bool                                           ie_exts_present = false;
  uint8_t                                        srb_id          = 0;
  cause_c                                        cause;
  srbs_failed_to_be_setup_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using srbs_failed_to_be_setup_mod_item_ext_ies_container = protocol_ext_container_empty_l;

// SRBs-FailedToBeSetupMod-Item ::= SEQUENCE
struct srbs_failed_to_be_setup_mod_item_s {
  bool                                               ext             = false;
  bool                                               cause_present   = false;
  bool                                               ie_exts_present = false;
  uint8_t                                            srb_id          = 0;
  cause_c                                            cause;
  srbs_failed_to_be_setup_mod_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using srbs_modified_item_ext_ies_container = protocol_ext_container_empty_l;

// SRBs-Modified-Item ::= SEQUENCE
struct srbs_modified_item_s {
  bool                                 ext             = false;
  bool                                 ie_exts_present = false;
  uint8_t                              srb_id          = 0;
  uint8_t                              lcid            = 1;
  srbs_modified_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using srbs_required_to_be_released_item_ext_ies_container = protocol_ext_container_empty_l;

// SRBs-Required-ToBeReleased-Item ::= SEQUENCE
struct srbs_required_to_be_released_item_s {
  bool                                                ext             = false;
  bool                                                ie_exts_present = false;
  uint8_t                                             srb_id          = 0;
  srbs_required_to_be_released_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using srbs_setup_item_ext_ies_container = protocol_ext_container_empty_l;

// SRBs-Setup-Item ::= SEQUENCE
struct srbs_setup_item_s {
  bool                              ext             = false;
  bool                              ie_exts_present = false;
  uint8_t                           srb_id          = 0;
  uint8_t                           lcid            = 1;
  srbs_setup_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using srbs_setup_mod_item_ext_ies_container = protocol_ext_container_empty_l;

// SRBs-SetupMod-Item ::= SEQUENCE
struct srbs_setup_mod_item_s {
  bool                                  ext             = false;
  bool                                  ie_exts_present = false;
  uint8_t                               srb_id          = 0;
  uint8_t                               lcid            = 1;
  srbs_setup_mod_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using srbs_to_be_released_item_ext_ies_container = protocol_ext_container_empty_l;

// SRBs-ToBeReleased-Item ::= SEQUENCE
struct srbs_to_be_released_item_s {
  bool                                       ext             = false;
  bool                                       ie_exts_present = false;
  uint8_t                                    srb_id          = 0;
  srbs_to_be_released_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

struct srbs_to_be_setup_item_ext_ies_container {
  template <class extT_>
  using ie_field_s = protocol_ext_container_item_s<extT_>;

  // member variables
  bool                                         add_dupl_ind_present       = false;
  bool                                         sdt_rlc_bearer_cfg_present = false;
  bool                                         srb_map_info_present       = false;
  ie_field_s<add_dupl_ind_e>                   add_dupl_ind;
  ie_field_s<unbounded_octstring<true>>        sdt_rlc_bearer_cfg;
  ie_field_s<fixed_bitstring<16, false, true>> srb_map_info;

  // sequence methods
  srbs_to_be_setup_item_ext_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SRBs-ToBeSetup-Item ::= SEQUENCE
struct srbs_to_be_setup_item_s {
  bool                                    ext              = false;
  bool                                    dupl_ind_present = false;
  bool                                    ie_exts_present  = false;
  uint8_t                                 srb_id           = 0;
  dupl_ind_e                              dupl_ind;
  srbs_to_be_setup_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

struct srbs_to_be_setup_mod_item_ext_ies_container {
  template <class extT_>
  using ie_field_s = protocol_ext_container_item_s<extT_>;

  // member variables
  bool                                         add_dupl_ind_present     = false;
  bool                                         srb_map_info_present     = false;
  bool                                         cg_sd_tind_setup_present = false;
  ie_field_s<add_dupl_ind_e>                   add_dupl_ind;
  ie_field_s<fixed_bitstring<16, false, true>> srb_map_info;
  ie_field_s<cg_sd_tind_setup_e>               cg_sd_tind_setup;

  // sequence methods
  srbs_to_be_setup_mod_item_ext_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SRBs-ToBeSetupMod-Item ::= SEQUENCE
struct srbs_to_be_setup_mod_item_s {
  bool                                        ext              = false;
  bool                                        dupl_ind_present = false;
  bool                                        ie_exts_present  = false;
  uint8_t                                     srb_id           = 0;
  dupl_ind_e                                  dupl_ind;
  srbs_to_be_setup_mod_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using srs_carrier_list_item_ext_ies_container = protocol_ext_container_empty_l;

// SRSCarrier-List-Item ::= SEQUENCE
struct srs_carrier_list_item_s {
  bool                                    pci_present     = false;
  bool                                    ie_exts_present = false;
  uint32_t                                point_a         = 0;
  ul_ch_bw_per_scs_list_l                 ul_ch_bw_per_scs_list;
  active_ul_bwp_s                         active_ul_bwp;
  uint16_t                                pci = 0;
  srs_carrier_list_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SRSResourceSetItem ::= SEQUENCE
struct srs_res_set_item_s {
  bool                                                 num_srs_resperset_present     = false;
  bool                                                 spatial_relation_info_present = false;
  bool                                                 pathloss_ref_info_present     = false;
  uint8_t                                              num_srs_resperset             = 1;
  periodicity_list_l                                   periodicity_list;
  spatial_relation_info_s                              spatial_relation_info;
  pathloss_ref_info_s                                  pathloss_ref_info;
  protocol_ext_container_l<srs_res_set_item_ext_ies_o> ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using search_win_info_ext_ies_container = protocol_ext_container_empty_l;

// Search-window-information ::= SEQUENCE
struct search_win_info_s {
  bool                              ie_exts_present            = false;
  int16_t                           expected_propagation_delay = -3841;
  uint8_t                           delay_uncertainty          = 1;
  search_win_info_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SemipersistentSRS-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
struct semipersistent_srs_ext_ies_o {
  // Extension ::= OPEN TYPE
  struct ext_c {
    struct types_opts {
      enum options { srs_spatial_relation_per_srs_res, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::srs_spatial_relation_per_srs_res; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    spatial_relation_per_srs_res_s&       srs_spatial_relation_per_srs_res() { return c; }
    const spatial_relation_per_srs_res_s& srs_spatial_relation_per_srs_res() const { return c; }

  private:
    spatial_relation_per_srs_res_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static ext_c      get_ext(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

using served_cells_to_add_item_ext_ies_container = protocol_ext_container_empty_l;

// Served-Cells-To-Add-Item ::= SEQUENCE
struct served_cells_to_add_item_s {
  bool                                       ext                     = false;
  bool                                       gnb_du_sys_info_present = false;
  bool                                       ie_exts_present         = false;
  served_cell_info_s                         served_cell_info;
  gnb_du_sys_info_s                          gnb_du_sys_info;
  served_cells_to_add_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using served_cells_to_delete_item_ext_ies_container = protocol_ext_container_empty_l;

// Served-Cells-To-Delete-Item ::= SEQUENCE
struct served_cells_to_delete_item_s {
  bool                                          ext             = false;
  bool                                          ie_exts_present = false;
  nr_cgi_s                                      old_nr_cgi;
  served_cells_to_delete_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using served_cells_to_modify_item_ext_ies_container = protocol_ext_container_empty_l;

// Served-Cells-To-Modify-Item ::= SEQUENCE
struct served_cells_to_modify_item_s {
  bool                                          ext                     = false;
  bool                                          gnb_du_sys_info_present = false;
  bool                                          ie_exts_present         = false;
  nr_cgi_s                                      old_nr_cgi;
  served_cell_info_s                            served_cell_info;
  gnb_du_sys_info_s                             gnb_du_sys_info;
  served_cells_to_modify_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// Serving-Cells-List-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using serving_cells_list_item_ext_ies_o = protocol_ext_empty_o;

using serving_cell_mo_list_item_ext_ies_container = protocol_ext_container_empty_l;

// ServingCellMO-List-Item ::= SEQUENCE
struct serving_cell_mo_list_item_s {
  bool                                        ie_exts_present = false;
  uint8_t                                     serving_cell_mo = 1;
  uint32_t                                    ssb_freq        = 0;
  serving_cell_mo_list_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// ServingCellMO-encoded-in-CGC-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using serving_cell_mo_encoded_in_cgc_item_ext_ies_o = protocol_ext_empty_o;

// TRP-MeasurementRequestItem-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
struct trp_meas_request_item_ext_ies_o {
  // Extension ::= OPEN TYPE
  struct ext_c {
    struct types_opts {
      enum options { nr_cgi, ao_a_search_win, nof_trp_rx_teg, nof_trp_rx_tx_teg, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    ext_c() = default;
    ext_c(const ext_c& other);
    ext_c& operator=(const ext_c& other);
    ~ext_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    nr_cgi_s&                  nr_cgi();
    ao_a_assist_info_s&        ao_a_search_win();
    nof_trp_rx_teg_e&          nof_trp_rx_teg();
    nof_trp_rx_tx_teg_e&       nof_trp_rx_tx_teg();
    const nr_cgi_s&            nr_cgi() const;
    const ao_a_assist_info_s&  ao_a_search_win() const;
    const nof_trp_rx_teg_e&    nof_trp_rx_teg() const;
    const nof_trp_rx_tx_teg_e& nof_trp_rx_tx_teg() const;

  private:
    types                                         type_;
    choice_buffer_t<ao_a_assist_info_s, nr_cgi_s> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static ext_c      get_ext(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// TRP-MeasurementUpdateItem-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
struct trp_meas_upd_item_ext_ies_o {
  // Extension ::= OPEN TYPE
  struct ext_c {
    struct types_opts {
      enum options { nof_trp_rx_teg, nof_trp_rx_tx_teg, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    ext_c() = default;
    ext_c(const ext_c& other);
    ext_c& operator=(const ext_c& other);
    ~ext_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    nof_trp_rx_teg_e&          nof_trp_rx_teg();
    nof_trp_rx_tx_teg_e&       nof_trp_rx_tx_teg();
    const nof_trp_rx_teg_e&    nof_trp_rx_teg() const;
    const nof_trp_rx_tx_teg_e& nof_trp_rx_tx_teg() const;

  private:
    types               type_;
    pod_choice_buffer_t c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static ext_c      get_ext(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// TRP-PRS-Info-List-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using trp_prs_info_list_item_ext_ies_o = protocol_ext_empty_o;

using trp_info_item_ext_ies_container = protocol_ext_container_empty_l;

// TRPInformationItem ::= SEQUENCE
struct trp_info_item_s {
  bool                            ie_exts_present = false;
  trp_info_s                      trp_info;
  trp_info_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// TRPInformationTypeItem ::= ENUMERATED
struct trp_info_type_item_opts {
  enum options {
    nr_pci,
    ng_ran_cgi,
    arfcn,
    prs_cfg,
    ssb_cfg,
    sfn_init_time,
    spatial_direct_info,
    geo_coord,
    // ...
    trp_type,
    ondemand_prs,
    trp_tx_teg,
    beam_ant_info,
    nulltype
  } value;

  const char* to_string() const;
};
typedef enumerated<trp_info_type_item_opts, true, 4> trp_info_type_item_e;

// TRPListItem-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using trp_list_item_ext_ies_o = protocol_ext_empty_o;

using transport_up_layer_address_info_to_add_item_ext_ies_container = protocol_ext_container_empty_l;

// Transport-UP-Layer-Address-Info-To-Add-Item ::= SEQUENCE
struct transport_up_layer_address_info_to_add_item_s {
  bool                                                          ie_exts_present = false;
  bounded_bitstring<1, 160, true, true>                         ip_sec_transport_layer_address;
  gtp_tlas_l                                                    gtp_transport_layer_address_to_add;
  transport_up_layer_address_info_to_add_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using transport_up_layer_address_info_to_rem_item_ext_ies_container = protocol_ext_container_empty_l;

// Transport-UP-Layer-Address-Info-To-Remove-Item ::= SEQUENCE
struct transport_up_layer_address_info_to_rem_item_s {
  bool                                                          ie_exts_present = false;
  bounded_bitstring<1, 160, true, true>                         ip_sec_transport_layer_address;
  gtp_tlas_l                                                    gtp_transport_layer_address_to_rem;
  transport_up_layer_address_info_to_rem_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UACPLMN-Item ::= SEQUENCE
struct uac_plmn_item_s {
  fixed_octstring<3, true>                          plmn_id;
  uac_type_list_l                                   uac_type_list;
  protocol_ext_container_l<uac_plmn_item_ext_ies_o> ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using ue_multicast_m_rbs_confirmed_to_be_modified_item_ext_ies_container = protocol_ext_container_empty_l;

// UE-MulticastMRBs-ConfirmedToBeModified-Item ::= SEQUENCE
struct ue_multicast_m_rbs_confirmed_to_be_modified_item_s {
  bool                                                               mrb_type_recfg_present = false;
  bool                                                               ie_exts_present        = false;
  uint16_t                                                           mrb_id                 = 1;
  mbsptp_retx_tunnel_required_e                                      mrb_type_recfg;
  ue_multicast_m_rbs_confirmed_to_be_modified_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UE-MulticastMRBs-RequiredToBeModified-Item ::= SEQUENCE
struct ue_multicast_m_rbs_required_to_be_modified_item_s {
  struct mrb_type_recfg_opts {
    enum options { true_value, /*...*/ nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<mrb_type_recfg_opts, true> mrb_type_recfg_e_;
  struct mrb_recfg_rlc_type_opts {
    enum options {
      rlc_um_ptp,
      rlc_am_ptp,
      rlc_um_dl_ptm,
      two_rlc_um_dl_ptp_and_dl_ptm,
      three_rlc_um_dl_ptp_ul_ptp_dl_ptm,
      two_rlc_am_ptp_um_dl_ptm,
      // ...
      nulltype
    } value;

    const char* to_string() const;
  };
  typedef enumerated<mrb_recfg_rlc_type_opts, true> mrb_recfg_rlc_type_e_;

  // member variables
  bool                  mrb_type_recfg_present     = false;
  bool                  mrb_recfg_rlc_type_present = false;
  uint16_t              mrb_id                     = 1;
  mrb_type_recfg_e_     mrb_type_recfg;
  mrb_recfg_rlc_type_e_ mrb_recfg_rlc_type;
  protocol_ext_container_l<ue_multicast_m_rbs_required_to_be_modified_item_ext_ies_o> ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using ue_multicast_m_rbs_required_to_be_released_item_ext_ies_container = protocol_ext_container_empty_l;

// UE-MulticastMRBs-RequiredToBeReleased-Item ::= SEQUENCE
struct ue_multicast_m_rbs_required_to_be_released_item_s {
  bool                                                              ie_exts_present = false;
  uint16_t                                                          mrb_id          = 1;
  ue_multicast_m_rbs_required_to_be_released_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using ue_multicast_m_rbs_setup_item_ext_ies_container = protocol_ext_container_empty_l;

// UE-MulticastMRBs-Setup-Item ::= SEQUENCE
struct ue_multicast_m_rbs_setup_item_s {
  bool                                            multicast_f1_u_context_ref_cu_present = false;
  bool                                            ie_exts_present                       = false;
  uint16_t                                        mrb_id                                = 1;
  fixed_octstring<4, true>                        multicast_f1_u_context_ref_cu;
  ue_multicast_m_rbs_setup_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using ue_multicast_m_rbs_to_be_released_item_ext_ies_container = protocol_ext_container_empty_l;

// UE-MulticastMRBs-ToBeReleased-Item ::= SEQUENCE
struct ue_multicast_m_rbs_to_be_released_item_s {
  bool                                                     ie_exts_present = false;
  uint16_t                                                 mrb_id          = 1;
  ue_multicast_m_rbs_to_be_released_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UE-MulticastMRBs-ToBeSetup-Item ::= SEQUENCE
struct ue_multicast_m_rbs_to_be_setup_item_s {
  bool                          mbs_ptp_retx_tunnel_required_present     = false;
  bool                          mbs_ptp_forwarding_required_info_present = false;
  uint16_t                      mrb_id                                   = 1;
  mbsptp_retx_tunnel_required_e mbs_ptp_retx_tunnel_required;
  mrb_progress_info_c           mbs_ptp_forwarding_required_info;
  protocol_ext_container_l<ue_multicast_m_rbs_to_be_setup_item_ext_ies_o> ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using ue_multicast_m_rbs_to_be_setup_at_modify_item_ext_ies_container = protocol_ext_container_empty_l;

// UE-MulticastMRBs-ToBeSetup-atModify-Item ::= SEQUENCE
struct ue_multicast_m_rbs_to_be_setup_at_modify_item_s {
  bool                                                            mbs_ptp_retx_tunnel_required_present     = false;
  bool                                                            mbs_ptp_forwarding_required_info_present = false;
  bool                                                            ie_exts_present                          = false;
  uint16_t                                                        mrb_id                                   = 1;
  mbsptp_retx_tunnel_required_e                                   mbs_ptp_retx_tunnel_required;
  mrb_progress_info_c                                             mbs_ptp_forwarding_required_info;
  ue_multicast_m_rbs_to_be_setup_at_modify_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UE-associatedLogicalF1-ConnectionItemRes ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct ue_associated_lc_f1_conn_item_res_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { ue_associated_lc_f1_conn_item, nulltype } value;
      typedef uint8_t number_type;

      const char* to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::ue_associated_lc_f1_conn_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    ue_associated_lc_f1_conn_item_s&       ue_associated_lc_f1_conn_item() { return c; }
    const ue_associated_lc_f1_conn_item_s& ue_associated_lc_f1_conn_item() const { return c; }

  private:
    ue_associated_lc_f1_conn_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

using ue_id_list_for_paging_item_ext_ies_container = protocol_ext_container_empty_l;

// UEIdentity-List-For-Paging-Item ::= SEQUENCE
struct ue_id_list_for_paging_item_s {
  bool                                         paging_drx_present = false;
  bool                                         ie_exts_present    = false;
  ue_id_idx_value_c                            ue_id_idx_value;
  paging_drx_e                                 paging_drx;
  ue_id_list_for_paging_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using ul_bh_non_up_traffic_map_item_ext_ies_container = protocol_ext_container_empty_l;

// UL-BH-Non-UP-Traffic-Mapping-Item ::= SEQUENCE
struct ul_bh_non_up_traffic_map_item_s {
  bool                                            ie_exts_present = false;
  non_up_traffic_type_e                           non_up_traffic_type;
  bh_info_s                                       bh_info;
  ul_bh_non_up_traffic_map_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using ul_up_tnl_address_to_upd_list_item_ext_ies_container = protocol_ext_container_empty_l;

// UL-UP-TNL-Address-to-Update-List-Item ::= SEQUENCE
struct ul_up_tnl_address_to_upd_list_item_s {
  bool                                                 ext             = false;
  bool                                                 ie_exts_present = false;
  bounded_bitstring<1, 160, true, true>                old_ip_adress;
  bounded_bitstring<1, 160, true, true>                new_ip_adress;
  ul_up_tnl_address_to_upd_list_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using ul_up_tnl_info_to_upd_list_item_ext_ies_container = protocol_ext_container_empty_l;

// UL-UP-TNL-Information-to-Update-List-Item ::= SEQUENCE
struct ul_up_tnl_info_to_upd_list_item_s {
  bool                                              ext                        = false;
  bool                                              new_ul_up_tnl_info_present = false;
  bool                                              ie_exts_present            = false;
  up_transport_layer_info_c                         ul_up_tnl_info;
  up_transport_layer_info_c                         new_ul_up_tnl_info;
  bh_info_s                                         bh_info;
  ul_up_tnl_info_to_upd_list_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UuRLCChannelFailedToBeModifiedItem-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using uu_rlc_ch_failed_to_be_modified_item_ext_ies_o = protocol_ext_empty_o;

// UuRLCChannelFailedToBeSetupItem-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using uu_rlc_ch_failed_to_be_setup_item_ext_ies_o = protocol_ext_empty_o;

// UuRLCChannelModifiedItem-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using uu_rlc_ch_modified_item_ext_ies_o = protocol_ext_empty_o;

// UuRLCChannelQoSInformation ::= CHOICE
struct uu_rlc_ch_qos_info_c {
  struct uu_ctrl_plane_traffic_type_opts {
    enum options { srb0, srb1, srb2, /*...*/ nulltype } value;
    typedef uint8_t number_type;

    const char* to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<uu_ctrl_plane_traffic_type_opts, true> uu_ctrl_plane_traffic_type_e_;
  struct types_opts {
    enum options { uu_rlc_ch_qos, uu_ctrl_plane_traffic_type, choice_ext, nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  uu_rlc_ch_qos_info_c() = default;
  uu_rlc_ch_qos_info_c(const uu_rlc_ch_qos_info_c& other);
  uu_rlc_ch_qos_info_c& operator=(const uu_rlc_ch_qos_info_c& other);
  ~uu_rlc_ch_qos_info_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  qos_flow_level_qos_params_s& uu_rlc_ch_qos()
  {
    assert_choice_type(types::uu_rlc_ch_qos, type_, "UuRLCChannelQoSInformation");
    return c.get<qos_flow_level_qos_params_s>();
  }
  uu_ctrl_plane_traffic_type_e_& uu_ctrl_plane_traffic_type()
  {
    assert_choice_type(types::uu_ctrl_plane_traffic_type, type_, "UuRLCChannelQoSInformation");
    return c.get<uu_ctrl_plane_traffic_type_e_>();
  }
  protocol_ie_single_container_s<uu_rlc_ch_qos_info_ext_ies_o>& choice_ext()
  {
    assert_choice_type(types::choice_ext, type_, "UuRLCChannelQoSInformation");
    return c.get<protocol_ie_single_container_s<uu_rlc_ch_qos_info_ext_ies_o>>();
  }
  const qos_flow_level_qos_params_s& uu_rlc_ch_qos() const
  {
    assert_choice_type(types::uu_rlc_ch_qos, type_, "UuRLCChannelQoSInformation");
    return c.get<qos_flow_level_qos_params_s>();
  }
  const uu_ctrl_plane_traffic_type_e_& uu_ctrl_plane_traffic_type() const
  {
    assert_choice_type(types::uu_ctrl_plane_traffic_type, type_, "UuRLCChannelQoSInformation");
    return c.get<uu_ctrl_plane_traffic_type_e_>();
  }
  const protocol_ie_single_container_s<uu_rlc_ch_qos_info_ext_ies_o>& choice_ext() const
  {
    assert_choice_type(types::choice_ext, type_, "UuRLCChannelQoSInformation");
    return c.get<protocol_ie_single_container_s<uu_rlc_ch_qos_info_ext_ies_o>>();
  }
  qos_flow_level_qos_params_s&                                  set_uu_rlc_ch_qos();
  uu_ctrl_plane_traffic_type_e_&                                set_uu_ctrl_plane_traffic_type();
  protocol_ie_single_container_s<uu_rlc_ch_qos_info_ext_ies_o>& set_choice_ext();

private:
  types                                                                                                      type_;
  choice_buffer_t<protocol_ie_single_container_s<uu_rlc_ch_qos_info_ext_ies_o>, qos_flow_level_qos_params_s> c;

  void destroy_();
};

// UuRLCChannelRequiredToBeModifiedItem-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using uu_rlc_ch_required_to_be_modified_item_ext_ies_o = protocol_ext_empty_o;

// UuRLCChannelRequiredToBeReleasedItem-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using uu_rlc_ch_required_to_be_released_item_ext_ies_o = protocol_ext_empty_o;

// UuRLCChannelSetupItem-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using uu_rlc_ch_setup_item_ext_ies_o = protocol_ext_empty_o;

// UuRLCChannelToBeModifiedItem-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using uu_rlc_ch_to_be_modified_item_ext_ies_o = protocol_ext_empty_o;

// UuRLCChannelToBeReleasedItem-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using uu_rlc_ch_to_be_released_item_ext_ies_o = protocol_ext_empty_o;

// UuRLCChannelToBeSetupItem-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using uu_rlc_ch_to_be_setup_item_ext_ies_o = protocol_ext_empty_o;

// EventType ::= ENUMERATED
struct event_type_opts {
  enum options { on_demand, periodic, stop, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<event_type_opts, true> event_type_e;

// F1CPathNRDC ::= ENUMERATED
struct f1_cp_ath_nr_dc_opts {
  enum options { mcg, scg, both, nulltype } value;

  const char* to_string() const;
};
typedef enumerated<f1_cp_ath_nr_dc_opts> f1_cp_ath_nr_dc_e;

// F1CPathNSA ::= ENUMERATED
struct f1_cp_ath_nsa_opts {
  enum options { lte, nr, both, nulltype } value;

  const char* to_string() const;
};
typedef enumerated<f1_cp_ath_nsa_opts> f1_cp_ath_nsa_e;

// F1CTransferPath-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using f1_c_transfer_path_ext_ies_o = protocol_ext_empty_o;

// F1CTransferPathNRDC-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using f1_c_transfer_path_nr_dc_ext_ies_o = protocol_ext_empty_o;

// FiveG-ProSeAuthorized-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using five_g_pro_se_authorized_ext_ies_o = protocol_ext_empty_o;

// FiveG-ProSeDirectCommunication ::= ENUMERATED
struct five_g_pro_se_direct_communication_opts {
  enum options { authorized, not_authorized, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<five_g_pro_se_direct_communication_opts, true> five_g_pro_se_direct_communication_e;

// FiveG-ProSeDirectDiscovery ::= ENUMERATED
struct five_g_pro_se_direct_discovery_opts {
  enum options { authorized, not_authorized, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<five_g_pro_se_direct_discovery_opts, true> five_g_pro_se_direct_discovery_e;

// FiveG-ProSeLayer2RemoteUE ::= ENUMERATED
struct five_g_pro_se_layer2_remote_ue_opts {
  enum options { authorized, not_authorized, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<five_g_pro_se_layer2_remote_ue_opts, true> five_g_pro_se_layer2_remote_ue_e;

// FiveG-ProSeLayer2UEtoNetworkRelay ::= ENUMERATED
struct five_g_pro_se_layer2_ue_to_network_relay_opts {
  enum options { authorized, not_authorized, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<five_g_pro_se_layer2_ue_to_network_relay_opts, true> five_g_pro_se_layer2_ue_to_network_relay_e;

// FiveG-ProSeLayer3UEtoNetworkRelay ::= ENUMERATED
struct five_g_pro_se_layer3_ue_to_network_relay_opts {
  enum options { authorized, not_authorized, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<five_g_pro_se_layer3_ue_to_network_relay_opts, true> five_g_pro_se_layer3_ue_to_network_relay_e;

// GNB-CU-TNL-Association-Failed-To-Setup-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct gnb_cu_tnl_assoc_failed_to_setup_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { gnb_cu_tnl_assoc_failed_to_setup_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::gnb_cu_tnl_assoc_failed_to_setup_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    gnb_cu_tnl_assoc_failed_to_setup_item_s&       gnb_cu_tnl_assoc_failed_to_setup_item() { return c; }
    const gnb_cu_tnl_assoc_failed_to_setup_item_s& gnb_cu_tnl_assoc_failed_to_setup_item() const { return c; }

  private:
    gnb_cu_tnl_assoc_failed_to_setup_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// GNB-CU-TNL-Association-Setup-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct gnb_cu_tnl_assoc_setup_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { gnb_cu_tnl_assoc_setup_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::gnb_cu_tnl_assoc_setup_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    gnb_cu_tnl_assoc_setup_item_s&       gnb_cu_tnl_assoc_setup_item() { return c; }
    const gnb_cu_tnl_assoc_setup_item_s& gnb_cu_tnl_assoc_setup_item() const { return c; }

  private:
    gnb_cu_tnl_assoc_setup_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// GNB-CU-TNL-Association-To-Add-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct gnb_cu_tnl_assoc_to_add_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { gnb_cu_tnl_assoc_to_add_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::gnb_cu_tnl_assoc_to_add_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    gnb_cu_tnl_assoc_to_add_item_s&       gnb_cu_tnl_assoc_to_add_item() { return c; }
    const gnb_cu_tnl_assoc_to_add_item_s& gnb_cu_tnl_assoc_to_add_item() const { return c; }

  private:
    gnb_cu_tnl_assoc_to_add_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// GNB-CU-TNL-Association-To-Remove-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct gnb_cu_tnl_assoc_to_rem_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { gnb_cu_tnl_assoc_to_rem_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::gnb_cu_tnl_assoc_to_rem_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    gnb_cu_tnl_assoc_to_rem_item_s&       gnb_cu_tnl_assoc_to_rem_item() { return c; }
    const gnb_cu_tnl_assoc_to_rem_item_s& gnb_cu_tnl_assoc_to_rem_item() const { return c; }

  private:
    gnb_cu_tnl_assoc_to_rem_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// GNB-CU-TNL-Association-To-Update-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct gnb_cu_tnl_assoc_to_upd_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { gnb_cu_tnl_assoc_to_upd_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::gnb_cu_tnl_assoc_to_upd_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    gnb_cu_tnl_assoc_to_upd_item_s&       gnb_cu_tnl_assoc_to_upd_item() { return c; }
    const gnb_cu_tnl_assoc_to_upd_item_s& gnb_cu_tnl_assoc_to_upd_item() const { return c; }

  private:
    gnb_cu_tnl_assoc_to_upd_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// GNB-DU-Served-Cells-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct gnb_du_served_cells_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { gnb_du_served_cells_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::gnb_du_served_cells_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    gnb_du_served_cells_item_s&       gnb_du_served_cells_item() { return c; }
    const gnb_du_served_cells_item_s& gnb_du_served_cells_item() const { return c; }

  private:
    gnb_du_served_cells_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// GNB-DU-TNL-Association-To-Remove-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct gnb_du_tnl_assoc_to_rem_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { gnb_du_tnl_assoc_to_rem_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::gnb_du_tnl_assoc_to_rem_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    gnb_du_tnl_assoc_to_rem_item_s&       gnb_du_tnl_assoc_to_rem_item() { return c; }
    const gnb_du_tnl_assoc_to_rem_item_s& gnb_du_tnl_assoc_to_rem_item() const { return c; }

  private:
    gnb_du_tnl_assoc_to_rem_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

using gnb_du_ue_slice_max_bit_rate_item_ext_ies_container = protocol_ext_container_empty_l;

// GNBDUUESliceMaximumBitRateItem ::= SEQUENCE
struct gnb_du_ue_slice_max_bit_rate_item_s {
  bool                                                ext             = false;
  bool                                                ie_exts_present = false;
  snssai_s                                            snssai;
  uint64_t                                            ue_slice_max_bit_rate_ul = 0;
  gnb_du_ue_slice_max_bit_rate_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// HardwareLoadIndicator-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using hardware_load_ind_ext_ies_o = protocol_ext_empty_o;

// IAB-Allocated-TNL-Address-List-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct iab_allocated_tnl_address_list_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { iab_allocated_tnl_address_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::iab_allocated_tnl_address_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    iab_allocated_tnl_address_item_s&       iab_allocated_tnl_address_item() { return c; }
    const iab_allocated_tnl_address_item_s& iab_allocated_tnl_address_item() const { return c; }

  private:
    iab_allocated_tnl_address_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// IAB-Congestion-Indication-List ::= SEQUENCE (SIZE (1..1024)) OF IAB-Congestion-Indication-Item
using iab_congestion_ind_list_l = dyn_array<iab_congestion_ind_item_s>;

// IAB-Congestion-Indication-List-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using iab_congestion_ind_list_ext_ies_o = protocol_ext_empty_o;

// IAB-TNL-Addresses-Exception-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using iab_tnl_addresses_exception_ext_ies_o = protocol_ext_empty_o;

// IAB-TNL-Addresses-To-Remove-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct iab_tnl_addresses_to_rem_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { iab_tnl_addresses_to_rem_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::iab_tnl_addresses_to_rem_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    iab_tnl_addresses_to_rem_item_s&       iab_tnl_addresses_to_rem_item() { return c; }
    const iab_tnl_addresses_to_rem_item_s& iab_tnl_addresses_to_rem_item() const { return c; }

  private:
    iab_tnl_addresses_to_rem_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// IABIPv6RequestType-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
using iab_ip_v6_request_type_ext_ies_o = protocol_ies_empty_o;

// IABTNLAddressList ::= SEQUENCE (SIZE (1..1024)) OF IABTNLAddress-Item
using iab_tnl_address_list_l = dyn_array<iab_tnl_address_item_s>;

using iab_tnl_addresses_requested_ext_ies_container = protocol_ext_container_empty_l;

// IABTNLAddressesRequested ::= SEQUENCE
struct iab_tnl_addresses_requested_s {
  bool                                          tnl_addresses_or_prefixes_requested_all_traffic_present = false;
  bool                                          tnl_addresses_or_prefixes_requested_f1_c_present        = false;
  bool                                          tnl_addresses_or_prefixes_requested_f1_u_present        = false;
  bool                                          tnl_addresses_or_prefixes_requested_no_nf1_present      = false;
  bool                                          ie_exts_present                                         = false;
  uint16_t                                      tnl_addresses_or_prefixes_requested_all_traffic         = 1;
  uint16_t                                      tnl_addresses_or_prefixes_requested_f1_c                = 1;
  uint16_t                                      tnl_addresses_or_prefixes_requested_f1_u                = 1;
  uint16_t                                      tnl_addresses_or_prefixes_requested_no_nf1              = 1;
  iab_tnl_addresses_requested_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// IABv4AddressesRequested-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using ia_bv4_addresses_requested_ext_ies_o = protocol_ext_empty_o;

// LTEUESidelinkAggregateMaximumBitrate-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using lte_ue_sidelink_aggr_max_bitrate_ext_ies_o = protocol_ext_empty_o;

// LTEV2XServicesAuthorized-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using ltev2x_services_authorized_ext_ies_o = protocol_ext_empty_o;

// MBSMulticastF1UContextDescriptor-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using mbs_multicast_f1_u_context_descriptor_ext_ies_o = protocol_ext_empty_o;

// MC-PagingCell-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct mc_paging_cell_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { mc_paging_cell_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::mc_paging_cell_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    mc_paging_cell_item_s&       mc_paging_cell_item() { return c; }
    const mc_paging_cell_item_s& mc_paging_cell_item() const { return c; }

  private:
    mc_paging_cell_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// MulticastF1UContext-FailedToBeSetup-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct multicast_f1_u_context_failed_to_be_setup_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { multicast_f1_u_context_failed_to_be_setup_item, nulltype } value;
      typedef uint8_t number_type;

      const char* to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::multicast_f1_u_context_failed_to_be_setup_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    multicast_f1_u_context_failed_to_be_setup_item_s& multicast_f1_u_context_failed_to_be_setup_item() { return c; }
    const multicast_f1_u_context_failed_to_be_setup_item_s& multicast_f1_u_context_failed_to_be_setup_item() const
    {
      return c;
    }

  private:
    multicast_f1_u_context_failed_to_be_setup_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// MulticastF1UContext-Setup-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct multicast_f1_u_context_setup_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { multicast_f1_u_context_setup_item, nulltype } value;
      typedef uint8_t number_type;

      const char* to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::multicast_f1_u_context_setup_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    multicast_f1_u_context_setup_item_s&       multicast_f1_u_context_setup_item() { return c; }
    const multicast_f1_u_context_setup_item_s& multicast_f1_u_context_setup_item() const { return c; }

  private:
    multicast_f1_u_context_setup_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// MulticastF1UContext-ToBeSetup-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct multicast_f1_u_context_to_be_setup_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { multicast_f1_u_context_to_be_setup_item, nulltype } value;
      typedef uint8_t number_type;

      const char* to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::multicast_f1_u_context_to_be_setup_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    multicast_f1_u_context_to_be_setup_item_s&       multicast_f1_u_context_to_be_setup_item() { return c; }
    const multicast_f1_u_context_to_be_setup_item_s& multicast_f1_u_context_to_be_setup_item() const { return c; }

  private:
    multicast_f1_u_context_to_be_setup_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

using multicast_mbs_session_list_item_ext_ies_container = protocol_ext_container_empty_l;

// MulticastMBSSessionList-Item ::= SEQUENCE
struct multicast_mbs_session_list_item_s {
  bool                                              ext             = false;
  bool                                              ie_exts_present = false;
  mbs_session_id_s                                  mbs_session_id;
  multicast_mbs_session_list_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MulticastMRBs-FailedToBeModified-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct multicast_m_rbs_failed_to_be_modified_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { multicast_m_rbs_failed_to_be_modified_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::multicast_m_rbs_failed_to_be_modified_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    multicast_m_rbs_failed_to_be_modified_item_s&       multicast_m_rbs_failed_to_be_modified_item() { return c; }
    const multicast_m_rbs_failed_to_be_modified_item_s& multicast_m_rbs_failed_to_be_modified_item() const { return c; }

  private:
    multicast_m_rbs_failed_to_be_modified_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// MulticastMRBs-FailedToBeSetup-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct multicast_m_rbs_failed_to_be_setup_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { multicast_m_rbs_failed_to_be_setup_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::multicast_m_rbs_failed_to_be_setup_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    multicast_m_rbs_failed_to_be_setup_item_s&       multicast_m_rbs_failed_to_be_setup_item() { return c; }
    const multicast_m_rbs_failed_to_be_setup_item_s& multicast_m_rbs_failed_to_be_setup_item() const { return c; }

  private:
    multicast_m_rbs_failed_to_be_setup_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// MulticastMRBs-FailedToBeSetupMod-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct multicast_m_rbs_failed_to_be_setup_mod_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { multicast_m_rbs_failed_to_be_setup_mod_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::multicast_m_rbs_failed_to_be_setup_mod_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    multicast_m_rbs_failed_to_be_setup_mod_item_s&       multicast_m_rbs_failed_to_be_setup_mod_item() { return c; }
    const multicast_m_rbs_failed_to_be_setup_mod_item_s& multicast_m_rbs_failed_to_be_setup_mod_item() const
    {
      return c;
    }

  private:
    multicast_m_rbs_failed_to_be_setup_mod_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// MulticastMRBs-Modified-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct multicast_m_rbs_modified_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { multicast_m_rbs_modified_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::multicast_m_rbs_modified_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    multicast_m_rbs_modified_item_s&       multicast_m_rbs_modified_item() { return c; }
    const multicast_m_rbs_modified_item_s& multicast_m_rbs_modified_item() const { return c; }

  private:
    multicast_m_rbs_modified_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// MulticastMRBs-Setup-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct multicast_m_rbs_setup_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { multicast_m_rbs_setup_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::multicast_m_rbs_setup_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    multicast_m_rbs_setup_item_s&       multicast_m_rbs_setup_item() { return c; }
    const multicast_m_rbs_setup_item_s& multicast_m_rbs_setup_item() const { return c; }

  private:
    multicast_m_rbs_setup_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// MulticastMRBs-SetupMod-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct multicast_m_rbs_setup_mod_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { multicast_m_rbs_setup_mod_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::multicast_m_rbs_setup_mod_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    multicast_m_rbs_setup_mod_item_s&       multicast_m_rbs_setup_mod_item() { return c; }
    const multicast_m_rbs_setup_mod_item_s& multicast_m_rbs_setup_mod_item() const { return c; }

  private:
    multicast_m_rbs_setup_mod_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// MulticastMRBs-ToBeModified-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct multicast_m_rbs_to_be_modified_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { multicast_m_rbs_to_be_modified_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::multicast_m_rbs_to_be_modified_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    multicast_m_rbs_to_be_modified_item_s&       multicast_m_rbs_to_be_modified_item() { return c; }
    const multicast_m_rbs_to_be_modified_item_s& multicast_m_rbs_to_be_modified_item() const { return c; }

  private:
    multicast_m_rbs_to_be_modified_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// MulticastMRBs-ToBeReleased-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct multicast_m_rbs_to_be_released_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { multicast_m_rbs_to_be_released_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::multicast_m_rbs_to_be_released_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    multicast_m_rbs_to_be_released_item_s&       multicast_m_rbs_to_be_released_item() { return c; }
    const multicast_m_rbs_to_be_released_item_s& multicast_m_rbs_to_be_released_item() const { return c; }

  private:
    multicast_m_rbs_to_be_released_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// MulticastMRBs-ToBeSetup-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct multicast_m_rbs_to_be_setup_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { multicast_m_rbs_to_be_setup_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::multicast_m_rbs_to_be_setup_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    multicast_m_rbs_to_be_setup_item_s&       multicast_m_rbs_to_be_setup_item() { return c; }
    const multicast_m_rbs_to_be_setup_item_s& multicast_m_rbs_to_be_setup_item() const { return c; }

  private:
    multicast_m_rbs_to_be_setup_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// MulticastMRBs-ToBeSetupMod-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct multicast_m_rbs_to_be_setup_mod_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { multicast_m_rbs_to_be_setup_mod_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::multicast_m_rbs_to_be_setup_mod_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    multicast_m_rbs_to_be_setup_mod_item_s&       multicast_m_rbs_to_be_setup_mod_item() { return c; }
    const multicast_m_rbs_to_be_setup_mod_item_s& multicast_m_rbs_to_be_setup_mod_item() const { return c; }

  private:
    multicast_m_rbs_to_be_setup_mod_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// NR-CGI-List-For-Restart-List-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct nr_cgi_list_for_restart_list_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { nr_cgi_list_for_restart_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::nr_cgi_list_for_restart_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    nr_cgi_list_for_restart_item_s&       nr_cgi_list_for_restart_item() { return c; }
    const nr_cgi_list_for_restart_item_s& nr_cgi_list_for_restart_item() const { return c; }

  private:
    nr_cgi_list_for_restart_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// NRPaging-Time-Window ::= ENUMERATED
struct nr_paging_time_win_opts {
  enum options {
    s1,
    s2,
    s3,
    s4,
    s5,
    s6,
    s7,
    s8,
    s9,
    s10,
    s11,
    s12,
    s13,
    s14,
    s15,
    s16,
    // ...
    s17,
    s18,
    s19,
    s20,
    s21,
    s22,
    s23,
    s24,
    s25,
    s26,
    s27,
    s28,
    s29,
    s30,
    s31,
    s32,
    nulltype
  } value;
  typedef uint8_t number_type;

  const char* to_string() const;
  uint8_t     to_number() const;
};
typedef enumerated<nr_paging_time_win_opts, true, 16> nr_paging_time_win_e;

// NRPaging-eDRX-Cycle-Idle ::= ENUMERATED
struct nr_paging_e_drx_cycle_idle_opts {
  enum options {
    hfquarter,
    hfhalf,
    hf1,
    hf2,
    hf4,
    hf8,
    hf16,
    hf32,
    hf64,
    hf128,
    hf256,
    hf512,
    hf1024,
    /*...*/ nulltype
  } value;
  typedef float number_type;

  const char* to_string() const;
  float       to_number() const;
  const char* to_number_string() const;
};
typedef enumerated<nr_paging_e_drx_cycle_idle_opts, true> nr_paging_e_drx_cycle_idle_e;

// NRPaging-eDRX-Cycle-Inactive ::= ENUMERATED
struct nr_paging_e_drx_cycle_inactive_opts {
  enum options { hfquarter, hfhalf, hf1, /*...*/ nulltype } value;
  typedef float number_type;

  const char* to_string() const;
  float       to_number() const;
  const char* to_number_string() const;
};
typedef enumerated<nr_paging_e_drx_cycle_inactive_opts, true> nr_paging_e_drx_cycle_inactive_e;

// NRPagingeDRXInformation-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using nr_paginge_drx_info_ext_ies_o = protocol_ext_empty_o;

// NRPagingeDRXInformationforRRCINACTIVE-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using nr_paginge_drx_infofor_rrc_inactive_ext_ies_o = protocol_ext_empty_o;

// NRUESidelinkAggregateMaximumBitrate-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using nr_ue_sidelink_aggr_max_bitrate_ext_ies_o = protocol_ext_empty_o;

// NRV2XServicesAuthorized-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using nr_v2x_services_authorized_ext_ies_o = protocol_ext_empty_o;

// Neighbour-Cell-Information-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct neighbour_cell_info_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { neighbour_cell_info_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::neighbour_cell_info_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    neighbour_cell_info_item_s&       neighbour_cell_info_item() { return c; }
    const neighbour_cell_info_item_s& neighbour_cell_info_item() const { return c; }

  private:
    neighbour_cell_info_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

using neighbour_node_cells_list_item_ext_ies_container = protocol_ext_container_empty_l;

// Neighbour-Node-Cells-List-Item ::= SEQUENCE
struct neighbour_node_cells_list_item_s {
  struct peer_parent_node_ind_opts {
    enum options { true_value, /*...*/ nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<peer_parent_node_ind_opts, true> peer_parent_node_ind_e_;

  // member variables
  bool                                             gnb_cu_ue_f1ap_id_present             = false;
  bool                                             gnb_du_ue_f1ap_id_present             = false;
  bool                                             peer_parent_node_ind_present          = false;
  bool                                             iab_du_cell_res_cfg_mode_info_present = false;
  bool                                             iab_stc_info_present                  = false;
  bool                                             ie_exts_present                       = false;
  nr_cgi_s                                         nr_cgi;
  uint64_t                                         gnb_cu_ue_f1ap_id = 0;
  uint64_t                                         gnb_du_ue_f1ap_id = 0;
  peer_parent_node_ind_e_                          peer_parent_node_ind;
  iab_du_cell_res_cfg_mode_info_c                  iab_du_cell_res_cfg_mode_info;
  iab_stc_info_s                                   iab_stc_info;
  unbounded_octstring<true>                        rach_cfg_common;
  unbounded_octstring<true>                        rach_cfg_common_iab;
  unbounded_octstring<true>                        csi_rs_cfg;
  unbounded_octstring<true>                        sr_cfg;
  unbounded_octstring<true>                        pdcch_cfg_sib1;
  unbounded_octstring<true>                        scs_common;
  neighbour_node_cells_list_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using pc5_rlc_ch_failed_to_be_modified_item_ext_ies_container = protocol_ext_container_empty_l;

// PC5RLCChannelFailedToBeModifiedItem ::= SEQUENCE
struct pc5_rlc_ch_failed_to_be_modified_item_s {
  bool                                                    ext                        = false;
  bool                                                    remote_ue_local_id_present = false;
  bool                                                    cause_present              = false;
  bool                                                    ie_exts_present            = false;
  uint16_t                                                pc5_rlc_ch_id              = 1;
  uint16_t                                                remote_ue_local_id         = 0;
  cause_c                                                 cause;
  pc5_rlc_ch_failed_to_be_modified_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using pc5_rlc_ch_failed_to_be_setup_item_ext_ies_container = protocol_ext_container_empty_l;

// PC5RLCChannelFailedToBeSetupItem ::= SEQUENCE
struct pc5_rlc_ch_failed_to_be_setup_item_s {
  bool                                                 ext                        = false;
  bool                                                 remote_ue_local_id_present = false;
  bool                                                 cause_present              = false;
  bool                                                 ie_exts_present            = false;
  uint16_t                                             pc5_rlc_ch_id              = 1;
  uint16_t                                             remote_ue_local_id         = 0;
  cause_c                                              cause;
  pc5_rlc_ch_failed_to_be_setup_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using pc5_rlc_ch_modified_item_ext_ies_container = protocol_ext_container_empty_l;

// PC5RLCChannelModifiedItem ::= SEQUENCE
struct pc5_rlc_ch_modified_item_s {
  bool                                       ext                        = false;
  bool                                       remote_ue_local_id_present = false;
  bool                                       ie_exts_present            = false;
  uint16_t                                   pc5_rlc_ch_id              = 1;
  uint16_t                                   remote_ue_local_id         = 0;
  pc5_rlc_ch_modified_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using pc5_rlc_ch_required_to_be_modified_item_ext_ies_container = protocol_ext_container_empty_l;

// PC5RLCChannelRequiredToBeModifiedItem ::= SEQUENCE
struct pc5_rlc_ch_required_to_be_modified_item_s {
  bool                                                      ext                        = false;
  bool                                                      remote_ue_local_id_present = false;
  bool                                                      ie_exts_present            = false;
  uint16_t                                                  pc5_rlc_ch_id              = 1;
  uint16_t                                                  remote_ue_local_id         = 0;
  pc5_rlc_ch_required_to_be_modified_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using pc5_rlc_ch_required_to_be_released_item_ext_ies_container = protocol_ext_container_empty_l;

// PC5RLCChannelRequiredToBeReleasedItem ::= SEQUENCE
struct pc5_rlc_ch_required_to_be_released_item_s {
  bool                                                      ext                        = false;
  bool                                                      remote_ue_local_id_present = false;
  bool                                                      ie_exts_present            = false;
  uint16_t                                                  pc5_rlc_ch_id              = 1;
  uint16_t                                                  remote_ue_local_id         = 0;
  pc5_rlc_ch_required_to_be_released_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using pc5_rlc_ch_setup_item_ext_ies_container = protocol_ext_container_empty_l;

// PC5RLCChannelSetupItem ::= SEQUENCE
struct pc5_rlc_ch_setup_item_s {
  bool                                    ext                        = false;
  bool                                    remote_ue_local_id_present = false;
  bool                                    ie_exts_present            = false;
  uint16_t                                pc5_rlc_ch_id              = 1;
  uint16_t                                remote_ue_local_id         = 0;
  pc5_rlc_ch_setup_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using pc5_rlc_ch_to_be_modified_item_ext_ies_container = protocol_ext_container_empty_l;

// PC5RLCChannelToBeModifiedItem ::= SEQUENCE
struct pc5_rlc_ch_to_be_modified_item_s {
  bool                                             ext                         = false;
  bool                                             remote_ue_local_id_present  = false;
  bool                                             pc5_rlc_ch_qos_info_present = false;
  bool                                             rlc_mode_present            = false;
  bool                                             ie_exts_present             = false;
  uint16_t                                         pc5_rlc_ch_id               = 1;
  uint16_t                                         remote_ue_local_id          = 0;
  pc5_rlc_ch_qos_info_c                            pc5_rlc_ch_qos_info;
  rlc_mode_e                                       rlc_mode;
  pc5_rlc_ch_to_be_modified_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using pc5_rlc_ch_to_be_released_item_ext_ies_container = protocol_ext_container_empty_l;

// PC5RLCChannelToBeReleasedItem ::= SEQUENCE
struct pc5_rlc_ch_to_be_released_item_s {
  bool                                             ext                        = false;
  bool                                             remote_ue_local_id_present = false;
  bool                                             ie_exts_present            = false;
  uint16_t                                         pc5_rlc_ch_id              = 1;
  uint16_t                                         remote_ue_local_id         = 0;
  pc5_rlc_ch_to_be_released_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using pc5_rlc_ch_to_be_setup_item_ext_ies_container = protocol_ext_container_empty_l;

// PC5RLCChannelToBeSetupItem ::= SEQUENCE
struct pc5_rlc_ch_to_be_setup_item_s {
  bool                                          ext                        = false;
  bool                                          remote_ue_local_id_present = false;
  bool                                          ie_exts_present            = false;
  uint16_t                                      pc5_rlc_ch_id              = 1;
  uint16_t                                      remote_ue_local_id         = 0;
  pc5_rlc_ch_qos_info_c                         pc5_rlc_ch_qos_info;
  rlc_mode_e                                    rlc_mode;
  pc5_rlc_ch_to_be_setup_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PDCMeasuredResultsList ::= SEQUENCE (SIZE (1..16)) OF PDCMeasuredResults-Item
using pdc_measured_results_list_l = dyn_array<pdc_measured_results_item_s>;

// PDCMeasurementQuantities-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct pdc_meas_quantities_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { pdc_meas_quantities_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::pdc_meas_quantities_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    pdc_meas_quantities_item_s&       pdc_meas_quantities_item() { return c; }
    const pdc_meas_quantities_item_s& pdc_meas_quantities_item() const { return c; }

  private:
    pdc_meas_quantities_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// PDCMeasurementResult-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using pdc_meas_result_ext_ies_o = protocol_ext_empty_o;

// PEIPSAssistanceInfo-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using pe_ip_s_assist_info_ext_ies_o = protocol_ext_empty_o;

using prs_meas_info_list_item_ext_ies_container = protocol_ext_container_empty_l;

// PRS-Measurement-Info-List-Item ::= SEQUENCE
struct prs_meas_info_list_item_s {
  struct meas_prs_periodicity_opts {
    enum options { ms20, ms40, ms80, ms160, /*...*/ nulltype } value;
    typedef uint8_t number_type;

    const char* to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<meas_prs_periodicity_opts, true> meas_prs_periodicity_e_;
  struct meas_prs_len_opts {
    enum options { ms1dot5, ms3, ms3dot5, ms4, ms5dot5, ms6, ms10, ms20, nulltype } value;
    typedef float number_type;

    const char* to_string() const;
    float       to_number() const;
    const char* to_number_string() const;
  };
  typedef enumerated<meas_prs_len_opts> meas_prs_len_e_;

  // member variables
  bool                                      ext             = false;
  bool                                      ie_exts_present = false;
  uint32_t                                  point_a         = 0;
  meas_prs_periodicity_e_                   meas_prs_periodicity;
  uint8_t                                   meas_prs_offset = 0;
  meas_prs_len_e_                           meas_prs_len;
  prs_meas_info_list_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using prstrp_item_ext_ies_container = protocol_ext_container_empty_l;

// PRSTRPItem ::= SEQUENCE
struct prstrp_item_s {
  bool                                  ext                                         = false;
  bool                                  requested_dl_prs_tx_characteristics_present = false;
  bool                                  prs_tx_off_info_present                     = false;
  bool                                  ie_exts_present                             = false;
  uint32_t                              trp_id                                      = 0;
  requested_dl_prs_tx_characteristics_s requested_dl_prs_tx_characteristics;
  prs_tx_off_info_s                     prs_tx_off_info;
  prstrp_item_ext_ies_container         ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using prs_tx_trp_item_ext_ies_container = protocol_ext_container_empty_l;

// PRSTransmissionTRPItem ::= SEQUENCE
struct prs_tx_trp_item_s {
  bool                              ext             = false;
  bool                              ie_exts_present = false;
  uint32_t                          trp_id          = 0;
  prs_cfg_s                         prs_cfg;
  prs_tx_trp_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PWS-Failed-NR-CGI-List-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct pws_failed_nr_cgi_list_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { pws_failed_nr_cgi_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::pws_failed_nr_cgi_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    pws_failed_nr_cgi_item_s&       pws_failed_nr_cgi_item() { return c; }
    const pws_failed_nr_cgi_item_s& pws_failed_nr_cgi_item() const { return c; }

  private:
    pws_failed_nr_cgi_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// PWSSystemInformationExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
struct pws_sys_info_ext_ies_o {
  // Extension ::= OPEN TYPE
  struct ext_c {
    struct types_opts {
      enum options { notif_info, add_sib_msg_list, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    ext_c() = default;
    ext_c(const ext_c& other);
    ext_c& operator=(const ext_c& other);
    ~ext_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    notif_info_s&             notif_info();
    add_sib_msg_list_l&       add_sib_msg_list();
    const notif_info_s&       notif_info() const;
    const add_sib_msg_list_l& add_sib_msg_list() const;

  private:
    types                                             type_;
    choice_buffer_t<add_sib_msg_list_l, notif_info_s> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static ext_c      get_ext(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// PagingCell-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct paging_cell_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { paging_cell_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::paging_cell_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    paging_cell_item_s&       paging_cell_item() { return c; }
    const paging_cell_item_s& paging_cell_item() const { return c; }

  private:
    paging_cell_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// PagingIdentity-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
using paging_id_ext_ies_o = protocol_ies_empty_o;

// PathSwitchConfiguration-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using path_switch_cfg_ext_ies_o = protocol_ext_empty_o;

// PedestrianUE ::= ENUMERATED
struct pedestrian_ue_opts {
  enum options { authorized, not_authorized, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<pedestrian_ue_opts, true> pedestrian_ue_e;

// PosMeasGapPreConfigList-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using pos_meas_gap_pre_cfg_list_ext_ies_o = protocol_ext_empty_o;

using pos_meas_quantities_item_ext_ies_container = protocol_ext_container_empty_l;

// PosMeasurementQuantities-Item ::= SEQUENCE
struct pos_meas_quantities_item_s {
  bool                                       timing_report_granularity_factor_present = false;
  bool                                       ie_exts_present                          = false;
  pos_meas_type_e                            pos_meas_type;
  uint8_t                                    timing_report_granularity_factor = 0;
  pos_meas_quantities_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PosMeasurementResultList-Item ::= SEQUENCE
struct pos_meas_result_list_item_s {
  pos_meas_result_l                                             pos_meas_result;
  uint32_t                                                      trp_id = 0;
  protocol_ext_container_l<pos_meas_result_list_item_ext_ies_o> ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using pos_sitype_item_ext_ies_container = protocol_ext_container_empty_l;

// PosSItype-Item ::= SEQUENCE
struct pos_sitype_item_s {
  bool                              ie_exts_present = false;
  uint8_t                           pos_itype       = 1;
  pos_sitype_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// Potential-SpCell-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct potential_sp_cell_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { potential_sp_cell_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::potential_sp_cell_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    potential_sp_cell_item_s&       potential_sp_cell_item() { return c; }
    const potential_sp_cell_item_s& potential_sp_cell_item() const { return c; }

  private:
    potential_sp_cell_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// Protected-EUTRA-Resources-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct protected_eutra_res_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { protected_eutra_res_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::protected_eutra_res_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    protected_eutra_res_item_s&       protected_eutra_res_item() { return c; }
    const protected_eutra_res_item_s& protected_eutra_res_item() const { return c; }

  private:
    protected_eutra_res_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// QoEInformation-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using qo_e_info_ext_ies_o = protocol_ext_empty_o;

// QoEInformationList ::= SEQUENCE (SIZE (1..16)) OF QoEInformationList-Item
using qo_e_info_list_l = dyn_array<qo_e_info_list_item_s>;

using ran_ue_paging_id_ext_ies_container = protocol_ext_container_empty_l;

// RANUEPagingIdentity ::= SEQUENCE
struct ran_ue_paging_id_s {
  bool                               ie_exts_present = false;
  fixed_bitstring<40, false, true>   irnti;
  ran_ue_paging_id_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RLCFailureIndication-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using rlc_fail_ind_ext_ies_o = protocol_ext_empty_o;

// RRC-Version-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
struct rrc_version_ext_ies_o {
  // Extension ::= OPEN TYPE
  struct ext_c {
    struct types_opts {
      enum options { latest_rrc_version_enhanced, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::latest_rrc_version_enhanced; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    fixed_octstring<3, true>&       latest_rrc_version_enhanced() { return c; }
    const fixed_octstring<3, true>& latest_rrc_version_enhanced() const { return c; }

  private:
    fixed_octstring<3, true> c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static ext_c      get_ext(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// RRCDeliveryStatus-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using rrc_delivery_status_ext_ies_o = protocol_ext_empty_o;

// ReportingRequestType-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using report_request_type_ext_ies_o = protocol_ext_empty_o;

// RequestedSRSTransmissionCharacteristics-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
struct requested_srs_tx_characteristics_ext_ies_o {
  // Extension ::= OPEN TYPE
  struct ext_c {
    struct types_opts {
      enum options { srs_freq, nulltype } value;
      typedef uint8_t number_type;

      const char* to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::srs_freq; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint32_t&       srs_freq() { return c; }
    const uint32_t& srs_freq() const { return c; }

  private:
    uint32_t c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static ext_c      get_ext(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// ResetAll ::= ENUMERATED
struct reset_all_opts {
  enum options { reset_all, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<reset_all_opts, true> reset_all_e;

// ResetType-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
using reset_type_ext_ies_o = protocol_ies_empty_o;

// ResourceCoordinationEUTRACellInfo ::= SEQUENCE
struct res_coordination_eutra_cell_info_s {
  bool                                                                 ext = false;
  eutra_coex_mode_info_c                                               eutra_mode_info;
  eutra_prach_cfg_s                                                    eutra_prach_cfg;
  protocol_ext_container_l<res_coordination_eutra_cell_info_ext_ies_o> ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// ResourceCoordinationTransferInformation-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using res_coordination_transfer_info_ext_ies_o = protocol_ext_empty_o;

// ResponseTime-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using resp_time_ext_ies_o = protocol_ext_empty_o;

// SCell-FailedtoSetup-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct scell_failedto_setup_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { scell_failedto_setup_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::scell_failedto_setup_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    scell_failedto_setup_item_s&       scell_failedto_setup_item() { return c; }
    const scell_failedto_setup_item_s& scell_failedto_setup_item() const { return c; }

  private:
    scell_failedto_setup_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// SCell-FailedtoSetupMod-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct scell_failedto_setup_mod_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { scell_failedto_setup_mod_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::scell_failedto_setup_mod_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    scell_failedto_setup_mod_item_s&       scell_failedto_setup_mod_item() { return c; }
    const scell_failedto_setup_mod_item_s& scell_failedto_setup_mod_item() const { return c; }

  private:
    scell_failedto_setup_mod_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// SCell-ToBeRemoved-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct scell_to_be_remd_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { scell_to_be_remd_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::scell_to_be_remd_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    scell_to_be_remd_item_s&       scell_to_be_remd_item() { return c; }
    const scell_to_be_remd_item_s& scell_to_be_remd_item() const { return c; }

  private:
    scell_to_be_remd_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// SCell-ToBeSetup-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct scell_to_be_setup_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { scell_to_be_setup_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::scell_to_be_setup_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    scell_to_be_setup_item_s&       scell_to_be_setup_item() { return c; }
    const scell_to_be_setup_item_s& scell_to_be_setup_item() const { return c; }

  private:
    scell_to_be_setup_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// SCell-ToBeSetupMod-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct scell_to_be_setup_mod_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { scell_to_be_setup_mod_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::scell_to_be_setup_mod_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    scell_to_be_setup_mod_item_s&       scell_to_be_setup_mod_item() { return c; }
    const scell_to_be_setup_mod_item_s& scell_to_be_setup_mod_item() const { return c; }

  private:
    scell_to_be_setup_mod_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// SDTBearerConfig-List ::= SEQUENCE (SIZE (1..72)) OF SDTBearerConfig-List-Item
using sdt_bearer_cfg_list_l = dyn_array<sdt_bearer_cfg_list_item_s>;

// SDTBearerConfigurationInfo-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using sdt_bearer_cfg_info_ext_ies_o = protocol_ext_empty_o;

// SDTInformation-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using sdt_info_ext_ies_o = protocol_ext_empty_o;

using sitype_item_ext_ies_container = protocol_ext_container_empty_l;

// SItype-Item ::= SEQUENCE
struct sitype_item_s {
  bool                          ie_exts_present = false;
  uint8_t                       sitype          = 1;
  sitype_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SLDRBs-FailedToBeModified-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct sl_drbs_failed_to_be_modified_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { sl_drbs_failed_to_be_modified_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::sl_drbs_failed_to_be_modified_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    sl_drbs_failed_to_be_modified_item_s&       sl_drbs_failed_to_be_modified_item() { return c; }
    const sl_drbs_failed_to_be_modified_item_s& sl_drbs_failed_to_be_modified_item() const { return c; }

  private:
    sl_drbs_failed_to_be_modified_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// SLDRBs-FailedToBeSetup-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct sl_drbs_failed_to_be_setup_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { sl_drbs_failed_to_be_setup_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::sl_drbs_failed_to_be_setup_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    sl_drbs_failed_to_be_setup_item_s&       sl_drbs_failed_to_be_setup_item() { return c; }
    const sl_drbs_failed_to_be_setup_item_s& sl_drbs_failed_to_be_setup_item() const { return c; }

  private:
    sl_drbs_failed_to_be_setup_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// SLDRBs-FailedToBeSetupMod-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct sl_drbs_failed_to_be_setup_mod_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { sl_drbs_failed_to_be_setup_mod_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::sl_drbs_failed_to_be_setup_mod_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    sl_drbs_failed_to_be_setup_mod_item_s&       sl_drbs_failed_to_be_setup_mod_item() { return c; }
    const sl_drbs_failed_to_be_setup_mod_item_s& sl_drbs_failed_to_be_setup_mod_item() const { return c; }

  private:
    sl_drbs_failed_to_be_setup_mod_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// SLDRBs-Modified-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct sl_drbs_modified_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { sl_drbs_modified_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::sl_drbs_modified_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    sl_drbs_modified_item_s&       sl_drbs_modified_item() { return c; }
    const sl_drbs_modified_item_s& sl_drbs_modified_item() const { return c; }

  private:
    sl_drbs_modified_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// SLDRBs-ModifiedConf-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct sl_drbs_modified_conf_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { sl_drbs_modified_conf_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::sl_drbs_modified_conf_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    sl_drbs_modified_conf_item_s&       sl_drbs_modified_conf_item() { return c; }
    const sl_drbs_modified_conf_item_s& sl_drbs_modified_conf_item() const { return c; }

  private:
    sl_drbs_modified_conf_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// SLDRBs-Required-ToBeModified-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct sl_drbs_required_to_be_modified_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { sl_drbs_required_to_be_modified_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::sl_drbs_required_to_be_modified_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    sl_drbs_required_to_be_modified_item_s&       sl_drbs_required_to_be_modified_item() { return c; }
    const sl_drbs_required_to_be_modified_item_s& sl_drbs_required_to_be_modified_item() const { return c; }

  private:
    sl_drbs_required_to_be_modified_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// SLDRBs-Required-ToBeReleased-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct sl_drbs_required_to_be_released_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { sl_drbs_required_to_be_released_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::sl_drbs_required_to_be_released_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    sl_drbs_required_to_be_released_item_s&       sl_drbs_required_to_be_released_item() { return c; }
    const sl_drbs_required_to_be_released_item_s& sl_drbs_required_to_be_released_item() const { return c; }

  private:
    sl_drbs_required_to_be_released_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// SLDRBs-Setup-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct sl_drbs_setup_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { sl_drbs_setup_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::sl_drbs_setup_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    sl_drbs_setup_item_s&       sl_drbs_setup_item() { return c; }
    const sl_drbs_setup_item_s& sl_drbs_setup_item() const { return c; }

  private:
    sl_drbs_setup_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// SLDRBs-SetupMod-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct sl_drbs_setup_mod_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { sl_drbs_setup_mod_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::sl_drbs_setup_mod_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    sl_drbs_setup_mod_item_s&       sl_drbs_setup_mod_item() { return c; }
    const sl_drbs_setup_mod_item_s& sl_drbs_setup_mod_item() const { return c; }

  private:
    sl_drbs_setup_mod_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// SLDRBs-ToBeModified-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct sl_drbs_to_be_modified_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { sl_drbs_to_be_modified_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::sl_drbs_to_be_modified_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    sl_drbs_to_be_modified_item_s&       sl_drbs_to_be_modified_item() { return c; }
    const sl_drbs_to_be_modified_item_s& sl_drbs_to_be_modified_item() const { return c; }

  private:
    sl_drbs_to_be_modified_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// SLDRBs-ToBeReleased-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct sl_drbs_to_be_released_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { sl_drbs_to_be_released_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::sl_drbs_to_be_released_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    sl_drbs_to_be_released_item_s&       sl_drbs_to_be_released_item() { return c; }
    const sl_drbs_to_be_released_item_s& sl_drbs_to_be_released_item() const { return c; }

  private:
    sl_drbs_to_be_released_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// SLDRBs-ToBeSetup-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct sl_drbs_to_be_setup_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { sl_drbs_to_be_setup_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::sl_drbs_to_be_setup_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    sl_drbs_to_be_setup_item_s&       sl_drbs_to_be_setup_item() { return c; }
    const sl_drbs_to_be_setup_item_s& sl_drbs_to_be_setup_item() const { return c; }

  private:
    sl_drbs_to_be_setup_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// SLDRBs-ToBeSetupMod-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct sl_drbs_to_be_setup_mod_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { sl_drbs_to_be_setup_mod_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::sl_drbs_to_be_setup_mod_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    sl_drbs_to_be_setup_mod_item_s&       sl_drbs_to_be_setup_mod_item() { return c; }
    const sl_drbs_to_be_setup_mod_item_s& sl_drbs_to_be_setup_mod_item() const { return c; }

  private:
    sl_drbs_to_be_setup_mod_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

using sldrx_cycle_item_ext_ies_container = protocol_ext_container_empty_l;

// SLDRXCycleItem ::= SEQUENCE
struct sldrx_cycle_item_s {
  bool                               ext             = false;
  bool                               ie_exts_present = false;
  fixed_bitstring<24, false, true>   rx_ue_id;
  sldrx_info_c                       sldrx_info;
  sldrx_cycle_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SRBs-FailedToBeSetup-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct srbs_failed_to_be_setup_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { srbs_failed_to_be_setup_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::srbs_failed_to_be_setup_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    srbs_failed_to_be_setup_item_s&       srbs_failed_to_be_setup_item() { return c; }
    const srbs_failed_to_be_setup_item_s& srbs_failed_to_be_setup_item() const { return c; }

  private:
    srbs_failed_to_be_setup_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// SRBs-FailedToBeSetupMod-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct srbs_failed_to_be_setup_mod_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { srbs_failed_to_be_setup_mod_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::srbs_failed_to_be_setup_mod_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    srbs_failed_to_be_setup_mod_item_s&       srbs_failed_to_be_setup_mod_item() { return c; }
    const srbs_failed_to_be_setup_mod_item_s& srbs_failed_to_be_setup_mod_item() const { return c; }

  private:
    srbs_failed_to_be_setup_mod_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// SRBs-Modified-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct srbs_modified_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { srbs_modified_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::srbs_modified_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    srbs_modified_item_s&       srbs_modified_item() { return c; }
    const srbs_modified_item_s& srbs_modified_item() const { return c; }

  private:
    srbs_modified_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// SRBs-Required-ToBeReleased-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct srbs_required_to_be_released_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { srbs_required_to_be_released_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::srbs_required_to_be_released_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    srbs_required_to_be_released_item_s&       srbs_required_to_be_released_item() { return c; }
    const srbs_required_to_be_released_item_s& srbs_required_to_be_released_item() const { return c; }

  private:
    srbs_required_to_be_released_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// SRBs-Setup-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct srbs_setup_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { srbs_setup_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::srbs_setup_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    srbs_setup_item_s&       srbs_setup_item() { return c; }
    const srbs_setup_item_s& srbs_setup_item() const { return c; }

  private:
    srbs_setup_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// SRBs-SetupMod-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct srbs_setup_mod_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { srbs_setup_mod_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::srbs_setup_mod_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    srbs_setup_mod_item_s&       srbs_setup_mod_item() { return c; }
    const srbs_setup_mod_item_s& srbs_setup_mod_item() const { return c; }

  private:
    srbs_setup_mod_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// SRBs-ToBeReleased-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct srbs_to_be_released_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { srbs_to_be_released_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::srbs_to_be_released_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    srbs_to_be_released_item_s&       srbs_to_be_released_item() { return c; }
    const srbs_to_be_released_item_s& srbs_to_be_released_item() const { return c; }

  private:
    srbs_to_be_released_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// SRBs-ToBeSetup-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct srbs_to_be_setup_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { srbs_to_be_setup_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::srbs_to_be_setup_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    srbs_to_be_setup_item_s&       srbs_to_be_setup_item() { return c; }
    const srbs_to_be_setup_item_s& srbs_to_be_setup_item() const { return c; }

  private:
    srbs_to_be_setup_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// SRBs-ToBeSetupMod-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct srbs_to_be_setup_mod_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { srbs_to_be_setup_mod_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::srbs_to_be_setup_mod_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    srbs_to_be_setup_mod_item_s&       srbs_to_be_setup_mod_item() { return c; }
    const srbs_to_be_setup_mod_item_s& srbs_to_be_setup_mod_item() const { return c; }

  private:
    srbs_to_be_setup_mod_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// SRSCarrier-List ::= SEQUENCE (SIZE (1..32)) OF SRSCarrier-List-Item
using srs_carrier_list_l = dyn_array<srs_carrier_list_item_s>;

// SRSType-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
using srs_type_ext_ies_o = protocol_ies_empty_o;

// SemipersistentSRS ::= SEQUENCE
struct semipersistent_srs_s {
  bool                                                   ext                          = false;
  bool                                                   srs_spatial_relation_present = false;
  uint8_t                                                srs_res_set_id               = 0;
  spatial_relation_info_s                                srs_spatial_relation;
  protocol_ext_container_l<semipersistent_srs_ext_ies_o> ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// Served-Cells-To-Add-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct served_cells_to_add_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { served_cells_to_add_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::served_cells_to_add_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    served_cells_to_add_item_s&       served_cells_to_add_item() { return c; }
    const served_cells_to_add_item_s& served_cells_to_add_item() const { return c; }

  private:
    served_cells_to_add_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// Served-Cells-To-Delete-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct served_cells_to_delete_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { served_cells_to_delete_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::served_cells_to_delete_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    served_cells_to_delete_item_s&       served_cells_to_delete_item() { return c; }
    const served_cells_to_delete_item_s& served_cells_to_delete_item() const { return c; }

  private:
    served_cells_to_delete_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// Served-Cells-To-Modify-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct served_cells_to_modify_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { served_cells_to_modify_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::served_cells_to_modify_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    served_cells_to_modify_item_s&       served_cells_to_modify_item() { return c; }
    const served_cells_to_modify_item_s& served_cells_to_modify_item() const { return c; }

  private:
    served_cells_to_modify_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

using serving_cells_list_item_ext_ies_container = protocol_ext_container_empty_l;

// Serving-Cells-List-Item ::= SEQUENCE
struct serving_cells_list_item_s {
  bool                                      iab_mt_cell_na_res_cfg_mode_info_present = false;
  bool                                      ie_exts_present                          = false;
  nr_cgi_s                                  nr_cgi;
  iab_mt_cell_na_res_cfg_mode_info_c        iab_mt_cell_na_res_cfg_mode_info;
  serving_cells_list_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// ServingCellMO-List-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct serving_cell_mo_list_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { serving_cell_mo_list_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::serving_cell_mo_list_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    serving_cell_mo_list_item_s&       serving_cell_mo_list_item() { return c; }
    const serving_cell_mo_list_item_s& serving_cell_mo_list_item() const { return c; }

  private:
    serving_cell_mo_list_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

using serving_cell_mo_encoded_in_cgc_item_ext_ies_container = protocol_ext_container_empty_l;

// ServingCellMO-encoded-in-CGC-Item ::= SEQUENCE
struct serving_cell_mo_encoded_in_cgc_item_s {
  bool                                                  ext             = false;
  bool                                                  ie_exts_present = false;
  uint8_t                                               serving_cell_mo = 1;
  serving_cell_mo_encoded_in_cgc_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SidelinkRelayConfiguration-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using sidelink_relay_cfg_ext_ies_o = protocol_ext_empty_o;

// TNLCapacityIndicator-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using tnl_capacity_ind_ext_ies_o = protocol_ext_empty_o;

struct trp_meas_request_item_ext_ies_container {
  template <class extT_>
  using ie_field_s = protocol_ext_container_item_s<extT_>;

  // member variables
  bool                            nr_cgi_present            = false;
  bool                            ao_a_search_win_present   = false;
  bool                            nof_trp_rx_teg_present    = false;
  bool                            nof_trp_rx_tx_teg_present = false;
  ie_field_s<nr_cgi_s>            nr_cgi;
  ie_field_s<ao_a_assist_info_s>  ao_a_search_win;
  ie_field_s<nof_trp_rx_teg_e>    nof_trp_rx_teg;
  ie_field_s<nof_trp_rx_tx_teg_e> nof_trp_rx_tx_teg;

  // sequence methods
  trp_meas_request_item_ext_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// TRP-MeasurementRequestItem ::= SEQUENCE
struct trp_meas_request_item_s {
  bool                                    search_win_info_present = false;
  bool                                    ie_exts_present         = false;
  uint32_t                                trp_id                  = 0;
  search_win_info_s                       search_win_info;
  trp_meas_request_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

struct trp_meas_upd_item_ext_ies_container {
  template <class extT_>
  using ie_field_s = protocol_ext_container_item_s<extT_>;

  // member variables
  bool                            nof_trp_rx_teg_present    = false;
  bool                            nof_trp_rx_tx_teg_present = false;
  ie_field_s<nof_trp_rx_teg_e>    nof_trp_rx_teg;
  ie_field_s<nof_trp_rx_tx_teg_e> nof_trp_rx_tx_teg;

  // sequence methods
  trp_meas_upd_item_ext_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// TRP-MeasurementUpdateItem ::= SEQUENCE
struct trp_meas_upd_item_s {
  bool                                ext                   = false;
  bool                                ao_a_win_info_present = false;
  bool                                ie_exts_present       = false;
  uint32_t                            trp_id                = 0;
  ao_a_assist_info_s                  ao_a_win_info;
  trp_meas_upd_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using trp_prs_info_list_item_ext_ies_container = protocol_ext_container_empty_l;

// TRP-PRS-Info-List-Item ::= SEQUENCE
struct trp_prs_info_list_item_s {
  bool                                     ext             = false;
  bool                                     cgi_nr_present  = false;
  bool                                     ie_exts_present = false;
  uint32_t                                 trp_id          = 0;
  uint16_t                                 nr_pci          = 0;
  nr_cgi_s                                 cgi_nr;
  prs_cfg_s                                prs_cfg;
  trp_prs_info_list_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// TRPInformationItemTRPResp ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct trp_info_item_trp_resp_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { trp_info_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::trp_info_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    trp_info_item_s&       trp_info_item() { return c; }
    const trp_info_item_s& trp_info_item() const { return c; }

  private:
    trp_info_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// TRPInformationTypeItemTRPReq ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct trp_info_type_item_trp_req_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { trp_info_type_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::trp_info_type_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    trp_info_type_item_e&       trp_info_type_item() { return c; }
    const trp_info_type_item_e& trp_info_type_item() const { return c; }

  private:
    trp_info_type_item_e c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

using trp_list_item_ext_ies_container = protocol_ext_container_empty_l;

// TRPListItem ::= SEQUENCE
struct trp_list_item_s {
  bool                            ie_exts_present = false;
  uint32_t                        trp_id          = 0;
  trp_list_item_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// TimeReferenceInformation-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using time_ref_info_ext_ies_o = protocol_ext_empty_o;

// TraceActivation-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
struct trace_activation_ext_ies_o {
  // Extension ::= OPEN TYPE
  struct ext_c {
    struct types_opts {
      enum options { mdt_cfg, trace_collection_entity_uri, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    ext_c() = default;
    ext_c(const ext_c& other);
    ext_c& operator=(const ext_c& other);
    ~ext_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    mdt_cfg_s&                                                   mdt_cfg();
    visible_string<0, MAX_ASN_STRING_LENGTH, false, true>&       trace_collection_entity_uri();
    const mdt_cfg_s&                                             mdt_cfg() const;
    const visible_string<0, MAX_ASN_STRING_LENGTH, false, true>& trace_collection_entity_uri() const;

  private:
    types                                                                             type_;
    choice_buffer_t<mdt_cfg_s, visible_string<0, MAX_ASN_STRING_LENGTH, false, true>> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static ext_c      get_ext(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// TraceDepth ::= ENUMERATED
struct trace_depth_opts {
  enum options {
    minimum,
    medium,
    max,
    minimum_without_vendor_specific_ext,
    medium_without_vendor_specific_ext,
    max_without_vendor_specific_ext,
    // ...
    nulltype
  } value;

  const char* to_string() const;
};
typedef enumerated<trace_depth_opts, true> trace_depth_e;

// Transport-Layer-Address-Info-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using transport_layer_address_info_ext_ies_o = protocol_ext_empty_o;

// Transport-UP-Layer-Address-Info-To-Add-List ::= SEQUENCE (SIZE (1..16)) OF
// Transport-UP-Layer-Address-Info-To-Add-Item
using transport_up_layer_address_info_to_add_list_l = dyn_array<transport_up_layer_address_info_to_add_item_s>;

// Transport-UP-Layer-Address-Info-To-Remove-List ::= SEQUENCE (SIZE (1..16)) OF
// Transport-UP-Layer-Address-Info-To-Remove-Item
using transport_up_layer_address_info_to_rem_list_l = dyn_array<transport_up_layer_address_info_to_rem_item_s>;

// UAC-Assistance-InfoExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using uac_assist_info_ext_ies_o = protocol_ext_empty_o;

// UACPLMN-List ::= SEQUENCE (SIZE (1..12)) OF UACPLMN-Item
using uac_plmn_list_l = dyn_array<uac_plmn_item_s>;

// UE-MulticastMRBs-ConfirmedToBeModified-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct ue_multicast_m_rbs_confirmed_to_be_modified_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { ue_multicast_m_rbs_confirmed_to_be_modified_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::ue_multicast_m_rbs_confirmed_to_be_modified_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    ue_multicast_m_rbs_confirmed_to_be_modified_item_s& ue_multicast_m_rbs_confirmed_to_be_modified_item() { return c; }
    const ue_multicast_m_rbs_confirmed_to_be_modified_item_s& ue_multicast_m_rbs_confirmed_to_be_modified_item() const
    {
      return c;
    }

  private:
    ue_multicast_m_rbs_confirmed_to_be_modified_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// UE-MulticastMRBs-RequiredToBeModified-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct ue_multicast_m_rbs_required_to_be_modified_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { ue_multicast_m_rbs_required_to_be_modified_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::ue_multicast_m_rbs_required_to_be_modified_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    ue_multicast_m_rbs_required_to_be_modified_item_s& ue_multicast_m_rbs_required_to_be_modified_item() { return c; }
    const ue_multicast_m_rbs_required_to_be_modified_item_s& ue_multicast_m_rbs_required_to_be_modified_item() const
    {
      return c;
    }

  private:
    ue_multicast_m_rbs_required_to_be_modified_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// UE-MulticastMRBs-RequiredToBeReleased-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct ue_multicast_m_rbs_required_to_be_released_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { ue_multicast_m_rbs_required_to_be_released_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::ue_multicast_m_rbs_required_to_be_released_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    ue_multicast_m_rbs_required_to_be_released_item_s& ue_multicast_m_rbs_required_to_be_released_item() { return c; }
    const ue_multicast_m_rbs_required_to_be_released_item_s& ue_multicast_m_rbs_required_to_be_released_item() const
    {
      return c;
    }

  private:
    ue_multicast_m_rbs_required_to_be_released_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// UE-MulticastMRBs-Setup-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct ue_multicast_m_rbs_setup_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { ue_multicast_m_rbs_setup_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::ue_multicast_m_rbs_setup_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    ue_multicast_m_rbs_setup_item_s&       ue_multicast_m_rbs_setup_item() { return c; }
    const ue_multicast_m_rbs_setup_item_s& ue_multicast_m_rbs_setup_item() const { return c; }

  private:
    ue_multicast_m_rbs_setup_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// UE-MulticastMRBs-ToBeReleased-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct ue_multicast_m_rbs_to_be_released_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { ue_multicast_m_rbs_to_be_released_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::ue_multicast_m_rbs_to_be_released_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    ue_multicast_m_rbs_to_be_released_item_s&       ue_multicast_m_rbs_to_be_released_item() { return c; }
    const ue_multicast_m_rbs_to_be_released_item_s& ue_multicast_m_rbs_to_be_released_item() const { return c; }

  private:
    ue_multicast_m_rbs_to_be_released_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// UE-MulticastMRBs-ToBeSetup-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct ue_multicast_m_rbs_to_be_setup_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { ue_multicast_m_rbs_to_be_setup_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::ue_multicast_m_rbs_to_be_setup_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    ue_multicast_m_rbs_to_be_setup_item_s&       ue_multicast_m_rbs_to_be_setup_item() { return c; }
    const ue_multicast_m_rbs_to_be_setup_item_s& ue_multicast_m_rbs_to_be_setup_item() const { return c; }

  private:
    ue_multicast_m_rbs_to_be_setup_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// UE-MulticastMRBs-ToBeSetup-atModify-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct ue_multicast_m_rbs_to_be_setup_at_modify_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { ue_multicast_m_rbs_to_be_setup_at_modify_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::ue_multicast_m_rbs_to_be_setup_at_modify_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    ue_multicast_m_rbs_to_be_setup_at_modify_item_s&       ue_multicast_m_rbs_to_be_setup_at_modify_item() { return c; }
    const ue_multicast_m_rbs_to_be_setup_at_modify_item_s& ue_multicast_m_rbs_to_be_setup_at_modify_item() const
    {
      return c;
    }

  private:
    ue_multicast_m_rbs_to_be_setup_at_modify_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// UE-associatedLogicalF1-ConnectionItemResAck ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct ue_associated_lc_f1_conn_item_res_ack_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { ue_associated_lc_f1_conn_item, nulltype } value;
      typedef uint8_t number_type;

      const char* to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::ue_associated_lc_f1_conn_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    ue_associated_lc_f1_conn_item_s&       ue_associated_lc_f1_conn_item() { return c; }
    const ue_associated_lc_f1_conn_item_s& ue_associated_lc_f1_conn_item() const { return c; }

  private:
    ue_associated_lc_f1_conn_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// UE-associatedLogicalF1-ConnectionListRes ::= SEQUENCE (SIZE (1..65536)) OF
// ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES : IEsSetParam}
using ue_associated_lc_f1_conn_list_res_l =
    dyn_array<protocol_ie_single_container_s<ue_associated_lc_f1_conn_item_res_o>>;

// UEIdentity-List-For-Paging-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct ue_id_list_for_paging_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { ue_id_list_for_paging_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::ue_id_list_for_paging_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    ue_id_list_for_paging_item_s&       ue_id_list_for_paging_item() { return c; }
    const ue_id_list_for_paging_item_s& ue_id_list_for_paging_item() const { return c; }

  private:
    ue_id_list_for_paging_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// UEPagingCapability-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
struct ue_paging_cap_ext_ies_o {
  // Extension ::= OPEN TYPE
  struct ext_c {
    struct types_opts {
      enum options { red_cap_ind, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::red_cap_ind; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    red_cap_ind_e&       red_cap_ind() { return c; }
    const red_cap_ind_e& red_cap_ind() const { return c; }

  private:
    red_cap_ind_e c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static ext_c      get_ext(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// UEReportingInformation-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using ue_report_info_ext_ies_o = protocol_ext_empty_o;

// UL-BH-Non-UP-Traffic-Mapping-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
using ul_bh_non_up_traffic_map_ext_ies_o = protocol_ext_empty_o;

// UL-BH-Non-UP-Traffic-Mapping-List ::= SEQUENCE (SIZE (1..32)) OF UL-BH-Non-UP-Traffic-Mapping-Item
using ul_bh_non_up_traffic_map_list_l = dyn_array<ul_bh_non_up_traffic_map_item_s>;

// UL-UP-TNL-Address-to-Update-List-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct ul_up_tnl_address_to_upd_list_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { ul_up_tnl_address_to_upd_list_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::ul_up_tnl_address_to_upd_list_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    ul_up_tnl_address_to_upd_list_item_s&       ul_up_tnl_address_to_upd_list_item() { return c; }
    const ul_up_tnl_address_to_upd_list_item_s& ul_up_tnl_address_to_upd_list_item() const { return c; }

  private:
    ul_up_tnl_address_to_upd_list_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// UL-UP-TNL-Information-to-Update-List-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct ul_up_tnl_info_to_upd_list_item_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { ul_up_tnl_info_to_upd_list_item, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::ul_up_tnl_info_to_upd_list_item; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    ul_up_tnl_info_to_upd_list_item_s&       ul_up_tnl_info_to_upd_list_item() { return c; }
    const ul_up_tnl_info_to_upd_list_item_s& ul_up_tnl_info_to_upd_list_item() const { return c; }

  private:
    ul_up_tnl_info_to_upd_list_item_s c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

using uu_rlc_ch_failed_to_be_modified_item_ext_ies_container = protocol_ext_container_empty_l;

// UuRLCChannelFailedToBeModifiedItem ::= SEQUENCE
struct uu_rlc_ch_failed_to_be_modified_item_s {
  bool                                                   ext             = false;
  bool                                                   cause_present   = false;
  bool                                                   ie_exts_present = false;
  fixed_bitstring<16, false, true>                       uu_rlc_ch_id;
  cause_c                                                cause;
  uu_rlc_ch_failed_to_be_modified_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using uu_rlc_ch_failed_to_be_setup_item_ext_ies_container = protocol_ext_container_empty_l;

// UuRLCChannelFailedToBeSetupItem ::= SEQUENCE
struct uu_rlc_ch_failed_to_be_setup_item_s {
  bool                                                ext             = false;
  bool                                                cause_present   = false;
  bool                                                ie_exts_present = false;
  fixed_bitstring<16, false, true>                    uu_rlc_ch_id;
  cause_c                                             cause;
  uu_rlc_ch_failed_to_be_setup_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using uu_rlc_ch_modified_item_ext_ies_container = protocol_ext_container_empty_l;

// UuRLCChannelModifiedItem ::= SEQUENCE
struct uu_rlc_ch_modified_item_s {
  bool                                      ext             = false;
  bool                                      ie_exts_present = false;
  fixed_bitstring<16, false, true>          uu_rlc_ch_id;
  uu_rlc_ch_modified_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using uu_rlc_ch_required_to_be_modified_item_ext_ies_container = protocol_ext_container_empty_l;

// UuRLCChannelRequiredToBeModifiedItem ::= SEQUENCE
struct uu_rlc_ch_required_to_be_modified_item_s {
  bool                                                     ext             = false;
  bool                                                     ie_exts_present = false;
  fixed_bitstring<16, false, true>                         uu_rlc_ch_id;
  uu_rlc_ch_required_to_be_modified_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using uu_rlc_ch_required_to_be_released_item_ext_ies_container = protocol_ext_container_empty_l;

// UuRLCChannelRequiredToBeReleasedItem ::= SEQUENCE
struct uu_rlc_ch_required_to_be_released_item_s {
  bool                                                     ext             = false;
  bool                                                     ie_exts_present = false;
  fixed_bitstring<16, false, true>                         uu_rlc_ch_id;
  uu_rlc_ch_required_to_be_released_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using uu_rlc_ch_setup_item_ext_ies_container = protocol_ext_container_empty_l;

// UuRLCChannelSetupItem ::= SEQUENCE
struct uu_rlc_ch_setup_item_s {
  bool                                   ext             = false;
  bool                                   ie_exts_present = false;
  fixed_bitstring<16, false, true>       uu_rlc_ch_id;
  uu_rlc_ch_setup_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using uu_rlc_ch_to_be_modified_item_ext_ies_container = protocol_ext_container_empty_l;

// UuRLCChannelToBeModifiedItem ::= SEQUENCE
struct uu_rlc_ch_to_be_modified_item_s {
  bool                                            ext                        = false;
  bool                                            uu_rlc_ch_qos_info_present = false;
  bool                                            rlc_mode_present           = false;
  bool                                            ie_exts_present            = false;
  fixed_bitstring<16, false, true>                uu_rlc_ch_id;
  uu_rlc_ch_qos_info_c                            uu_rlc_ch_qos_info;
  rlc_mode_e                                      rlc_mode;
  uu_rlc_ch_to_be_modified_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using uu_rlc_ch_to_be_released_item_ext_ies_container = protocol_ext_container_empty_l;

// UuRLCChannelToBeReleasedItem ::= SEQUENCE
struct uu_rlc_ch_to_be_released_item_s {
  bool                                            ext             = false;
  bool                                            ie_exts_present = false;
  fixed_bitstring<16, false, true>                uu_rlc_ch_id;
  uu_rlc_ch_to_be_released_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using uu_rlc_ch_to_be_setup_item_ext_ies_container = protocol_ext_container_empty_l;

// UuRLCChannelToBeSetupItem ::= SEQUENCE
struct uu_rlc_ch_to_be_setup_item_s {
  bool                                         ext             = false;
  bool                                         ie_exts_present = false;
  fixed_bitstring<16, false, true>             uu_rlc_ch_id;
  uu_rlc_ch_qos_info_c                         uu_rlc_ch_qos_info;
  rlc_mode_e                                   rlc_mode;
  uu_rlc_ch_to_be_setup_item_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// VehicleUE ::= ENUMERATED
struct vehicle_ue_opts {
  enum options { authorized, not_authorized, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<vehicle_ue_opts, true> vehicle_ue_e;

// ActivationRequestType ::= ENUMERATED
struct activation_request_type_opts {
  enum options { activ, deactiv, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<activation_request_type_opts, true> activation_request_type_e;

// CG-SDTKeptIndicator ::= ENUMERATED
struct cg_sdt_kept_ind_opts {
  enum options { true_value, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<cg_sdt_kept_ind_opts, true> cg_sdt_kept_ind_e;

// CG-SDTQueryIndication ::= ENUMERATED
struct cg_sdt_query_ind_opts {
  enum options { true_value, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<cg_sdt_query_ind_opts, true> cg_sdt_query_ind_e;

// Cancel-all-Warning-Messages-Indicator ::= ENUMERATED
struct cancel_all_warning_msgs_ind_opts {
  enum options { true_value, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<cancel_all_warning_msgs_ind_opts, true> cancel_all_warning_msgs_ind_e;

// DAPS-HO-Status ::= ENUMERATED
struct daps_ho_status_opts {
  enum options { initiation, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<daps_ho_status_opts, true> daps_ho_status_e;

// DRXConfigurationIndicator ::= ENUMERATED
struct drx_cfg_ind_opts {
  enum options { release, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<drx_cfg_ind_opts, true> drx_cfg_ind_e;

using f1_c_transfer_path_ext_ies_container = protocol_ext_container_empty_l;

// F1CTransferPath ::= SEQUENCE
struct f1_c_transfer_path_s {
  bool                                 ext             = false;
  bool                                 ie_exts_present = false;
  f1_cp_ath_nsa_e                      f1_cp_ath_nsa;
  f1_c_transfer_path_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using f1_c_transfer_path_nr_dc_ext_ies_container = protocol_ext_container_empty_l;

// F1CTransferPathNRDC ::= SEQUENCE
struct f1_c_transfer_path_nr_dc_s {
  bool                                       ext             = false;
  bool                                       ie_exts_present = false;
  f1_cp_ath_nr_dc_e                          f1_cp_ath_nr_dc;
  f1_c_transfer_path_nr_dc_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using five_g_pro_se_authorized_ext_ies_container = protocol_ext_container_empty_l;

// FiveG-ProSeAuthorized ::= SEQUENCE
struct five_g_pro_se_authorized_s {
  bool                                       ext                                              = false;
  bool                                       five_g_pro_se_direct_discovery_present           = false;
  bool                                       five_g_pro_se_direct_communication_present       = false;
  bool                                       five_g_pro_se_layer2_ue_to_network_relay_present = false;
  bool                                       five_g_pro_se_layer3_ue_to_network_relay_present = false;
  bool                                       five_g_pro_se_layer2_remote_ue_present           = false;
  bool                                       ie_exts_present                                  = false;
  five_g_pro_se_direct_discovery_e           five_g_pro_se_direct_discovery;
  five_g_pro_se_direct_communication_e       five_g_pro_se_direct_communication;
  five_g_pro_se_layer2_ue_to_network_relay_e five_g_pro_se_layer2_ue_to_network_relay;
  five_g_pro_se_layer3_ue_to_network_relay_e five_g_pro_se_layer3_ue_to_network_relay;
  five_g_pro_se_layer2_remote_ue_e           five_g_pro_se_layer2_remote_ue;
  five_g_pro_se_authorized_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// FullConfiguration ::= ENUMERATED
struct full_cfg_opts {
  enum options { full, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<full_cfg_opts, true> full_cfg_e;

// GNB-CU-TNL-Association-Failed-To-Setup-List ::= SEQUENCE (SIZE (1..32)) OF
// ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES : IEsSetParam}
using gnb_cu_tnl_assoc_failed_to_setup_list_l =
    bounded_array<protocol_ie_single_container_s<gnb_cu_tnl_assoc_failed_to_setup_item_ies_o>, 32>;

// GNB-CU-TNL-Association-Setup-List ::= SEQUENCE (SIZE (1..32)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES :
// IEsSetParam}
using gnb_cu_tnl_assoc_setup_list_l =
    bounded_array<protocol_ie_single_container_s<gnb_cu_tnl_assoc_setup_item_ies_o>, 32>;

// GNB-CU-TNL-Association-To-Add-List ::= SEQUENCE (SIZE (1..32)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES :
// IEsSetParam}
using gnb_cu_tnl_assoc_to_add_list_l =
    bounded_array<protocol_ie_single_container_s<gnb_cu_tnl_assoc_to_add_item_ies_o>, 32>;

// GNB-CU-TNL-Association-To-Remove-List ::= SEQUENCE (SIZE (1..32)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES :
// IEsSetParam}
using gnb_cu_tnl_assoc_to_rem_list_l =
    bounded_array<protocol_ie_single_container_s<gnb_cu_tnl_assoc_to_rem_item_ies_o>, 32>;

// GNB-CU-TNL-Association-To-Update-List ::= SEQUENCE (SIZE (1..32)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES :
// IEsSetParam}
using gnb_cu_tnl_assoc_to_upd_list_l =
    bounded_array<protocol_ie_single_container_s<gnb_cu_tnl_assoc_to_upd_item_ies_o>, 32>;

// GNB-DU-Served-Cells-List ::= SEQUENCE (SIZE (1..512)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES : IEsSetParam}
using gnb_du_served_cells_list_l = dyn_array<protocol_ie_single_container_s<gnb_du_served_cells_item_ies_o>>;

// GNB-DU-TNL-Association-To-Remove-List ::= SEQUENCE (SIZE (1..32)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES :
// IEsSetParam}
using gnb_du_tnl_assoc_to_rem_list_l =
    bounded_array<protocol_ie_single_container_s<gnb_du_tnl_assoc_to_rem_item_ies_o>, 32>;

// GNB-DUConfigurationQuery ::= ENUMERATED
struct gnb_du_cfg_query_opts {
  enum options { true_value, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<gnb_du_cfg_query_opts, true> gnb_du_cfg_query_e;

// GNBDUOverloadInformation ::= ENUMERATED
struct gnb_du_overload_info_opts {
  enum options { overloaded, not_overloaded, nulltype } value;

  const char* to_string() const;
};
typedef enumerated<gnb_du_overload_info_opts> gnb_du_overload_info_e;

// GNBDUUESliceMaximumBitRateList ::= SEQUENCE (SIZE (1..8)) OF GNBDUUESliceMaximumBitRateItem
using gnb_du_ue_slice_max_bit_rate_list_l = dyn_array<gnb_du_ue_slice_max_bit_rate_item_s>;

using hardware_load_ind_ext_ies_container = protocol_ext_container_empty_l;

// HardwareLoadIndicator ::= SEQUENCE
struct hardware_load_ind_s {
  bool                                ext                  = false;
  bool                                ie_exts_present      = false;
  uint8_t                             dl_hardware_load_ind = 0;
  uint8_t                             ul_hardware_load_ind = 0;
  hardware_load_ind_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// IAB-Allocated-TNL-Address-List ::= SEQUENCE (SIZE (1..1024)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES :
// IEsSetParam}
using iab_allocated_tnl_address_list_l =
    dyn_array<protocol_ie_single_container_s<iab_allocated_tnl_address_list_item_ies_o>>;

using iab_tnl_addresses_exception_ext_ies_container = protocol_ext_container_empty_l;

// IAB-TNL-Addresses-Exception ::= SEQUENCE
struct iab_tnl_addresses_exception_s {
  bool                                          ie_exts_present = false;
  iab_tnl_address_list_l                        iab_tnl_address_list;
  iab_tnl_addresses_exception_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// IAB-TNL-Addresses-To-Remove-List ::= SEQUENCE (SIZE (1..1024)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES :
// IEsSetParam}
using iab_tnl_addresses_to_rem_list_l = dyn_array<protocol_ie_single_container_s<iab_tnl_addresses_to_rem_item_ies_o>>;

// IABConditionalRRCMessageDeliveryIndication ::= ENUMERATED
struct iab_conditional_rrc_msg_delivery_ind_opts {
  enum options { true_value, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<iab_conditional_rrc_msg_delivery_ind_opts, true> iab_conditional_rrc_msg_delivery_ind_e;

using iab_congestion_ind_list_ext_ies_container = protocol_ext_container_empty_l;

// IABCongestionIndication ::= SEQUENCE
struct iab_congestion_ind_s {
  bool                                      ie_exts_present = false;
  iab_congestion_ind_list_l                 iab_congestion_ind_list;
  iab_congestion_ind_list_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// IABIPv6RequestType ::= CHOICE
struct iab_ip_v6_request_type_c {
  struct types_opts {
    enum options { ip_v6_address, ip_v6_prefix, choice_ext, nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  iab_ip_v6_request_type_c() = default;
  iab_ip_v6_request_type_c(const iab_ip_v6_request_type_c& other);
  iab_ip_v6_request_type_c& operator=(const iab_ip_v6_request_type_c& other);
  ~iab_ip_v6_request_type_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  iab_tnl_addresses_requested_s& ip_v6_address()
  {
    assert_choice_type(types::ip_v6_address, type_, "IABIPv6RequestType");
    return c.get<iab_tnl_addresses_requested_s>();
  }
  iab_tnl_addresses_requested_s& ip_v6_prefix()
  {
    assert_choice_type(types::ip_v6_prefix, type_, "IABIPv6RequestType");
    return c.get<iab_tnl_addresses_requested_s>();
  }
  protocol_ie_single_container_s<iab_ip_v6_request_type_ext_ies_o>& choice_ext()
  {
    assert_choice_type(types::choice_ext, type_, "IABIPv6RequestType");
    return c.get<protocol_ie_single_container_s<iab_ip_v6_request_type_ext_ies_o>>();
  }
  const iab_tnl_addresses_requested_s& ip_v6_address() const
  {
    assert_choice_type(types::ip_v6_address, type_, "IABIPv6RequestType");
    return c.get<iab_tnl_addresses_requested_s>();
  }
  const iab_tnl_addresses_requested_s& ip_v6_prefix() const
  {
    assert_choice_type(types::ip_v6_prefix, type_, "IABIPv6RequestType");
    return c.get<iab_tnl_addresses_requested_s>();
  }
  const protocol_ie_single_container_s<iab_ip_v6_request_type_ext_ies_o>& choice_ext() const
  {
    assert_choice_type(types::choice_ext, type_, "IABIPv6RequestType");
    return c.get<protocol_ie_single_container_s<iab_ip_v6_request_type_ext_ies_o>>();
  }
  iab_tnl_addresses_requested_s&                                    set_ip_v6_address();
  iab_tnl_addresses_requested_s&                                    set_ip_v6_prefix();
  protocol_ie_single_container_s<iab_ip_v6_request_type_ext_ies_o>& set_choice_ext();

private:
  types type_;
  choice_buffer_t<iab_tnl_addresses_requested_s, protocol_ie_single_container_s<iab_ip_v6_request_type_ext_ies_o>> c;

  void destroy_();
};

using ia_bv4_addresses_requested_ext_ies_container = protocol_ext_container_empty_l;

// IABv4AddressesRequested ::= SEQUENCE
struct ia_bv4_addresses_requested_s {
  bool                                         ie_exts_present = false;
  iab_tnl_addresses_requested_s                ia_bv4_addresses_requested;
  ia_bv4_addresses_requested_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// IgnoreResourceCoordinationContainer ::= ENUMERATED
struct ignore_res_coordination_container_opts {
  enum options { yes, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<ignore_res_coordination_container_opts, true> ignore_res_coordination_container_e;

// InactivityMonitoringRequest ::= ENUMERATED
struct inactivity_monitoring_request_opts {
  enum options { true_value, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<inactivity_monitoring_request_opts, true> inactivity_monitoring_request_e;

// InactivityMonitoringResponse ::= ENUMERATED
struct inactivity_monitoring_resp_opts {
  enum options { not_supported, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<inactivity_monitoring_resp_opts, true> inactivity_monitoring_resp_e;

using lte_ue_sidelink_aggr_max_bitrate_ext_ies_container = protocol_ext_container_empty_l;

// LTEUESidelinkAggregateMaximumBitrate ::= SEQUENCE
struct lte_ue_sidelink_aggr_max_bitrate_s {
  bool                                               ie_exts_present                  = false;
  uint64_t                                           ue_lte_sidelink_aggr_max_bitrate = 0;
  lte_ue_sidelink_aggr_max_bitrate_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using ltev2x_services_authorized_ext_ies_container = protocol_ext_container_empty_l;

// LTEV2XServicesAuthorized ::= SEQUENCE
struct ltev2x_services_authorized_s {
  bool                                         vehicle_ue_present    = false;
  bool                                         pedestrian_ue_present = false;
  bool                                         ie_exts_present       = false;
  vehicle_ue_e                                 vehicle_ue;
  pedestrian_ue_e                              pedestrian_ue;
  ltev2x_services_authorized_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// LowerLayerPresenceStatusChange ::= ENUMERATED
struct lower_layer_presence_status_change_opts {
  enum options { suspend_lower_layers, resume_lower_layers, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<lower_layer_presence_status_change_opts, true> lower_layer_presence_status_change_e;

using mbs_multicast_f1_u_context_descriptor_ext_ies_container = protocol_ext_container_empty_l;

// MBSMulticastF1UContextDescriptor ::= SEQUENCE
struct mbs_multicast_f1_u_context_descriptor_s {
  struct mc_f1_u_ctxtusage_opts {
    enum options { ptm, ptp, ptp_retx, ptp_forwarding, /*...*/ nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<mc_f1_u_ctxtusage_opts, true> mc_f1_u_ctxtusage_e_;

  // member variables
  bool                                                    ext                      = false;
  bool                                                    mbs_area_session_present = false;
  bool                                                    ie_exts_present          = false;
  fixed_octstring<4, true>                                multicast_f1_u_context_ref_f1;
  mc_f1_u_ctxtusage_e_                                    mc_f1_u_ctxtusage;
  uint32_t                                                mbs_area_session = 0;
  mbs_multicast_f1_u_context_descriptor_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MC-PagingCell-list ::= SEQUENCE (SIZE (1..512)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES : IEsSetParam}
using mc_paging_cell_list_l = dyn_array<protocol_ie_single_container_s<mc_paging_cell_item_ies_o>>;

// MDTPLMNList ::= SEQUENCE (SIZE (1..16)) OF OCTET STRING (SIZE (3))
using mdt_plmn_list_l = bounded_array<fixed_octstring<3, true>, 16>;

// MDTPLMNModificationList ::= SEQUENCE (SIZE (0..16)) OF OCTET STRING (SIZE (3))
using mdt_plmn_mod_list_l = bounded_array<fixed_octstring<3, true>, 16>;

// MDTPollutedMeasurementIndicator ::= ENUMERATED
struct mdt_polluted_meas_ind_opts {
  enum options { id_c, no_id_c, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<mdt_polluted_meas_ind_opts, true> mdt_polluted_meas_ind_e;

// MeasurementBeamInfoRequest ::= ENUMERATED
struct meas_beam_info_request_opts {
  enum options { true_value, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<meas_beam_info_request_opts, true> meas_beam_info_request_e;

// MeasurementPeriodicityExtended ::= ENUMERATED
struct meas_periodicity_extended_opts {
  enum options {
    ms160,
    ms320,
    ms1280,
    ms2560,
    ms61440,
    ms81920,
    ms368640,
    ms737280,
    ms1843200,
    /*...*/ nulltype
  } value;
  typedef uint32_t number_type;

  const char* to_string() const;
  uint32_t    to_number() const;
};
typedef enumerated<meas_periodicity_extended_opts, true> meas_periodicity_extended_e;

// MeasurementTimeOccasion ::= ENUMERATED
struct meas_time_occasion_opts {
  enum options { o1, o4, /*...*/ nulltype } value;
  typedef uint8_t number_type;

  const char* to_string() const;
  uint8_t     to_number() const;
};
typedef enumerated<meas_time_occasion_opts, true> meas_time_occasion_e;

// MulticastF1UContext-FailedToBeSetup-List ::= SEQUENCE (SIZE (1..32)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES
// : IEsSetParam}
using multicast_f1_u_context_failed_to_be_setup_list_l =
    bounded_array<protocol_ie_single_container_s<multicast_f1_u_context_failed_to_be_setup_item_ies_o>, 32>;

// MulticastF1UContext-Setup-List ::= SEQUENCE (SIZE (1..32)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES :
// IEsSetParam}
using multicast_f1_u_context_setup_list_l =
    bounded_array<protocol_ie_single_container_s<multicast_f1_u_context_setup_item_ies_o>, 32>;

// MulticastF1UContext-ToBeSetup-List ::= SEQUENCE (SIZE (1..32)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES :
// IEsSetParam}
using multicast_f1_u_context_to_be_setup_list_l =
    bounded_array<protocol_ie_single_container_s<multicast_f1_u_context_to_be_setup_item_ies_o>, 32>;

// MulticastMBSSessionList ::= SEQUENCE (SIZE (1..256)) OF MulticastMBSSessionList-Item
using multicast_mbs_session_list_l = dyn_array<multicast_mbs_session_list_item_s>;

// MulticastMRBs-FailedToBeModified-List ::= SEQUENCE (SIZE (1..32)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES :
// IEsSetParam}
using multicast_m_rbs_failed_to_be_modified_list_l =
    bounded_array<protocol_ie_single_container_s<multicast_m_rbs_failed_to_be_modified_item_ies_o>, 32>;

// MulticastMRBs-FailedToBeSetup-List ::= SEQUENCE (SIZE (1..32)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES :
// IEsSetParam}
using multicast_m_rbs_failed_to_be_setup_list_l =
    bounded_array<protocol_ie_single_container_s<multicast_m_rbs_failed_to_be_setup_item_ies_o>, 32>;

// MulticastMRBs-FailedToBeSetupMod-List ::= SEQUENCE (SIZE (1..32)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES :
// IEsSetParam}
using multicast_m_rbs_failed_to_be_setup_mod_list_l =
    bounded_array<protocol_ie_single_container_s<multicast_m_rbs_failed_to_be_setup_mod_item_ies_o>, 32>;

// MulticastMRBs-Modified-List ::= SEQUENCE (SIZE (1..32)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES :
// IEsSetParam}
using multicast_m_rbs_modified_list_l =
    bounded_array<protocol_ie_single_container_s<multicast_m_rbs_modified_item_ies_o>, 32>;

// MulticastMRBs-Setup-List ::= SEQUENCE (SIZE (1..32)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES : IEsSetParam}
using multicast_m_rbs_setup_list_l =
    bounded_array<protocol_ie_single_container_s<multicast_m_rbs_setup_item_ies_o>, 32>;

// MulticastMRBs-SetupMod-List ::= SEQUENCE (SIZE (1..32)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES :
// IEsSetParam}
using multicast_m_rbs_setup_mod_list_l =
    bounded_array<protocol_ie_single_container_s<multicast_m_rbs_setup_mod_item_ies_o>, 32>;

// MulticastMRBs-ToBeModified-List ::= SEQUENCE (SIZE (1..32)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES :
// IEsSetParam}
using multicast_m_rbs_to_be_modified_list_l =
    bounded_array<protocol_ie_single_container_s<multicast_m_rbs_to_be_modified_item_ies_o>, 32>;

// MulticastMRBs-ToBeReleased-List ::= SEQUENCE (SIZE (1..32)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES :
// IEsSetParam}
using multicast_m_rbs_to_be_released_list_l =
    bounded_array<protocol_ie_single_container_s<multicast_m_rbs_to_be_released_item_ies_o>, 32>;

// MulticastMRBs-ToBeSetup-List ::= SEQUENCE (SIZE (1..32)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES :
// IEsSetParam}
using multicast_m_rbs_to_be_setup_list_l =
    bounded_array<protocol_ie_single_container_s<multicast_m_rbs_to_be_setup_item_ies_o>, 32>;

// MulticastMRBs-ToBeSetupMod-List ::= SEQUENCE (SIZE (1..32)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES :
// IEsSetParam}
using multicast_m_rbs_to_be_setup_mod_list_l =
    bounded_array<protocol_ie_single_container_s<multicast_m_rbs_to_be_setup_mod_item_ies_o>, 32>;

// NR-CGI-List-For-Restart-List ::= SEQUENCE (SIZE (1..512)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES :
// IEsSetParam}
using nr_cgi_list_for_restart_list_l =
    dyn_array<protocol_ie_single_container_s<nr_cgi_list_for_restart_list_item_ies_o>>;

using nr_paginge_drx_info_ext_ies_container = protocol_ext_container_empty_l;

// NRPagingeDRXInformation ::= SEQUENCE
struct nr_paginge_drx_info_s {
  bool                                  ext                       = false;
  bool                                  nrpaging_time_win_present = false;
  bool                                  ie_exts_present           = false;
  nr_paging_e_drx_cycle_idle_e          nrpaging_e_drx_cycle_idle;
  nr_paging_time_win_e                  nrpaging_time_win;
  nr_paginge_drx_info_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using nr_paginge_drx_infofor_rrc_inactive_ext_ies_container = protocol_ext_container_empty_l;

// NRPagingeDRXInformationforRRCINACTIVE ::= SEQUENCE
struct nr_paginge_drx_infofor_rrc_inactive_s {
  bool                                                  ext             = false;
  bool                                                  ie_exts_present = false;
  nr_paging_e_drx_cycle_inactive_e                      nrpaging_e_drx_cycle_inactive;
  nr_paginge_drx_infofor_rrc_inactive_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// NRRedCapUEIndication ::= ENUMERATED
struct nr_red_cap_ue_ind_opts {
  enum options { true_value, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<nr_red_cap_ue_ind_opts, true> nr_red_cap_ue_ind_e;

using nr_ue_sidelink_aggr_max_bitrate_ext_ies_container = protocol_ext_container_empty_l;

// NRUESidelinkAggregateMaximumBitrate ::= SEQUENCE
struct nr_ue_sidelink_aggr_max_bitrate_s {
  bool                                              ie_exts_present                 = false;
  uint64_t                                          ue_nr_sidelink_aggr_max_bitrate = 0;
  nr_ue_sidelink_aggr_max_bitrate_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using nr_v2x_services_authorized_ext_ies_container = protocol_ext_container_empty_l;

// NRV2XServicesAuthorized ::= SEQUENCE
struct nr_v2x_services_authorized_s {
  bool                                         vehicle_ue_present    = false;
  bool                                         pedestrian_ue_present = false;
  bool                                         ie_exts_present       = false;
  vehicle_ue_e                                 vehicle_ue;
  pedestrian_ue_e                              pedestrian_ue;
  nr_v2x_services_authorized_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// NeedforGap ::= ENUMERATED
struct needfor_gap_opts {
  enum options { true_value, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<needfor_gap_opts, true> needfor_gap_e;

// Neighbour-Cell-Information-List ::= SEQUENCE (SIZE (1..512)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES :
// IEsSetParam}
using neighbour_cell_info_list_l = dyn_array<protocol_ie_single_container_s<neighbour_cell_info_item_ies_o>>;

// Neighbour-Node-Cells-List ::= SEQUENCE (SIZE (1..1024)) OF Neighbour-Node-Cells-List-Item
using neighbour_node_cells_list_l = dyn_array<neighbour_node_cells_list_item_s>;

// PC5RLCChannelFailedToBeModifiedList ::= SEQUENCE (SIZE (1..512)) OF PC5RLCChannelFailedToBeModifiedItem
using pc5_rlc_ch_failed_to_be_modified_list_l = dyn_array<pc5_rlc_ch_failed_to_be_modified_item_s>;

// PC5RLCChannelFailedToBeSetupList ::= SEQUENCE (SIZE (1..512)) OF PC5RLCChannelFailedToBeSetupItem
using pc5_rlc_ch_failed_to_be_setup_list_l = dyn_array<pc5_rlc_ch_failed_to_be_setup_item_s>;

// PC5RLCChannelModifiedList ::= SEQUENCE (SIZE (1..512)) OF PC5RLCChannelModifiedItem
using pc5_rlc_ch_modified_list_l = dyn_array<pc5_rlc_ch_modified_item_s>;

// PC5RLCChannelRequiredToBeModifiedList ::= SEQUENCE (SIZE (1..512)) OF PC5RLCChannelRequiredToBeModifiedItem
using pc5_rlc_ch_required_to_be_modified_list_l = dyn_array<pc5_rlc_ch_required_to_be_modified_item_s>;

// PC5RLCChannelRequiredToBeReleasedList ::= SEQUENCE (SIZE (1..512)) OF PC5RLCChannelRequiredToBeReleasedItem
using pc5_rlc_ch_required_to_be_released_list_l = dyn_array<pc5_rlc_ch_required_to_be_released_item_s>;

// PC5RLCChannelSetupList ::= SEQUENCE (SIZE (1..512)) OF PC5RLCChannelSetupItem
using pc5_rlc_ch_setup_list_l = dyn_array<pc5_rlc_ch_setup_item_s>;

// PC5RLCChannelToBeModifiedList ::= SEQUENCE (SIZE (1..512)) OF PC5RLCChannelToBeModifiedItem
using pc5_rlc_ch_to_be_modified_list_l = dyn_array<pc5_rlc_ch_to_be_modified_item_s>;

// PC5RLCChannelToBeReleasedList ::= SEQUENCE (SIZE (1..512)) OF PC5RLCChannelToBeReleasedItem
using pc5_rlc_ch_to_be_released_list_l = dyn_array<pc5_rlc_ch_to_be_released_item_s>;

// PC5RLCChannelToBeSetupList ::= SEQUENCE (SIZE (1..512)) OF PC5RLCChannelToBeSetupItem
using pc5_rlc_ch_to_be_setup_list_l = dyn_array<pc5_rlc_ch_to_be_setup_item_s>;

// PDCMeasurementPeriodicity ::= ENUMERATED
struct pdc_meas_periodicity_opts {
  enum options {
    ms80,
    ms120,
    ms160,
    ms240,
    ms320,
    ms480,
    ms640,
    ms1024,
    ms1280,
    ms2048,
    ms2560,
    ms5120,
    /*...*/ nulltype
  } value;
  typedef uint16_t number_type;

  const char* to_string() const;
  uint16_t    to_number() const;
};
typedef enumerated<pdc_meas_periodicity_opts, true> pdc_meas_periodicity_e;

// PDCMeasurementQuantities ::= SEQUENCE (SIZE (1..16)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES : IEsSetParam}
using pdc_meas_quantities_l = bounded_array<protocol_ie_single_container_s<pdc_meas_quantities_item_ies_o>, 16>;

using pdc_meas_result_ext_ies_container = protocol_ext_container_empty_l;

// PDCMeasurementResult ::= SEQUENCE
struct pdc_meas_result_s {
  bool                              ie_exts_present = false;
  pdc_measured_results_list_l       pdc_measured_results_list;
  pdc_meas_result_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PDCReportType ::= ENUMERATED
struct pdc_report_type_opts {
  enum options { on_demand, periodic, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<pdc_report_type_opts, true> pdc_report_type_e;

using pe_ip_s_assist_info_ext_ies_container = protocol_ext_container_empty_l;

// PEIPSAssistanceInfo ::= SEQUENCE
struct pe_ip_s_assist_info_s {
  bool                                  ie_exts_present = false;
  uint8_t                               cn_subgroup_id  = 0;
  pe_ip_s_assist_info_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PRS-Measurement-Info-List ::= SEQUENCE (SIZE (1..4)) OF PRS-Measurement-Info-List-Item
using prs_meas_info_list_l = dyn_array<prs_meas_info_list_item_s>;

// PRSConfigRequestType ::= ENUMERATED
struct prs_cfg_request_type_opts {
  enum options { cfgure, off, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<prs_cfg_request_type_opts, true> prs_cfg_request_type_e;

// PRSTRPList ::= SEQUENCE (SIZE (1..65535)) OF PRSTRPItem
using prstrp_list_l = dyn_array<prstrp_item_s>;

// PRSTransmissionTRPList ::= SEQUENCE (SIZE (1..65535)) OF PRSTransmissionTRPItem
using prs_tx_trp_list_l = dyn_array<prs_tx_trp_item_s>;

// PWS-Failed-NR-CGI-List ::= SEQUENCE (SIZE (1..512)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES : IEsSetParam}
using pws_failed_nr_cgi_list_l = dyn_array<protocol_ie_single_container_s<pws_failed_nr_cgi_list_item_ies_o>>;

struct pws_sys_info_ext_ies_container {
  template <class extT_>
  using ie_field_s = protocol_ext_container_item_s<extT_>;

  // member variables
  bool                                                         notif_info_present       = false;
  bool                                                         add_sib_msg_list_present = false;
  ie_field_s<notif_info_s>                                     notif_info;
  ie_field_s<dyn_seq_of<add_sib_msg_list_item_s, 1, 63, true>> add_sib_msg_list;

  // sequence methods
  pws_sys_info_ext_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PWSSystemInformation ::= SEQUENCE
struct pws_sys_info_s {
  bool                           ext             = false;
  bool                           ie_exts_present = false;
  uint8_t                        sib_type        = 6;
  unbounded_octstring<true>      sib_msg;
  pws_sys_info_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PagingCause ::= ENUMERATED
struct paging_cause_opts {
  enum options { voice, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<paging_cause_opts, true> paging_cause_e;

// PagingCell-list ::= SEQUENCE (SIZE (1..512)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES : IEsSetParam}
using paging_cell_list_l = dyn_array<protocol_ie_single_container_s<paging_cell_item_ies_o>>;

// PagingIdentity ::= CHOICE
struct paging_id_c {
  struct types_opts {
    enum options { ran_ue_paging_id, cn_ue_paging_id, choice_ext, nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  paging_id_c() = default;
  paging_id_c(const paging_id_c& other);
  paging_id_c& operator=(const paging_id_c& other);
  ~paging_id_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  ran_ue_paging_id_s& ran_ue_paging_id()
  {
    assert_choice_type(types::ran_ue_paging_id, type_, "PagingIdentity");
    return c.get<ran_ue_paging_id_s>();
  }
  cn_ue_paging_id_c& cn_ue_paging_id()
  {
    assert_choice_type(types::cn_ue_paging_id, type_, "PagingIdentity");
    return c.get<cn_ue_paging_id_c>();
  }
  protocol_ie_single_container_s<paging_id_ext_ies_o>& choice_ext()
  {
    assert_choice_type(types::choice_ext, type_, "PagingIdentity");
    return c.get<protocol_ie_single_container_s<paging_id_ext_ies_o>>();
  }
  const ran_ue_paging_id_s& ran_ue_paging_id() const
  {
    assert_choice_type(types::ran_ue_paging_id, type_, "PagingIdentity");
    return c.get<ran_ue_paging_id_s>();
  }
  const cn_ue_paging_id_c& cn_ue_paging_id() const
  {
    assert_choice_type(types::cn_ue_paging_id, type_, "PagingIdentity");
    return c.get<cn_ue_paging_id_c>();
  }
  const protocol_ie_single_container_s<paging_id_ext_ies_o>& choice_ext() const
  {
    assert_choice_type(types::choice_ext, type_, "PagingIdentity");
    return c.get<protocol_ie_single_container_s<paging_id_ext_ies_o>>();
  }
  ran_ue_paging_id_s&                                  set_ran_ue_paging_id();
  cn_ue_paging_id_c&                                   set_cn_ue_paging_id();
  protocol_ie_single_container_s<paging_id_ext_ies_o>& set_choice_ext();

private:
  types                                                                                                       type_;
  choice_buffer_t<cn_ue_paging_id_c, protocol_ie_single_container_s<paging_id_ext_ies_o>, ran_ue_paging_id_s> c;

  void destroy_();
};

// PagingOrigin ::= ENUMERATED
struct paging_origin_opts {
  enum options { non_neg3gpp, /*...*/ nulltype } value;
  typedef int8_t number_type;

  const char* to_string() const;
  int8_t      to_number() const;
};
typedef enumerated<paging_origin_opts, true> paging_origin_e;

// PagingPriority ::= ENUMERATED
struct paging_prio_opts {
  enum options {
    priolevel1,
    priolevel2,
    priolevel3,
    priolevel4,
    priolevel5,
    priolevel6,
    priolevel7,
    priolevel8,
    // ...
    nulltype
  } value;
  typedef uint8_t number_type;

  const char* to_string() const;
  uint8_t     to_number() const;
};
typedef enumerated<paging_prio_opts, true> paging_prio_e;

using path_switch_cfg_ext_ies_container = protocol_ext_container_empty_l;

// PathSwitchConfiguration ::= SEQUENCE
struct path_switch_cfg_s {
  struct t420_opts {
    enum options { ms50, ms100, ms150, ms200, ms500, ms1000, ms2000, ms10000, nulltype } value;
    typedef uint16_t number_type;

    const char* to_string() const;
    uint16_t    to_number() const;
  };
  typedef enumerated<t420_opts> t420_e_;

  // member variables
  bool                              ext             = false;
  bool                              ie_exts_present = false;
  fixed_bitstring<24, false, true>  target_relay_ue_id;
  uint16_t                          remote_ue_local_id = 0;
  t420_e_                           t420;
  path_switch_cfg_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PosBroadcast ::= ENUMERATED
struct pos_broadcast_opts {
  enum options { start, stop, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<pos_broadcast_opts, true> pos_broadcast_e;

// PosConextRevIndication ::= ENUMERATED
struct pos_conext_rev_ind_opts {
  enum options { true_value, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<pos_conext_rev_ind_opts, true> pos_conext_rev_ind_e;

using pos_meas_gap_pre_cfg_list_ext_ies_container = protocol_ext_container_empty_l;

// PosMeasGapPreConfigList ::= SEQUENCE
struct pos_meas_gap_pre_cfg_list_s {
  bool                                        ie_exts_present = false;
  unbounded_octstring<true>                   pos_meas_gap_pre_cfg_to_add_mod_list;
  unbounded_octstring<true>                   pos_meas_gap_pre_cfg_to_release_list;
  pos_meas_gap_pre_cfg_list_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PosMeasurementAmount ::= ENUMERATED
struct pos_meas_amount_opts {
  enum options { ma0, ma1, ma2, ma4, ma8, ma16, ma32, ma64, nulltype } value;
  typedef uint8_t number_type;

  const char* to_string() const;
  uint8_t     to_number() const;
};
typedef enumerated<pos_meas_amount_opts> pos_meas_amount_e;

// PosMeasurementQuantities ::= SEQUENCE (SIZE (1..16384)) OF PosMeasurementQuantities-Item
using pos_meas_quantities_l = dyn_array<pos_meas_quantities_item_s>;

// PosMeasurementResultList ::= SEQUENCE (SIZE (1..64)) OF PosMeasurementResultList-Item
using pos_meas_result_list_l = dyn_array<pos_meas_result_list_item_s>;

// PosReportCharacteristics ::= ENUMERATED
struct pos_report_characteristics_opts {
  enum options { ondemand, periodic, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<pos_report_characteristics_opts, true> pos_report_characteristics_e;

// PosSItypeList ::= SEQUENCE (SIZE (1..32)) OF PosSItype-Item
using pos_sitype_list_l = dyn_array<pos_sitype_item_s>;

// PositioningBroadcastCells ::= SEQUENCE (SIZE (1..16384)) OF NRCGI
using positioning_broadcast_cells_l = dyn_array<nr_cgi_s>;

// Potential-SpCell-List ::= SEQUENCE (SIZE (0..64)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES : IEsSetParam}
using potential_sp_cell_list_l = dyn_array<protocol_ie_single_container_s<potential_sp_cell_item_ies_o>>;

// PrivateIE-Field{F1AP-PRIVATE-IES : IEsSetParam} ::= SEQUENCE{{F1AP-PRIVATE-IES}}
template <class ies_set_paramT_>
struct private_ie_field_s {
  private_ie_id_c                   id;
  crit_e                            crit;
  typename ies_set_paramT_::value_c value;

  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// Protected-EUTRA-Resources-List ::= SEQUENCE (SIZE (1..256)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES :
// IEsSetParam}
using protected_eutra_res_list_l = dyn_array<protocol_ie_single_container_s<protected_eutra_res_item_ies_o>>;

using qo_e_info_ext_ies_container = protocol_ext_container_empty_l;

// QoEInformation ::= SEQUENCE
struct qo_e_info_s {
  bool                        ie_exts_present = false;
  qo_e_info_list_l            qo_e_info_list;
  qo_e_info_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using rlc_fail_ind_ext_ies_container = protocol_ext_container_empty_l;

// RLCFailureIndication ::= SEQUENCE
struct rlc_fail_ind_s {
  bool                           ie_exts_present = false;
  uint8_t                        assocated_lcid  = 1;
  rlc_fail_ind_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RRC-Version ::= SEQUENCE
struct rrc_version_s {
  fixed_bitstring<3, false, true>                 latest_rrc_version;
  protocol_ext_container_l<rrc_version_ext_ies_o> ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using rrc_delivery_status_ext_ies_container = protocol_ext_container_empty_l;

// RRCDeliveryStatus ::= SEQUENCE
struct rrc_delivery_status_s {
  bool                                  ie_exts_present = false;
  uint16_t                              delivery_status = 0;
  uint16_t                              trigger_msg     = 0;
  rrc_delivery_status_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RRCReconfigurationCompleteIndicator ::= ENUMERATED
struct rrc_recfg_complete_ind_opts {
  enum options { true_value, /*...*/ fail, nulltype } value;

  const char* to_string() const;
};
typedef enumerated<rrc_recfg_complete_ind_opts, true, 1> rrc_recfg_complete_ind_e;

// RegistrationRequest ::= ENUMERATED
struct regist_request_opts {
  enum options { start, stop, add, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<regist_request_opts, true> regist_request_e;

// ReportingPeriodicity ::= ENUMERATED
struct report_periodicity_opts {
  enum options { ms500, ms1000, ms2000, ms5000, ms10000, /*...*/ nulltype } value;
  typedef uint16_t number_type;

  const char* to_string() const;
  uint16_t    to_number() const;
};
typedef enumerated<report_periodicity_opts, true> report_periodicity_e;

using report_request_type_ext_ies_container = protocol_ext_container_empty_l;

// ReportingRequestType ::= SEQUENCE
struct report_request_type_s {
  bool                                  report_periodicity_value_present = false;
  bool                                  ie_exts_present                  = false;
  event_type_e                          event_type;
  uint16_t                              report_periodicity_value = 0;
  report_request_type_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RequestType ::= ENUMERATED
struct request_type_opts {
  enum options { offer, execution, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<request_type_opts, true> request_type_e;

// RequestedSRSTransmissionCharacteristics ::= SEQUENCE
struct requested_srs_tx_characteristics_s {
  struct res_type_opts {
    enum options { periodic, semi_persistent, aperiodic, /*...*/ nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<res_type_opts, true> res_type_e_;

  // member variables
  bool                                                                 nof_txs_present  = false;
  bool                                                                 ssb_info_present = false;
  uint16_t                                                             nof_txs          = 0;
  res_type_e_                                                          res_type;
  bw_srs_c                                                             bw_srs;
  srs_res_set_list_l                                                   srs_res_set_list;
  ssb_info_s                                                           ssb_info;
  protocol_ext_container_l<requested_srs_tx_characteristics_ext_ies_o> ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// ResetType ::= CHOICE
struct reset_type_c {
  struct types_opts {
    enum options { f1_interface, part_of_f1_interface, choice_ext, nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  reset_type_c() = default;
  reset_type_c(const reset_type_c& other);
  reset_type_c& operator=(const reset_type_c& other);
  ~reset_type_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  reset_all_e& f1_interface()
  {
    assert_choice_type(types::f1_interface, type_, "ResetType");
    return c.get<reset_all_e>();
  }
  ue_associated_lc_f1_conn_list_res_l& part_of_f1_interface()
  {
    assert_choice_type(types::part_of_f1_interface, type_, "ResetType");
    return c.get<ue_associated_lc_f1_conn_list_res_l>();
  }
  protocol_ie_single_container_s<reset_type_ext_ies_o>& choice_ext()
  {
    assert_choice_type(types::choice_ext, type_, "ResetType");
    return c.get<protocol_ie_single_container_s<reset_type_ext_ies_o>>();
  }
  const reset_all_e& f1_interface() const
  {
    assert_choice_type(types::f1_interface, type_, "ResetType");
    return c.get<reset_all_e>();
  }
  const ue_associated_lc_f1_conn_list_res_l& part_of_f1_interface() const
  {
    assert_choice_type(types::part_of_f1_interface, type_, "ResetType");
    return c.get<ue_associated_lc_f1_conn_list_res_l>();
  }
  const protocol_ie_single_container_s<reset_type_ext_ies_o>& choice_ext() const
  {
    assert_choice_type(types::choice_ext, type_, "ResetType");
    return c.get<protocol_ie_single_container_s<reset_type_ext_ies_o>>();
  }
  reset_all_e&                                          set_f1_interface();
  ue_associated_lc_f1_conn_list_res_l&                  set_part_of_f1_interface();
  protocol_ie_single_container_s<reset_type_ext_ies_o>& set_choice_ext();

private:
  types                                                                                                      type_;
  choice_buffer_t<protocol_ie_single_container_s<reset_type_ext_ies_o>, ue_associated_lc_f1_conn_list_res_l> c;

  void destroy_();
};

using res_coordination_transfer_info_ext_ies_container = protocol_ext_container_empty_l;

// ResourceCoordinationTransferInformation ::= SEQUENCE
struct res_coordination_transfer_info_s {
  bool                                             ext                                      = false;
  bool                                             res_coordination_eutra_cell_info_present = false;
  bool                                             ie_exts_present                          = false;
  fixed_bitstring<28, false, true>                 m_enb_cell_id;
  res_coordination_eutra_cell_info_s               res_coordination_eutra_cell_info;
  res_coordination_transfer_info_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using resp_time_ext_ies_container = protocol_ext_container_empty_l;

// ResponseTime ::= SEQUENCE
struct resp_time_s {
  struct time_unit_opts {
    enum options { second, ten_seconds, ten_milliseconds, /*...*/ nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<time_unit_opts, true> time_unit_e_;

  // member variables
  bool                        ext             = false;
  bool                        ie_exts_present = false;
  uint8_t                     time            = 1;
  time_unit_e_                time_unit;
  resp_time_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SCGActivationRequest ::= ENUMERATED
struct scg_activation_request_opts {
  enum options { activ_scg, deactiv_scg, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<scg_activation_request_opts, true> scg_activation_request_e;

// SCGActivationStatus ::= ENUMERATED
struct scg_activation_status_opts {
  enum options { scg_activ, scg_deactiv, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<scg_activation_status_opts, true> scg_activation_status_e;

// SCGIndicator ::= ENUMERATED
struct scg_ind_opts {
  enum options { released, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<scg_ind_opts, true> scg_ind_e;

// SCell-FailedtoSetup-List ::= SEQUENCE (SIZE (1..32)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES : IEsSetParam}
using scell_failedto_setup_list_l = bounded_array<protocol_ie_single_container_s<scell_failedto_setup_item_ies_o>, 32>;

// SCell-FailedtoSetupMod-List ::= SEQUENCE (SIZE (1..32)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES :
// IEsSetParam}
using scell_failedto_setup_mod_list_l =
    bounded_array<protocol_ie_single_container_s<scell_failedto_setup_mod_item_ies_o>, 32>;

// SCell-ToBeRemoved-List ::= SEQUENCE (SIZE (1..32)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES : IEsSetParam}
using scell_to_be_remd_list_l = bounded_array<protocol_ie_single_container_s<scell_to_be_remd_item_ies_o>, 32>;

// SCell-ToBeSetup-List ::= SEQUENCE (SIZE (1..32)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES : IEsSetParam}
using scell_to_be_setup_list_l = bounded_array<protocol_ie_single_container_s<scell_to_be_setup_item_ies_o>, 32>;

// SCell-ToBeSetupMod-List ::= SEQUENCE (SIZE (1..32)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES : IEsSetParam}
using scell_to_be_setup_mod_list_l =
    bounded_array<protocol_ie_single_container_s<scell_to_be_setup_mod_item_ies_o>, 32>;

// SDT-Termination-Request ::= ENUMERATED
struct sdt_termination_request_opts {
  enum options { radio_link_problem, normal, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<sdt_termination_request_opts, true> sdt_termination_request_e;

using sdt_bearer_cfg_info_ext_ies_container = protocol_ext_container_empty_l;

// SDTBearerConfigurationInfo ::= SEQUENCE
struct sdt_bearer_cfg_info_s {
  bool                                  ie_exts_present = false;
  sdt_bearer_cfg_list_l                 sdt_bearer_cfg_list;
  sdt_bearer_cfg_info_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SDTBearerConfigurationQueryIndication ::= ENUMERATED
struct sdt_bearer_cfg_query_ind_opts {
  enum options { true_value, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<sdt_bearer_cfg_query_ind_opts, true> sdt_bearer_cfg_query_ind_e;

using sdt_info_ext_ies_container = protocol_ext_container_empty_l;

// SDTInformation ::= SEQUENCE
struct sdt_info_s {
  struct sdt_ind_opts {
    enum options { true_value, /*...*/ nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<sdt_ind_opts, true> sdt_ind_e_;
  struct sdt_assistant_info_opts {
    enum options { singlepacket, multiplepackets, /*...*/ nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<sdt_assistant_info_opts, true> sdt_assistant_info_e_;

  // member variables
  bool                       sdt_assistant_info_present = false;
  bool                       ie_exts_present            = false;
  sdt_ind_e_                 sdt_ind;
  sdt_assistant_info_e_      sdt_assistant_info;
  sdt_info_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SItype-List ::= SEQUENCE (SIZE (1..32)) OF SItype-Item
using sitype_list_l = dyn_array<sitype_item_s>;

// SLDRBs-FailedToBeModified-List ::= SEQUENCE (SIZE (1..512)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES :
// IEsSetParam}
using sl_drbs_failed_to_be_modified_list_l =
    dyn_array<protocol_ie_single_container_s<sl_drbs_failed_to_be_modified_item_ies_o>>;

// SLDRBs-FailedToBeSetup-List ::= SEQUENCE (SIZE (1..512)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES :
// IEsSetParam}
using sl_drbs_failed_to_be_setup_list_l =
    dyn_array<protocol_ie_single_container_s<sl_drbs_failed_to_be_setup_item_ies_o>>;

// SLDRBs-FailedToBeSetupMod-List ::= SEQUENCE (SIZE (1..512)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES :
// IEsSetParam}
using sl_drbs_failed_to_be_setup_mod_list_l =
    dyn_array<protocol_ie_single_container_s<sl_drbs_failed_to_be_setup_mod_item_ies_o>>;

// SLDRBs-Modified-List ::= SEQUENCE (SIZE (1..512)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES : IEsSetParam}
using sl_drbs_modified_list_l = dyn_array<protocol_ie_single_container_s<sl_drbs_modified_item_ies_o>>;

// SLDRBs-ModifiedConf-List ::= SEQUENCE (SIZE (1..512)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES : IEsSetParam}
using sl_drbs_modified_conf_list_l = dyn_array<protocol_ie_single_container_s<sl_drbs_modified_conf_item_ies_o>>;

// SLDRBs-Required-ToBeModified-List ::= SEQUENCE (SIZE (1..512)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES :
// IEsSetParam}
using sl_drbs_required_to_be_modified_list_l =
    dyn_array<protocol_ie_single_container_s<sl_drbs_required_to_be_modified_item_ies_o>>;

// SLDRBs-Required-ToBeReleased-List ::= SEQUENCE (SIZE (1..512)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES :
// IEsSetParam}
using sl_drbs_required_to_be_released_list_l =
    dyn_array<protocol_ie_single_container_s<sl_drbs_required_to_be_released_item_ies_o>>;

// SLDRBs-Setup-List ::= SEQUENCE (SIZE (1..512)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES : IEsSetParam}
using sl_drbs_setup_list_l = dyn_array<protocol_ie_single_container_s<sl_drbs_setup_item_ies_o>>;

// SLDRBs-SetupMod-List ::= SEQUENCE (SIZE (1..512)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES : IEsSetParam}
using sl_drbs_setup_mod_list_l = dyn_array<protocol_ie_single_container_s<sl_drbs_setup_mod_item_ies_o>>;

// SLDRBs-ToBeModified-List ::= SEQUENCE (SIZE (1..512)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES : IEsSetParam}
using sl_drbs_to_be_modified_list_l = dyn_array<protocol_ie_single_container_s<sl_drbs_to_be_modified_item_ies_o>>;

// SLDRBs-ToBeReleased-List ::= SEQUENCE (SIZE (1..512)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES : IEsSetParam}
using sl_drbs_to_be_released_list_l = dyn_array<protocol_ie_single_container_s<sl_drbs_to_be_released_item_ies_o>>;

// SLDRBs-ToBeSetup-List ::= SEQUENCE (SIZE (1..512)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES : IEsSetParam}
using sl_drbs_to_be_setup_list_l = dyn_array<protocol_ie_single_container_s<sl_drbs_to_be_setup_item_ies_o>>;

// SLDRBs-ToBeSetupMod-List ::= SEQUENCE (SIZE (1..512)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES : IEsSetParam}
using sl_drbs_to_be_setup_mod_list_l = dyn_array<protocol_ie_single_container_s<sl_drbs_to_be_setup_mod_item_ies_o>>;

// SLDRXCycleList ::= SEQUENCE (SIZE (1..32)) OF SLDRXCycleItem
using sldrx_cycle_list_l = dyn_array<sldrx_cycle_item_s>;

// SRBs-FailedToBeSetup-List ::= SEQUENCE (SIZE (1..8)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES : IEsSetParam}
using srbs_failed_to_be_setup_list_l =
    bounded_array<protocol_ie_single_container_s<srbs_failed_to_be_setup_item_ies_o>, 8>;

// SRBs-FailedToBeSetupMod-List ::= SEQUENCE (SIZE (1..8)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES :
// IEsSetParam}
using srbs_failed_to_be_setup_mod_list_l =
    bounded_array<protocol_ie_single_container_s<srbs_failed_to_be_setup_mod_item_ies_o>, 8>;

// SRBs-Modified-List ::= SEQUENCE (SIZE (1..8)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES : IEsSetParam}
using srbs_modified_list_l = bounded_array<protocol_ie_single_container_s<srbs_modified_item_ies_o>, 8>;

// SRBs-Required-ToBeReleased-List ::= SEQUENCE (SIZE (1..8)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES :
// IEsSetParam}
using srbs_required_to_be_released_list_l =
    bounded_array<protocol_ie_single_container_s<srbs_required_to_be_released_item_ies_o>, 8>;

// SRBs-Setup-List ::= SEQUENCE (SIZE (1..8)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES : IEsSetParam}
using srbs_setup_list_l = bounded_array<protocol_ie_single_container_s<srbs_setup_item_ies_o>, 8>;

// SRBs-SetupMod-List ::= SEQUENCE (SIZE (1..8)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES : IEsSetParam}
using srbs_setup_mod_list_l = bounded_array<protocol_ie_single_container_s<srbs_setup_mod_item_ies_o>, 8>;

// SRBs-ToBeReleased-List ::= SEQUENCE (SIZE (1..8)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES : IEsSetParam}
using srbs_to_be_released_list_l = bounded_array<protocol_ie_single_container_s<srbs_to_be_released_item_ies_o>, 8>;

// SRBs-ToBeSetup-List ::= SEQUENCE (SIZE (1..8)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES : IEsSetParam}
using srbs_to_be_setup_list_l = bounded_array<protocol_ie_single_container_s<srbs_to_be_setup_item_ies_o>, 8>;

// SRBs-ToBeSetupMod-List ::= SEQUENCE (SIZE (1..8)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES : IEsSetParam}
using srbs_to_be_setup_mod_list_l = bounded_array<protocol_ie_single_container_s<srbs_to_be_setup_mod_item_ies_o>, 8>;

// SRSPosRRCInactiveQueryIndication ::= ENUMERATED
struct srs_pos_rrc_inactive_query_ind_opts {
  enum options { true_value, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<srs_pos_rrc_inactive_query_ind_opts, true> srs_pos_rrc_inactive_query_ind_e;

// SRSType ::= CHOICE
struct srs_type_c {
  struct types_opts {
    enum options { semipersistent_srs, aperiodic_srs, choice_ext, nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  srs_type_c() = default;
  srs_type_c(const srs_type_c& other);
  srs_type_c& operator=(const srs_type_c& other);
  ~srs_type_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  semipersistent_srs_s& semipersistent_srs()
  {
    assert_choice_type(types::semipersistent_srs, type_, "SRSType");
    return c.get<semipersistent_srs_s>();
  }
  aperiodic_srs_s& aperiodic_srs()
  {
    assert_choice_type(types::aperiodic_srs, type_, "SRSType");
    return c.get<aperiodic_srs_s>();
  }
  protocol_ie_single_container_s<srs_type_ext_ies_o>& choice_ext()
  {
    assert_choice_type(types::choice_ext, type_, "SRSType");
    return c.get<protocol_ie_single_container_s<srs_type_ext_ies_o>>();
  }
  const semipersistent_srs_s& semipersistent_srs() const
  {
    assert_choice_type(types::semipersistent_srs, type_, "SRSType");
    return c.get<semipersistent_srs_s>();
  }
  const aperiodic_srs_s& aperiodic_srs() const
  {
    assert_choice_type(types::aperiodic_srs, type_, "SRSType");
    return c.get<aperiodic_srs_s>();
  }
  const protocol_ie_single_container_s<srs_type_ext_ies_o>& choice_ext() const
  {
    assert_choice_type(types::choice_ext, type_, "SRSType");
    return c.get<protocol_ie_single_container_s<srs_type_ext_ies_o>>();
  }
  semipersistent_srs_s&                               set_semipersistent_srs();
  aperiodic_srs_s&                                    set_aperiodic_srs();
  protocol_ie_single_container_s<srs_type_ext_ies_o>& set_choice_ext();

private:
  types                                                                                                      type_;
  choice_buffer_t<aperiodic_srs_s, protocol_ie_single_container_s<srs_type_ext_ies_o>, semipersistent_srs_s> c;

  void destroy_();
};

// SULAccessIndication ::= ENUMERATED
struct sul_access_ind_opts {
  enum options { true_value, /*...*/ nulltype } value;

  const char* to_string() const;
};
typedef enumerated<sul_access_ind_opts, true> sul_access_ind_e;

// Served-Cells-To-Add-List ::= SEQUENCE (SIZE (1..512)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES : IEsSetParam}
using served_cells_to_add_list_l = dyn_array<protocol_ie_single_container_s<served_cells_to_add_item_ies_o>>;

// Served-Cells-To-Delete-List ::= SEQUENCE (SIZE (1..512)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES :
// IEsSetParam}
using served_cells_to_delete_list_l = dyn_array<protocol_ie_single_container_s<served_cells_to_delete_item_ies_o>>;

// Served-Cells-To-Modify-List ::= SEQUENCE (SIZE (1..512)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES :
// IEsSetParam}
using served_cells_to_modify_list_l = dyn_array<protocol_ie_single_container_s<served_cells_to_modify_item_ies_o>>;

// Serving-Cells-List ::= SEQUENCE (SIZE (1..32)) OF Serving-Cells-List-Item
using serving_cells_list_l = dyn_array<serving_cells_list_item_s>;

// ServingCellMO-List ::= SEQUENCE (SIZE (1..16)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES : IEsSetParam}
using serving_cell_mo_list_l = bounded_array<protocol_ie_single_container_s<serving_cell_mo_list_item_ies_o>, 16>;

// ServingCellMO-encoded-in-CGC-List ::= SEQUENCE (SIZE (1..8)) OF ServingCellMO-encoded-in-CGC-Item
using serving_cell_mo_encoded_in_cgc_list_l = dyn_array<serving_cell_mo_encoded_in_cgc_item_s>;

using sidelink_relay_cfg_ext_ies_container = protocol_ext_container_empty_l;

// SidelinkRelayConfiguration ::= SEQUENCE
struct sidelink_relay_cfg_s {
  bool                                 ext                           = false;
  bool                                 ie_exts_present               = false;
  uint64_t                             gnb_du_ue_f1ap_id_of_relay_ue = 0;
  uint16_t                             remote_ue_local_id            = 0;
  unbounded_octstring<true>            sidelink_cfg_container;
  sidelink_relay_cfg_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using tnl_capacity_ind_ext_ies_container = protocol_ext_container_empty_l;

// TNLCapacityIndicator ::= SEQUENCE
struct tnl_capacity_ind_s {
  bool                               ie_exts_present           = false;
  uint32_t                           dl_tnl_offered_capacity   = 1;
  uint8_t                            dl_tnl_available_capacity = 0;
  uint32_t                           ul_tnl_offered_capacity   = 1;
  uint8_t                            ul_tnl_available_capacity = 0;
  tnl_capacity_ind_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// TRP-MeasurementRequestList ::= SEQUENCE (SIZE (1..64)) OF TRP-MeasurementRequestItem
using trp_meas_request_list_l = dyn_array<trp_meas_request_item_s>;

// TRP-MeasurementUpdateList ::= SEQUENCE (SIZE (1..64)) OF TRP-MeasurementUpdateItem
using trp_meas_upd_list_l = dyn_array<trp_meas_upd_item_s>;

// TRP-PRS-Info-List ::= SEQUENCE (SIZE (1..256)) OF TRP-PRS-Info-List-Item
using trp_prs_info_list_l = dyn_array<trp_prs_info_list_item_s>;

// TRPInformationListTRPResp ::= SEQUENCE (SIZE (1..65535)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES :
// IEsSetParam}
using trp_info_list_trp_resp_l = dyn_array<protocol_ie_single_container_s<trp_info_item_trp_resp_o>>;

// TRPInformationTypeListTRPReq ::= SEQUENCE (SIZE (1..64)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES :
// IEsSetParam}
using trp_info_type_list_trp_req_l = dyn_array<protocol_ie_single_container_s<trp_info_type_item_trp_req_o>>;

// TRPList ::= SEQUENCE (SIZE (1..65535)) OF TRPListItem
using trp_list_l = dyn_array<trp_list_item_s>;

using time_ref_info_ext_ies_container = protocol_ext_container_empty_l;

// TimeReferenceInformation ::= SEQUENCE
struct time_ref_info_s {
  bool                            ie_exts_present = false;
  unbounded_octstring<true>       ref_time;
  uint16_t                        ref_sfn     = 0;
  uint16_t                        uncertainty = 0;
  time_ref_info_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

struct trace_activation_ext_ies_container {
  template <class extT_>
  using ie_field_s = protocol_ext_container_item_s<extT_>;

  // member variables
  bool                                                              mdt_cfg_present                     = false;
  bool                                                              trace_collection_entity_uri_present = false;
  ie_field_s<mdt_cfg_s>                                             mdt_cfg;
  ie_field_s<visible_string<0, MAX_ASN_STRING_LENGTH, false, true>> trace_collection_entity_uri;

  // sequence methods
  trace_activation_ext_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// TraceActivation ::= SEQUENCE
struct trace_activation_s {
  bool                                  ie_exts_present = false;
  fixed_octstring<8, true>              trace_id;
  fixed_bitstring<8, false, true>       interfaces_to_trace;
  trace_depth_e                         trace_depth;
  bounded_bitstring<1, 160, true, true> trace_collection_entity_ip_address;
  trace_activation_ext_ies_container    ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// TransmissionActionIndicator ::= ENUMERATED
struct tx_action_ind_opts {
  enum options { stop, /*...*/ restart, nulltype } value;

  const char* to_string() const;
};
typedef enumerated<tx_action_ind_opts, true, 1> tx_action_ind_e;

using transport_layer_address_info_ext_ies_container = protocol_ext_container_empty_l;

// Transport-Layer-Address-Info ::= SEQUENCE
struct transport_layer_address_info_s {
  bool                                           ie_exts_present = false;
  transport_up_layer_address_info_to_add_list_l  transport_up_layer_address_info_to_add_list;
  transport_up_layer_address_info_to_rem_list_l  transport_up_layer_address_info_to_rem_list;
  transport_layer_address_info_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using uac_assist_info_ext_ies_container = protocol_ext_container_empty_l;

// UAC-Assistance-Info ::= SEQUENCE
struct uac_assist_info_s {
  bool                              ie_exts_present = false;
  uac_plmn_list_l                   uac_plmn_list;
  uac_assist_info_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UE-MulticastMRBs-ConfirmedToBeModified-List ::= SEQUENCE (SIZE (1..64)) OF
// ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES : IEsSetParam}
using ue_multicast_m_rbs_confirmed_to_be_modified_list_l =
    dyn_array<protocol_ie_single_container_s<ue_multicast_m_rbs_confirmed_to_be_modified_item_ies_o>>;

// UE-MulticastMRBs-RequiredToBeModified-List ::= SEQUENCE (SIZE (1..64)) OF
// ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES : IEsSetParam}
using ue_multicast_m_rbs_required_to_be_modified_list_l =
    dyn_array<protocol_ie_single_container_s<ue_multicast_m_rbs_required_to_be_modified_item_ies_o>>;

// UE-MulticastMRBs-RequiredToBeReleased-List ::= SEQUENCE (SIZE (1..64)) OF
// ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES : IEsSetParam}
using ue_multicast_m_rbs_required_to_be_released_list_l =
    dyn_array<protocol_ie_single_container_s<ue_multicast_m_rbs_required_to_be_released_item_ies_o>>;

// UE-MulticastMRBs-Setup-List ::= SEQUENCE (SIZE (1..64)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES :
// IEsSetParam}
using ue_multicast_m_rbs_setup_list_l = dyn_array<protocol_ie_single_container_s<ue_multicast_m_rbs_setup_item_ies_o>>;

// UE-MulticastMRBs-ToBeReleased-List ::= SEQUENCE (SIZE (1..64)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES :
// IEsSetParam}
using ue_multicast_m_rbs_to_be_released_list_l =
    dyn_array<protocol_ie_single_container_s<ue_multicast_m_rbs_to_be_released_item_ies_o>>;

// UE-MulticastMRBs-ToBeSetup-List ::= SEQUENCE (SIZE (1..64)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES :
// IEsSetParam}
using ue_multicast_m_rbs_to_be_setup_list_l =
    dyn_array<protocol_ie_single_container_s<ue_multicast_m_rbs_to_be_setup_item_ies_o>>;

// UE-MulticastMRBs-ToBeSetup-atModify-List ::= SEQUENCE (SIZE (1..64)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES
// : IEsSetParam}
using ue_multicast_m_rbs_to_be_setup_at_modify_list_l =
    dyn_array<protocol_ie_single_container_s<ue_multicast_m_rbs_to_be_setup_at_modify_item_ies_o>>;

// UE-associatedLogicalF1-ConnectionListResAck ::= SEQUENCE (SIZE (1..65536)) OF
// ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES : IEsSetParam}
using ue_associated_lc_f1_conn_list_res_ack_l =
    dyn_array<protocol_ie_single_container_s<ue_associated_lc_f1_conn_item_res_ack_o>>;

// UEIdentity-List-For-Paging-List ::= SEQUENCE (SIZE (1..4096)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES :
// IEsSetParam}
using ue_id_list_for_paging_list_l = dyn_array<protocol_ie_single_container_s<ue_id_list_for_paging_item_ies_o>>;

// UEPagingCapability ::= SEQUENCE
struct ue_paging_cap_s {
  struct inactive_state_po_determination_opts {
    enum options { supported, /*...*/ nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<inactive_state_po_determination_opts, true> inactive_state_po_determination_e_;

  // member variables
  bool                                              ext                                     = false;
  bool                                              inactive_state_po_determination_present = false;
  inactive_state_po_determination_e_                inactive_state_po_determination;
  protocol_ext_container_l<ue_paging_cap_ext_ies_o> ie_ext;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using ue_report_info_ext_ies_container = protocol_ext_container_empty_l;

// UEReportingInformation ::= SEQUENCE
struct ue_report_info_s {
  struct report_amount_opts {
    enum options { ma0, ma1, ma2, ma4, ma8, ma16, ma32, ma64, nulltype } value;
    typedef uint8_t number_type;

    const char* to_string() const;
    uint8_t     to_number() const;
  };
  typedef enumerated<report_amount_opts> report_amount_e_;
  struct report_interv_opts {
    enum options { none, one, two, four, eight, ten, sixteen, twenty, thirty_two, sixty_four, /*...*/ nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<report_interv_opts, true> report_interv_e_;

  // member variables
  bool                             ext             = false;
  bool                             ie_exts_present = false;
  report_amount_e_                 report_amount;
  report_interv_e_                 report_interv;
  ue_report_info_ext_ies_container ie_exts;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

using ul_bh_non_up_traffic_map_ext_ies_container = protocol_ext_container_empty_l;

// UL-BH-Non-UP-Traffic-Mapping ::= SEQUENCE
struct ul_bh_non_up_traffic_map_s {
  bool                                       ie_exts_present = false;
  ul_bh_non_up_traffic_map_list_l            ul_bh_non_up_traffic_map_list;
  ul_bh_non_up_traffic_map_ext_ies_container ie_exts;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UL-UP-TNL-Address-to-Update-List ::= SEQUENCE (SIZE (1..8)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES :
// IEsSetParam}
using ul_up_tnl_address_to_upd_list_l =
    bounded_array<protocol_ie_single_container_s<ul_up_tnl_address_to_upd_list_item_ies_o>, 8>;

// UL-UP-TNL-Information-to-Update-List ::= SEQUENCE (SIZE (1..32678)) OF ProtocolIE-SingleContainer{F1AP-PROTOCOL-IES :
// IEsSetParam}
using ul_up_tnl_info_to_upd_list_l = dyn_array<protocol_ie_single_container_s<ul_up_tnl_info_to_upd_list_item_ies_o>>;

// UuRLCChannelFailedToBeModifiedList ::= SEQUENCE (SIZE (1..32)) OF UuRLCChannelFailedToBeModifiedItem
using uu_rlc_ch_failed_to_be_modified_list_l = dyn_array<uu_rlc_ch_failed_to_be_modified_item_s>;

// UuRLCChannelFailedToBeSetupList ::= SEQUENCE (SIZE (1..32)) OF UuRLCChannelFailedToBeSetupItem
using uu_rlc_ch_failed_to_be_setup_list_l = dyn_array<uu_rlc_ch_failed_to_be_setup_item_s>;

// UuRLCChannelModifiedList ::= SEQUENCE (SIZE (1..32)) OF UuRLCChannelModifiedItem
using uu_rlc_ch_modified_list_l = dyn_array<uu_rlc_ch_modified_item_s>;

// UuRLCChannelRequiredToBeModifiedList ::= SEQUENCE (SIZE (1..32)) OF UuRLCChannelRequiredToBeModifiedItem
using uu_rlc_ch_required_to_be_modified_list_l = dyn_array<uu_rlc_ch_required_to_be_modified_item_s>;

// UuRLCChannelRequiredToBeReleasedList ::= SEQUENCE (SIZE (1..32)) OF UuRLCChannelRequiredToBeReleasedItem
using uu_rlc_ch_required_to_be_released_list_l = dyn_array<uu_rlc_ch_required_to_be_released_item_s>;

// UuRLCChannelSetupList ::= SEQUENCE (SIZE (1..32)) OF UuRLCChannelSetupItem
using uu_rlc_ch_setup_list_l = dyn_array<uu_rlc_ch_setup_item_s>;

// UuRLCChannelToBeModifiedList ::= SEQUENCE (SIZE (1..32)) OF UuRLCChannelToBeModifiedItem
using uu_rlc_ch_to_be_modified_list_l = dyn_array<uu_rlc_ch_to_be_modified_item_s>;

// UuRLCChannelToBeReleasedList ::= SEQUENCE (SIZE (1..32)) OF UuRLCChannelToBeReleasedItem
using uu_rlc_ch_to_be_released_list_l = dyn_array<uu_rlc_ch_to_be_released_item_s>;

// UuRLCChannelToBeSetupList ::= SEQUENCE (SIZE (1..32)) OF UuRLCChannelToBeSetupItem
using uu_rlc_ch_to_be_setup_list_l = dyn_array<uu_rlc_ch_to_be_setup_item_s>;

// F1RemovalFailureIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct f1_removal_fail_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { transaction_id, cause, crit_diagnostics, nulltype } value;
      typedef uint8_t number_type;

      const char* to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint16_t&                 transaction_id();
    cause_c&                  cause();
    crit_diagnostics_s&       crit_diagnostics();
    const uint16_t&           transaction_id() const;
    const cause_c&            cause() const;
    const crit_diagnostics_s& crit_diagnostics() const;

  private:
    types                                        type_;
    choice_buffer_t<cause_c, crit_diagnostics_s> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// F1RemovalRequestIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct f1_removal_request_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { transaction_id, nulltype } value;
      typedef uint8_t number_type;

      const char* to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::transaction_id; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint16_t&       transaction_id() { return c; }
    const uint16_t& transaction_id() const { return c; }

  private:
    uint16_t c;
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// F1RemovalResponseIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct f1_removal_resp_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { transaction_id, crit_diagnostics, nulltype } value;
      typedef uint8_t number_type;

      const char* to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint16_t&                 transaction_id();
    crit_diagnostics_s&       crit_diagnostics();
    const uint16_t&           transaction_id() const;
    const crit_diagnostics_s& crit_diagnostics() const;

  private:
    types                               type_;
    choice_buffer_t<crit_diagnostics_s> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// F1SetupFailureIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct f1_setup_fail_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { transaction_id, cause, time_to_wait, crit_diagnostics, nulltype } value;
      typedef uint8_t number_type;

      const char* to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint16_t&                 transaction_id();
    cause_c&                  cause();
    time_to_wait_e&           time_to_wait();
    crit_diagnostics_s&       crit_diagnostics();
    const uint16_t&           transaction_id() const;
    const cause_c&            cause() const;
    const time_to_wait_e&     time_to_wait() const;
    const crit_diagnostics_s& crit_diagnostics() const;

  private:
    types                                        type_;
    choice_buffer_t<cause_c, crit_diagnostics_s> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// F1SetupRequestIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct f1_setup_request_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options {
        transaction_id,
        gnb_du_id,
        gnb_du_name,
        gnb_du_served_cells_list,
        gnb_du_rrc_version,
        transport_layer_address_info,
        bap_address,
        extended_gnb_du_name,
        nulltype
      } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint16_t&                                   transaction_id();
    uint64_t&                                   gnb_du_id();
    printable_string<1, 150, true, true>&       gnb_du_name();
    gnb_du_served_cells_list_l&                 gnb_du_served_cells_list();
    rrc_version_s&                              gnb_du_rrc_version();
    transport_layer_address_info_s&             transport_layer_address_info();
    fixed_bitstring<10, false, true>&           bap_address();
    extended_gnb_du_name_s&                     extended_gnb_du_name();
    const uint16_t&                             transaction_id() const;
    const uint64_t&                             gnb_du_id() const;
    const printable_string<1, 150, true, true>& gnb_du_name() const;
    const gnb_du_served_cells_list_l&           gnb_du_served_cells_list() const;
    const rrc_version_s&                        gnb_du_rrc_version() const;
    const transport_layer_address_info_s&       transport_layer_address_info() const;
    const fixed_bitstring<10, false, true>&     bap_address() const;
    const extended_gnb_du_name_s&               extended_gnb_du_name() const;

  private:
    types type_;
    choice_buffer_t<extended_gnb_du_name_s,
                    fixed_bitstring<10, false, true>,
                    gnb_du_served_cells_list_l,
                    printable_string<1, 150, true, true>,
                    rrc_version_s,
                    transport_layer_address_info_s>
        c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// F1SetupResponseIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct f1_setup_resp_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options {
        transaction_id,
        gnb_cu_name,
        cells_to_be_activ_list,
        gnb_cu_rrc_version,
        transport_layer_address_info,
        ul_bh_non_up_traffic_map,
        bap_address,
        extended_gnb_cu_name,
        nulltype
      } value;
      typedef uint8_t number_type;

      const char* to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint16_t&                                   transaction_id();
    printable_string<1, 150, true, true>&       gnb_cu_name();
    cells_to_be_activ_list_l&                   cells_to_be_activ_list();
    rrc_version_s&                              gnb_cu_rrc_version();
    transport_layer_address_info_s&             transport_layer_address_info();
    ul_bh_non_up_traffic_map_s&                 ul_bh_non_up_traffic_map();
    fixed_bitstring<10, false, true>&           bap_address();
    extended_gnb_cu_name_s&                     extended_gnb_cu_name();
    const uint16_t&                             transaction_id() const;
    const printable_string<1, 150, true, true>& gnb_cu_name() const;
    const cells_to_be_activ_list_l&             cells_to_be_activ_list() const;
    const rrc_version_s&                        gnb_cu_rrc_version() const;
    const transport_layer_address_info_s&       transport_layer_address_info() const;
    const ul_bh_non_up_traffic_map_s&           ul_bh_non_up_traffic_map() const;
    const fixed_bitstring<10, false, true>&     bap_address() const;
    const extended_gnb_cu_name_s&               extended_gnb_cu_name() const;

  private:
    types type_;
    choice_buffer_t<cells_to_be_activ_list_l,
                    extended_gnb_cu_name_s,
                    fixed_bitstring<10, false, true>,
                    printable_string<1, 150, true, true>,
                    rrc_version_s,
                    transport_layer_address_info_s,
                    ul_bh_non_up_traffic_map_s>
        c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// GNBCUConfigurationUpdateAcknowledgeIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct gnb_cu_cfg_upd_ack_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options {
        transaction_id,
        cells_failed_to_be_activ_list,
        crit_diagnostics,
        gnb_cu_tnl_assoc_setup_list,
        gnb_cu_tnl_assoc_failed_to_setup_list,
        ded_si_delivery_needed_ue_list,
        transport_layer_address_info,
        nulltype
      } value;
      typedef uint8_t number_type;

      const char* to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint16_t&                                      transaction_id();
    cells_failed_to_be_activ_list_l&               cells_failed_to_be_activ_list();
    crit_diagnostics_s&                            crit_diagnostics();
    gnb_cu_tnl_assoc_setup_list_l&                 gnb_cu_tnl_assoc_setup_list();
    gnb_cu_tnl_assoc_failed_to_setup_list_l&       gnb_cu_tnl_assoc_failed_to_setup_list();
    ded_si_delivery_needed_ue_list_l&              ded_si_delivery_needed_ue_list();
    transport_layer_address_info_s&                transport_layer_address_info();
    const uint16_t&                                transaction_id() const;
    const cells_failed_to_be_activ_list_l&         cells_failed_to_be_activ_list() const;
    const crit_diagnostics_s&                      crit_diagnostics() const;
    const gnb_cu_tnl_assoc_setup_list_l&           gnb_cu_tnl_assoc_setup_list() const;
    const gnb_cu_tnl_assoc_failed_to_setup_list_l& gnb_cu_tnl_assoc_failed_to_setup_list() const;
    const ded_si_delivery_needed_ue_list_l&        ded_si_delivery_needed_ue_list() const;
    const transport_layer_address_info_s&          transport_layer_address_info() const;

  private:
    types type_;
    choice_buffer_t<cells_failed_to_be_activ_list_l,
                    crit_diagnostics_s,
                    ded_si_delivery_needed_ue_list_l,
                    gnb_cu_tnl_assoc_failed_to_setup_list_l,
                    gnb_cu_tnl_assoc_setup_list_l,
                    transport_layer_address_info_s>
        c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// GNBCUConfigurationUpdateFailureIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct gnb_cu_cfg_upd_fail_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { transaction_id, cause, time_to_wait, crit_diagnostics, nulltype } value;
      typedef uint8_t number_type;

      const char* to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint16_t&                 transaction_id();
    cause_c&                  cause();
    time_to_wait_e&           time_to_wait();
    crit_diagnostics_s&       crit_diagnostics();
    const uint16_t&           transaction_id() const;
    const cause_c&            cause() const;
    const time_to_wait_e&     time_to_wait() const;
    const crit_diagnostics_s& crit_diagnostics() const;

  private:
    types                                        type_;
    choice_buffer_t<cause_c, crit_diagnostics_s> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// GNBCUConfigurationUpdateIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct gnb_cu_cfg_upd_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options {
        transaction_id,
        cells_to_be_activ_list,
        cells_to_be_deactiv_list,
        gnb_cu_tnl_assoc_to_add_list,
        gnb_cu_tnl_assoc_to_rem_list,
        gnb_cu_tnl_assoc_to_upd_list,
        cells_to_be_barred_list,
        protected_eutra_res_list,
        neighbour_cell_info_list,
        transport_layer_address_info,
        ul_bh_non_up_traffic_map,
        bap_address,
        cco_assist_info,
        cells_for_son_list,
        gnb_cu_name,
        extended_gnb_cu_name,
        nulltype
      } value;
      typedef uint8_t number_type;

      const char* to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint16_t&                                   transaction_id();
    cells_to_be_activ_list_l&                   cells_to_be_activ_list();
    cells_to_be_deactiv_list_l&                 cells_to_be_deactiv_list();
    gnb_cu_tnl_assoc_to_add_list_l&             gnb_cu_tnl_assoc_to_add_list();
    gnb_cu_tnl_assoc_to_rem_list_l&             gnb_cu_tnl_assoc_to_rem_list();
    gnb_cu_tnl_assoc_to_upd_list_l&             gnb_cu_tnl_assoc_to_upd_list();
    cells_to_be_barred_list_l&                  cells_to_be_barred_list();
    protected_eutra_res_list_l&                 protected_eutra_res_list();
    neighbour_cell_info_list_l&                 neighbour_cell_info_list();
    transport_layer_address_info_s&             transport_layer_address_info();
    ul_bh_non_up_traffic_map_s&                 ul_bh_non_up_traffic_map();
    fixed_bitstring<10, false, true>&           bap_address();
    cco_assist_info_s&                          cco_assist_info();
    cells_for_son_list_l&                       cells_for_son_list();
    printable_string<1, 150, true, true>&       gnb_cu_name();
    extended_gnb_cu_name_s&                     extended_gnb_cu_name();
    const uint16_t&                             transaction_id() const;
    const cells_to_be_activ_list_l&             cells_to_be_activ_list() const;
    const cells_to_be_deactiv_list_l&           cells_to_be_deactiv_list() const;
    const gnb_cu_tnl_assoc_to_add_list_l&       gnb_cu_tnl_assoc_to_add_list() const;
    const gnb_cu_tnl_assoc_to_rem_list_l&       gnb_cu_tnl_assoc_to_rem_list() const;
    const gnb_cu_tnl_assoc_to_upd_list_l&       gnb_cu_tnl_assoc_to_upd_list() const;
    const cells_to_be_barred_list_l&            cells_to_be_barred_list() const;
    const protected_eutra_res_list_l&           protected_eutra_res_list() const;
    const neighbour_cell_info_list_l&           neighbour_cell_info_list() const;
    const transport_layer_address_info_s&       transport_layer_address_info() const;
    const ul_bh_non_up_traffic_map_s&           ul_bh_non_up_traffic_map() const;
    const fixed_bitstring<10, false, true>&     bap_address() const;
    const cco_assist_info_s&                    cco_assist_info() const;
    const cells_for_son_list_l&                 cells_for_son_list() const;
    const printable_string<1, 150, true, true>& gnb_cu_name() const;
    const extended_gnb_cu_name_s&               extended_gnb_cu_name() const;

  private:
    types type_;
    choice_buffer_t<cco_assist_info_s,
                    cells_for_son_list_l,
                    cells_to_be_activ_list_l,
                    cells_to_be_barred_list_l,
                    cells_to_be_deactiv_list_l,
                    extended_gnb_cu_name_s,
                    fixed_bitstring<10, false, true>,
                    gnb_cu_tnl_assoc_to_add_list_l,
                    gnb_cu_tnl_assoc_to_rem_list_l,
                    gnb_cu_tnl_assoc_to_upd_list_l,
                    neighbour_cell_info_list_l,
                    printable_string<1, 150, true, true>,
                    protected_eutra_res_list_l,
                    transport_layer_address_info_s,
                    ul_bh_non_up_traffic_map_s>
        c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// GNBDUConfigurationUpdateAcknowledgeIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct gnb_du_cfg_upd_ack_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options {
        transaction_id,
        cells_to_be_activ_list,
        crit_diagnostics,
        cells_to_be_deactiv_list,
        transport_layer_address_info,
        ul_bh_non_up_traffic_map,
        bap_address,
        cells_for_son_list,
        nulltype
      } value;
      typedef uint8_t number_type;

      const char* to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint16_t&                               transaction_id();
    cells_to_be_activ_list_l&               cells_to_be_activ_list();
    crit_diagnostics_s&                     crit_diagnostics();
    cells_to_be_deactiv_list_l&             cells_to_be_deactiv_list();
    transport_layer_address_info_s&         transport_layer_address_info();
    ul_bh_non_up_traffic_map_s&             ul_bh_non_up_traffic_map();
    fixed_bitstring<10, false, true>&       bap_address();
    cells_for_son_list_l&                   cells_for_son_list();
    const uint16_t&                         transaction_id() const;
    const cells_to_be_activ_list_l&         cells_to_be_activ_list() const;
    const crit_diagnostics_s&               crit_diagnostics() const;
    const cells_to_be_deactiv_list_l&       cells_to_be_deactiv_list() const;
    const transport_layer_address_info_s&   transport_layer_address_info() const;
    const ul_bh_non_up_traffic_map_s&       ul_bh_non_up_traffic_map() const;
    const fixed_bitstring<10, false, true>& bap_address() const;
    const cells_for_son_list_l&             cells_for_son_list() const;

  private:
    types type_;
    choice_buffer_t<cells_for_son_list_l,
                    cells_to_be_activ_list_l,
                    cells_to_be_deactiv_list_l,
                    crit_diagnostics_s,
                    fixed_bitstring<10, false, true>,
                    transport_layer_address_info_s,
                    ul_bh_non_up_traffic_map_s>
        c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// GNBDUConfigurationUpdateFailureIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct gnb_du_cfg_upd_fail_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { transaction_id, cause, time_to_wait, crit_diagnostics, nulltype } value;
      typedef uint8_t number_type;

      const char* to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint16_t&                 transaction_id();
    cause_c&                  cause();
    time_to_wait_e&           time_to_wait();
    crit_diagnostics_s&       crit_diagnostics();
    const uint16_t&           transaction_id() const;
    const cause_c&            cause() const;
    const time_to_wait_e&     time_to_wait() const;
    const crit_diagnostics_s& crit_diagnostics() const;

  private:
    types                                        type_;
    choice_buffer_t<cause_c, crit_diagnostics_s> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// GNBDUConfigurationUpdateIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct gnb_du_cfg_upd_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options {
        transaction_id,
        served_cells_to_add_list,
        served_cells_to_modify_list,
        served_cells_to_delete_list,
        cells_status_list,
        ded_si_delivery_needed_ue_list,
        gnb_du_id,
        gnb_du_tnl_assoc_to_rem_list,
        transport_layer_address_info,
        coverage_mod_notif,
        gnb_du_name,
        extended_gnb_du_name,
        nulltype
      } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint16_t&                                   transaction_id();
    served_cells_to_add_list_l&                 served_cells_to_add_list();
    served_cells_to_modify_list_l&              served_cells_to_modify_list();
    served_cells_to_delete_list_l&              served_cells_to_delete_list();
    cells_status_list_l&                        cells_status_list();
    ded_si_delivery_needed_ue_list_l&           ded_si_delivery_needed_ue_list();
    uint64_t&                                   gnb_du_id();
    gnb_du_tnl_assoc_to_rem_list_l&             gnb_du_tnl_assoc_to_rem_list();
    transport_layer_address_info_s&             transport_layer_address_info();
    coverage_mod_notif_s&                       coverage_mod_notif();
    printable_string<1, 150, true, true>&       gnb_du_name();
    extended_gnb_du_name_s&                     extended_gnb_du_name();
    const uint16_t&                             transaction_id() const;
    const served_cells_to_add_list_l&           served_cells_to_add_list() const;
    const served_cells_to_modify_list_l&        served_cells_to_modify_list() const;
    const served_cells_to_delete_list_l&        served_cells_to_delete_list() const;
    const cells_status_list_l&                  cells_status_list() const;
    const ded_si_delivery_needed_ue_list_l&     ded_si_delivery_needed_ue_list() const;
    const uint64_t&                             gnb_du_id() const;
    const gnb_du_tnl_assoc_to_rem_list_l&       gnb_du_tnl_assoc_to_rem_list() const;
    const transport_layer_address_info_s&       transport_layer_address_info() const;
    const coverage_mod_notif_s&                 coverage_mod_notif() const;
    const printable_string<1, 150, true, true>& gnb_du_name() const;
    const extended_gnb_du_name_s&               extended_gnb_du_name() const;

  private:
    types type_;
    choice_buffer_t<cells_status_list_l,
                    coverage_mod_notif_s,
                    ded_si_delivery_needed_ue_list_l,
                    extended_gnb_du_name_s,
                    gnb_du_tnl_assoc_to_rem_list_l,
                    printable_string<1, 150, true, true>,
                    served_cells_to_add_list_l,
                    served_cells_to_delete_list_l,
                    served_cells_to_modify_list_l,
                    transport_layer_address_info_s>
        c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// GNBDUResourceConfigurationAcknowledgeIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct gnb_du_res_cfg_ack_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { transaction_id, crit_diagnostics, nulltype } value;
      typedef uint8_t number_type;

      const char* to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint16_t&                 transaction_id();
    crit_diagnostics_s&       crit_diagnostics();
    const uint16_t&           transaction_id() const;
    const crit_diagnostics_s& crit_diagnostics() const;

  private:
    types                               type_;
    choice_buffer_t<crit_diagnostics_s> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// GNBDUResourceConfigurationFailureIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct gnb_du_res_cfg_fail_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { transaction_id, cause, time_to_wait, crit_diagnostics, nulltype } value;
      typedef uint8_t number_type;

      const char* to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint16_t&                 transaction_id();
    cause_c&                  cause();
    time_to_wait_e&           time_to_wait();
    crit_diagnostics_s&       crit_diagnostics();
    const uint16_t&           transaction_id() const;
    const cause_c&            cause() const;
    const time_to_wait_e&     time_to_wait() const;
    const crit_diagnostics_s& crit_diagnostics() const;

  private:
    types                                        type_;
    choice_buffer_t<cause_c, crit_diagnostics_s> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// GNBDUResourceConfigurationIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct gnb_du_res_cfg_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options {
        transaction_id,
        activ_cells_to_be_upd_list,
        child_nodes_list,
        neighbour_node_cells_list,
        serving_cells_list,
        nulltype
      } value;
      typedef uint8_t number_type;

      const char* to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint16_t&                           transaction_id();
    activ_cells_to_be_upd_list_l&       activ_cells_to_be_upd_list();
    child_nodes_list_l&                 child_nodes_list();
    neighbour_node_cells_list_l&        neighbour_node_cells_list();
    serving_cells_list_l&               serving_cells_list();
    const uint16_t&                     transaction_id() const;
    const activ_cells_to_be_upd_list_l& activ_cells_to_be_upd_list() const;
    const child_nodes_list_l&           child_nodes_list() const;
    const neighbour_node_cells_list_l&  neighbour_node_cells_list() const;
    const serving_cells_list_l&         serving_cells_list() const;

  private:
    types type_;
    choice_buffer_t<activ_cells_to_be_upd_list_l, child_nodes_list_l, neighbour_node_cells_list_l, serving_cells_list_l>
        c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// GNBDUResourceCoordinationRequest-IEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct gnb_du_res_coordination_request_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options {
        transaction_id,
        request_type,
        eutra_nr_cell_res_coordination_req_container,
        ignore_res_coordination_container,
        nulltype
      } value;
      typedef uint8_t number_type;

      const char* to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint16_t&                                  transaction_id();
    request_type_e&                            request_type();
    unbounded_octstring<true>&                 eutra_nr_cell_res_coordination_req_container();
    ignore_res_coordination_container_e&       ignore_res_coordination_container();
    const uint16_t&                            transaction_id() const;
    const request_type_e&                      request_type() const;
    const unbounded_octstring<true>&           eutra_nr_cell_res_coordination_req_container() const;
    const ignore_res_coordination_container_e& ignore_res_coordination_container() const;

  private:
    types                                      type_;
    choice_buffer_t<unbounded_octstring<true>> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// GNBDUResourceCoordinationResponse-IEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct gnb_du_res_coordination_resp_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { transaction_id, eutra_nr_cell_res_coordination_req_ack_container, nulltype } value;
      typedef uint8_t number_type;

      const char* to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint16_t&                        transaction_id();
    unbounded_octstring<true>&       eutra_nr_cell_res_coordination_req_ack_container();
    const uint16_t&                  transaction_id() const;
    const unbounded_octstring<true>& eutra_nr_cell_res_coordination_req_ack_container() const;

  private:
    types                                      type_;
    choice_buffer_t<unbounded_octstring<true>> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// GNBDUStatusIndicationIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct gnb_du_status_ind_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { transaction_id, gnb_du_overload_info, iab_congestion_ind, nulltype } value;
      typedef uint8_t number_type;

      const char* to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint16_t&                     transaction_id();
    gnb_du_overload_info_e&       gnb_du_overload_info();
    iab_congestion_ind_s&         iab_congestion_ind();
    const uint16_t&               transaction_id() const;
    const gnb_du_overload_info_e& gnb_du_overload_info() const;
    const iab_congestion_ind_s&   iab_congestion_ind() const;

  private:
    types                                 type_;
    choice_buffer_t<iab_congestion_ind_s> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// IABTNLAddressFailureIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct iab_tnl_address_fail_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { transaction_id, cause, time_to_wait, crit_diagnostics, nulltype } value;
      typedef uint8_t number_type;

      const char* to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint16_t&                 transaction_id();
    cause_c&                  cause();
    time_to_wait_e&           time_to_wait();
    crit_diagnostics_s&       crit_diagnostics();
    const uint16_t&           transaction_id() const;
    const cause_c&            cause() const;
    const time_to_wait_e&     time_to_wait() const;
    const crit_diagnostics_s& crit_diagnostics() const;

  private:
    types                                        type_;
    choice_buffer_t<cause_c, crit_diagnostics_s> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// IABTNLAddressRequestIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct iab_tnl_address_request_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options {
        transaction_id,
        ia_bv4_addresses_requested,
        iab_ip_v6_request_type,
        iab_tnl_addresses_to_rem_list,
        iab_tnl_addresses_exception,
        nulltype
      } value;
      typedef uint8_t number_type;

      const char* to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint16_t&                              transaction_id();
    ia_bv4_addresses_requested_s&          ia_bv4_addresses_requested();
    iab_ip_v6_request_type_c&              iab_ip_v6_request_type();
    iab_tnl_addresses_to_rem_list_l&       iab_tnl_addresses_to_rem_list();
    iab_tnl_addresses_exception_s&         iab_tnl_addresses_exception();
    const uint16_t&                        transaction_id() const;
    const ia_bv4_addresses_requested_s&    ia_bv4_addresses_requested() const;
    const iab_ip_v6_request_type_c&        iab_ip_v6_request_type() const;
    const iab_tnl_addresses_to_rem_list_l& iab_tnl_addresses_to_rem_list() const;
    const iab_tnl_addresses_exception_s&   iab_tnl_addresses_exception() const;

  private:
    types type_;
    choice_buffer_t<ia_bv4_addresses_requested_s,
                    iab_ip_v6_request_type_c,
                    iab_tnl_addresses_exception_s,
                    iab_tnl_addresses_to_rem_list_l>
        c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// IABTNLAddressResponseIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct iab_tnl_address_resp_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { transaction_id, iab_allocated_tnl_address_list, nulltype } value;
      typedef uint8_t number_type;

      const char* to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint16_t&                               transaction_id();
    iab_allocated_tnl_address_list_l&       iab_allocated_tnl_address_list();
    const uint16_t&                         transaction_id() const;
    const iab_allocated_tnl_address_list_l& iab_allocated_tnl_address_list() const;

  private:
    types                                             type_;
    choice_buffer_t<iab_allocated_tnl_address_list_l> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// IABUPConfigurationUpdateFailureIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct iab_up_cfg_upd_fail_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { transaction_id, cause, time_to_wait, crit_diagnostics, nulltype } value;
      typedef uint8_t number_type;

      const char* to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint16_t&                 transaction_id();
    cause_c&                  cause();
    time_to_wait_e&           time_to_wait();
    crit_diagnostics_s&       crit_diagnostics();
    const uint16_t&           transaction_id() const;
    const cause_c&            cause() const;
    const time_to_wait_e&     time_to_wait() const;
    const crit_diagnostics_s& crit_diagnostics() const;

  private:
    types                                        type_;
    choice_buffer_t<cause_c, crit_diagnostics_s> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// IABUPConfigurationUpdateRequestIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct iab_up_cfg_upd_request_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { transaction_id, ul_up_tnl_info_to_upd_list, ul_up_tnl_address_to_upd_list, nulltype } value;
      typedef uint8_t number_type;

      const char* to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint16_t&                              transaction_id();
    ul_up_tnl_info_to_upd_list_l&          ul_up_tnl_info_to_upd_list();
    ul_up_tnl_address_to_upd_list_l&       ul_up_tnl_address_to_upd_list();
    const uint16_t&                        transaction_id() const;
    const ul_up_tnl_info_to_upd_list_l&    ul_up_tnl_info_to_upd_list() const;
    const ul_up_tnl_address_to_upd_list_l& ul_up_tnl_address_to_upd_list() const;

  private:
    types                                                                          type_;
    choice_buffer_t<ul_up_tnl_address_to_upd_list_l, ul_up_tnl_info_to_upd_list_l> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// IABUPConfigurationUpdateResponseIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct iab_up_cfg_upd_resp_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { transaction_id, crit_diagnostics, dl_up_tnl_address_to_upd_list, nulltype } value;
      typedef uint8_t number_type;

      const char* to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint16_t&                              transaction_id();
    crit_diagnostics_s&                    crit_diagnostics();
    dl_up_tnl_address_to_upd_list_l&       dl_up_tnl_address_to_upd_list();
    const uint16_t&                        transaction_id() const;
    const crit_diagnostics_s&              crit_diagnostics() const;
    const dl_up_tnl_address_to_upd_list_l& dl_up_tnl_address_to_upd_list() const;

  private:
    types                                                                type_;
    choice_buffer_t<crit_diagnostics_s, dl_up_tnl_address_to_upd_list_l> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// InitialULRRCMessageTransferIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct init_ul_rrc_msg_transfer_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options {
        gnb_du_ue_f1ap_id,
        nr_cgi,
        c_rnti,
        rrc_container,
        du_to_cu_rrc_container,
        sul_access_ind,
        transaction_id,
        ran_ue_id,
        rrc_container_rrc_setup_complete,
        nr_red_cap_ue_ind,
        sdt_info,
        sidelink_relay_cfg,
        nulltype
      } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint64_t&                        gnb_du_ue_f1ap_id();
    nr_cgi_s&                        nr_cgi();
    uint32_t&                        c_rnti();
    unbounded_octstring<true>&       rrc_container();
    unbounded_octstring<true>&       du_to_cu_rrc_container();
    sul_access_ind_e&                sul_access_ind();
    uint16_t&                        transaction_id();
    fixed_octstring<8, true>&        ran_ue_id();
    unbounded_octstring<true>&       rrc_container_rrc_setup_complete();
    nr_red_cap_ue_ind_e&             nr_red_cap_ue_ind();
    sdt_info_s&                      sdt_info();
    sidelink_relay_cfg_s&            sidelink_relay_cfg();
    const uint64_t&                  gnb_du_ue_f1ap_id() const;
    const nr_cgi_s&                  nr_cgi() const;
    const uint32_t&                  c_rnti() const;
    const unbounded_octstring<true>& rrc_container() const;
    const unbounded_octstring<true>& du_to_cu_rrc_container() const;
    const sul_access_ind_e&          sul_access_ind() const;
    const uint16_t&                  transaction_id() const;
    const fixed_octstring<8, true>&  ran_ue_id() const;
    const unbounded_octstring<true>& rrc_container_rrc_setup_complete() const;
    const nr_red_cap_ue_ind_e&       nr_red_cap_ue_ind() const;
    const sdt_info_s&                sdt_info() const;
    const sidelink_relay_cfg_s&      sidelink_relay_cfg() const;

  private:
    types type_;
    choice_buffer_t<fixed_octstring<8, true>, nr_cgi_s, sdt_info_s, sidelink_relay_cfg_s, unbounded_octstring<true>> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// MeasurementActivation-IEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct meas_activation_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options {
        gnb_cu_ue_f1ap_id,
        gnb_du_ue_f1ap_id,
        activation_request_type,
        prs_meas_info_list,
        nulltype
      } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint64_t&                        gnb_cu_ue_f1ap_id();
    uint64_t&                        gnb_du_ue_f1ap_id();
    activation_request_type_e&       activation_request_type();
    prs_meas_info_list_l&            prs_meas_info_list();
    const uint64_t&                  gnb_cu_ue_f1ap_id() const;
    const uint64_t&                  gnb_du_ue_f1ap_id() const;
    const activation_request_type_e& activation_request_type() const;
    const prs_meas_info_list_l&      prs_meas_info_list() const;

  private:
    types                                 type_;
    choice_buffer_t<prs_meas_info_list_l> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// MeasurementPreconfigurationConfirm-IEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct meas_precfg_confirm_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options {
        gnb_cu_ue_f1ap_id,
        gnb_du_ue_f1ap_id,
        pos_meas_gap_pre_cfg_list,
        crit_diagnostics,
        nulltype
      } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint64_t&                          gnb_cu_ue_f1ap_id();
    uint64_t&                          gnb_du_ue_f1ap_id();
    pos_meas_gap_pre_cfg_list_s&       pos_meas_gap_pre_cfg_list();
    crit_diagnostics_s&                crit_diagnostics();
    const uint64_t&                    gnb_cu_ue_f1ap_id() const;
    const uint64_t&                    gnb_du_ue_f1ap_id() const;
    const pos_meas_gap_pre_cfg_list_s& pos_meas_gap_pre_cfg_list() const;
    const crit_diagnostics_s&          crit_diagnostics() const;

  private:
    types                                                            type_;
    choice_buffer_t<crit_diagnostics_s, pos_meas_gap_pre_cfg_list_s> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// MeasurementPreconfigurationRefuse-IEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct meas_precfg_refuse_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { gnb_cu_ue_f1ap_id, gnb_du_ue_f1ap_id, cause, crit_diagnostics, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint64_t&                 gnb_cu_ue_f1ap_id();
    uint64_t&                 gnb_du_ue_f1ap_id();
    cause_c&                  cause();
    crit_diagnostics_s&       crit_diagnostics();
    const uint64_t&           gnb_cu_ue_f1ap_id() const;
    const uint64_t&           gnb_du_ue_f1ap_id() const;
    const cause_c&            cause() const;
    const crit_diagnostics_s& crit_diagnostics() const;

  private:
    types                                        type_;
    choice_buffer_t<cause_c, crit_diagnostics_s> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// MeasurementPreconfigurationRequired-IEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct meas_precfg_required_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { gnb_cu_ue_f1ap_id, gnb_du_ue_f1ap_id, trp_prs_info_list, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint64_t&                  gnb_cu_ue_f1ap_id();
    uint64_t&                  gnb_du_ue_f1ap_id();
    trp_prs_info_list_l&       trp_prs_info_list();
    const uint64_t&            gnb_cu_ue_f1ap_id() const;
    const uint64_t&            gnb_du_ue_f1ap_id() const;
    const trp_prs_info_list_l& trp_prs_info_list() const;

  private:
    types                                type_;
    choice_buffer_t<trp_prs_info_list_l> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// MulticastContextModificationFailureIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct multicast_context_mod_fail_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { gnb_cu_mbs_f1ap_id, gnb_du_mbs_f1ap_id, cause, crit_diagnostics, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint64_t&                 gnb_cu_mbs_f1ap_id();
    uint64_t&                 gnb_du_mbs_f1ap_id();
    cause_c&                  cause();
    crit_diagnostics_s&       crit_diagnostics();
    const uint64_t&           gnb_cu_mbs_f1ap_id() const;
    const uint64_t&           gnb_du_mbs_f1ap_id() const;
    const cause_c&            cause() const;
    const crit_diagnostics_s& crit_diagnostics() const;

  private:
    types                                        type_;
    choice_buffer_t<cause_c, crit_diagnostics_s> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// MulticastContextModificationRequestIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct multicast_context_mod_request_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options {
        gnb_cu_mbs_f1ap_id,
        gnb_du_mbs_f1ap_id,
        mbs_service_area,
        multicast_m_rbs_to_be_setup_mod_list,
        multicast_m_rbs_to_be_modified_list,
        multicast_m_rbs_to_be_released_list,
        nulltype
      } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint64_t&                                     gnb_cu_mbs_f1ap_id();
    uint64_t&                                     gnb_du_mbs_f1ap_id();
    mbs_service_area_c&                           mbs_service_area();
    multicast_m_rbs_to_be_setup_mod_list_l&       multicast_m_rbs_to_be_setup_mod_list();
    multicast_m_rbs_to_be_modified_list_l&        multicast_m_rbs_to_be_modified_list();
    multicast_m_rbs_to_be_released_list_l&        multicast_m_rbs_to_be_released_list();
    const uint64_t&                               gnb_cu_mbs_f1ap_id() const;
    const uint64_t&                               gnb_du_mbs_f1ap_id() const;
    const mbs_service_area_c&                     mbs_service_area() const;
    const multicast_m_rbs_to_be_setup_mod_list_l& multicast_m_rbs_to_be_setup_mod_list() const;
    const multicast_m_rbs_to_be_modified_list_l&  multicast_m_rbs_to_be_modified_list() const;
    const multicast_m_rbs_to_be_released_list_l&  multicast_m_rbs_to_be_released_list() const;

  private:
    types type_;
    choice_buffer_t<mbs_service_area_c,
                    multicast_m_rbs_to_be_modified_list_l,
                    multicast_m_rbs_to_be_released_list_l,
                    multicast_m_rbs_to_be_setup_mod_list_l>
        c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// MulticastContextModificationResponseIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct multicast_context_mod_resp_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options {
        gnb_cu_mbs_f1ap_id,
        gnb_du_mbs_f1ap_id,
        multicast_m_rbs_setup_mod_list,
        multicast_m_rbs_failed_to_be_setup_mod_list,
        multicast_m_rbs_modified_list,
        multicast_m_rbs_failed_to_be_modified_list,
        crit_diagnostics,
        nulltype
      } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint64_t&                                            gnb_cu_mbs_f1ap_id();
    uint64_t&                                            gnb_du_mbs_f1ap_id();
    multicast_m_rbs_setup_mod_list_l&                    multicast_m_rbs_setup_mod_list();
    multicast_m_rbs_failed_to_be_setup_mod_list_l&       multicast_m_rbs_failed_to_be_setup_mod_list();
    multicast_m_rbs_modified_list_l&                     multicast_m_rbs_modified_list();
    multicast_m_rbs_failed_to_be_modified_list_l&        multicast_m_rbs_failed_to_be_modified_list();
    crit_diagnostics_s&                                  crit_diagnostics();
    const uint64_t&                                      gnb_cu_mbs_f1ap_id() const;
    const uint64_t&                                      gnb_du_mbs_f1ap_id() const;
    const multicast_m_rbs_setup_mod_list_l&              multicast_m_rbs_setup_mod_list() const;
    const multicast_m_rbs_failed_to_be_setup_mod_list_l& multicast_m_rbs_failed_to_be_setup_mod_list() const;
    const multicast_m_rbs_modified_list_l&               multicast_m_rbs_modified_list() const;
    const multicast_m_rbs_failed_to_be_modified_list_l&  multicast_m_rbs_failed_to_be_modified_list() const;
    const crit_diagnostics_s&                            crit_diagnostics() const;

  private:
    types type_;
    choice_buffer_t<crit_diagnostics_s,
                    multicast_m_rbs_failed_to_be_modified_list_l,
                    multicast_m_rbs_failed_to_be_setup_mod_list_l,
                    multicast_m_rbs_modified_list_l,
                    multicast_m_rbs_setup_mod_list_l>
        c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// MulticastContextReleaseCommandIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct multicast_context_release_cmd_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { gnb_cu_mbs_f1ap_id, gnb_du_mbs_f1ap_id, cause, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint64_t&       gnb_cu_mbs_f1ap_id();
    uint64_t&       gnb_du_mbs_f1ap_id();
    cause_c&        cause();
    const uint64_t& gnb_cu_mbs_f1ap_id() const;
    const uint64_t& gnb_du_mbs_f1ap_id() const;
    const cause_c&  cause() const;

  private:
    types                    type_;
    choice_buffer_t<cause_c> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// MulticastContextReleaseCompleteIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct multicast_context_release_complete_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { gnb_cu_mbs_f1ap_id, gnb_du_mbs_f1ap_id, crit_diagnostics, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint64_t&                 gnb_cu_mbs_f1ap_id();
    uint64_t&                 gnb_du_mbs_f1ap_id();
    crit_diagnostics_s&       crit_diagnostics();
    const uint64_t&           gnb_cu_mbs_f1ap_id() const;
    const uint64_t&           gnb_du_mbs_f1ap_id() const;
    const crit_diagnostics_s& crit_diagnostics() const;

  private:
    types                               type_;
    choice_buffer_t<crit_diagnostics_s> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// MulticastContextReleaseRequestIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct multicast_context_release_request_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { gnb_cu_mbs_f1ap_id, gnb_du_mbs_f1ap_id, cause, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint64_t&       gnb_cu_mbs_f1ap_id();
    uint64_t&       gnb_du_mbs_f1ap_id();
    cause_c&        cause();
    const uint64_t& gnb_cu_mbs_f1ap_id() const;
    const uint64_t& gnb_du_mbs_f1ap_id() const;
    const cause_c&  cause() const;

  private:
    types                    type_;
    choice_buffer_t<cause_c> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// MulticastContextSetupFailureIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct multicast_context_setup_fail_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { gnb_cu_mbs_f1ap_id, gnb_du_mbs_f1ap_id, cause, crit_diagnostics, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint64_t&                 gnb_cu_mbs_f1ap_id();
    uint64_t&                 gnb_du_mbs_f1ap_id();
    cause_c&                  cause();
    crit_diagnostics_s&       crit_diagnostics();
    const uint64_t&           gnb_cu_mbs_f1ap_id() const;
    const uint64_t&           gnb_du_mbs_f1ap_id() const;
    const cause_c&            cause() const;
    const crit_diagnostics_s& crit_diagnostics() const;

  private:
    types                                        type_;
    choice_buffer_t<cause_c, crit_diagnostics_s> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// MulticastContextSetupRequestIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct multicast_context_setup_request_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options {
        gnb_cu_mbs_f1ap_id,
        mbs_session_id,
        mbs_service_area,
        snssai,
        multicast_m_rbs_to_be_setup_list,
        nulltype
      } value;
      typedef uint8_t number_type;

      const char* to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint64_t&                                 gnb_cu_mbs_f1ap_id();
    mbs_session_id_s&                         mbs_session_id();
    mbs_service_area_c&                       mbs_service_area();
    snssai_s&                                 snssai();
    multicast_m_rbs_to_be_setup_list_l&       multicast_m_rbs_to_be_setup_list();
    const uint64_t&                           gnb_cu_mbs_f1ap_id() const;
    const mbs_session_id_s&                   mbs_session_id() const;
    const mbs_service_area_c&                 mbs_service_area() const;
    const snssai_s&                           snssai() const;
    const multicast_m_rbs_to_be_setup_list_l& multicast_m_rbs_to_be_setup_list() const;

  private:
    types                                                                                               type_;
    choice_buffer_t<mbs_service_area_c, mbs_session_id_s, multicast_m_rbs_to_be_setup_list_l, snssai_s> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// MulticastContextSetupResponseIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct multicast_context_setup_resp_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options {
        gnb_cu_mbs_f1ap_id,
        gnb_du_mbs_f1ap_id,
        multicast_m_rbs_setup_list,
        multicast_m_rbs_failed_to_be_setup_list,
        crit_diagnostics,
        nulltype
      } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint64_t&                                        gnb_cu_mbs_f1ap_id();
    uint64_t&                                        gnb_du_mbs_f1ap_id();
    multicast_m_rbs_setup_list_l&                    multicast_m_rbs_setup_list();
    multicast_m_rbs_failed_to_be_setup_list_l&       multicast_m_rbs_failed_to_be_setup_list();
    crit_diagnostics_s&                              crit_diagnostics();
    const uint64_t&                                  gnb_cu_mbs_f1ap_id() const;
    const uint64_t&                                  gnb_du_mbs_f1ap_id() const;
    const multicast_m_rbs_setup_list_l&              multicast_m_rbs_setup_list() const;
    const multicast_m_rbs_failed_to_be_setup_list_l& multicast_m_rbs_failed_to_be_setup_list() const;
    const crit_diagnostics_s&                        crit_diagnostics() const;

  private:
    types                                                                                                        type_;
    choice_buffer_t<crit_diagnostics_s, multicast_m_rbs_failed_to_be_setup_list_l, multicast_m_rbs_setup_list_l> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// MulticastDistributionReleaseCommandIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct multicast_distribution_release_cmd_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options {
        gnb_cu_mbs_f1ap_id,
        gnb_du_mbs_f1ap_id,
        mbs_multicast_f1_u_context_descriptor,
        cause,
        nulltype
      } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint64_t&                                      gnb_cu_mbs_f1ap_id();
    uint64_t&                                      gnb_du_mbs_f1ap_id();
    mbs_multicast_f1_u_context_descriptor_s&       mbs_multicast_f1_u_context_descriptor();
    cause_c&                                       cause();
    const uint64_t&                                gnb_cu_mbs_f1ap_id() const;
    const uint64_t&                                gnb_du_mbs_f1ap_id() const;
    const mbs_multicast_f1_u_context_descriptor_s& mbs_multicast_f1_u_context_descriptor() const;
    const cause_c&                                 cause() const;

  private:
    types                                                             type_;
    choice_buffer_t<cause_c, mbs_multicast_f1_u_context_descriptor_s> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// MulticastDistributionReleaseCompleteIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct multicast_distribution_release_complete_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options {
        gnb_cu_mbs_f1ap_id,
        gnb_du_mbs_f1ap_id,
        mbs_multicast_f1_u_context_descriptor,
        crit_diagnostics,
        nulltype
      } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint64_t&                                      gnb_cu_mbs_f1ap_id();
    uint64_t&                                      gnb_du_mbs_f1ap_id();
    mbs_multicast_f1_u_context_descriptor_s&       mbs_multicast_f1_u_context_descriptor();
    crit_diagnostics_s&                            crit_diagnostics();
    const uint64_t&                                gnb_cu_mbs_f1ap_id() const;
    const uint64_t&                                gnb_du_mbs_f1ap_id() const;
    const mbs_multicast_f1_u_context_descriptor_s& mbs_multicast_f1_u_context_descriptor() const;
    const crit_diagnostics_s&                      crit_diagnostics() const;

  private:
    types                                                                        type_;
    choice_buffer_t<crit_diagnostics_s, mbs_multicast_f1_u_context_descriptor_s> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// MulticastDistributionSetupFailureIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct multicast_distribution_setup_fail_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options {
        gnb_cu_mbs_f1ap_id,
        gnb_du_mbs_f1ap_id,
        mbs_multicast_f1_u_context_descriptor,
        cause,
        crit_diagnostics,
        nulltype
      } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint64_t&                                      gnb_cu_mbs_f1ap_id();
    uint64_t&                                      gnb_du_mbs_f1ap_id();
    mbs_multicast_f1_u_context_descriptor_s&       mbs_multicast_f1_u_context_descriptor();
    cause_c&                                       cause();
    crit_diagnostics_s&                            crit_diagnostics();
    const uint64_t&                                gnb_cu_mbs_f1ap_id() const;
    const uint64_t&                                gnb_du_mbs_f1ap_id() const;
    const mbs_multicast_f1_u_context_descriptor_s& mbs_multicast_f1_u_context_descriptor() const;
    const cause_c&                                 cause() const;
    const crit_diagnostics_s&                      crit_diagnostics() const;

  private:
    types                                                                                 type_;
    choice_buffer_t<cause_c, crit_diagnostics_s, mbs_multicast_f1_u_context_descriptor_s> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// MulticastDistributionSetupRequestIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct multicast_distribution_setup_request_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options {
        gnb_cu_mbs_f1ap_id,
        gnb_du_mbs_f1ap_id,
        mbs_multicast_f1_u_context_descriptor,
        multicast_f1_u_context_to_be_setup_list,
        nulltype
      } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint64_t&                                        gnb_cu_mbs_f1ap_id();
    uint64_t&                                        gnb_du_mbs_f1ap_id();
    mbs_multicast_f1_u_context_descriptor_s&         mbs_multicast_f1_u_context_descriptor();
    multicast_f1_u_context_to_be_setup_list_l&       multicast_f1_u_context_to_be_setup_list();
    const uint64_t&                                  gnb_cu_mbs_f1ap_id() const;
    const uint64_t&                                  gnb_du_mbs_f1ap_id() const;
    const mbs_multicast_f1_u_context_descriptor_s&   mbs_multicast_f1_u_context_descriptor() const;
    const multicast_f1_u_context_to_be_setup_list_l& multicast_f1_u_context_to_be_setup_list() const;

  private:
    types                                                                                               type_;
    choice_buffer_t<mbs_multicast_f1_u_context_descriptor_s, multicast_f1_u_context_to_be_setup_list_l> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// MulticastDistributionSetupResponseIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct multicast_distribution_setup_resp_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options {
        gnb_cu_mbs_f1ap_id,
        gnb_du_mbs_f1ap_id,
        mbs_multicast_f1_u_context_descriptor,
        multicast_f1_u_context_setup_list,
        multicast_f1_u_context_failed_to_be_setup_list,
        crit_diagnostics,
        multicast_f1_u_context_ref_cu,
        nulltype
      } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint64_t&                                               gnb_cu_mbs_f1ap_id();
    uint64_t&                                               gnb_du_mbs_f1ap_id();
    mbs_multicast_f1_u_context_descriptor_s&                mbs_multicast_f1_u_context_descriptor();
    multicast_f1_u_context_setup_list_l&                    multicast_f1_u_context_setup_list();
    multicast_f1_u_context_failed_to_be_setup_list_l&       multicast_f1_u_context_failed_to_be_setup_list();
    crit_diagnostics_s&                                     crit_diagnostics();
    fixed_octstring<4, true>&                               multicast_f1_u_context_ref_cu();
    const uint64_t&                                         gnb_cu_mbs_f1ap_id() const;
    const uint64_t&                                         gnb_du_mbs_f1ap_id() const;
    const mbs_multicast_f1_u_context_descriptor_s&          mbs_multicast_f1_u_context_descriptor() const;
    const multicast_f1_u_context_setup_list_l&              multicast_f1_u_context_setup_list() const;
    const multicast_f1_u_context_failed_to_be_setup_list_l& multicast_f1_u_context_failed_to_be_setup_list() const;
    const crit_diagnostics_s&                               crit_diagnostics() const;
    const fixed_octstring<4, true>&                         multicast_f1_u_context_ref_cu() const;

  private:
    types type_;
    choice_buffer_t<crit_diagnostics_s,
                    fixed_octstring<4, true>,
                    mbs_multicast_f1_u_context_descriptor_s,
                    multicast_f1_u_context_failed_to_be_setup_list_l,
                    multicast_f1_u_context_setup_list_l>
        c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// MulticastGroupPagingIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct multicast_group_paging_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { mbs_session_id, ue_id_list_for_paging_list, mc_paging_cell_list, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    mbs_session_id_s&                   mbs_session_id();
    ue_id_list_for_paging_list_l&       ue_id_list_for_paging_list();
    mc_paging_cell_list_l&              mc_paging_cell_list();
    const mbs_session_id_s&             mbs_session_id() const;
    const ue_id_list_for_paging_list_l& ue_id_list_for_paging_list() const;
    const mc_paging_cell_list_l&        mc_paging_cell_list() const;

  private:
    types                                                                                  type_;
    choice_buffer_t<mbs_session_id_s, mc_paging_cell_list_l, ue_id_list_for_paging_list_l> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// NetworkAccessRateReductionIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct network_access_rate_reduction_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { transaction_id, uac_assist_info, nulltype } value;
      typedef uint8_t number_type;

      const char* to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint16_t&                transaction_id();
    uac_assist_info_s&       uac_assist_info();
    const uint16_t&          transaction_id() const;
    const uac_assist_info_s& uac_assist_info() const;

  private:
    types                              type_;
    choice_buffer_t<uac_assist_info_s> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// NotifyIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct notify_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { gnb_cu_ue_f1ap_id, gnb_du_ue_f1ap_id, drb_notify_list, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint64_t&                gnb_cu_ue_f1ap_id();
    uint64_t&                gnb_du_ue_f1ap_id();
    drb_notify_list_l&       drb_notify_list();
    const uint64_t&          gnb_cu_ue_f1ap_id() const;
    const uint64_t&          gnb_du_ue_f1ap_id() const;
    const drb_notify_list_l& drb_notify_list() const;

  private:
    types                              type_;
    choice_buffer_t<drb_notify_list_l> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// PDCMeasurementFailureIndication-IEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct pdc_meas_fail_ind_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { gnb_cu_ue_f1ap_id, gnb_du_ue_f1ap_id, ran_ue_pdc_meas_id, cause, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint64_t&       gnb_cu_ue_f1ap_id();
    uint64_t&       gnb_du_ue_f1ap_id();
    uint8_t&        ran_ue_pdc_meas_id();
    cause_c&        cause();
    const uint64_t& gnb_cu_ue_f1ap_id() const;
    const uint64_t& gnb_du_ue_f1ap_id() const;
    const uint8_t&  ran_ue_pdc_meas_id() const;
    const cause_c&  cause() const;

  private:
    types                    type_;
    choice_buffer_t<cause_c> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// PDCMeasurementInitiationFailure-IEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct pdc_meas_initiation_fail_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options {
        gnb_cu_ue_f1ap_id,
        gnb_du_ue_f1ap_id,
        ran_ue_pdc_meas_id,
        cause,
        crit_diagnostics,
        nulltype
      } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint64_t&                 gnb_cu_ue_f1ap_id();
    uint64_t&                 gnb_du_ue_f1ap_id();
    uint8_t&                  ran_ue_pdc_meas_id();
    cause_c&                  cause();
    crit_diagnostics_s&       crit_diagnostics();
    const uint64_t&           gnb_cu_ue_f1ap_id() const;
    const uint64_t&           gnb_du_ue_f1ap_id() const;
    const uint8_t&            ran_ue_pdc_meas_id() const;
    const cause_c&            cause() const;
    const crit_diagnostics_s& crit_diagnostics() const;

  private:
    types                                        type_;
    choice_buffer_t<cause_c, crit_diagnostics_s> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// PDCMeasurementInitiationRequest-IEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct pdc_meas_initiation_request_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options {
        gnb_cu_ue_f1ap_id,
        gnb_du_ue_f1ap_id,
        ran_ue_pdc_meas_id,
        pdc_report_type,
        pdc_meas_periodicity,
        pdc_meas_quantities,
        nulltype
      } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint64_t&                     gnb_cu_ue_f1ap_id();
    uint64_t&                     gnb_du_ue_f1ap_id();
    uint8_t&                      ran_ue_pdc_meas_id();
    pdc_report_type_e&            pdc_report_type();
    pdc_meas_periodicity_e&       pdc_meas_periodicity();
    pdc_meas_quantities_l&        pdc_meas_quantities();
    const uint64_t&               gnb_cu_ue_f1ap_id() const;
    const uint64_t&               gnb_du_ue_f1ap_id() const;
    const uint8_t&                ran_ue_pdc_meas_id() const;
    const pdc_report_type_e&      pdc_report_type() const;
    const pdc_meas_periodicity_e& pdc_meas_periodicity() const;
    const pdc_meas_quantities_l&  pdc_meas_quantities() const;

  private:
    types                                  type_;
    choice_buffer_t<pdc_meas_quantities_l> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// PDCMeasurementInitiationResponse-IEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct pdc_meas_initiation_resp_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options {
        gnb_cu_ue_f1ap_id,
        gnb_du_ue_f1ap_id,
        ran_ue_pdc_meas_id,
        pdc_meas_result,
        crit_diagnostics,
        nulltype
      } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint64_t&                 gnb_cu_ue_f1ap_id();
    uint64_t&                 gnb_du_ue_f1ap_id();
    uint8_t&                  ran_ue_pdc_meas_id();
    pdc_meas_result_s&        pdc_meas_result();
    crit_diagnostics_s&       crit_diagnostics();
    const uint64_t&           gnb_cu_ue_f1ap_id() const;
    const uint64_t&           gnb_du_ue_f1ap_id() const;
    const uint8_t&            ran_ue_pdc_meas_id() const;
    const pdc_meas_result_s&  pdc_meas_result() const;
    const crit_diagnostics_s& crit_diagnostics() const;

  private:
    types                                                  type_;
    choice_buffer_t<crit_diagnostics_s, pdc_meas_result_s> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// PDCMeasurementReport-IEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct pdc_meas_report_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { gnb_cu_ue_f1ap_id, gnb_du_ue_f1ap_id, ran_ue_pdc_meas_id, pdc_meas_result, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint64_t&                gnb_cu_ue_f1ap_id();
    uint64_t&                gnb_du_ue_f1ap_id();
    uint8_t&                 ran_ue_pdc_meas_id();
    pdc_meas_result_s&       pdc_meas_result();
    const uint64_t&          gnb_cu_ue_f1ap_id() const;
    const uint64_t&          gnb_du_ue_f1ap_id() const;
    const uint8_t&           ran_ue_pdc_meas_id() const;
    const pdc_meas_result_s& pdc_meas_result() const;

  private:
    types                              type_;
    choice_buffer_t<pdc_meas_result_s> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// PDCMeasurementTerminationCommand-IEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct pdc_meas_termination_cmd_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { gnb_cu_ue_f1ap_id, gnb_du_ue_f1ap_id, ran_ue_pdc_meas_id, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint64_t&       gnb_cu_ue_f1ap_id();
    uint64_t&       gnb_du_ue_f1ap_id();
    uint8_t&        ran_ue_pdc_meas_id();
    const uint64_t& gnb_cu_ue_f1ap_id() const;
    const uint64_t& gnb_du_ue_f1ap_id() const;
    const uint8_t&  ran_ue_pdc_meas_id() const;

  private:
    types               type_;
    pod_choice_buffer_t c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// PRSConfigurationFailure-IEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct prs_cfg_fail_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { transaction_id, cause, crit_diagnostics, nulltype } value;
      typedef uint8_t number_type;

      const char* to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint16_t&                 transaction_id();
    cause_c&                  cause();
    crit_diagnostics_s&       crit_diagnostics();
    const uint16_t&           transaction_id() const;
    const cause_c&            cause() const;
    const crit_diagnostics_s& crit_diagnostics() const;

  private:
    types                                        type_;
    choice_buffer_t<cause_c, crit_diagnostics_s> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// PRSConfigurationRequest-IEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct prs_cfg_request_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { prs_cfg_request_type, prstrp_list, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    prs_cfg_request_type_e&       prs_cfg_request_type();
    prstrp_list_l&                prstrp_list();
    const prs_cfg_request_type_e& prs_cfg_request_type() const;
    const prstrp_list_l&          prstrp_list() const;

  private:
    types                          type_;
    choice_buffer_t<prstrp_list_l> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// PRSConfigurationResponse-IEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct prs_cfg_resp_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { transaction_id, prs_tx_trp_list, crit_diagnostics, nulltype } value;
      typedef uint8_t number_type;

      const char* to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint16_t&                 transaction_id();
    prs_tx_trp_list_l&        prs_tx_trp_list();
    crit_diagnostics_s&       crit_diagnostics();
    const uint16_t&           transaction_id() const;
    const prs_tx_trp_list_l&  prs_tx_trp_list() const;
    const crit_diagnostics_s& crit_diagnostics() const;

  private:
    types                                                  type_;
    choice_buffer_t<crit_diagnostics_s, prs_tx_trp_list_l> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// PWSCancelRequestIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct pws_cancel_request_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options {
        transaction_id,
        numof_broadcast_request,
        broadcast_to_be_cancelled_list,
        cancel_all_warning_msgs_ind,
        notif_info,
        nulltype
      } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint16_t&                               transaction_id();
    uint32_t&                               numof_broadcast_request();
    broadcast_to_be_cancelled_list_l&       broadcast_to_be_cancelled_list();
    cancel_all_warning_msgs_ind_e&          cancel_all_warning_msgs_ind();
    notif_info_s&                           notif_info();
    const uint16_t&                         transaction_id() const;
    const uint32_t&                         numof_broadcast_request() const;
    const broadcast_to_be_cancelled_list_l& broadcast_to_be_cancelled_list() const;
    const cancel_all_warning_msgs_ind_e&    cancel_all_warning_msgs_ind() const;
    const notif_info_s&                     notif_info() const;

  private:
    types                                                           type_;
    choice_buffer_t<broadcast_to_be_cancelled_list_l, notif_info_s> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// PWSCancelResponseIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct pws_cancel_resp_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { transaction_id, cells_broadcast_cancelled_list, crit_diagnostics, nulltype } value;
      typedef uint8_t number_type;

      const char* to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint16_t&                               transaction_id();
    cells_broadcast_cancelled_list_l&       cells_broadcast_cancelled_list();
    crit_diagnostics_s&                     crit_diagnostics();
    const uint16_t&                         transaction_id() const;
    const cells_broadcast_cancelled_list_l& cells_broadcast_cancelled_list() const;
    const crit_diagnostics_s&               crit_diagnostics() const;

  private:
    types                                                                 type_;
    choice_buffer_t<cells_broadcast_cancelled_list_l, crit_diagnostics_s> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// PWSFailureIndicationIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct pws_fail_ind_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { transaction_id, pws_failed_nr_cgi_list, nulltype } value;
      typedef uint8_t number_type;

      const char* to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint16_t&                       transaction_id();
    pws_failed_nr_cgi_list_l&       pws_failed_nr_cgi_list();
    const uint16_t&                 transaction_id() const;
    const pws_failed_nr_cgi_list_l& pws_failed_nr_cgi_list() const;

  private:
    types                                     type_;
    choice_buffer_t<pws_failed_nr_cgi_list_l> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// PWSRestartIndicationIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct pws_restart_ind_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { transaction_id, nr_cgi_list_for_restart_list, nulltype } value;
      typedef uint8_t number_type;

      const char* to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint16_t&                             transaction_id();
    nr_cgi_list_for_restart_list_l&       nr_cgi_list_for_restart_list();
    const uint16_t&                       transaction_id() const;
    const nr_cgi_list_for_restart_list_l& nr_cgi_list_for_restart_list() const;

  private:
    types                                           type_;
    choice_buffer_t<nr_cgi_list_for_restart_list_l> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// PagingIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct paging_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options {
        ue_id_idx_value,
        paging_id,
        paging_drx,
        paging_prio,
        paging_cell_list,
        paging_origin,
        ran_ue_paging_drx,
        cn_ue_paging_drx,
        nr_paginge_drx_info,
        nr_paginge_drx_infofor_rrc_inactive,
        paging_cause,
        pe_ip_s_assist_info,
        ue_paging_cap,
        extended_ue_id_idx_value,
        nulltype
      } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    ue_id_idx_value_c&                           ue_id_idx_value();
    paging_id_c&                                 paging_id();
    paging_drx_e&                                paging_drx();
    paging_prio_e&                               paging_prio();
    paging_cell_list_l&                          paging_cell_list();
    paging_origin_e&                             paging_origin();
    paging_drx_e&                                ran_ue_paging_drx();
    paging_drx_e&                                cn_ue_paging_drx();
    nr_paginge_drx_info_s&                       nr_paginge_drx_info();
    nr_paginge_drx_infofor_rrc_inactive_s&       nr_paginge_drx_infofor_rrc_inactive();
    paging_cause_e&                              paging_cause();
    pe_ip_s_assist_info_s&                       pe_ip_s_assist_info();
    ue_paging_cap_s&                             ue_paging_cap();
    fixed_bitstring<16, false, true>&            extended_ue_id_idx_value();
    const ue_id_idx_value_c&                     ue_id_idx_value() const;
    const paging_id_c&                           paging_id() const;
    const paging_drx_e&                          paging_drx() const;
    const paging_prio_e&                         paging_prio() const;
    const paging_cell_list_l&                    paging_cell_list() const;
    const paging_origin_e&                       paging_origin() const;
    const paging_drx_e&                          ran_ue_paging_drx() const;
    const paging_drx_e&                          cn_ue_paging_drx() const;
    const nr_paginge_drx_info_s&                 nr_paginge_drx_info() const;
    const nr_paginge_drx_infofor_rrc_inactive_s& nr_paginge_drx_infofor_rrc_inactive() const;
    const paging_cause_e&                        paging_cause() const;
    const pe_ip_s_assist_info_s&                 pe_ip_s_assist_info() const;
    const ue_paging_cap_s&                       ue_paging_cap() const;
    const fixed_bitstring<16, false, true>&      extended_ue_id_idx_value() const;

  private:
    types type_;
    choice_buffer_t<fixed_bitstring<16, false, true>,
                    nr_paginge_drx_info_s,
                    nr_paginge_drx_infofor_rrc_inactive_s,
                    paging_cell_list_l,
                    paging_id_c,
                    pe_ip_s_assist_info_s,
                    ue_id_idx_value_c,
                    ue_paging_cap_s>
        c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// PosSystemInformationDeliveryCommandIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct pos_sys_info_delivery_cmd_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { transaction_id, nr_cgi, pos_sitype_list, confirmed_ue_id, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint16_t&                transaction_id();
    nr_cgi_s&                nr_cgi();
    pos_sitype_list_l&       pos_sitype_list();
    uint64_t&                confirmed_ue_id();
    const uint16_t&          transaction_id() const;
    const nr_cgi_s&          nr_cgi() const;
    const pos_sitype_list_l& pos_sitype_list() const;
    const uint64_t&          confirmed_ue_id() const;

  private:
    types                                        type_;
    choice_buffer_t<nr_cgi_s, pos_sitype_list_l> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// PositioningActivationFailureIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct positioning_activation_fail_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { gnb_cu_ue_f1ap_id, gnb_du_ue_f1ap_id, cause, crit_diagnostics, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint64_t&                 gnb_cu_ue_f1ap_id();
    uint64_t&                 gnb_du_ue_f1ap_id();
    cause_c&                  cause();
    crit_diagnostics_s&       crit_diagnostics();
    const uint64_t&           gnb_cu_ue_f1ap_id() const;
    const uint64_t&           gnb_du_ue_f1ap_id() const;
    const cause_c&            cause() const;
    const crit_diagnostics_s& crit_diagnostics() const;

  private:
    types                                        type_;
    choice_buffer_t<cause_c, crit_diagnostics_s> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// PositioningActivationRequestIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct positioning_activation_request_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { gnb_cu_ue_f1ap_id, gnb_du_ue_f1ap_id, srs_type, activation_time, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint64_t&                               gnb_cu_ue_f1ap_id();
    uint64_t&                               gnb_du_ue_f1ap_id();
    srs_type_c&                             srs_type();
    fixed_bitstring<64, false, true>&       activation_time();
    const uint64_t&                         gnb_cu_ue_f1ap_id() const;
    const uint64_t&                         gnb_du_ue_f1ap_id() const;
    const srs_type_c&                       srs_type() const;
    const fixed_bitstring<64, false, true>& activation_time() const;

  private:
    types                                                         type_;
    choice_buffer_t<fixed_bitstring<64, false, true>, srs_type_c> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// PositioningActivationResponseIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct positioning_activation_resp_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { gnb_cu_ue_f1ap_id, gnb_du_ue_f1ap_id, sys_frame_num, slot_num, crit_diagnostics, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint64_t&                 gnb_cu_ue_f1ap_id();
    uint64_t&                 gnb_du_ue_f1ap_id();
    uint16_t&                 sys_frame_num();
    uint8_t&                  slot_num();
    crit_diagnostics_s&       crit_diagnostics();
    const uint64_t&           gnb_cu_ue_f1ap_id() const;
    const uint64_t&           gnb_du_ue_f1ap_id() const;
    const uint16_t&           sys_frame_num() const;
    const uint8_t&            slot_num() const;
    const crit_diagnostics_s& crit_diagnostics() const;

  private:
    types                               type_;
    choice_buffer_t<crit_diagnostics_s> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// PositioningAssistanceInformationControlIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct positioning_assist_info_ctrl_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options {
        transaction_id,
        pos_assist_info,
        pos_broadcast,
        positioning_broadcast_cells,
        routing_id,
        nulltype
      } value;
      typedef uint8_t number_type;

      const char* to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint16_t&                            transaction_id();
    unbounded_octstring<true>&           pos_assist_info();
    pos_broadcast_e&                     pos_broadcast();
    positioning_broadcast_cells_l&       positioning_broadcast_cells();
    unbounded_octstring<true>&           routing_id();
    const uint16_t&                      transaction_id() const;
    const unbounded_octstring<true>&     pos_assist_info() const;
    const pos_broadcast_e&               pos_broadcast() const;
    const positioning_broadcast_cells_l& positioning_broadcast_cells() const;
    const unbounded_octstring<true>&     routing_id() const;

  private:
    types                                                                     type_;
    choice_buffer_t<positioning_broadcast_cells_l, unbounded_octstring<true>> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// PositioningAssistanceInformationFeedbackIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct positioning_assist_info_feedback_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options {
        transaction_id,
        pos_assist_info_fail_list,
        positioning_broadcast_cells,
        routing_id,
        crit_diagnostics,
        nulltype
      } value;
      typedef uint8_t number_type;

      const char* to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint16_t&                            transaction_id();
    unbounded_octstring<true>&           pos_assist_info_fail_list();
    positioning_broadcast_cells_l&       positioning_broadcast_cells();
    unbounded_octstring<true>&           routing_id();
    crit_diagnostics_s&                  crit_diagnostics();
    const uint16_t&                      transaction_id() const;
    const unbounded_octstring<true>&     pos_assist_info_fail_list() const;
    const positioning_broadcast_cells_l& positioning_broadcast_cells() const;
    const unbounded_octstring<true>&     routing_id() const;
    const crit_diagnostics_s&            crit_diagnostics() const;

  private:
    types                                                                                         type_;
    choice_buffer_t<crit_diagnostics_s, positioning_broadcast_cells_l, unbounded_octstring<true>> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// PositioningDeactivationIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct positioning_deactivation_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { gnb_cu_ue_f1ap_id, gnb_du_ue_f1ap_id, abort_tx, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint64_t&         gnb_cu_ue_f1ap_id();
    uint64_t&         gnb_du_ue_f1ap_id();
    abort_tx_c&       abort_tx();
    const uint64_t&   gnb_cu_ue_f1ap_id() const;
    const uint64_t&   gnb_du_ue_f1ap_id() const;
    const abort_tx_c& abort_tx() const;

  private:
    types                       type_;
    choice_buffer_t<abort_tx_c> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// PositioningInformationFailureIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct positioning_info_fail_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { gnb_cu_ue_f1ap_id, gnb_du_ue_f1ap_id, cause, crit_diagnostics, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint64_t&                 gnb_cu_ue_f1ap_id();
    uint64_t&                 gnb_du_ue_f1ap_id();
    cause_c&                  cause();
    crit_diagnostics_s&       crit_diagnostics();
    const uint64_t&           gnb_cu_ue_f1ap_id() const;
    const uint64_t&           gnb_du_ue_f1ap_id() const;
    const cause_c&            cause() const;
    const crit_diagnostics_s& crit_diagnostics() const;

  private:
    types                                        type_;
    choice_buffer_t<cause_c, crit_diagnostics_s> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// PositioningInformationRequestIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct positioning_info_request_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options {
        gnb_cu_ue_f1ap_id,
        gnb_du_ue_f1ap_id,
        requested_srs_tx_characteristics,
        ue_report_info,
        srs_pos_rrc_inactive_query_ind,
        nulltype
      } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint64_t&                                 gnb_cu_ue_f1ap_id();
    uint64_t&                                 gnb_du_ue_f1ap_id();
    requested_srs_tx_characteristics_s&       requested_srs_tx_characteristics();
    ue_report_info_s&                         ue_report_info();
    srs_pos_rrc_inactive_query_ind_e&         srs_pos_rrc_inactive_query_ind();
    const uint64_t&                           gnb_cu_ue_f1ap_id() const;
    const uint64_t&                           gnb_du_ue_f1ap_id() const;
    const requested_srs_tx_characteristics_s& requested_srs_tx_characteristics() const;
    const ue_report_info_s&                   ue_report_info() const;
    const srs_pos_rrc_inactive_query_ind_e&   srs_pos_rrc_inactive_query_ind() const;

  private:
    types                                                                 type_;
    choice_buffer_t<requested_srs_tx_characteristics_s, ue_report_info_s> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// PositioningInformationResponseIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct positioning_info_resp_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options {
        gnb_cu_ue_f1ap_id,
        gnb_du_ue_f1ap_id,
        srs_cfg,
        sfn_initisation_time,
        crit_diagnostics,
        srs_pos_rrc_inactive_cfg,
        nulltype
      } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint64_t&                               gnb_cu_ue_f1ap_id();
    uint64_t&                               gnb_du_ue_f1ap_id();
    srs_cfg_s&                              srs_cfg();
    fixed_bitstring<64, false, true>&       sfn_initisation_time();
    crit_diagnostics_s&                     crit_diagnostics();
    unbounded_octstring<true>&              srs_pos_rrc_inactive_cfg();
    const uint64_t&                         gnb_cu_ue_f1ap_id() const;
    const uint64_t&                         gnb_du_ue_f1ap_id() const;
    const srs_cfg_s&                        srs_cfg() const;
    const fixed_bitstring<64, false, true>& sfn_initisation_time() const;
    const crit_diagnostics_s&               crit_diagnostics() const;
    const unbounded_octstring<true>&        srs_pos_rrc_inactive_cfg() const;

  private:
    types                                                                                                       type_;
    choice_buffer_t<crit_diagnostics_s, fixed_bitstring<64, false, true>, srs_cfg_s, unbounded_octstring<true>> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// PositioningInformationUpdateIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct positioning_info_upd_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { gnb_cu_ue_f1ap_id, gnb_du_ue_f1ap_id, srs_cfg, sfn_initisation_time, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint64_t&                               gnb_cu_ue_f1ap_id();
    uint64_t&                               gnb_du_ue_f1ap_id();
    srs_cfg_s&                              srs_cfg();
    fixed_bitstring<64, false, true>&       sfn_initisation_time();
    const uint64_t&                         gnb_cu_ue_f1ap_id() const;
    const uint64_t&                         gnb_du_ue_f1ap_id() const;
    const srs_cfg_s&                        srs_cfg() const;
    const fixed_bitstring<64, false, true>& sfn_initisation_time() const;

  private:
    types                                                        type_;
    choice_buffer_t<fixed_bitstring<64, false, true>, srs_cfg_s> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// PositioningMeasurementAbortIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct positioning_meas_abort_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { transaction_id, lmf_meas_id, ran_meas_id, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint16_t&       transaction_id();
    uint32_t&       lmf_meas_id();
    uint32_t&       ran_meas_id();
    const uint16_t& transaction_id() const;
    const uint32_t& lmf_meas_id() const;
    const uint32_t& ran_meas_id() const;

  private:
    types               type_;
    pod_choice_buffer_t c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// PositioningMeasurementFailureIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct positioning_meas_fail_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { transaction_id, lmf_meas_id, ran_meas_id, cause, crit_diagnostics, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint16_t&                 transaction_id();
    uint32_t&                 lmf_meas_id();
    uint32_t&                 ran_meas_id();
    cause_c&                  cause();
    crit_diagnostics_s&       crit_diagnostics();
    const uint16_t&           transaction_id() const;
    const uint32_t&           lmf_meas_id() const;
    const uint32_t&           ran_meas_id() const;
    const cause_c&            cause() const;
    const crit_diagnostics_s& crit_diagnostics() const;

  private:
    types                                        type_;
    choice_buffer_t<cause_c, crit_diagnostics_s> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// PositioningMeasurementFailureIndicationIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct positioning_meas_fail_ind_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { transaction_id, lmf_meas_id, ran_meas_id, cause, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint16_t&       transaction_id();
    uint32_t&       lmf_meas_id();
    uint32_t&       ran_meas_id();
    cause_c&        cause();
    const uint16_t& transaction_id() const;
    const uint32_t& lmf_meas_id() const;
    const uint32_t& ran_meas_id() const;
    const cause_c&  cause() const;

  private:
    types                    type_;
    choice_buffer_t<cause_c> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// PositioningMeasurementReportIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct positioning_meas_report_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { transaction_id, lmf_meas_id, ran_meas_id, pos_meas_result_list, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint16_t&                     transaction_id();
    uint32_t&                     lmf_meas_id();
    uint32_t&                     ran_meas_id();
    pos_meas_result_list_l&       pos_meas_result_list();
    const uint16_t&               transaction_id() const;
    const uint32_t&               lmf_meas_id() const;
    const uint32_t&               ran_meas_id() const;
    const pos_meas_result_list_l& pos_meas_result_list() const;

  private:
    types                                   type_;
    choice_buffer_t<pos_meas_result_list_l> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// PositioningMeasurementRequestIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct positioning_meas_request_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options {
        transaction_id,
        lmf_meas_id,
        ran_meas_id,
        trp_meas_request_list,
        pos_report_characteristics,
        pos_meas_periodicity,
        pos_meas_quantities,
        sfn_initisation_time,
        srs_cfg,
        meas_beam_info_request,
        sys_frame_num,
        slot_num,
        pos_meas_periodicity_extended,
        resp_time,
        meas_characteristics_request_ind,
        meas_time_occasion,
        pos_meas_amount,
        nulltype
      } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint16_t&                               transaction_id();
    uint32_t&                               lmf_meas_id();
    uint32_t&                               ran_meas_id();
    trp_meas_request_list_l&                trp_meas_request_list();
    pos_report_characteristics_e&           pos_report_characteristics();
    meas_periodicity_e&                     pos_meas_periodicity();
    pos_meas_quantities_l&                  pos_meas_quantities();
    fixed_bitstring<64, false, true>&       sfn_initisation_time();
    srs_cfg_s&                              srs_cfg();
    meas_beam_info_request_e&               meas_beam_info_request();
    uint16_t&                               sys_frame_num();
    uint8_t&                                slot_num();
    meas_periodicity_extended_e&            pos_meas_periodicity_extended();
    resp_time_s&                            resp_time();
    fixed_bitstring<16, false, true>&       meas_characteristics_request_ind();
    meas_time_occasion_e&                   meas_time_occasion();
    pos_meas_amount_e&                      pos_meas_amount();
    const uint16_t&                         transaction_id() const;
    const uint32_t&                         lmf_meas_id() const;
    const uint32_t&                         ran_meas_id() const;
    const trp_meas_request_list_l&          trp_meas_request_list() const;
    const pos_report_characteristics_e&     pos_report_characteristics() const;
    const meas_periodicity_e&               pos_meas_periodicity() const;
    const pos_meas_quantities_l&            pos_meas_quantities() const;
    const fixed_bitstring<64, false, true>& sfn_initisation_time() const;
    const srs_cfg_s&                        srs_cfg() const;
    const meas_beam_info_request_e&         meas_beam_info_request() const;
    const uint16_t&                         sys_frame_num() const;
    const uint8_t&                          slot_num() const;
    const meas_periodicity_extended_e&      pos_meas_periodicity_extended() const;
    const resp_time_s&                      resp_time() const;
    const fixed_bitstring<16, false, true>& meas_characteristics_request_ind() const;
    const meas_time_occasion_e&             meas_time_occasion() const;
    const pos_meas_amount_e&                pos_meas_amount() const;

  private:
    types type_;
    choice_buffer_t<fixed_bitstring<64, false, true>,
                    pos_meas_quantities_l,
                    resp_time_s,
                    srs_cfg_s,
                    trp_meas_request_list_l>
        c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// PositioningMeasurementResponseIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct positioning_meas_resp_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { transaction_id, lmf_meas_id, ran_meas_id, pos_meas_result_list, crit_diagnostics, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint16_t&                     transaction_id();
    uint32_t&                     lmf_meas_id();
    uint32_t&                     ran_meas_id();
    pos_meas_result_list_l&       pos_meas_result_list();
    crit_diagnostics_s&           crit_diagnostics();
    const uint16_t&               transaction_id() const;
    const uint32_t&               lmf_meas_id() const;
    const uint32_t&               ran_meas_id() const;
    const pos_meas_result_list_l& pos_meas_result_list() const;
    const crit_diagnostics_s&     crit_diagnostics() const;

  private:
    types                                                       type_;
    choice_buffer_t<crit_diagnostics_s, pos_meas_result_list_l> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// PositioningMeasurementUpdateIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct positioning_meas_upd_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options {
        transaction_id,
        lmf_meas_id,
        ran_meas_id,
        srs_cfg,
        trp_meas_upd_list,
        meas_characteristics_request_ind,
        meas_time_occasion,
        nulltype
      } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint16_t&                               transaction_id();
    uint32_t&                               lmf_meas_id();
    uint32_t&                               ran_meas_id();
    srs_cfg_s&                              srs_cfg();
    trp_meas_upd_list_l&                    trp_meas_upd_list();
    fixed_bitstring<16, false, true>&       meas_characteristics_request_ind();
    meas_time_occasion_e&                   meas_time_occasion();
    const uint16_t&                         transaction_id() const;
    const uint32_t&                         lmf_meas_id() const;
    const uint32_t&                         ran_meas_id() const;
    const srs_cfg_s&                        srs_cfg() const;
    const trp_meas_upd_list_l&              trp_meas_upd_list() const;
    const fixed_bitstring<16, false, true>& meas_characteristics_request_ind() const;
    const meas_time_occasion_e&             meas_time_occasion() const;

  private:
    types                                                                             type_;
    choice_buffer_t<fixed_bitstring<16, false, true>, srs_cfg_s, trp_meas_upd_list_l> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// PrivateIE-Container{F1AP-PRIVATE-IES : IEsSetParam} ::= SEQUENCE (SIZE (1..65535)) OF PrivateIE-Field
template <class ies_set_paramT_>
using private_ie_container_l = dyn_seq_of<private_ie_field_s<ies_set_paramT_>, 1, 65535, true>;

struct f1ap_private_ies_empty_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    types       type() const { return types::nulltype; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
  };
};
// PrivateMessage-IEs ::= OBJECT SET OF F1AP-PRIVATE-IES
using private_msg_ies_o = f1ap_private_ies_empty_o;

// QoEInformationTransfer-IEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct qo_e_info_transfer_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { gnb_cu_ue_f1ap_id, gnb_du_ue_f1ap_id, qo_e_info, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint64_t&          gnb_cu_ue_f1ap_id();
    uint64_t&          gnb_du_ue_f1ap_id();
    qo_e_info_s&       qo_e_info();
    const uint64_t&    gnb_cu_ue_f1ap_id() const;
    const uint64_t&    gnb_du_ue_f1ap_id() const;
    const qo_e_info_s& qo_e_info() const;

  private:
    types                        type_;
    choice_buffer_t<qo_e_info_s> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// RRCDeliveryReportIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct rrc_delivery_report_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { gnb_cu_ue_f1ap_id, gnb_du_ue_f1ap_id, rrc_delivery_status, srb_id, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint64_t&                    gnb_cu_ue_f1ap_id();
    uint64_t&                    gnb_du_ue_f1ap_id();
    rrc_delivery_status_s&       rrc_delivery_status();
    uint8_t&                     srb_id();
    const uint64_t&              gnb_cu_ue_f1ap_id() const;
    const uint64_t&              gnb_du_ue_f1ap_id() const;
    const rrc_delivery_status_s& rrc_delivery_status() const;
    const uint8_t&               srb_id() const;

  private:
    types                                  type_;
    choice_buffer_t<rrc_delivery_status_s> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// ReferenceTimeInformationReportIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct ref_time_info_report_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { transaction_id, time_ref_info, nulltype } value;
      typedef uint8_t number_type;

      const char* to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint16_t&              transaction_id();
    time_ref_info_s&       time_ref_info();
    const uint16_t&        transaction_id() const;
    const time_ref_info_s& time_ref_info() const;

  private:
    types                            type_;
    choice_buffer_t<time_ref_info_s> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// ReferenceTimeInformationReportingControlIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct ref_time_info_report_ctrl_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { transaction_id, report_request_type, nulltype } value;
      typedef uint8_t number_type;

      const char* to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint16_t&                    transaction_id();
    report_request_type_s&       report_request_type();
    const uint16_t&              transaction_id() const;
    const report_request_type_s& report_request_type() const;

  private:
    types                                  type_;
    choice_buffer_t<report_request_type_s> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// ResetAcknowledgeIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct reset_ack_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { transaction_id, ue_associated_lc_f1_conn_list_res_ack, crit_diagnostics, nulltype } value;
      typedef uint8_t number_type;

      const char* to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint16_t&                                      transaction_id();
    ue_associated_lc_f1_conn_list_res_ack_l&       ue_associated_lc_f1_conn_list_res_ack();
    crit_diagnostics_s&                            crit_diagnostics();
    const uint16_t&                                transaction_id() const;
    const ue_associated_lc_f1_conn_list_res_ack_l& ue_associated_lc_f1_conn_list_res_ack() const;
    const crit_diagnostics_s&                      crit_diagnostics() const;

  private:
    types                                                                        type_;
    choice_buffer_t<crit_diagnostics_s, ue_associated_lc_f1_conn_list_res_ack_l> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// ResetIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct reset_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { transaction_id, cause, reset_type, nulltype } value;
      typedef uint8_t number_type;

      const char* to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint16_t&           transaction_id();
    cause_c&            cause();
    reset_type_c&       reset_type();
    const uint16_t&     transaction_id() const;
    const cause_c&      cause() const;
    const reset_type_c& reset_type() const;

  private:
    types                                  type_;
    choice_buffer_t<cause_c, reset_type_c> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// ResourceStatusFailureIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct res_status_fail_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { transaction_id, gnb_cu_meas_id, gnb_du_meas_id, cause, crit_diagnostics, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint16_t&                 transaction_id();
    uint16_t&                 gnb_cu_meas_id();
    uint16_t&                 gnb_du_meas_id();
    cause_c&                  cause();
    crit_diagnostics_s&       crit_diagnostics();
    const uint16_t&           transaction_id() const;
    const uint16_t&           gnb_cu_meas_id() const;
    const uint16_t&           gnb_du_meas_id() const;
    const cause_c&            cause() const;
    const crit_diagnostics_s& crit_diagnostics() const;

  private:
    types                                        type_;
    choice_buffer_t<cause_c, crit_diagnostics_s> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// ResourceStatusRequestIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct res_status_request_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options {
        transaction_id,
        gnb_cu_meas_id,
        gnb_du_meas_id,
        regist_request,
        report_characteristics,
        cell_to_report_list,
        report_periodicity,
        nulltype
      } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint16_t&                               transaction_id();
    uint16_t&                               gnb_cu_meas_id();
    uint16_t&                               gnb_du_meas_id();
    regist_request_e&                       regist_request();
    fixed_bitstring<32, false, true>&       report_characteristics();
    cell_to_report_list_l&                  cell_to_report_list();
    report_periodicity_e&                   report_periodicity();
    const uint16_t&                         transaction_id() const;
    const uint16_t&                         gnb_cu_meas_id() const;
    const uint16_t&                         gnb_du_meas_id() const;
    const regist_request_e&                 regist_request() const;
    const fixed_bitstring<32, false, true>& report_characteristics() const;
    const cell_to_report_list_l&            cell_to_report_list() const;
    const report_periodicity_e&             report_periodicity() const;

  private:
    types                                                                    type_;
    choice_buffer_t<cell_to_report_list_l, fixed_bitstring<32, false, true>> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// ResourceStatusResponseIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct res_status_resp_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { transaction_id, gnb_cu_meas_id, gnb_du_meas_id, crit_diagnostics, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint16_t&                 transaction_id();
    uint16_t&                 gnb_cu_meas_id();
    uint16_t&                 gnb_du_meas_id();
    crit_diagnostics_s&       crit_diagnostics();
    const uint16_t&           transaction_id() const;
    const uint16_t&           gnb_cu_meas_id() const;
    const uint16_t&           gnb_du_meas_id() const;
    const crit_diagnostics_s& crit_diagnostics() const;

  private:
    types                               type_;
    choice_buffer_t<crit_diagnostics_s> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// ResourceStatusUpdateIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct res_status_upd_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options {
        transaction_id,
        gnb_cu_meas_id,
        gnb_du_meas_id,
        hardware_load_ind,
        tnl_capacity_ind,
        cell_meas_result_list,
        nulltype
      } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint16_t&                      transaction_id();
    uint16_t&                      gnb_cu_meas_id();
    uint16_t&                      gnb_du_meas_id();
    hardware_load_ind_s&           hardware_load_ind();
    tnl_capacity_ind_s&            tnl_capacity_ind();
    cell_meas_result_list_l&       cell_meas_result_list();
    const uint16_t&                transaction_id() const;
    const uint16_t&                gnb_cu_meas_id() const;
    const uint16_t&                gnb_du_meas_id() const;
    const hardware_load_ind_s&     hardware_load_ind() const;
    const tnl_capacity_ind_s&      tnl_capacity_ind() const;
    const cell_meas_result_list_l& cell_meas_result_list() const;

  private:
    types                                                                             type_;
    choice_buffer_t<cell_meas_result_list_l, hardware_load_ind_s, tnl_capacity_ind_s> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// SystemInformationDeliveryCommandIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct sys_info_delivery_cmd_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { transaction_id, nr_cgi, sitype_list, confirmed_ue_id, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint16_t&            transaction_id();
    nr_cgi_s&            nr_cgi();
    sitype_list_l&       sitype_list();
    uint64_t&            confirmed_ue_id();
    const uint16_t&      transaction_id() const;
    const nr_cgi_s&      nr_cgi() const;
    const sitype_list_l& sitype_list() const;
    const uint64_t&      confirmed_ue_id() const;

  private:
    types                                    type_;
    choice_buffer_t<nr_cgi_s, sitype_list_l> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// TRPInformationFailureIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct trp_info_fail_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { transaction_id, cause, crit_diagnostics, nulltype } value;
      typedef uint8_t number_type;

      const char* to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint16_t&                 transaction_id();
    cause_c&                  cause();
    crit_diagnostics_s&       crit_diagnostics();
    const uint16_t&           transaction_id() const;
    const cause_c&            cause() const;
    const crit_diagnostics_s& crit_diagnostics() const;

  private:
    types                                        type_;
    choice_buffer_t<cause_c, crit_diagnostics_s> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// TRPInformationRequestIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct trp_info_request_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { transaction_id, trp_list, trp_info_type_list_trp_req, nulltype } value;
      typedef uint8_t number_type;

      const char* to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint16_t&                           transaction_id();
    trp_list_l&                         trp_list();
    trp_info_type_list_trp_req_l&       trp_info_type_list_trp_req();
    const uint16_t&                     transaction_id() const;
    const trp_list_l&                   trp_list() const;
    const trp_info_type_list_trp_req_l& trp_info_type_list_trp_req() const;

  private:
    types                                                     type_;
    choice_buffer_t<trp_info_type_list_trp_req_l, trp_list_l> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// TRPInformationResponseIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct trp_info_resp_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { transaction_id, trp_info_list_trp_resp, crit_diagnostics, nulltype } value;
      typedef uint8_t number_type;

      const char* to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint16_t&                       transaction_id();
    trp_info_list_trp_resp_l&       trp_info_list_trp_resp();
    crit_diagnostics_s&             crit_diagnostics();
    const uint16_t&                 transaction_id() const;
    const trp_info_list_trp_resp_l& trp_info_list_trp_resp() const;
    const crit_diagnostics_s&       crit_diagnostics() const;

  private:
    types                                                         type_;
    choice_buffer_t<crit_diagnostics_s, trp_info_list_trp_resp_l> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// TraceStartIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct trace_start_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { gnb_cu_ue_f1ap_id, gnb_du_ue_f1ap_id, trace_activation, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint64_t&                 gnb_cu_ue_f1ap_id();
    uint64_t&                 gnb_du_ue_f1ap_id();
    trace_activation_s&       trace_activation();
    const uint64_t&           gnb_cu_ue_f1ap_id() const;
    const uint64_t&           gnb_du_ue_f1ap_id() const;
    const trace_activation_s& trace_activation() const;

  private:
    types                               type_;
    choice_buffer_t<trace_activation_s> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// UEContextModificationConfirmIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct ue_context_mod_confirm_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options {
        gnb_cu_ue_f1ap_id,
        gnb_du_ue_f1ap_id,
        res_coordination_transfer_container,
        drbs_modified_conf_list,
        rrc_container,
        crit_diagnostics,
        execute_dupl,
        res_coordination_transfer_info,
        sl_drbs_modified_conf_list,
        uu_rlc_ch_modified_list,
        pc5_rlc_ch_modified_list,
        ue_multicast_m_rbs_confirmed_to_be_modified_list,
        nulltype
      } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint64_t&                                                 gnb_cu_ue_f1ap_id();
    uint64_t&                                                 gnb_du_ue_f1ap_id();
    unbounded_octstring<true>&                                res_coordination_transfer_container();
    drbs_modified_conf_list_l&                                drbs_modified_conf_list();
    unbounded_octstring<true>&                                rrc_container();
    crit_diagnostics_s&                                       crit_diagnostics();
    execute_dupl_e&                                           execute_dupl();
    res_coordination_transfer_info_s&                         res_coordination_transfer_info();
    sl_drbs_modified_conf_list_l&                             sl_drbs_modified_conf_list();
    uu_rlc_ch_modified_list_l&                                uu_rlc_ch_modified_list();
    pc5_rlc_ch_modified_list_l&                               pc5_rlc_ch_modified_list();
    ue_multicast_m_rbs_confirmed_to_be_modified_list_l&       ue_multicast_m_rbs_confirmed_to_be_modified_list();
    const uint64_t&                                           gnb_cu_ue_f1ap_id() const;
    const uint64_t&                                           gnb_du_ue_f1ap_id() const;
    const unbounded_octstring<true>&                          res_coordination_transfer_container() const;
    const drbs_modified_conf_list_l&                          drbs_modified_conf_list() const;
    const unbounded_octstring<true>&                          rrc_container() const;
    const crit_diagnostics_s&                                 crit_diagnostics() const;
    const execute_dupl_e&                                     execute_dupl() const;
    const res_coordination_transfer_info_s&                   res_coordination_transfer_info() const;
    const sl_drbs_modified_conf_list_l&                       sl_drbs_modified_conf_list() const;
    const uu_rlc_ch_modified_list_l&                          uu_rlc_ch_modified_list() const;
    const pc5_rlc_ch_modified_list_l&                         pc5_rlc_ch_modified_list() const;
    const ue_multicast_m_rbs_confirmed_to_be_modified_list_l& ue_multicast_m_rbs_confirmed_to_be_modified_list() const;

  private:
    types type_;
    choice_buffer_t<crit_diagnostics_s,
                    drbs_modified_conf_list_l,
                    pc5_rlc_ch_modified_list_l,
                    res_coordination_transfer_info_s,
                    sl_drbs_modified_conf_list_l,
                    ue_multicast_m_rbs_confirmed_to_be_modified_list_l,
                    unbounded_octstring<true>,
                    uu_rlc_ch_modified_list_l>
        c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// UEContextModificationFailureIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct ue_context_mod_fail_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options {
        gnb_cu_ue_f1ap_id,
        gnb_du_ue_f1ap_id,
        cause,
        crit_diagnostics,
        requested_target_cell_global_id,
        nulltype
      } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint64_t&                 gnb_cu_ue_f1ap_id();
    uint64_t&                 gnb_du_ue_f1ap_id();
    cause_c&                  cause();
    crit_diagnostics_s&       crit_diagnostics();
    nr_cgi_s&                 requested_target_cell_global_id();
    const uint64_t&           gnb_cu_ue_f1ap_id() const;
    const uint64_t&           gnb_du_ue_f1ap_id() const;
    const cause_c&            cause() const;
    const crit_diagnostics_s& crit_diagnostics() const;
    const nr_cgi_s&           requested_target_cell_global_id() const;

  private:
    types                                                  type_;
    choice_buffer_t<cause_c, crit_diagnostics_s, nr_cgi_s> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// UEContextModificationRefuseIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct ue_context_mod_refuse_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { gnb_cu_ue_f1ap_id, gnb_du_ue_f1ap_id, cause, crit_diagnostics, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint64_t&                 gnb_cu_ue_f1ap_id();
    uint64_t&                 gnb_du_ue_f1ap_id();
    cause_c&                  cause();
    crit_diagnostics_s&       crit_diagnostics();
    const uint64_t&           gnb_cu_ue_f1ap_id() const;
    const uint64_t&           gnb_du_ue_f1ap_id() const;
    const cause_c&            cause() const;
    const crit_diagnostics_s& crit_diagnostics() const;

  private:
    types                                        type_;
    choice_buffer_t<cause_c, crit_diagnostics_s> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// UEContextModificationRequestIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct ue_context_mod_request_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options {
        gnb_cu_ue_f1ap_id,
        gnb_du_ue_f1ap_id,
        sp_cell_id,
        serv_cell_idx,
        sp_cell_ul_cfg,
        drx_cycle,
        cu_to_du_rrc_info,
        tx_action_ind,
        res_coordination_transfer_container,
        rrc_recfg_complete_ind,
        rrc_container,
        scell_to_be_setup_mod_list,
        scell_to_be_remd_list,
        srbs_to_be_setup_mod_list,
        drbs_to_be_setup_mod_list,
        drbs_to_be_modified_list,
        srbs_to_be_released_list,
        drbs_to_be_released_list,
        inactivity_monitoring_request,
        rat_freq_prio_info,
        drx_cfg_ind,
        rlc_fail_ind,
        ul_tx_direct_current_list_info,
        gnb_du_cfg_query,
        gnb_du_ue_ambr_ul,
        execute_dupl,
        rrc_delivery_status_request,
        res_coordination_transfer_info,
        serving_cell_mo,
        needfor_gap,
        full_cfg,
        add_rrm_prio_idx,
        lower_layer_presence_status_change,
        bh_chs_to_be_setup_mod_list,
        bh_chs_to_be_modified_list,
        bh_chs_to_be_released_list,
        nr_v2x_services_authorized,
        ltev2x_services_authorized,
        nr_ue_sidelink_aggr_max_bitrate,
        lte_ue_sidelink_aggr_max_bitrate,
        pc5_link_ambr,
        sl_drbs_to_be_setup_mod_list,
        sl_drbs_to_be_modified_list,
        sl_drbs_to_be_released_list,
        conditional_intra_du_mob_info,
        f1_c_transfer_path,
        scg_ind,
        ul_tx_direct_current_two_carrier_list_info,
        iab_conditional_rrc_msg_delivery_ind,
        f1_c_transfer_path_nr_dc,
        mdt_polluted_meas_ind,
        scg_activation_request,
        cg_sdt_query_ind,
        five_g_pro_se_authorized,
        five_g_pro_se_ue_pc5_aggr_max_bitrate,
        five_g_pro_se_pc5_link_ambr,
        upd_remote_ue_local_id,
        uu_rlc_ch_to_be_setup_list,
        uu_rlc_ch_to_be_modified_list,
        uu_rlc_ch_to_be_released_list,
        pc5_rlc_ch_to_be_setup_list,
        pc5_rlc_ch_to_be_modified_list,
        pc5_rlc_ch_to_be_released_list,
        path_switch_cfg,
        gnb_du_ue_slice_max_bit_rate_list,
        multicast_mbs_session_setup_list,
        multicast_mbs_session_rem_list,
        ue_multicast_m_rbs_to_be_setup_at_modify_list,
        ue_multicast_m_rbs_to_be_released_list,
        sldrx_cycle_list,
        management_based_mdt_plmn_mod_list,
        sdt_bearer_cfg_query_ind,
        daps_ho_status,
        serving_cell_mo_list,
        ul_tx_direct_current_more_carrier_info,
        cp_acmcg_info,
        nulltype
      } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint64_t&                                              gnb_cu_ue_f1ap_id();
    uint64_t&                                              gnb_du_ue_f1ap_id();
    nr_cgi_s&                                              sp_cell_id();
    uint8_t&                                               serv_cell_idx();
    cell_ul_cfg_e&                                         sp_cell_ul_cfg();
    drx_cycle_s&                                           drx_cycle();
    cu_to_du_rrc_info_s&                                   cu_to_du_rrc_info();
    tx_action_ind_e&                                       tx_action_ind();
    unbounded_octstring<true>&                             res_coordination_transfer_container();
    rrc_recfg_complete_ind_e&                              rrc_recfg_complete_ind();
    unbounded_octstring<true>&                             rrc_container();
    scell_to_be_setup_mod_list_l&                          scell_to_be_setup_mod_list();
    scell_to_be_remd_list_l&                               scell_to_be_remd_list();
    srbs_to_be_setup_mod_list_l&                           srbs_to_be_setup_mod_list();
    drbs_to_be_setup_mod_list_l&                           drbs_to_be_setup_mod_list();
    drbs_to_be_modified_list_l&                            drbs_to_be_modified_list();
    srbs_to_be_released_list_l&                            srbs_to_be_released_list();
    drbs_to_be_released_list_l&                            drbs_to_be_released_list();
    inactivity_monitoring_request_e&                       inactivity_monitoring_request();
    rat_freq_prio_info_c&                                  rat_freq_prio_info();
    drx_cfg_ind_e&                                         drx_cfg_ind();
    rlc_fail_ind_s&                                        rlc_fail_ind();
    unbounded_octstring<true>&                             ul_tx_direct_current_list_info();
    gnb_du_cfg_query_e&                                    gnb_du_cfg_query();
    uint64_t&                                              gnb_du_ue_ambr_ul();
    execute_dupl_e&                                        execute_dupl();
    rrc_delivery_status_request_e&                         rrc_delivery_status_request();
    res_coordination_transfer_info_s&                      res_coordination_transfer_info();
    uint8_t&                                               serving_cell_mo();
    needfor_gap_e&                                         needfor_gap();
    full_cfg_e&                                            full_cfg();
    fixed_bitstring<32, false, true>&                      add_rrm_prio_idx();
    lower_layer_presence_status_change_e&                  lower_layer_presence_status_change();
    bh_chs_to_be_setup_mod_list_l&                         bh_chs_to_be_setup_mod_list();
    bh_chs_to_be_modified_list_l&                          bh_chs_to_be_modified_list();
    bh_chs_to_be_released_list_l&                          bh_chs_to_be_released_list();
    nr_v2x_services_authorized_s&                          nr_v2x_services_authorized();
    ltev2x_services_authorized_s&                          ltev2x_services_authorized();
    nr_ue_sidelink_aggr_max_bitrate_s&                     nr_ue_sidelink_aggr_max_bitrate();
    lte_ue_sidelink_aggr_max_bitrate_s&                    lte_ue_sidelink_aggr_max_bitrate();
    uint64_t&                                              pc5_link_ambr();
    sl_drbs_to_be_setup_mod_list_l&                        sl_drbs_to_be_setup_mod_list();
    sl_drbs_to_be_modified_list_l&                         sl_drbs_to_be_modified_list();
    sl_drbs_to_be_released_list_l&                         sl_drbs_to_be_released_list();
    conditional_intra_du_mob_info_s&                       conditional_intra_du_mob_info();
    f1_c_transfer_path_s&                                  f1_c_transfer_path();
    scg_ind_e&                                             scg_ind();
    unbounded_octstring<true>&                             ul_tx_direct_current_two_carrier_list_info();
    iab_conditional_rrc_msg_delivery_ind_e&                iab_conditional_rrc_msg_delivery_ind();
    f1_c_transfer_path_nr_dc_s&                            f1_c_transfer_path_nr_dc();
    mdt_polluted_meas_ind_e&                               mdt_polluted_meas_ind();
    scg_activation_request_e&                              scg_activation_request();
    cg_sdt_query_ind_e&                                    cg_sdt_query_ind();
    five_g_pro_se_authorized_s&                            five_g_pro_se_authorized();
    nr_ue_sidelink_aggr_max_bitrate_s&                     five_g_pro_se_ue_pc5_aggr_max_bitrate();
    uint64_t&                                              five_g_pro_se_pc5_link_ambr();
    uint16_t&                                              upd_remote_ue_local_id();
    uu_rlc_ch_to_be_setup_list_l&                          uu_rlc_ch_to_be_setup_list();
    uu_rlc_ch_to_be_modified_list_l&                       uu_rlc_ch_to_be_modified_list();
    uu_rlc_ch_to_be_released_list_l&                       uu_rlc_ch_to_be_released_list();
    pc5_rlc_ch_to_be_setup_list_l&                         pc5_rlc_ch_to_be_setup_list();
    pc5_rlc_ch_to_be_modified_list_l&                      pc5_rlc_ch_to_be_modified_list();
    pc5_rlc_ch_to_be_released_list_l&                      pc5_rlc_ch_to_be_released_list();
    path_switch_cfg_s&                                     path_switch_cfg();
    gnb_du_ue_slice_max_bit_rate_list_l&                   gnb_du_ue_slice_max_bit_rate_list();
    multicast_mbs_session_list_l&                          multicast_mbs_session_setup_list();
    multicast_mbs_session_list_l&                          multicast_mbs_session_rem_list();
    ue_multicast_m_rbs_to_be_setup_at_modify_list_l&       ue_multicast_m_rbs_to_be_setup_at_modify_list();
    ue_multicast_m_rbs_to_be_released_list_l&              ue_multicast_m_rbs_to_be_released_list();
    sldrx_cycle_list_l&                                    sldrx_cycle_list();
    mdt_plmn_mod_list_l&                                   management_based_mdt_plmn_mod_list();
    sdt_bearer_cfg_query_ind_e&                            sdt_bearer_cfg_query_ind();
    daps_ho_status_e&                                      daps_ho_status();
    serving_cell_mo_list_l&                                serving_cell_mo_list();
    unbounded_octstring<true>&                             ul_tx_direct_current_more_carrier_info();
    cp_acmcg_info_s&                                       cp_acmcg_info();
    const uint64_t&                                        gnb_cu_ue_f1ap_id() const;
    const uint64_t&                                        gnb_du_ue_f1ap_id() const;
    const nr_cgi_s&                                        sp_cell_id() const;
    const uint8_t&                                         serv_cell_idx() const;
    const cell_ul_cfg_e&                                   sp_cell_ul_cfg() const;
    const drx_cycle_s&                                     drx_cycle() const;
    const cu_to_du_rrc_info_s&                             cu_to_du_rrc_info() const;
    const tx_action_ind_e&                                 tx_action_ind() const;
    const unbounded_octstring<true>&                       res_coordination_transfer_container() const;
    const rrc_recfg_complete_ind_e&                        rrc_recfg_complete_ind() const;
    const unbounded_octstring<true>&                       rrc_container() const;
    const scell_to_be_setup_mod_list_l&                    scell_to_be_setup_mod_list() const;
    const scell_to_be_remd_list_l&                         scell_to_be_remd_list() const;
    const srbs_to_be_setup_mod_list_l&                     srbs_to_be_setup_mod_list() const;
    const drbs_to_be_setup_mod_list_l&                     drbs_to_be_setup_mod_list() const;
    const drbs_to_be_modified_list_l&                      drbs_to_be_modified_list() const;
    const srbs_to_be_released_list_l&                      srbs_to_be_released_list() const;
    const drbs_to_be_released_list_l&                      drbs_to_be_released_list() const;
    const inactivity_monitoring_request_e&                 inactivity_monitoring_request() const;
    const rat_freq_prio_info_c&                            rat_freq_prio_info() const;
    const drx_cfg_ind_e&                                   drx_cfg_ind() const;
    const rlc_fail_ind_s&                                  rlc_fail_ind() const;
    const unbounded_octstring<true>&                       ul_tx_direct_current_list_info() const;
    const gnb_du_cfg_query_e&                              gnb_du_cfg_query() const;
    const uint64_t&                                        gnb_du_ue_ambr_ul() const;
    const execute_dupl_e&                                  execute_dupl() const;
    const rrc_delivery_status_request_e&                   rrc_delivery_status_request() const;
    const res_coordination_transfer_info_s&                res_coordination_transfer_info() const;
    const uint8_t&                                         serving_cell_mo() const;
    const needfor_gap_e&                                   needfor_gap() const;
    const full_cfg_e&                                      full_cfg() const;
    const fixed_bitstring<32, false, true>&                add_rrm_prio_idx() const;
    const lower_layer_presence_status_change_e&            lower_layer_presence_status_change() const;
    const bh_chs_to_be_setup_mod_list_l&                   bh_chs_to_be_setup_mod_list() const;
    const bh_chs_to_be_modified_list_l&                    bh_chs_to_be_modified_list() const;
    const bh_chs_to_be_released_list_l&                    bh_chs_to_be_released_list() const;
    const nr_v2x_services_authorized_s&                    nr_v2x_services_authorized() const;
    const ltev2x_services_authorized_s&                    ltev2x_services_authorized() const;
    const nr_ue_sidelink_aggr_max_bitrate_s&               nr_ue_sidelink_aggr_max_bitrate() const;
    const lte_ue_sidelink_aggr_max_bitrate_s&              lte_ue_sidelink_aggr_max_bitrate() const;
    const uint64_t&                                        pc5_link_ambr() const;
    const sl_drbs_to_be_setup_mod_list_l&                  sl_drbs_to_be_setup_mod_list() const;
    const sl_drbs_to_be_modified_list_l&                   sl_drbs_to_be_modified_list() const;
    const sl_drbs_to_be_released_list_l&                   sl_drbs_to_be_released_list() const;
    const conditional_intra_du_mob_info_s&                 conditional_intra_du_mob_info() const;
    const f1_c_transfer_path_s&                            f1_c_transfer_path() const;
    const scg_ind_e&                                       scg_ind() const;
    const unbounded_octstring<true>&                       ul_tx_direct_current_two_carrier_list_info() const;
    const iab_conditional_rrc_msg_delivery_ind_e&          iab_conditional_rrc_msg_delivery_ind() const;
    const f1_c_transfer_path_nr_dc_s&                      f1_c_transfer_path_nr_dc() const;
    const mdt_polluted_meas_ind_e&                         mdt_polluted_meas_ind() const;
    const scg_activation_request_e&                        scg_activation_request() const;
    const cg_sdt_query_ind_e&                              cg_sdt_query_ind() const;
    const five_g_pro_se_authorized_s&                      five_g_pro_se_authorized() const;
    const nr_ue_sidelink_aggr_max_bitrate_s&               five_g_pro_se_ue_pc5_aggr_max_bitrate() const;
    const uint64_t&                                        five_g_pro_se_pc5_link_ambr() const;
    const uint16_t&                                        upd_remote_ue_local_id() const;
    const uu_rlc_ch_to_be_setup_list_l&                    uu_rlc_ch_to_be_setup_list() const;
    const uu_rlc_ch_to_be_modified_list_l&                 uu_rlc_ch_to_be_modified_list() const;
    const uu_rlc_ch_to_be_released_list_l&                 uu_rlc_ch_to_be_released_list() const;
    const pc5_rlc_ch_to_be_setup_list_l&                   pc5_rlc_ch_to_be_setup_list() const;
    const pc5_rlc_ch_to_be_modified_list_l&                pc5_rlc_ch_to_be_modified_list() const;
    const pc5_rlc_ch_to_be_released_list_l&                pc5_rlc_ch_to_be_released_list() const;
    const path_switch_cfg_s&                               path_switch_cfg() const;
    const gnb_du_ue_slice_max_bit_rate_list_l&             gnb_du_ue_slice_max_bit_rate_list() const;
    const multicast_mbs_session_list_l&                    multicast_mbs_session_setup_list() const;
    const multicast_mbs_session_list_l&                    multicast_mbs_session_rem_list() const;
    const ue_multicast_m_rbs_to_be_setup_at_modify_list_l& ue_multicast_m_rbs_to_be_setup_at_modify_list() const;
    const ue_multicast_m_rbs_to_be_released_list_l&        ue_multicast_m_rbs_to_be_released_list() const;
    const sldrx_cycle_list_l&                              sldrx_cycle_list() const;
    const mdt_plmn_mod_list_l&                             management_based_mdt_plmn_mod_list() const;
    const sdt_bearer_cfg_query_ind_e&                      sdt_bearer_cfg_query_ind() const;
    const daps_ho_status_e&                                daps_ho_status() const;
    const serving_cell_mo_list_l&                          serving_cell_mo_list() const;
    const unbounded_octstring<true>&                       ul_tx_direct_current_more_carrier_info() const;
    const cp_acmcg_info_s&                                 cp_acmcg_info() const;

  private:
    types type_;
    choice_buffer_t<bh_chs_to_be_modified_list_l,
                    bh_chs_to_be_released_list_l,
                    bh_chs_to_be_setup_mod_list_l,
                    conditional_intra_du_mob_info_s,
                    cp_acmcg_info_s,
                    cu_to_du_rrc_info_s,
                    drbs_to_be_modified_list_l,
                    drbs_to_be_released_list_l,
                    drbs_to_be_setup_mod_list_l,
                    drx_cycle_s,
                    f1_c_transfer_path_nr_dc_s,
                    f1_c_transfer_path_s,
                    five_g_pro_se_authorized_s,
                    fixed_bitstring<32, false, true>,
                    gnb_du_ue_slice_max_bit_rate_list_l,
                    lte_ue_sidelink_aggr_max_bitrate_s,
                    ltev2x_services_authorized_s,
                    mdt_plmn_mod_list_l,
                    multicast_mbs_session_list_l,
                    nr_cgi_s,
                    nr_ue_sidelink_aggr_max_bitrate_s,
                    nr_v2x_services_authorized_s,
                    path_switch_cfg_s,
                    pc5_rlc_ch_to_be_modified_list_l,
                    pc5_rlc_ch_to_be_released_list_l,
                    pc5_rlc_ch_to_be_setup_list_l,
                    rat_freq_prio_info_c,
                    res_coordination_transfer_info_s,
                    rlc_fail_ind_s,
                    scell_to_be_remd_list_l,
                    scell_to_be_setup_mod_list_l,
                    serving_cell_mo_list_l,
                    sl_drbs_to_be_modified_list_l,
                    sl_drbs_to_be_released_list_l,
                    sl_drbs_to_be_setup_mod_list_l,
                    sldrx_cycle_list_l,
                    srbs_to_be_released_list_l,
                    srbs_to_be_setup_mod_list_l,
                    ue_multicast_m_rbs_to_be_released_list_l,
                    ue_multicast_m_rbs_to_be_setup_at_modify_list_l,
                    unbounded_octstring<true>,
                    uu_rlc_ch_to_be_modified_list_l,
                    uu_rlc_ch_to_be_released_list_l,
                    uu_rlc_ch_to_be_setup_list_l>
        c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// UEContextModificationRequiredIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct ue_context_mod_required_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options {
        gnb_cu_ue_f1ap_id,
        gnb_du_ue_f1ap_id,
        res_coordination_transfer_container,
        du_to_cu_rrc_info,
        drbs_required_to_be_modified_list,
        srbs_required_to_be_released_list,
        drbs_required_to_be_released_list,
        cause,
        bh_chs_required_to_be_released_list,
        sl_drbs_required_to_be_modified_list,
        sl_drbs_required_to_be_released_list,
        target_cells_to_cancel,
        uu_rlc_ch_required_to_be_modified_list,
        uu_rlc_ch_required_to_be_released_list,
        pc5_rlc_ch_required_to_be_modified_list,
        pc5_rlc_ch_required_to_be_released_list,
        ue_multicast_m_rbs_required_to_be_modified_list,
        ue_multicast_m_rbs_required_to_be_released_list,
        nulltype
      } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint64_t&                                                gnb_cu_ue_f1ap_id();
    uint64_t&                                                gnb_du_ue_f1ap_id();
    unbounded_octstring<true>&                               res_coordination_transfer_container();
    du_to_cu_rrc_info_s&                                     du_to_cu_rrc_info();
    drbs_required_to_be_modified_list_l&                     drbs_required_to_be_modified_list();
    srbs_required_to_be_released_list_l&                     srbs_required_to_be_released_list();
    drbs_required_to_be_released_list_l&                     drbs_required_to_be_released_list();
    cause_c&                                                 cause();
    bh_chs_required_to_be_released_list_l&                   bh_chs_required_to_be_released_list();
    sl_drbs_required_to_be_modified_list_l&                  sl_drbs_required_to_be_modified_list();
    sl_drbs_required_to_be_released_list_l&                  sl_drbs_required_to_be_released_list();
    target_cell_list_l&                                      target_cells_to_cancel();
    uu_rlc_ch_required_to_be_modified_list_l&                uu_rlc_ch_required_to_be_modified_list();
    uu_rlc_ch_required_to_be_released_list_l&                uu_rlc_ch_required_to_be_released_list();
    pc5_rlc_ch_required_to_be_modified_list_l&               pc5_rlc_ch_required_to_be_modified_list();
    pc5_rlc_ch_required_to_be_released_list_l&               pc5_rlc_ch_required_to_be_released_list();
    ue_multicast_m_rbs_required_to_be_modified_list_l&       ue_multicast_m_rbs_required_to_be_modified_list();
    ue_multicast_m_rbs_required_to_be_released_list_l&       ue_multicast_m_rbs_required_to_be_released_list();
    const uint64_t&                                          gnb_cu_ue_f1ap_id() const;
    const uint64_t&                                          gnb_du_ue_f1ap_id() const;
    const unbounded_octstring<true>&                         res_coordination_transfer_container() const;
    const du_to_cu_rrc_info_s&                               du_to_cu_rrc_info() const;
    const drbs_required_to_be_modified_list_l&               drbs_required_to_be_modified_list() const;
    const srbs_required_to_be_released_list_l&               srbs_required_to_be_released_list() const;
    const drbs_required_to_be_released_list_l&               drbs_required_to_be_released_list() const;
    const cause_c&                                           cause() const;
    const bh_chs_required_to_be_released_list_l&             bh_chs_required_to_be_released_list() const;
    const sl_drbs_required_to_be_modified_list_l&            sl_drbs_required_to_be_modified_list() const;
    const sl_drbs_required_to_be_released_list_l&            sl_drbs_required_to_be_released_list() const;
    const target_cell_list_l&                                target_cells_to_cancel() const;
    const uu_rlc_ch_required_to_be_modified_list_l&          uu_rlc_ch_required_to_be_modified_list() const;
    const uu_rlc_ch_required_to_be_released_list_l&          uu_rlc_ch_required_to_be_released_list() const;
    const pc5_rlc_ch_required_to_be_modified_list_l&         pc5_rlc_ch_required_to_be_modified_list() const;
    const pc5_rlc_ch_required_to_be_released_list_l&         pc5_rlc_ch_required_to_be_released_list() const;
    const ue_multicast_m_rbs_required_to_be_modified_list_l& ue_multicast_m_rbs_required_to_be_modified_list() const;
    const ue_multicast_m_rbs_required_to_be_released_list_l& ue_multicast_m_rbs_required_to_be_released_list() const;

  private:
    types type_;
    choice_buffer_t<bh_chs_required_to_be_released_list_l,
                    cause_c,
                    drbs_required_to_be_modified_list_l,
                    drbs_required_to_be_released_list_l,
                    du_to_cu_rrc_info_s,
                    pc5_rlc_ch_required_to_be_modified_list_l,
                    pc5_rlc_ch_required_to_be_released_list_l,
                    sl_drbs_required_to_be_modified_list_l,
                    sl_drbs_required_to_be_released_list_l,
                    srbs_required_to_be_released_list_l,
                    target_cell_list_l,
                    ue_multicast_m_rbs_required_to_be_modified_list_l,
                    ue_multicast_m_rbs_required_to_be_released_list_l,
                    unbounded_octstring<true>,
                    uu_rlc_ch_required_to_be_modified_list_l,
                    uu_rlc_ch_required_to_be_released_list_l>
        c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// UEContextModificationResponseIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct ue_context_mod_resp_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options {
        gnb_cu_ue_f1ap_id,
        gnb_du_ue_f1ap_id,
        res_coordination_transfer_container,
        du_to_cu_rrc_info,
        drbs_setup_mod_list,
        drbs_modified_list,
        srbs_failed_to_be_setup_mod_list,
        drbs_failed_to_be_setup_mod_list,
        scell_failedto_setup_mod_list,
        drbs_failed_to_be_modified_list,
        inactivity_monitoring_resp,
        crit_diagnostics,
        c_rnti,
        associated_scell_list,
        srbs_setup_mod_list,
        srbs_modified_list,
        full_cfg,
        bh_chs_setup_mod_list,
        bh_chs_modified_list,
        bh_chs_failed_to_be_setup_mod_list,
        bh_chs_failed_to_be_modified_list,
        sl_drbs_setup_mod_list,
        sl_drbs_modified_list,
        sl_drbs_failed_to_be_setup_mod_list,
        sl_drbs_failed_to_be_modified_list,
        requested_target_cell_global_id,
        scg_activation_status,
        uu_rlc_ch_setup_list,
        uu_rlc_ch_failed_to_be_setup_list,
        uu_rlc_ch_modified_list,
        uu_rlc_ch_failed_to_be_modified_list,
        pc5_rlc_ch_setup_list,
        pc5_rlc_ch_failed_to_be_setup_list,
        pc5_rlc_ch_modified_list,
        pc5_rlc_ch_failed_to_be_modified_list,
        sdt_bearer_cfg_info,
        ue_multicast_m_rbs_setup_list,
        serving_cell_mo_encoded_in_cgc_list,
        nulltype
      } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint64_t&                                      gnb_cu_ue_f1ap_id();
    uint64_t&                                      gnb_du_ue_f1ap_id();
    unbounded_octstring<true>&                     res_coordination_transfer_container();
    du_to_cu_rrc_info_s&                           du_to_cu_rrc_info();
    drbs_setup_mod_list_l&                         drbs_setup_mod_list();
    drbs_modified_list_l&                          drbs_modified_list();
    srbs_failed_to_be_setup_mod_list_l&            srbs_failed_to_be_setup_mod_list();
    drbs_failed_to_be_setup_mod_list_l&            drbs_failed_to_be_setup_mod_list();
    scell_failedto_setup_mod_list_l&               scell_failedto_setup_mod_list();
    drbs_failed_to_be_modified_list_l&             drbs_failed_to_be_modified_list();
    inactivity_monitoring_resp_e&                  inactivity_monitoring_resp();
    crit_diagnostics_s&                            crit_diagnostics();
    uint32_t&                                      c_rnti();
    associated_scell_list_l&                       associated_scell_list();
    srbs_setup_mod_list_l&                         srbs_setup_mod_list();
    srbs_modified_list_l&                          srbs_modified_list();
    full_cfg_e&                                    full_cfg();
    bh_chs_setup_mod_list_l&                       bh_chs_setup_mod_list();
    bh_chs_modified_list_l&                        bh_chs_modified_list();
    bh_chs_failed_to_be_setup_mod_list_l&          bh_chs_failed_to_be_setup_mod_list();
    bh_chs_failed_to_be_modified_list_l&           bh_chs_failed_to_be_modified_list();
    sl_drbs_setup_mod_list_l&                      sl_drbs_setup_mod_list();
    sl_drbs_modified_list_l&                       sl_drbs_modified_list();
    sl_drbs_failed_to_be_setup_mod_list_l&         sl_drbs_failed_to_be_setup_mod_list();
    sl_drbs_failed_to_be_modified_list_l&          sl_drbs_failed_to_be_modified_list();
    nr_cgi_s&                                      requested_target_cell_global_id();
    scg_activation_status_e&                       scg_activation_status();
    uu_rlc_ch_setup_list_l&                        uu_rlc_ch_setup_list();
    uu_rlc_ch_failed_to_be_setup_list_l&           uu_rlc_ch_failed_to_be_setup_list();
    uu_rlc_ch_modified_list_l&                     uu_rlc_ch_modified_list();
    uu_rlc_ch_failed_to_be_modified_list_l&        uu_rlc_ch_failed_to_be_modified_list();
    pc5_rlc_ch_setup_list_l&                       pc5_rlc_ch_setup_list();
    pc5_rlc_ch_failed_to_be_setup_list_l&          pc5_rlc_ch_failed_to_be_setup_list();
    pc5_rlc_ch_modified_list_l&                    pc5_rlc_ch_modified_list();
    pc5_rlc_ch_failed_to_be_modified_list_l&       pc5_rlc_ch_failed_to_be_modified_list();
    sdt_bearer_cfg_info_s&                         sdt_bearer_cfg_info();
    ue_multicast_m_rbs_setup_list_l&               ue_multicast_m_rbs_setup_list();
    serving_cell_mo_encoded_in_cgc_list_l&         serving_cell_mo_encoded_in_cgc_list();
    const uint64_t&                                gnb_cu_ue_f1ap_id() const;
    const uint64_t&                                gnb_du_ue_f1ap_id() const;
    const unbounded_octstring<true>&               res_coordination_transfer_container() const;
    const du_to_cu_rrc_info_s&                     du_to_cu_rrc_info() const;
    const drbs_setup_mod_list_l&                   drbs_setup_mod_list() const;
    const drbs_modified_list_l&                    drbs_modified_list() const;
    const srbs_failed_to_be_setup_mod_list_l&      srbs_failed_to_be_setup_mod_list() const;
    const drbs_failed_to_be_setup_mod_list_l&      drbs_failed_to_be_setup_mod_list() const;
    const scell_failedto_setup_mod_list_l&         scell_failedto_setup_mod_list() const;
    const drbs_failed_to_be_modified_list_l&       drbs_failed_to_be_modified_list() const;
    const inactivity_monitoring_resp_e&            inactivity_monitoring_resp() const;
    const crit_diagnostics_s&                      crit_diagnostics() const;
    const uint32_t&                                c_rnti() const;
    const associated_scell_list_l&                 associated_scell_list() const;
    const srbs_setup_mod_list_l&                   srbs_setup_mod_list() const;
    const srbs_modified_list_l&                    srbs_modified_list() const;
    const full_cfg_e&                              full_cfg() const;
    const bh_chs_setup_mod_list_l&                 bh_chs_setup_mod_list() const;
    const bh_chs_modified_list_l&                  bh_chs_modified_list() const;
    const bh_chs_failed_to_be_setup_mod_list_l&    bh_chs_failed_to_be_setup_mod_list() const;
    const bh_chs_failed_to_be_modified_list_l&     bh_chs_failed_to_be_modified_list() const;
    const sl_drbs_setup_mod_list_l&                sl_drbs_setup_mod_list() const;
    const sl_drbs_modified_list_l&                 sl_drbs_modified_list() const;
    const sl_drbs_failed_to_be_setup_mod_list_l&   sl_drbs_failed_to_be_setup_mod_list() const;
    const sl_drbs_failed_to_be_modified_list_l&    sl_drbs_failed_to_be_modified_list() const;
    const nr_cgi_s&                                requested_target_cell_global_id() const;
    const scg_activation_status_e&                 scg_activation_status() const;
    const uu_rlc_ch_setup_list_l&                  uu_rlc_ch_setup_list() const;
    const uu_rlc_ch_failed_to_be_setup_list_l&     uu_rlc_ch_failed_to_be_setup_list() const;
    const uu_rlc_ch_modified_list_l&               uu_rlc_ch_modified_list() const;
    const uu_rlc_ch_failed_to_be_modified_list_l&  uu_rlc_ch_failed_to_be_modified_list() const;
    const pc5_rlc_ch_setup_list_l&                 pc5_rlc_ch_setup_list() const;
    const pc5_rlc_ch_failed_to_be_setup_list_l&    pc5_rlc_ch_failed_to_be_setup_list() const;
    const pc5_rlc_ch_modified_list_l&              pc5_rlc_ch_modified_list() const;
    const pc5_rlc_ch_failed_to_be_modified_list_l& pc5_rlc_ch_failed_to_be_modified_list() const;
    const sdt_bearer_cfg_info_s&                   sdt_bearer_cfg_info() const;
    const ue_multicast_m_rbs_setup_list_l&         ue_multicast_m_rbs_setup_list() const;
    const serving_cell_mo_encoded_in_cgc_list_l&   serving_cell_mo_encoded_in_cgc_list() const;

  private:
    types type_;
    choice_buffer_t<associated_scell_list_l,
                    bh_chs_failed_to_be_modified_list_l,
                    bh_chs_failed_to_be_setup_mod_list_l,
                    bh_chs_modified_list_l,
                    bh_chs_setup_mod_list_l,
                    crit_diagnostics_s,
                    drbs_failed_to_be_modified_list_l,
                    drbs_failed_to_be_setup_mod_list_l,
                    drbs_modified_list_l,
                    drbs_setup_mod_list_l,
                    du_to_cu_rrc_info_s,
                    nr_cgi_s,
                    pc5_rlc_ch_failed_to_be_modified_list_l,
                    pc5_rlc_ch_failed_to_be_setup_list_l,
                    pc5_rlc_ch_modified_list_l,
                    pc5_rlc_ch_setup_list_l,
                    scell_failedto_setup_mod_list_l,
                    sdt_bearer_cfg_info_s,
                    serving_cell_mo_encoded_in_cgc_list_l,
                    sl_drbs_failed_to_be_modified_list_l,
                    sl_drbs_failed_to_be_setup_mod_list_l,
                    sl_drbs_modified_list_l,
                    sl_drbs_setup_mod_list_l,
                    srbs_failed_to_be_setup_mod_list_l,
                    srbs_modified_list_l,
                    srbs_setup_mod_list_l,
                    ue_multicast_m_rbs_setup_list_l,
                    unbounded_octstring<true>,
                    uu_rlc_ch_failed_to_be_modified_list_l,
                    uu_rlc_ch_failed_to_be_setup_list_l,
                    uu_rlc_ch_modified_list_l,
                    uu_rlc_ch_setup_list_l>
        c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// UEContextReleaseCommandIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct ue_context_release_cmd_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options {
        gnb_cu_ue_f1ap_id,
        gnb_du_ue_f1ap_id,
        cause,
        rrc_container,
        srb_id,
        old_gnb_du_ue_f1ap_id,
        execute_dupl,
        rrc_delivery_status_request,
        target_cells_to_cancel,
        pos_conext_rev_ind,
        cg_sdt_kept_ind,
        nulltype
      } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint64_t&                            gnb_cu_ue_f1ap_id();
    uint64_t&                            gnb_du_ue_f1ap_id();
    cause_c&                             cause();
    unbounded_octstring<true>&           rrc_container();
    uint8_t&                             srb_id();
    uint64_t&                            old_gnb_du_ue_f1ap_id();
    execute_dupl_e&                      execute_dupl();
    rrc_delivery_status_request_e&       rrc_delivery_status_request();
    target_cell_list_l&                  target_cells_to_cancel();
    pos_conext_rev_ind_e&                pos_conext_rev_ind();
    cg_sdt_kept_ind_e&                   cg_sdt_kept_ind();
    const uint64_t&                      gnb_cu_ue_f1ap_id() const;
    const uint64_t&                      gnb_du_ue_f1ap_id() const;
    const cause_c&                       cause() const;
    const unbounded_octstring<true>&     rrc_container() const;
    const uint8_t&                       srb_id() const;
    const uint64_t&                      old_gnb_du_ue_f1ap_id() const;
    const execute_dupl_e&                execute_dupl() const;
    const rrc_delivery_status_request_e& rrc_delivery_status_request() const;
    const target_cell_list_l&            target_cells_to_cancel() const;
    const pos_conext_rev_ind_e&          pos_conext_rev_ind() const;
    const cg_sdt_kept_ind_e&             cg_sdt_kept_ind() const;

  private:
    types                                                                   type_;
    choice_buffer_t<cause_c, target_cell_list_l, unbounded_octstring<true>> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// UEContextReleaseCompleteIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct ue_context_release_complete_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { gnb_cu_ue_f1ap_id, gnb_du_ue_f1ap_id, crit_diagnostics, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint64_t&                 gnb_cu_ue_f1ap_id();
    uint64_t&                 gnb_du_ue_f1ap_id();
    crit_diagnostics_s&       crit_diagnostics();
    const uint64_t&           gnb_cu_ue_f1ap_id() const;
    const uint64_t&           gnb_du_ue_f1ap_id() const;
    const crit_diagnostics_s& crit_diagnostics() const;

  private:
    types                               type_;
    choice_buffer_t<crit_diagnostics_s> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// UEContextReleaseRequestIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct ue_context_release_request_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { gnb_cu_ue_f1ap_id, gnb_du_ue_f1ap_id, cause, target_cells_to_cancel, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint64_t&                 gnb_cu_ue_f1ap_id();
    uint64_t&                 gnb_du_ue_f1ap_id();
    cause_c&                  cause();
    target_cell_list_l&       target_cells_to_cancel();
    const uint64_t&           gnb_cu_ue_f1ap_id() const;
    const uint64_t&           gnb_du_ue_f1ap_id() const;
    const cause_c&            cause() const;
    const target_cell_list_l& target_cells_to_cancel() const;

  private:
    types                                        type_;
    choice_buffer_t<cause_c, target_cell_list_l> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// UEContextSetupFailureIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct ue_context_setup_fail_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options {
        gnb_cu_ue_f1ap_id,
        gnb_du_ue_f1ap_id,
        cause,
        crit_diagnostics,
        potential_sp_cell_list,
        requested_target_cell_global_id,
        nulltype
      } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint64_t&                       gnb_cu_ue_f1ap_id();
    uint64_t&                       gnb_du_ue_f1ap_id();
    cause_c&                        cause();
    crit_diagnostics_s&             crit_diagnostics();
    potential_sp_cell_list_l&       potential_sp_cell_list();
    nr_cgi_s&                       requested_target_cell_global_id();
    const uint64_t&                 gnb_cu_ue_f1ap_id() const;
    const uint64_t&                 gnb_du_ue_f1ap_id() const;
    const cause_c&                  cause() const;
    const crit_diagnostics_s&       crit_diagnostics() const;
    const potential_sp_cell_list_l& potential_sp_cell_list() const;
    const nr_cgi_s&                 requested_target_cell_global_id() const;

  private:
    types                                                                            type_;
    choice_buffer_t<cause_c, crit_diagnostics_s, nr_cgi_s, potential_sp_cell_list_l> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// UEContextSetupRequestIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct ue_context_setup_request_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options {
        gnb_cu_ue_f1ap_id,
        gnb_du_ue_f1ap_id,
        sp_cell_id,
        serv_cell_idx,
        sp_cell_ul_cfg,
        cu_to_du_rrc_info,
        candidate_sp_cell_list,
        drx_cycle,
        res_coordination_transfer_container,
        scell_to_be_setup_list,
        srbs_to_be_setup_list,
        drbs_to_be_setup_list,
        inactivity_monitoring_request,
        rat_freq_prio_info,
        rrc_container,
        masked_imeisv,
        serving_plmn,
        gnb_du_ue_ambr_ul,
        rrc_delivery_status_request,
        res_coordination_transfer_info,
        serving_cell_mo,
        new_gnb_cu_ue_f1ap_id,
        ran_ue_id,
        trace_activation,
        add_rrm_prio_idx,
        bh_chs_to_be_setup_list,
        cfg_bap_address,
        nr_v2x_services_authorized,
        ltev2x_services_authorized,
        nr_ue_sidelink_aggr_max_bitrate,
        lte_ue_sidelink_aggr_max_bitrate,
        pc5_link_ambr,
        sl_drbs_to_be_setup_list,
        conditional_inter_du_mob_info,
        management_based_mdt_plmn_list,
        serving_n_id,
        f1_c_transfer_path,
        f1_c_transfer_path_nr_dc,
        mdt_polluted_meas_ind,
        scg_activation_request,
        cg_sdt_session_info_old,
        five_g_pro_se_authorized,
        five_g_pro_se_ue_pc5_aggr_max_bitrate,
        five_g_pro_se_pc5_link_ambr,
        uu_rlc_ch_to_be_setup_list,
        pc5_rlc_ch_to_be_setup_list,
        path_switch_cfg,
        gnb_du_ue_slice_max_bit_rate_list,
        multicast_mbs_session_setup_list,
        ue_multicast_m_rbs_to_be_setup_list,
        serving_cell_mo_list,
        nulltype
      } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint64_t&                                    gnb_cu_ue_f1ap_id();
    uint64_t&                                    gnb_du_ue_f1ap_id();
    nr_cgi_s&                                    sp_cell_id();
    uint8_t&                                     serv_cell_idx();
    cell_ul_cfg_e&                               sp_cell_ul_cfg();
    cu_to_du_rrc_info_s&                         cu_to_du_rrc_info();
    candidate_sp_cell_list_l&                    candidate_sp_cell_list();
    drx_cycle_s&                                 drx_cycle();
    unbounded_octstring<true>&                   res_coordination_transfer_container();
    scell_to_be_setup_list_l&                    scell_to_be_setup_list();
    srbs_to_be_setup_list_l&                     srbs_to_be_setup_list();
    drbs_to_be_setup_list_l&                     drbs_to_be_setup_list();
    inactivity_monitoring_request_e&             inactivity_monitoring_request();
    rat_freq_prio_info_c&                        rat_freq_prio_info();
    unbounded_octstring<true>&                   rrc_container();
    fixed_bitstring<64, false, true>&            masked_imeisv();
    fixed_octstring<3, true>&                    serving_plmn();
    uint64_t&                                    gnb_du_ue_ambr_ul();
    rrc_delivery_status_request_e&               rrc_delivery_status_request();
    res_coordination_transfer_info_s&            res_coordination_transfer_info();
    uint8_t&                                     serving_cell_mo();
    uint64_t&                                    new_gnb_cu_ue_f1ap_id();
    fixed_octstring<8, true>&                    ran_ue_id();
    trace_activation_s&                          trace_activation();
    fixed_bitstring<32, false, true>&            add_rrm_prio_idx();
    bh_chs_to_be_setup_list_l&                   bh_chs_to_be_setup_list();
    fixed_bitstring<10, false, true>&            cfg_bap_address();
    nr_v2x_services_authorized_s&                nr_v2x_services_authorized();
    ltev2x_services_authorized_s&                ltev2x_services_authorized();
    nr_ue_sidelink_aggr_max_bitrate_s&           nr_ue_sidelink_aggr_max_bitrate();
    lte_ue_sidelink_aggr_max_bitrate_s&          lte_ue_sidelink_aggr_max_bitrate();
    uint64_t&                                    pc5_link_ambr();
    sl_drbs_to_be_setup_list_l&                  sl_drbs_to_be_setup_list();
    conditional_inter_du_mob_info_s&             conditional_inter_du_mob_info();
    mdt_plmn_list_l&                             management_based_mdt_plmn_list();
    fixed_bitstring<44, false, true>&            serving_n_id();
    f1_c_transfer_path_s&                        f1_c_transfer_path();
    f1_c_transfer_path_nr_dc_s&                  f1_c_transfer_path_nr_dc();
    mdt_polluted_meas_ind_e&                     mdt_polluted_meas_ind();
    scg_activation_request_e&                    scg_activation_request();
    cg_sdt_session_info_s&                       cg_sdt_session_info_old();
    five_g_pro_se_authorized_s&                  five_g_pro_se_authorized();
    nr_ue_sidelink_aggr_max_bitrate_s&           five_g_pro_se_ue_pc5_aggr_max_bitrate();
    uint64_t&                                    five_g_pro_se_pc5_link_ambr();
    uu_rlc_ch_to_be_setup_list_l&                uu_rlc_ch_to_be_setup_list();
    pc5_rlc_ch_to_be_setup_list_l&               pc5_rlc_ch_to_be_setup_list();
    path_switch_cfg_s&                           path_switch_cfg();
    gnb_du_ue_slice_max_bit_rate_list_l&         gnb_du_ue_slice_max_bit_rate_list();
    multicast_mbs_session_list_l&                multicast_mbs_session_setup_list();
    ue_multicast_m_rbs_to_be_setup_list_l&       ue_multicast_m_rbs_to_be_setup_list();
    serving_cell_mo_list_l&                      serving_cell_mo_list();
    const uint64_t&                              gnb_cu_ue_f1ap_id() const;
    const uint64_t&                              gnb_du_ue_f1ap_id() const;
    const nr_cgi_s&                              sp_cell_id() const;
    const uint8_t&                               serv_cell_idx() const;
    const cell_ul_cfg_e&                         sp_cell_ul_cfg() const;
    const cu_to_du_rrc_info_s&                   cu_to_du_rrc_info() const;
    const candidate_sp_cell_list_l&              candidate_sp_cell_list() const;
    const drx_cycle_s&                           drx_cycle() const;
    const unbounded_octstring<true>&             res_coordination_transfer_container() const;
    const scell_to_be_setup_list_l&              scell_to_be_setup_list() const;
    const srbs_to_be_setup_list_l&               srbs_to_be_setup_list() const;
    const drbs_to_be_setup_list_l&               drbs_to_be_setup_list() const;
    const inactivity_monitoring_request_e&       inactivity_monitoring_request() const;
    const rat_freq_prio_info_c&                  rat_freq_prio_info() const;
    const unbounded_octstring<true>&             rrc_container() const;
    const fixed_bitstring<64, false, true>&      masked_imeisv() const;
    const fixed_octstring<3, true>&              serving_plmn() const;
    const uint64_t&                              gnb_du_ue_ambr_ul() const;
    const rrc_delivery_status_request_e&         rrc_delivery_status_request() const;
    const res_coordination_transfer_info_s&      res_coordination_transfer_info() const;
    const uint8_t&                               serving_cell_mo() const;
    const uint64_t&                              new_gnb_cu_ue_f1ap_id() const;
    const fixed_octstring<8, true>&              ran_ue_id() const;
    const trace_activation_s&                    trace_activation() const;
    const fixed_bitstring<32, false, true>&      add_rrm_prio_idx() const;
    const bh_chs_to_be_setup_list_l&             bh_chs_to_be_setup_list() const;
    const fixed_bitstring<10, false, true>&      cfg_bap_address() const;
    const nr_v2x_services_authorized_s&          nr_v2x_services_authorized() const;
    const ltev2x_services_authorized_s&          ltev2x_services_authorized() const;
    const nr_ue_sidelink_aggr_max_bitrate_s&     nr_ue_sidelink_aggr_max_bitrate() const;
    const lte_ue_sidelink_aggr_max_bitrate_s&    lte_ue_sidelink_aggr_max_bitrate() const;
    const uint64_t&                              pc5_link_ambr() const;
    const sl_drbs_to_be_setup_list_l&            sl_drbs_to_be_setup_list() const;
    const conditional_inter_du_mob_info_s&       conditional_inter_du_mob_info() const;
    const mdt_plmn_list_l&                       management_based_mdt_plmn_list() const;
    const fixed_bitstring<44, false, true>&      serving_n_id() const;
    const f1_c_transfer_path_s&                  f1_c_transfer_path() const;
    const f1_c_transfer_path_nr_dc_s&            f1_c_transfer_path_nr_dc() const;
    const mdt_polluted_meas_ind_e&               mdt_polluted_meas_ind() const;
    const scg_activation_request_e&              scg_activation_request() const;
    const cg_sdt_session_info_s&                 cg_sdt_session_info_old() const;
    const five_g_pro_se_authorized_s&            five_g_pro_se_authorized() const;
    const nr_ue_sidelink_aggr_max_bitrate_s&     five_g_pro_se_ue_pc5_aggr_max_bitrate() const;
    const uint64_t&                              five_g_pro_se_pc5_link_ambr() const;
    const uu_rlc_ch_to_be_setup_list_l&          uu_rlc_ch_to_be_setup_list() const;
    const pc5_rlc_ch_to_be_setup_list_l&         pc5_rlc_ch_to_be_setup_list() const;
    const path_switch_cfg_s&                     path_switch_cfg() const;
    const gnb_du_ue_slice_max_bit_rate_list_l&   gnb_du_ue_slice_max_bit_rate_list() const;
    const multicast_mbs_session_list_l&          multicast_mbs_session_setup_list() const;
    const ue_multicast_m_rbs_to_be_setup_list_l& ue_multicast_m_rbs_to_be_setup_list() const;
    const serving_cell_mo_list_l&                serving_cell_mo_list() const;

  private:
    types type_;
    choice_buffer_t<bh_chs_to_be_setup_list_l,
                    candidate_sp_cell_list_l,
                    cg_sdt_session_info_s,
                    conditional_inter_du_mob_info_s,
                    cu_to_du_rrc_info_s,
                    drbs_to_be_setup_list_l,
                    drx_cycle_s,
                    f1_c_transfer_path_nr_dc_s,
                    f1_c_transfer_path_s,
                    five_g_pro_se_authorized_s,
                    fixed_bitstring<64, false, true>,
                    fixed_octstring<3, true>,
                    fixed_octstring<8, true>,
                    gnb_du_ue_slice_max_bit_rate_list_l,
                    lte_ue_sidelink_aggr_max_bitrate_s,
                    ltev2x_services_authorized_s,
                    mdt_plmn_list_l,
                    multicast_mbs_session_list_l,
                    nr_cgi_s,
                    nr_ue_sidelink_aggr_max_bitrate_s,
                    nr_v2x_services_authorized_s,
                    path_switch_cfg_s,
                    pc5_rlc_ch_to_be_setup_list_l,
                    rat_freq_prio_info_c,
                    res_coordination_transfer_info_s,
                    scell_to_be_setup_list_l,
                    serving_cell_mo_list_l,
                    sl_drbs_to_be_setup_list_l,
                    srbs_to_be_setup_list_l,
                    trace_activation_s,
                    ue_multicast_m_rbs_to_be_setup_list_l,
                    unbounded_octstring<true>,
                    uu_rlc_ch_to_be_setup_list_l>
        c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// UEContextSetupResponseIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct ue_context_setup_resp_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options {
        gnb_cu_ue_f1ap_id,
        gnb_du_ue_f1ap_id,
        du_to_cu_rrc_info,
        c_rnti,
        res_coordination_transfer_container,
        full_cfg,
        drbs_setup_list,
        srbs_failed_to_be_setup_list,
        drbs_failed_to_be_setup_list,
        scell_failedto_setup_list,
        inactivity_monitoring_resp,
        crit_diagnostics,
        srbs_setup_list,
        bh_chs_setup_list,
        bh_chs_failed_to_be_setup_list,
        sl_drbs_setup_list,
        sl_drbs_failed_to_be_setup_list,
        requested_target_cell_global_id,
        scg_activation_status,
        uu_rlc_ch_setup_list,
        uu_rlc_ch_failed_to_be_setup_list,
        pc5_rlc_ch_setup_list,
        pc5_rlc_ch_failed_to_be_setup_list,
        serving_cell_mo_encoded_in_cgc_list,
        nulltype
      } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint64_t&                                    gnb_cu_ue_f1ap_id();
    uint64_t&                                    gnb_du_ue_f1ap_id();
    du_to_cu_rrc_info_s&                         du_to_cu_rrc_info();
    uint32_t&                                    c_rnti();
    unbounded_octstring<true>&                   res_coordination_transfer_container();
    full_cfg_e&                                  full_cfg();
    drbs_setup_list_l&                           drbs_setup_list();
    srbs_failed_to_be_setup_list_l&              srbs_failed_to_be_setup_list();
    drbs_failed_to_be_setup_list_l&              drbs_failed_to_be_setup_list();
    scell_failedto_setup_list_l&                 scell_failedto_setup_list();
    inactivity_monitoring_resp_e&                inactivity_monitoring_resp();
    crit_diagnostics_s&                          crit_diagnostics();
    srbs_setup_list_l&                           srbs_setup_list();
    bh_chs_setup_list_l&                         bh_chs_setup_list();
    bh_chs_failed_to_be_setup_list_l&            bh_chs_failed_to_be_setup_list();
    sl_drbs_setup_list_l&                        sl_drbs_setup_list();
    sl_drbs_failed_to_be_setup_list_l&           sl_drbs_failed_to_be_setup_list();
    nr_cgi_s&                                    requested_target_cell_global_id();
    scg_activation_status_e&                     scg_activation_status();
    uu_rlc_ch_setup_list_l&                      uu_rlc_ch_setup_list();
    uu_rlc_ch_failed_to_be_setup_list_l&         uu_rlc_ch_failed_to_be_setup_list();
    pc5_rlc_ch_setup_list_l&                     pc5_rlc_ch_setup_list();
    pc5_rlc_ch_failed_to_be_setup_list_l&        pc5_rlc_ch_failed_to_be_setup_list();
    serving_cell_mo_encoded_in_cgc_list_l&       serving_cell_mo_encoded_in_cgc_list();
    const uint64_t&                              gnb_cu_ue_f1ap_id() const;
    const uint64_t&                              gnb_du_ue_f1ap_id() const;
    const du_to_cu_rrc_info_s&                   du_to_cu_rrc_info() const;
    const uint32_t&                              c_rnti() const;
    const unbounded_octstring<true>&             res_coordination_transfer_container() const;
    const full_cfg_e&                            full_cfg() const;
    const drbs_setup_list_l&                     drbs_setup_list() const;
    const srbs_failed_to_be_setup_list_l&        srbs_failed_to_be_setup_list() const;
    const drbs_failed_to_be_setup_list_l&        drbs_failed_to_be_setup_list() const;
    const scell_failedto_setup_list_l&           scell_failedto_setup_list() const;
    const inactivity_monitoring_resp_e&          inactivity_monitoring_resp() const;
    const crit_diagnostics_s&                    crit_diagnostics() const;
    const srbs_setup_list_l&                     srbs_setup_list() const;
    const bh_chs_setup_list_l&                   bh_chs_setup_list() const;
    const bh_chs_failed_to_be_setup_list_l&      bh_chs_failed_to_be_setup_list() const;
    const sl_drbs_setup_list_l&                  sl_drbs_setup_list() const;
    const sl_drbs_failed_to_be_setup_list_l&     sl_drbs_failed_to_be_setup_list() const;
    const nr_cgi_s&                              requested_target_cell_global_id() const;
    const scg_activation_status_e&               scg_activation_status() const;
    const uu_rlc_ch_setup_list_l&                uu_rlc_ch_setup_list() const;
    const uu_rlc_ch_failed_to_be_setup_list_l&   uu_rlc_ch_failed_to_be_setup_list() const;
    const pc5_rlc_ch_setup_list_l&               pc5_rlc_ch_setup_list() const;
    const pc5_rlc_ch_failed_to_be_setup_list_l&  pc5_rlc_ch_failed_to_be_setup_list() const;
    const serving_cell_mo_encoded_in_cgc_list_l& serving_cell_mo_encoded_in_cgc_list() const;

  private:
    types type_;
    choice_buffer_t<bh_chs_failed_to_be_setup_list_l,
                    bh_chs_setup_list_l,
                    crit_diagnostics_s,
                    drbs_failed_to_be_setup_list_l,
                    drbs_setup_list_l,
                    du_to_cu_rrc_info_s,
                    nr_cgi_s,
                    pc5_rlc_ch_failed_to_be_setup_list_l,
                    pc5_rlc_ch_setup_list_l,
                    scell_failedto_setup_list_l,
                    serving_cell_mo_encoded_in_cgc_list_l,
                    sl_drbs_failed_to_be_setup_list_l,
                    sl_drbs_setup_list_l,
                    srbs_failed_to_be_setup_list_l,
                    srbs_setup_list_l,
                    unbounded_octstring<true>,
                    uu_rlc_ch_failed_to_be_setup_list_l,
                    uu_rlc_ch_setup_list_l>
        c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// UEInactivityNotificationIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct ue_inactivity_notif_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options { gnb_cu_ue_f1ap_id, gnb_du_ue_f1ap_id, drb_activity_list, sdt_termination_request, nulltype } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint64_t&                        gnb_cu_ue_f1ap_id();
    uint64_t&                        gnb_du_ue_f1ap_id();
    drb_activity_list_l&             drb_activity_list();
    sdt_termination_request_e&       sdt_termination_request();
    const uint64_t&                  gnb_cu_ue_f1ap_id() const;
    const uint64_t&                  gnb_du_ue_f1ap_id() const;
    const drb_activity_list_l&       drb_activity_list() const;
    const sdt_termination_request_e& sdt_termination_request() const;

  private:
    types                                type_;
    choice_buffer_t<drb_activity_list_l> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// ULRRCMessageTransferIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct ul_rrc_msg_transfer_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options {
        gnb_cu_ue_f1ap_id,
        gnb_du_ue_f1ap_id,
        srb_id,
        rrc_container,
        sel_plmn_id,
        new_gnb_du_ue_f1ap_id,
        nulltype
      } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint64_t&                        gnb_cu_ue_f1ap_id();
    uint64_t&                        gnb_du_ue_f1ap_id();
    uint8_t&                         srb_id();
    unbounded_octstring<true>&       rrc_container();
    fixed_octstring<3, true>&        sel_plmn_id();
    uint64_t&                        new_gnb_du_ue_f1ap_id();
    const uint64_t&                  gnb_cu_ue_f1ap_id() const;
    const uint64_t&                  gnb_du_ue_f1ap_id() const;
    const uint8_t&                   srb_id() const;
    const unbounded_octstring<true>& rrc_container() const;
    const fixed_octstring<3, true>&  sel_plmn_id() const;
    const uint64_t&                  new_gnb_du_ue_f1ap_id() const;

  private:
    types                                                                type_;
    choice_buffer_t<fixed_octstring<3, true>, unbounded_octstring<true>> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// WriteReplaceWarningRequestIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct write_replace_warning_request_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options {
        transaction_id,
        pws_sys_info,
        repeat_period,
        numof_broadcast_request,
        cells_to_be_broadcast_list,
        nulltype
      } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint16_t&                           transaction_id();
    pws_sys_info_s&                     pws_sys_info();
    uint32_t&                           repeat_period();
    uint32_t&                           numof_broadcast_request();
    cells_to_be_broadcast_list_l&       cells_to_be_broadcast_list();
    const uint16_t&                     transaction_id() const;
    const pws_sys_info_s&               pws_sys_info() const;
    const uint32_t&                     repeat_period() const;
    const uint32_t&                     numof_broadcast_request() const;
    const cells_to_be_broadcast_list_l& cells_to_be_broadcast_list() const;

  private:
    types                                                         type_;
    choice_buffer_t<cells_to_be_broadcast_list_l, pws_sys_info_s> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

// WriteReplaceWarningResponseIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
struct write_replace_warning_resp_ies_o {
  // Value ::= OPEN TYPE
  struct value_c {
    struct types_opts {
      enum options {
        transaction_id,
        cells_broadcast_completed_list,
        crit_diagnostics,
        ded_si_delivery_needed_ue_list,
        nulltype
      } value;
      typedef uint8_t number_type;

      const char* to_string() const;
      uint8_t     to_number() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    value_c() = default;
    value_c(const value_c& other);
    value_c& operator=(const value_c& other);
    ~value_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    uint16_t&                               transaction_id();
    cells_broadcast_completed_list_l&       cells_broadcast_completed_list();
    crit_diagnostics_s&                     crit_diagnostics();
    ded_si_delivery_needed_ue_list_l&       ded_si_delivery_needed_ue_list();
    const uint16_t&                         transaction_id() const;
    const cells_broadcast_completed_list_l& cells_broadcast_completed_list() const;
    const crit_diagnostics_s&               crit_diagnostics() const;
    const ded_si_delivery_needed_ue_list_l& ded_si_delivery_needed_ue_list() const;

  private:
    types                                                                                                   type_;
    choice_buffer_t<cells_broadcast_completed_list_l, crit_diagnostics_s, ded_si_delivery_needed_ue_list_l> c;

    void destroy_();
  };

  // members lookup methods
  static uint32_t   idx_to_id(uint32_t idx);
  static bool       is_id_valid(const uint32_t& id);
  static crit_e     get_crit(const uint32_t& id);
  static value_c    get_value(const uint32_t& id);
  static presence_e get_presence(const uint32_t& id);
};

struct f1_removal_fail_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                              crit_diagnostics_present = false;
  ie_field_s<integer<uint16_t, 0, 255, true, true>> transaction_id;
  ie_field_s<cause_c>                               cause;
  ie_field_s<crit_diagnostics_s>                    crit_diagnostics;

  // sequence methods
  f1_removal_fail_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// F1RemovalFailure ::= SEQUENCE
using f1_removal_fail_s = elementary_procedure_option<f1_removal_fail_ies_container>;

// F1RemovalRequest ::= SEQUENCE
using f1_removal_request_s = elementary_procedure_option<protocol_ie_container_l<f1_removal_request_ies_o>>;

struct f1_removal_resp_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                              crit_diagnostics_present = false;
  ie_field_s<integer<uint16_t, 0, 255, true, true>> transaction_id;
  ie_field_s<crit_diagnostics_s>                    crit_diagnostics;

  // sequence methods
  f1_removal_resp_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// F1RemovalResponse ::= SEQUENCE
using f1_removal_resp_s = elementary_procedure_option<f1_removal_resp_ies_container>;

struct f1_setup_fail_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                              time_to_wait_present     = false;
  bool                                              crit_diagnostics_present = false;
  ie_field_s<integer<uint16_t, 0, 255, true, true>> transaction_id;
  ie_field_s<cause_c>                               cause;
  ie_field_s<time_to_wait_e>                        time_to_wait;
  ie_field_s<crit_diagnostics_s>                    crit_diagnostics;

  // sequence methods
  f1_setup_fail_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// F1SetupFailure ::= SEQUENCE
using f1_setup_fail_s = elementary_procedure_option<f1_setup_fail_ies_container>;

struct f1_setup_request_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                                       gnb_du_name_present                  = false;
  bool                                                       gnb_du_served_cells_list_present     = false;
  bool                                                       transport_layer_address_info_present = false;
  bool                                                       bap_address_present                  = false;
  bool                                                       extended_gnb_du_name_present         = false;
  ie_field_s<integer<uint16_t, 0, 255, true, true>>          transaction_id;
  ie_field_s<integer<uint64_t, 0, 68719476735, false, true>> gnb_du_id;
  ie_field_s<printable_string<1, 150, true, true>>           gnb_du_name;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<gnb_du_served_cells_item_ies_o>, 1, 512, true>>
                                               gnb_du_served_cells_list;
  ie_field_s<rrc_version_s>                    gnb_du_rrc_version;
  ie_field_s<transport_layer_address_info_s>   transport_layer_address_info;
  ie_field_s<fixed_bitstring<10, false, true>> bap_address;
  ie_field_s<extended_gnb_du_name_s>           extended_gnb_du_name;

  // sequence methods
  f1_setup_request_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// F1SetupRequest ::= SEQUENCE
using f1_setup_request_s = elementary_procedure_option<f1_setup_request_ies_container>;

struct f1_setup_resp_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                              gnb_cu_name_present                  = false;
  bool                                              cells_to_be_activ_list_present       = false;
  bool                                              transport_layer_address_info_present = false;
  bool                                              ul_bh_non_up_traffic_map_present     = false;
  bool                                              bap_address_present                  = false;
  bool                                              extended_gnb_cu_name_present         = false;
  ie_field_s<integer<uint16_t, 0, 255, true, true>> transaction_id;
  ie_field_s<printable_string<1, 150, true, true>>  gnb_cu_name;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<cells_to_be_activ_list_item_ies_o>, 1, 512, true>>
                                               cells_to_be_activ_list;
  ie_field_s<rrc_version_s>                    gnb_cu_rrc_version;
  ie_field_s<transport_layer_address_info_s>   transport_layer_address_info;
  ie_field_s<ul_bh_non_up_traffic_map_s>       ul_bh_non_up_traffic_map;
  ie_field_s<fixed_bitstring<10, false, true>> bap_address;
  ie_field_s<extended_gnb_cu_name_s>           extended_gnb_cu_name;

  // sequence methods
  f1_setup_resp_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// F1SetupResponse ::= SEQUENCE
using f1_setup_resp_s = elementary_procedure_option<f1_setup_resp_ies_container>;

struct gnb_cu_cfg_upd_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                              cells_to_be_activ_list_present       = false;
  bool                                              cells_to_be_deactiv_list_present     = false;
  bool                                              gnb_cu_tnl_assoc_to_add_list_present = false;
  bool                                              gnb_cu_tnl_assoc_to_rem_list_present = false;
  bool                                              gnb_cu_tnl_assoc_to_upd_list_present = false;
  bool                                              cells_to_be_barred_list_present      = false;
  bool                                              protected_eutra_res_list_present     = false;
  bool                                              neighbour_cell_info_list_present     = false;
  bool                                              transport_layer_address_info_present = false;
  bool                                              ul_bh_non_up_traffic_map_present     = false;
  bool                                              bap_address_present                  = false;
  bool                                              cco_assist_info_present              = false;
  bool                                              cells_for_son_list_present           = false;
  bool                                              gnb_cu_name_present                  = false;
  bool                                              extended_gnb_cu_name_present         = false;
  ie_field_s<integer<uint16_t, 0, 255, true, true>> transaction_id;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<cells_to_be_activ_list_item_ies_o>, 1, 512, true>>
      cells_to_be_activ_list;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<cells_to_be_deactiv_list_item_ies_o>, 1, 512, true>>
      cells_to_be_deactiv_list;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<gnb_cu_tnl_assoc_to_add_item_ies_o>, 1, 32, true>>
      gnb_cu_tnl_assoc_to_add_list;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<gnb_cu_tnl_assoc_to_rem_item_ies_o>, 1, 32, true>>
      gnb_cu_tnl_assoc_to_rem_list;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<gnb_cu_tnl_assoc_to_upd_item_ies_o>, 1, 32, true>>
      gnb_cu_tnl_assoc_to_upd_list;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<cells_to_be_barred_item_ies_o>, 1, 512, true>>
      cells_to_be_barred_list;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<protected_eutra_res_item_ies_o>, 1, 256, true>>
      protected_eutra_res_list;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<neighbour_cell_info_item_ies_o>, 1, 512, true>>
                                                             neighbour_cell_info_list;
  ie_field_s<transport_layer_address_info_s>                 transport_layer_address_info;
  ie_field_s<ul_bh_non_up_traffic_map_s>                     ul_bh_non_up_traffic_map;
  ie_field_s<fixed_bitstring<10, false, true>>               bap_address;
  ie_field_s<cco_assist_info_s>                              cco_assist_info;
  ie_field_s<dyn_seq_of<cells_for_son_item_s, 1, 256, true>> cells_for_son_list;
  ie_field_s<printable_string<1, 150, true, true>>           gnb_cu_name;
  ie_field_s<extended_gnb_cu_name_s>                         extended_gnb_cu_name;

  // sequence methods
  gnb_cu_cfg_upd_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// GNBCUConfigurationUpdate ::= SEQUENCE
using gnb_cu_cfg_upd_s = elementary_procedure_option<gnb_cu_cfg_upd_ies_container>;

struct gnb_cu_cfg_upd_ack_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                              cells_failed_to_be_activ_list_present         = false;
  bool                                              crit_diagnostics_present                      = false;
  bool                                              gnb_cu_tnl_assoc_setup_list_present           = false;
  bool                                              gnb_cu_tnl_assoc_failed_to_setup_list_present = false;
  bool                                              ded_si_delivery_needed_ue_list_present        = false;
  bool                                              transport_layer_address_info_present          = false;
  ie_field_s<integer<uint16_t, 0, 255, true, true>> transaction_id;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<cells_failed_to_be_activ_list_item_ies_o>, 1, 512, true>>
                                 cells_failed_to_be_activ_list;
  ie_field_s<crit_diagnostics_s> crit_diagnostics;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<gnb_cu_tnl_assoc_setup_item_ies_o>, 1, 32, true>>
      gnb_cu_tnl_assoc_setup_list;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<gnb_cu_tnl_assoc_failed_to_setup_item_ies_o>, 1, 32, true>>
      gnb_cu_tnl_assoc_failed_to_setup_list;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<ded_si_delivery_needed_ue_item_ies_o>, 1, 65536, true>>
                                             ded_si_delivery_needed_ue_list;
  ie_field_s<transport_layer_address_info_s> transport_layer_address_info;

  // sequence methods
  gnb_cu_cfg_upd_ack_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// GNBCUConfigurationUpdateAcknowledge ::= SEQUENCE
using gnb_cu_cfg_upd_ack_s = elementary_procedure_option<gnb_cu_cfg_upd_ack_ies_container>;

struct gnb_cu_cfg_upd_fail_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                              time_to_wait_present     = false;
  bool                                              crit_diagnostics_present = false;
  ie_field_s<integer<uint16_t, 0, 255, true, true>> transaction_id;
  ie_field_s<cause_c>                               cause;
  ie_field_s<time_to_wait_e>                        time_to_wait;
  ie_field_s<crit_diagnostics_s>                    crit_diagnostics;

  // sequence methods
  gnb_cu_cfg_upd_fail_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// GNBCUConfigurationUpdateFailure ::= SEQUENCE
using gnb_cu_cfg_upd_fail_s = elementary_procedure_option<gnb_cu_cfg_upd_fail_ies_container>;

struct gnb_du_cfg_upd_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                              served_cells_to_add_list_present       = false;
  bool                                              served_cells_to_modify_list_present    = false;
  bool                                              served_cells_to_delete_list_present    = false;
  bool                                              cells_status_list_present              = false;
  bool                                              ded_si_delivery_needed_ue_list_present = false;
  bool                                              gnb_du_id_present                      = false;
  bool                                              gnb_du_tnl_assoc_to_rem_list_present   = false;
  bool                                              transport_layer_address_info_present   = false;
  bool                                              coverage_mod_notif_present             = false;
  bool                                              gnb_du_name_present                    = false;
  bool                                              extended_gnb_du_name_present           = false;
  ie_field_s<integer<uint16_t, 0, 255, true, true>> transaction_id;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<served_cells_to_add_item_ies_o>, 1, 512, true>>
      served_cells_to_add_list;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<served_cells_to_modify_item_ies_o>, 1, 512, true>>
      served_cells_to_modify_list;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<served_cells_to_delete_item_ies_o>, 1, 512, true>>
      served_cells_to_delete_list;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<cells_status_item_ies_o>, 0, 512, true>> cells_status_list;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<ded_si_delivery_needed_ue_item_ies_o>, 1, 65536, true>>
                                                             ded_si_delivery_needed_ue_list;
  ie_field_s<integer<uint64_t, 0, 68719476735, false, true>> gnb_du_id;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<gnb_du_tnl_assoc_to_rem_item_ies_o>, 1, 32, true>>
                                                   gnb_du_tnl_assoc_to_rem_list;
  ie_field_s<transport_layer_address_info_s>       transport_layer_address_info;
  ie_field_s<coverage_mod_notif_s>                 coverage_mod_notif;
  ie_field_s<printable_string<1, 150, true, true>> gnb_du_name;
  ie_field_s<extended_gnb_du_name_s>               extended_gnb_du_name;

  // sequence methods
  gnb_du_cfg_upd_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// GNBDUConfigurationUpdate ::= SEQUENCE
using gnb_du_cfg_upd_s = elementary_procedure_option<gnb_du_cfg_upd_ies_container>;

struct gnb_du_cfg_upd_ack_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                              cells_to_be_activ_list_present       = false;
  bool                                              crit_diagnostics_present             = false;
  bool                                              cells_to_be_deactiv_list_present     = false;
  bool                                              transport_layer_address_info_present = false;
  bool                                              ul_bh_non_up_traffic_map_present     = false;
  bool                                              bap_address_present                  = false;
  bool                                              cells_for_son_list_present           = false;
  ie_field_s<integer<uint16_t, 0, 255, true, true>> transaction_id;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<cells_to_be_activ_list_item_ies_o>, 1, 512, true>>
                                 cells_to_be_activ_list;
  ie_field_s<crit_diagnostics_s> crit_diagnostics;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<cells_to_be_deactiv_list_item_ies_o>, 1, 512, true>>
                                                             cells_to_be_deactiv_list;
  ie_field_s<transport_layer_address_info_s>                 transport_layer_address_info;
  ie_field_s<ul_bh_non_up_traffic_map_s>                     ul_bh_non_up_traffic_map;
  ie_field_s<fixed_bitstring<10, false, true>>               bap_address;
  ie_field_s<dyn_seq_of<cells_for_son_item_s, 1, 256, true>> cells_for_son_list;

  // sequence methods
  gnb_du_cfg_upd_ack_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// GNBDUConfigurationUpdateAcknowledge ::= SEQUENCE
using gnb_du_cfg_upd_ack_s = elementary_procedure_option<gnb_du_cfg_upd_ack_ies_container>;

struct gnb_du_cfg_upd_fail_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                              time_to_wait_present     = false;
  bool                                              crit_diagnostics_present = false;
  ie_field_s<integer<uint16_t, 0, 255, true, true>> transaction_id;
  ie_field_s<cause_c>                               cause;
  ie_field_s<time_to_wait_e>                        time_to_wait;
  ie_field_s<crit_diagnostics_s>                    crit_diagnostics;

  // sequence methods
  gnb_du_cfg_upd_fail_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// GNBDUConfigurationUpdateFailure ::= SEQUENCE
using gnb_du_cfg_upd_fail_s = elementary_procedure_option<gnb_du_cfg_upd_fail_ies_container>;

struct gnb_du_res_cfg_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                                                    activ_cells_to_be_upd_list_present = false;
  bool                                                                    child_nodes_list_present           = false;
  bool                                                                    neighbour_node_cells_list_present  = false;
  bool                                                                    serving_cells_list_present         = false;
  ie_field_s<integer<uint16_t, 0, 255, true, true>>                       transaction_id;
  ie_field_s<dyn_seq_of<activ_cells_to_be_upd_list_item_s, 1, 512, true>> activ_cells_to_be_upd_list;
  ie_field_s<dyn_seq_of<child_nodes_list_item_s, 1, 1024, true>>          child_nodes_list;
  ie_field_s<dyn_seq_of<neighbour_node_cells_list_item_s, 1, 1024, true>> neighbour_node_cells_list;
  ie_field_s<dyn_seq_of<serving_cells_list_item_s, 1, 32, true>>          serving_cells_list;

  // sequence methods
  gnb_du_res_cfg_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// GNBDUResourceConfiguration ::= SEQUENCE
using gnb_du_res_cfg_s = elementary_procedure_option<gnb_du_res_cfg_ies_container>;

struct gnb_du_res_cfg_ack_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                              crit_diagnostics_present = false;
  ie_field_s<integer<uint16_t, 0, 255, true, true>> transaction_id;
  ie_field_s<crit_diagnostics_s>                    crit_diagnostics;

  // sequence methods
  gnb_du_res_cfg_ack_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// GNBDUResourceConfigurationAcknowledge ::= SEQUENCE
using gnb_du_res_cfg_ack_s = elementary_procedure_option<gnb_du_res_cfg_ack_ies_container>;

struct gnb_du_res_cfg_fail_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                              time_to_wait_present     = false;
  bool                                              crit_diagnostics_present = false;
  ie_field_s<integer<uint16_t, 0, 255, true, true>> transaction_id;
  ie_field_s<cause_c>                               cause;
  ie_field_s<time_to_wait_e>                        time_to_wait;
  ie_field_s<crit_diagnostics_s>                    crit_diagnostics;

  // sequence methods
  gnb_du_res_cfg_fail_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// GNBDUResourceConfigurationFailure ::= SEQUENCE
using gnb_du_res_cfg_fail_s = elementary_procedure_option<gnb_du_res_cfg_fail_ies_container>;

struct gnb_du_res_coordination_request_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                              ignore_res_coordination_container_present = false;
  ie_field_s<integer<uint16_t, 0, 255, true, true>> transaction_id;
  ie_field_s<request_type_e>                        request_type;
  ie_field_s<unbounded_octstring<true>>             eutra_nr_cell_res_coordination_req_container;
  ie_field_s<ignore_res_coordination_container_e>   ignore_res_coordination_container;

  // sequence methods
  gnb_du_res_coordination_request_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// GNBDUResourceCoordinationRequest ::= SEQUENCE
using gnb_du_res_coordination_request_s = elementary_procedure_option<gnb_du_res_coordination_request_ies_container>;

struct gnb_du_res_coordination_resp_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  ie_field_s<integer<uint16_t, 0, 255, true, true>> transaction_id;
  ie_field_s<unbounded_octstring<true>>             eutra_nr_cell_res_coordination_req_ack_container;

  // sequence methods
  gnb_du_res_coordination_resp_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// GNBDUResourceCoordinationResponse ::= SEQUENCE
using gnb_du_res_coordination_resp_s = elementary_procedure_option<gnb_du_res_coordination_resp_ies_container>;

struct gnb_du_status_ind_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                              iab_congestion_ind_present = false;
  ie_field_s<integer<uint16_t, 0, 255, true, true>> transaction_id;
  ie_field_s<gnb_du_overload_info_e>                gnb_du_overload_info;
  ie_field_s<iab_congestion_ind_s>                  iab_congestion_ind;

  // sequence methods
  gnb_du_status_ind_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// GNBDUStatusIndication ::= SEQUENCE
using gnb_du_status_ind_s = elementary_procedure_option<gnb_du_status_ind_ies_container>;

struct iab_tnl_address_fail_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                              time_to_wait_present     = false;
  bool                                              crit_diagnostics_present = false;
  ie_field_s<integer<uint16_t, 0, 255, true, true>> transaction_id;
  ie_field_s<cause_c>                               cause;
  ie_field_s<time_to_wait_e>                        time_to_wait;
  ie_field_s<crit_diagnostics_s>                    crit_diagnostics;

  // sequence methods
  iab_tnl_address_fail_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// IABTNLAddressFailure ::= SEQUENCE
using iab_tnl_address_fail_s = elementary_procedure_option<iab_tnl_address_fail_ies_container>;

struct iab_tnl_address_request_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                              ia_bv4_addresses_requested_present    = false;
  bool                                              iab_ip_v6_request_type_present        = false;
  bool                                              iab_tnl_addresses_to_rem_list_present = false;
  bool                                              iab_tnl_addresses_exception_present   = false;
  ie_field_s<integer<uint16_t, 0, 255, true, true>> transaction_id;
  ie_field_s<ia_bv4_addresses_requested_s>          ia_bv4_addresses_requested;
  ie_field_s<iab_ip_v6_request_type_c>              iab_ip_v6_request_type;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<iab_tnl_addresses_to_rem_item_ies_o>, 1, 1024, true>>
                                            iab_tnl_addresses_to_rem_list;
  ie_field_s<iab_tnl_addresses_exception_s> iab_tnl_addresses_exception;

  // sequence methods
  iab_tnl_address_request_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// IABTNLAddressRequest ::= SEQUENCE
using iab_tnl_address_request_s = elementary_procedure_option<iab_tnl_address_request_ies_container>;

struct iab_tnl_address_resp_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  ie_field_s<integer<uint16_t, 0, 255, true, true>> transaction_id;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<iab_allocated_tnl_address_list_item_ies_o>, 1, 1024, true>>
      iab_allocated_tnl_address_list;

  // sequence methods
  iab_tnl_address_resp_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// IABTNLAddressResponse ::= SEQUENCE
using iab_tnl_address_resp_s = elementary_procedure_option<iab_tnl_address_resp_ies_container>;

struct iab_up_cfg_upd_fail_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                              time_to_wait_present     = false;
  bool                                              crit_diagnostics_present = false;
  ie_field_s<integer<uint16_t, 0, 255, true, true>> transaction_id;
  ie_field_s<cause_c>                               cause;
  ie_field_s<time_to_wait_e>                        time_to_wait;
  ie_field_s<crit_diagnostics_s>                    crit_diagnostics;

  // sequence methods
  iab_up_cfg_upd_fail_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// IABUPConfigurationUpdateFailure ::= SEQUENCE
using iab_up_cfg_upd_fail_s = elementary_procedure_option<iab_up_cfg_upd_fail_ies_container>;

struct iab_up_cfg_upd_request_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                              ul_up_tnl_info_to_upd_list_present    = false;
  bool                                              ul_up_tnl_address_to_upd_list_present = false;
  ie_field_s<integer<uint16_t, 0, 255, true, true>> transaction_id;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<ul_up_tnl_info_to_upd_list_item_ies_o>, 1, 32678, true>>
      ul_up_tnl_info_to_upd_list;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<ul_up_tnl_address_to_upd_list_item_ies_o>, 1, 8, true>>
      ul_up_tnl_address_to_upd_list;

  // sequence methods
  iab_up_cfg_upd_request_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// IABUPConfigurationUpdateRequest ::= SEQUENCE
using iab_up_cfg_upd_request_s = elementary_procedure_option<iab_up_cfg_upd_request_ies_container>;

struct iab_up_cfg_upd_resp_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                              crit_diagnostics_present              = false;
  bool                                              dl_up_tnl_address_to_upd_list_present = false;
  ie_field_s<integer<uint16_t, 0, 255, true, true>> transaction_id;
  ie_field_s<crit_diagnostics_s>                    crit_diagnostics;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<dl_up_tnl_address_to_upd_list_item_ies_o>, 1, 8, true>>
      dl_up_tnl_address_to_upd_list;

  // sequence methods
  iab_up_cfg_upd_resp_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// IABUPConfigurationUpdateResponse ::= SEQUENCE
using iab_up_cfg_upd_resp_s = elementary_procedure_option<iab_up_cfg_upd_resp_ies_container>;

struct init_ul_rrc_msg_transfer_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                                      du_to_cu_rrc_container_present           = false;
  bool                                                      sul_access_ind_present                   = false;
  bool                                                      ran_ue_id_present                        = false;
  bool                                                      rrc_container_rrc_setup_complete_present = false;
  bool                                                      nr_red_cap_ue_ind_present                = false;
  bool                                                      sdt_info_present                         = false;
  bool                                                      sidelink_relay_cfg_present               = false;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_du_ue_f1ap_id;
  ie_field_s<nr_cgi_s>                                      nr_cgi;
  ie_field_s<integer<uint32_t, 0, 65535, true, true>>       c_rnti;
  ie_field_s<unbounded_octstring<true>>                     rrc_container;
  ie_field_s<unbounded_octstring<true>>                     du_to_cu_rrc_container;
  ie_field_s<sul_access_ind_e>                              sul_access_ind;
  ie_field_s<integer<uint16_t, 0, 255, true, true>>         transaction_id;
  ie_field_s<fixed_octstring<8, true>>                      ran_ue_id;
  ie_field_s<unbounded_octstring<true>>                     rrc_container_rrc_setup_complete;
  ie_field_s<nr_red_cap_ue_ind_e>                           nr_red_cap_ue_ind;
  ie_field_s<sdt_info_s>                                    sdt_info;
  ie_field_s<sidelink_relay_cfg_s>                          sidelink_relay_cfg;

  // sequence methods
  init_ul_rrc_msg_transfer_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// InitialULRRCMessageTransfer ::= SEQUENCE
using init_ul_rrc_msg_transfer_s = elementary_procedure_option<init_ul_rrc_msg_transfer_ies_container>;

struct meas_activation_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                                          prs_meas_info_list_present = false;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>>     gnb_cu_ue_f1ap_id;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>>     gnb_du_ue_f1ap_id;
  ie_field_s<activation_request_type_e>                         activation_request_type;
  ie_field_s<dyn_seq_of<prs_meas_info_list_item_s, 1, 4, true>> prs_meas_info_list;

  // sequence methods
  meas_activation_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MeasurementActivation ::= SEQUENCE
using meas_activation_s = elementary_procedure_option<meas_activation_ies_container>;

struct meas_precfg_confirm_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                                      pos_meas_gap_pre_cfg_list_present = false;
  bool                                                      crit_diagnostics_present          = false;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_cu_ue_f1ap_id;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_du_ue_f1ap_id;
  ie_field_s<pos_meas_gap_pre_cfg_list_s>                   pos_meas_gap_pre_cfg_list;
  ie_field_s<crit_diagnostics_s>                            crit_diagnostics;

  // sequence methods
  meas_precfg_confirm_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MeasurementPreconfigurationConfirm ::= SEQUENCE
using meas_precfg_confirm_s = elementary_procedure_option<meas_precfg_confirm_ies_container>;

struct meas_precfg_refuse_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                                      crit_diagnostics_present = false;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_cu_ue_f1ap_id;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_du_ue_f1ap_id;
  ie_field_s<cause_c>                                       cause;
  ie_field_s<crit_diagnostics_s>                            crit_diagnostics;

  // sequence methods
  meas_precfg_refuse_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MeasurementPreconfigurationRefuse ::= SEQUENCE
using meas_precfg_refuse_s = elementary_procedure_option<meas_precfg_refuse_ies_container>;

struct meas_precfg_required_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>>      gnb_cu_ue_f1ap_id;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>>      gnb_du_ue_f1ap_id;
  ie_field_s<dyn_seq_of<trp_prs_info_list_item_s, 1, 256, true>> trp_prs_info_list;

  // sequence methods
  meas_precfg_required_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MeasurementPreconfigurationRequired ::= SEQUENCE
using meas_precfg_required_s = elementary_procedure_option<meas_precfg_required_ies_container>;

struct multicast_context_mod_fail_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                                      crit_diagnostics_present = false;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_cu_mbs_f1ap_id;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_du_mbs_f1ap_id;
  ie_field_s<cause_c>                                       cause;
  ie_field_s<crit_diagnostics_s>                            crit_diagnostics;

  // sequence methods
  multicast_context_mod_fail_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MulticastContextModificationFailure ::= SEQUENCE
using multicast_context_mod_fail_s = elementary_procedure_option<multicast_context_mod_fail_ies_container>;

struct multicast_context_mod_request_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                                      mbs_service_area_present                     = false;
  bool                                                      multicast_m_rbs_to_be_setup_mod_list_present = false;
  bool                                                      multicast_m_rbs_to_be_modified_list_present  = false;
  bool                                                      multicast_m_rbs_to_be_released_list_present  = false;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_cu_mbs_f1ap_id;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_du_mbs_f1ap_id;
  ie_field_s<mbs_service_area_c>                            mbs_service_area;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<multicast_m_rbs_to_be_setup_mod_item_ies_o>, 1, 32, true>>
      multicast_m_rbs_to_be_setup_mod_list;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<multicast_m_rbs_to_be_modified_item_ies_o>, 1, 32, true>>
      multicast_m_rbs_to_be_modified_list;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<multicast_m_rbs_to_be_released_item_ies_o>, 1, 32, true>>
      multicast_m_rbs_to_be_released_list;

  // sequence methods
  multicast_context_mod_request_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MulticastContextModificationRequest ::= SEQUENCE
using multicast_context_mod_request_s = elementary_procedure_option<multicast_context_mod_request_ies_container>;

struct multicast_context_mod_resp_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                                      multicast_m_rbs_setup_mod_list_present              = false;
  bool                                                      multicast_m_rbs_failed_to_be_setup_mod_list_present = false;
  bool                                                      multicast_m_rbs_modified_list_present               = false;
  bool                                                      multicast_m_rbs_failed_to_be_modified_list_present  = false;
  bool                                                      crit_diagnostics_present                            = false;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_cu_mbs_f1ap_id;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_du_mbs_f1ap_id;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<multicast_m_rbs_setup_mod_item_ies_o>, 1, 32, true>>
      multicast_m_rbs_setup_mod_list;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<multicast_m_rbs_failed_to_be_setup_mod_item_ies_o>, 1, 32, true>>
      multicast_m_rbs_failed_to_be_setup_mod_list;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<multicast_m_rbs_modified_item_ies_o>, 1, 32, true>>
      multicast_m_rbs_modified_list;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<multicast_m_rbs_failed_to_be_modified_item_ies_o>, 1, 32, true>>
                                 multicast_m_rbs_failed_to_be_modified_list;
  ie_field_s<crit_diagnostics_s> crit_diagnostics;

  // sequence methods
  multicast_context_mod_resp_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MulticastContextModificationResponse ::= SEQUENCE
using multicast_context_mod_resp_s = elementary_procedure_option<multicast_context_mod_resp_ies_container>;

struct multicast_context_release_cmd_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_cu_mbs_f1ap_id;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_du_mbs_f1ap_id;
  ie_field_s<cause_c>                                       cause;

  // sequence methods
  multicast_context_release_cmd_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MulticastContextReleaseCommand ::= SEQUENCE
using multicast_context_release_cmd_s = elementary_procedure_option<multicast_context_release_cmd_ies_container>;

struct multicast_context_release_complete_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                                      crit_diagnostics_present = false;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_cu_mbs_f1ap_id;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_du_mbs_f1ap_id;
  ie_field_s<crit_diagnostics_s>                            crit_diagnostics;

  // sequence methods
  multicast_context_release_complete_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MulticastContextReleaseComplete ::= SEQUENCE
using multicast_context_release_complete_s =
    elementary_procedure_option<multicast_context_release_complete_ies_container>;

struct multicast_context_release_request_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_cu_mbs_f1ap_id;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_du_mbs_f1ap_id;
  ie_field_s<cause_c>                                       cause;

  // sequence methods
  multicast_context_release_request_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MulticastContextReleaseRequest ::= SEQUENCE
using multicast_context_release_request_s =
    elementary_procedure_option<multicast_context_release_request_ies_container>;

struct multicast_context_setup_fail_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                                      gnb_du_mbs_f1ap_id_present = false;
  bool                                                      crit_diagnostics_present   = false;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_cu_mbs_f1ap_id;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_du_mbs_f1ap_id;
  ie_field_s<cause_c>                                       cause;
  ie_field_s<crit_diagnostics_s>                            crit_diagnostics;

  // sequence methods
  multicast_context_setup_fail_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MulticastContextSetupFailure ::= SEQUENCE
using multicast_context_setup_fail_s = elementary_procedure_option<multicast_context_setup_fail_ies_container>;

struct multicast_context_setup_request_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                                      mbs_service_area_present = false;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_cu_mbs_f1ap_id;
  ie_field_s<mbs_session_id_s>                              mbs_session_id;
  ie_field_s<mbs_service_area_c>                            mbs_service_area;
  ie_field_s<snssai_s>                                      snssai;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<multicast_m_rbs_to_be_setup_item_ies_o>, 1, 32, true>>
      multicast_m_rbs_to_be_setup_list;

  // sequence methods
  multicast_context_setup_request_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MulticastContextSetupRequest ::= SEQUENCE
using multicast_context_setup_request_s = elementary_procedure_option<multicast_context_setup_request_ies_container>;

struct multicast_context_setup_resp_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                                      multicast_m_rbs_failed_to_be_setup_list_present = false;
  bool                                                      crit_diagnostics_present                        = false;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_cu_mbs_f1ap_id;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_du_mbs_f1ap_id;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<multicast_m_rbs_setup_item_ies_o>, 1, 32, true>>
      multicast_m_rbs_setup_list;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<multicast_m_rbs_failed_to_be_setup_item_ies_o>, 1, 32, true>>
                                 multicast_m_rbs_failed_to_be_setup_list;
  ie_field_s<crit_diagnostics_s> crit_diagnostics;

  // sequence methods
  multicast_context_setup_resp_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MulticastContextSetupResponse ::= SEQUENCE
using multicast_context_setup_resp_s = elementary_procedure_option<multicast_context_setup_resp_ies_container>;

struct multicast_distribution_release_cmd_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_cu_mbs_f1ap_id;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_du_mbs_f1ap_id;
  ie_field_s<mbs_multicast_f1_u_context_descriptor_s>       mbs_multicast_f1_u_context_descriptor;
  ie_field_s<cause_c>                                       cause;

  // sequence methods
  multicast_distribution_release_cmd_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MulticastDistributionReleaseCommand ::= SEQUENCE
using multicast_distribution_release_cmd_s =
    elementary_procedure_option<multicast_distribution_release_cmd_ies_container>;

struct multicast_distribution_release_complete_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                                      crit_diagnostics_present = false;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_cu_mbs_f1ap_id;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_du_mbs_f1ap_id;
  ie_field_s<mbs_multicast_f1_u_context_descriptor_s>       mbs_multicast_f1_u_context_descriptor;
  ie_field_s<crit_diagnostics_s>                            crit_diagnostics;

  // sequence methods
  multicast_distribution_release_complete_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MulticastDistributionReleaseComplete ::= SEQUENCE
using multicast_distribution_release_complete_s =
    elementary_procedure_option<multicast_distribution_release_complete_ies_container>;

struct multicast_distribution_setup_fail_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                                      gnb_du_mbs_f1ap_id_present = false;
  bool                                                      crit_diagnostics_present   = false;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_cu_mbs_f1ap_id;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_du_mbs_f1ap_id;
  ie_field_s<mbs_multicast_f1_u_context_descriptor_s>       mbs_multicast_f1_u_context_descriptor;
  ie_field_s<cause_c>                                       cause;
  ie_field_s<crit_diagnostics_s>                            crit_diagnostics;

  // sequence methods
  multicast_distribution_setup_fail_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MulticastDistributionSetupFailure ::= SEQUENCE
using multicast_distribution_setup_fail_s =
    elementary_procedure_option<multicast_distribution_setup_fail_ies_container>;

struct multicast_distribution_setup_request_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_cu_mbs_f1ap_id;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_du_mbs_f1ap_id;
  ie_field_s<mbs_multicast_f1_u_context_descriptor_s>       mbs_multicast_f1_u_context_descriptor;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<multicast_f1_u_context_to_be_setup_item_ies_o>, 1, 32, true>>
      multicast_f1_u_context_to_be_setup_list;

  // sequence methods
  multicast_distribution_setup_request_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MulticastDistributionSetupRequest ::= SEQUENCE
using multicast_distribution_setup_request_s =
    elementary_procedure_option<multicast_distribution_setup_request_ies_container>;

struct multicast_distribution_setup_resp_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool multicast_f1_u_context_failed_to_be_setup_list_present = false;
  bool crit_diagnostics_present                               = false;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_cu_mbs_f1ap_id;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_du_mbs_f1ap_id;
  ie_field_s<mbs_multicast_f1_u_context_descriptor_s>       mbs_multicast_f1_u_context_descriptor;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<multicast_f1_u_context_setup_item_ies_o>, 1, 32, true>>
      multicast_f1_u_context_setup_list;
  ie_field_s<
      dyn_seq_of<protocol_ie_single_container_s<multicast_f1_u_context_failed_to_be_setup_item_ies_o>, 1, 32, true>>
                                       multicast_f1_u_context_failed_to_be_setup_list;
  ie_field_s<crit_diagnostics_s>       crit_diagnostics;
  ie_field_s<fixed_octstring<4, true>> multicast_f1_u_context_ref_cu;

  // sequence methods
  multicast_distribution_setup_resp_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MulticastDistributionSetupResponse ::= SEQUENCE
using multicast_distribution_setup_resp_s =
    elementary_procedure_option<multicast_distribution_setup_resp_ies_container>;

struct multicast_group_paging_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                         ue_id_list_for_paging_list_present = false;
  bool                         mc_paging_cell_list_present        = false;
  ie_field_s<mbs_session_id_s> mbs_session_id;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<ue_id_list_for_paging_item_ies_o>, 1, 4096, true>>
      ue_id_list_for_paging_list;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<mc_paging_cell_item_ies_o>, 1, 512, true>> mc_paging_cell_list;

  // sequence methods
  multicast_group_paging_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// MulticastGroupPaging ::= SEQUENCE
using multicast_group_paging_s = elementary_procedure_option<multicast_group_paging_ies_container>;

struct network_access_rate_reduction_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  ie_field_s<integer<uint16_t, 0, 255, true, true>> transaction_id;
  ie_field_s<uac_assist_info_s>                     uac_assist_info;

  // sequence methods
  network_access_rate_reduction_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// NetworkAccessRateReduction ::= SEQUENCE
using network_access_rate_reduction_s = elementary_procedure_option<network_access_rate_reduction_ies_container>;

struct notify_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>>                                  gnb_cu_ue_f1ap_id;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>>                                  gnb_du_ue_f1ap_id;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<drb_notify_item_ies_o>, 1, 64, true>> drb_notify_list;

  // sequence methods
  notify_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// Notify ::= SEQUENCE
using notify_s = elementary_procedure_option<notify_ies_container>;

struct pdc_meas_fail_ind_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_cu_ue_f1ap_id;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_du_ue_f1ap_id;
  ie_field_s<integer<uint8_t, 1, 16, true, true>>           ran_ue_pdc_meas_id;
  ie_field_s<cause_c>                                       cause;

  // sequence methods
  pdc_meas_fail_ind_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PDCMeasurementFailureIndication ::= SEQUENCE
using pdc_meas_fail_ind_s = elementary_procedure_option<pdc_meas_fail_ind_ies_container>;

struct pdc_meas_initiation_fail_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                                      crit_diagnostics_present = false;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_cu_ue_f1ap_id;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_du_ue_f1ap_id;
  ie_field_s<integer<uint8_t, 1, 16, true, true>>           ran_ue_pdc_meas_id;
  ie_field_s<cause_c>                                       cause;
  ie_field_s<crit_diagnostics_s>                            crit_diagnostics;

  // sequence methods
  pdc_meas_initiation_fail_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PDCMeasurementInitiationFailure ::= SEQUENCE
using pdc_meas_initiation_fail_s = elementary_procedure_option<pdc_meas_initiation_fail_ies_container>;

struct pdc_meas_initiation_request_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                                      pdc_meas_periodicity_present = false;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_cu_ue_f1ap_id;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_du_ue_f1ap_id;
  ie_field_s<integer<uint8_t, 1, 16, true, true>>           ran_ue_pdc_meas_id;
  ie_field_s<pdc_report_type_e>                             pdc_report_type;
  ie_field_s<pdc_meas_periodicity_e>                        pdc_meas_periodicity;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<pdc_meas_quantities_item_ies_o>, 1, 16, true>>
      pdc_meas_quantities;

  // sequence methods
  pdc_meas_initiation_request_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PDCMeasurementInitiationRequest ::= SEQUENCE
using pdc_meas_initiation_request_s = elementary_procedure_option<pdc_meas_initiation_request_ies_container>;

struct pdc_meas_initiation_resp_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                                      pdc_meas_result_present  = false;
  bool                                                      crit_diagnostics_present = false;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_cu_ue_f1ap_id;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_du_ue_f1ap_id;
  ie_field_s<integer<uint8_t, 1, 16, true, true>>           ran_ue_pdc_meas_id;
  ie_field_s<pdc_meas_result_s>                             pdc_meas_result;
  ie_field_s<crit_diagnostics_s>                            crit_diagnostics;

  // sequence methods
  pdc_meas_initiation_resp_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PDCMeasurementInitiationResponse ::= SEQUENCE
using pdc_meas_initiation_resp_s = elementary_procedure_option<pdc_meas_initiation_resp_ies_container>;

struct pdc_meas_report_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_cu_ue_f1ap_id;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_du_ue_f1ap_id;
  ie_field_s<integer<uint8_t, 1, 16, true, true>>           ran_ue_pdc_meas_id;
  ie_field_s<pdc_meas_result_s>                             pdc_meas_result;

  // sequence methods
  pdc_meas_report_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PDCMeasurementReport ::= SEQUENCE
using pdc_meas_report_s = elementary_procedure_option<pdc_meas_report_ies_container>;

struct pdc_meas_termination_cmd_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_cu_ue_f1ap_id;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_du_ue_f1ap_id;
  ie_field_s<integer<uint8_t, 1, 16, true, true>>           ran_ue_pdc_meas_id;

  // sequence methods
  pdc_meas_termination_cmd_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PDCMeasurementTerminationCommand ::= SEQUENCE
using pdc_meas_termination_cmd_s = elementary_procedure_option<pdc_meas_termination_cmd_ies_container>;

struct prs_cfg_fail_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                              crit_diagnostics_present = false;
  ie_field_s<integer<uint16_t, 0, 255, true, true>> transaction_id;
  ie_field_s<cause_c>                               cause;
  ie_field_s<crit_diagnostics_s>                    crit_diagnostics;

  // sequence methods
  prs_cfg_fail_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PRSConfigurationFailure ::= SEQUENCE
using prs_cfg_fail_s = elementary_procedure_option<prs_cfg_fail_ies_container>;

struct prs_cfg_request_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  ie_field_s<prs_cfg_request_type_e>                    prs_cfg_request_type;
  ie_field_s<dyn_seq_of<prstrp_item_s, 1, 65535, true>> prstrp_list;

  // sequence methods
  prs_cfg_request_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PRSConfigurationRequest ::= SEQUENCE
using prs_cfg_request_s = elementary_procedure_option<prs_cfg_request_ies_container>;

struct prs_cfg_resp_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                                      prs_tx_trp_list_present  = false;
  bool                                                      crit_diagnostics_present = false;
  ie_field_s<integer<uint16_t, 0, 255, true, true>>         transaction_id;
  ie_field_s<dyn_seq_of<prs_tx_trp_item_s, 1, 65535, true>> prs_tx_trp_list;
  ie_field_s<crit_diagnostics_s>                            crit_diagnostics;

  // sequence methods
  prs_cfg_resp_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PRSConfigurationResponse ::= SEQUENCE
using prs_cfg_resp_s = elementary_procedure_option<prs_cfg_resp_ies_container>;

struct pws_cancel_request_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                                 broadcast_to_be_cancelled_list_present = false;
  bool                                                 cancel_all_warning_msgs_ind_present    = false;
  bool                                                 notif_info_present                     = false;
  ie_field_s<integer<uint16_t, 0, 255, true, true>>    transaction_id;
  ie_field_s<integer<uint32_t, 0, 65535, false, true>> numof_broadcast_request;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<broadcast_to_be_cancelled_list_item_ies_o>, 1, 512, true>>
                                            broadcast_to_be_cancelled_list;
  ie_field_s<cancel_all_warning_msgs_ind_e> cancel_all_warning_msgs_ind;
  ie_field_s<notif_info_s>                  notif_info;

  // sequence methods
  pws_cancel_request_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PWSCancelRequest ::= SEQUENCE
using pws_cancel_request_s = elementary_procedure_option<pws_cancel_request_ies_container>;

struct pws_cancel_resp_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                              cells_broadcast_cancelled_list_present = false;
  bool                                              crit_diagnostics_present               = false;
  ie_field_s<integer<uint16_t, 0, 255, true, true>> transaction_id;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<cells_broadcast_cancelled_list_item_ies_o>, 1, 512, true>>
                                 cells_broadcast_cancelled_list;
  ie_field_s<crit_diagnostics_s> crit_diagnostics;

  // sequence methods
  pws_cancel_resp_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PWSCancelResponse ::= SEQUENCE
using pws_cancel_resp_s = elementary_procedure_option<pws_cancel_resp_ies_container>;

struct pws_fail_ind_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                              pws_failed_nr_cgi_list_present = false;
  ie_field_s<integer<uint16_t, 0, 255, true, true>> transaction_id;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<pws_failed_nr_cgi_list_item_ies_o>, 1, 512, true>>
      pws_failed_nr_cgi_list;

  // sequence methods
  pws_fail_ind_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PWSFailureIndication ::= SEQUENCE
using pws_fail_ind_s = elementary_procedure_option<pws_fail_ind_ies_container>;

struct pws_restart_ind_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  ie_field_s<integer<uint16_t, 0, 255, true, true>> transaction_id;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<nr_cgi_list_for_restart_list_item_ies_o>, 1, 512, true>>
      nr_cgi_list_for_restart_list;

  // sequence methods
  pws_restart_ind_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PWSRestartIndication ::= SEQUENCE
using pws_restart_ind_s = elementary_procedure_option<pws_restart_ind_ies_container>;

struct paging_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                          paging_drx_present                          = false;
  bool                          paging_prio_present                         = false;
  bool                          paging_origin_present                       = false;
  bool                          ran_ue_paging_drx_present                   = false;
  bool                          cn_ue_paging_drx_present                    = false;
  bool                          nr_paginge_drx_info_present                 = false;
  bool                          nr_paginge_drx_infofor_rrc_inactive_present = false;
  bool                          paging_cause_present                        = false;
  bool                          pe_ip_s_assist_info_present                 = false;
  bool                          ue_paging_cap_present                       = false;
  bool                          extended_ue_id_idx_value_present            = false;
  ie_field_s<ue_id_idx_value_c> ue_id_idx_value;
  ie_field_s<paging_id_c>       paging_id;
  ie_field_s<paging_drx_e>      paging_drx;
  ie_field_s<paging_prio_e>     paging_prio;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<paging_cell_item_ies_o>, 1, 512, true>> paging_cell_list;
  ie_field_s<paging_origin_e>                                                                  paging_origin;
  ie_field_s<paging_drx_e>                                                                     ran_ue_paging_drx;
  ie_field_s<paging_drx_e>                                                                     cn_ue_paging_drx;
  ie_field_s<nr_paginge_drx_info_s>                                                            nr_paginge_drx_info;
  ie_field_s<nr_paginge_drx_infofor_rrc_inactive_s> nr_paginge_drx_infofor_rrc_inactive;
  ie_field_s<paging_cause_e>                        paging_cause;
  ie_field_s<pe_ip_s_assist_info_s>                 pe_ip_s_assist_info;
  ie_field_s<ue_paging_cap_s>                       ue_paging_cap;
  ie_field_s<fixed_bitstring<16, false, true>>      extended_ue_id_idx_value;

  // sequence methods
  paging_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// Paging ::= SEQUENCE
using paging_s = elementary_procedure_option<paging_ies_container>;

struct pos_sys_info_delivery_cmd_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  ie_field_s<integer<uint16_t, 0, 255, true, true>>         transaction_id;
  ie_field_s<nr_cgi_s>                                      nr_cgi;
  ie_field_s<dyn_seq_of<pos_sitype_item_s, 1, 32, true>>    pos_sitype_list;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> confirmed_ue_id;

  // sequence methods
  pos_sys_info_delivery_cmd_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PosSystemInformationDeliveryCommand ::= SEQUENCE
using pos_sys_info_delivery_cmd_s = elementary_procedure_option<pos_sys_info_delivery_cmd_ies_container>;

struct positioning_activation_fail_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                                      crit_diagnostics_present = false;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_cu_ue_f1ap_id;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_du_ue_f1ap_id;
  ie_field_s<cause_c>                                       cause;
  ie_field_s<crit_diagnostics_s>                            crit_diagnostics;

  // sequence methods
  positioning_activation_fail_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PositioningActivationFailure ::= SEQUENCE
using positioning_activation_fail_s = elementary_procedure_option<positioning_activation_fail_ies_container>;

struct positioning_activation_request_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                                      activation_time_present = false;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_cu_ue_f1ap_id;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_du_ue_f1ap_id;
  ie_field_s<srs_type_c>                                    srs_type;
  ie_field_s<fixed_bitstring<64, false, true>>              activation_time;

  // sequence methods
  positioning_activation_request_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PositioningActivationRequest ::= SEQUENCE
using positioning_activation_request_s = elementary_procedure_option<positioning_activation_request_ies_container>;

struct positioning_activation_resp_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                                      sys_frame_num_present    = false;
  bool                                                      slot_num_present         = false;
  bool                                                      crit_diagnostics_present = false;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_cu_ue_f1ap_id;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_du_ue_f1ap_id;
  ie_field_s<integer<uint16_t, 0, 1023, false, true>>       sys_frame_num;
  ie_field_s<integer<uint8_t, 0, 79, false, true>>          slot_num;
  ie_field_s<crit_diagnostics_s>                            crit_diagnostics;

  // sequence methods
  positioning_activation_resp_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PositioningActivationResponse ::= SEQUENCE
using positioning_activation_resp_s = elementary_procedure_option<positioning_activation_resp_ies_container>;

struct positioning_assist_info_ctrl_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                              pos_assist_info_present             = false;
  bool                                              pos_broadcast_present               = false;
  bool                                              positioning_broadcast_cells_present = false;
  bool                                              routing_id_present                  = false;
  ie_field_s<integer<uint16_t, 0, 255, true, true>> transaction_id;
  ie_field_s<unbounded_octstring<true>>             pos_assist_info;
  ie_field_s<pos_broadcast_e>                       pos_broadcast;
  ie_field_s<dyn_seq_of<nr_cgi_s, 1, 16384, true>>  positioning_broadcast_cells;
  ie_field_s<unbounded_octstring<true>>             routing_id;

  // sequence methods
  positioning_assist_info_ctrl_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PositioningAssistanceInformationControl ::= SEQUENCE
using positioning_assist_info_ctrl_s = elementary_procedure_option<positioning_assist_info_ctrl_ies_container>;

struct positioning_assist_info_feedback_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                              pos_assist_info_fail_list_present   = false;
  bool                                              positioning_broadcast_cells_present = false;
  bool                                              routing_id_present                  = false;
  bool                                              crit_diagnostics_present            = false;
  ie_field_s<integer<uint16_t, 0, 255, true, true>> transaction_id;
  ie_field_s<unbounded_octstring<true>>             pos_assist_info_fail_list;
  ie_field_s<dyn_seq_of<nr_cgi_s, 1, 16384, true>>  positioning_broadcast_cells;
  ie_field_s<unbounded_octstring<true>>             routing_id;
  ie_field_s<crit_diagnostics_s>                    crit_diagnostics;

  // sequence methods
  positioning_assist_info_feedback_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PositioningAssistanceInformationFeedback ::= SEQUENCE
using positioning_assist_info_feedback_s = elementary_procedure_option<positioning_assist_info_feedback_ies_container>;

struct positioning_deactivation_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_cu_ue_f1ap_id;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_du_ue_f1ap_id;
  ie_field_s<abort_tx_c>                                    abort_tx;

  // sequence methods
  positioning_deactivation_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PositioningDeactivation ::= SEQUENCE
using positioning_deactivation_s = elementary_procedure_option<positioning_deactivation_ies_container>;

struct positioning_info_fail_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                                      crit_diagnostics_present = false;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_cu_ue_f1ap_id;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_du_ue_f1ap_id;
  ie_field_s<cause_c>                                       cause;
  ie_field_s<crit_diagnostics_s>                            crit_diagnostics;

  // sequence methods
  positioning_info_fail_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PositioningInformationFailure ::= SEQUENCE
using positioning_info_fail_s = elementary_procedure_option<positioning_info_fail_ies_container>;

struct positioning_info_request_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                                      requested_srs_tx_characteristics_present = false;
  bool                                                      ue_report_info_present                   = false;
  bool                                                      srs_pos_rrc_inactive_query_ind_present   = false;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_cu_ue_f1ap_id;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_du_ue_f1ap_id;
  ie_field_s<requested_srs_tx_characteristics_s>            requested_srs_tx_characteristics;
  ie_field_s<ue_report_info_s>                              ue_report_info;
  ie_field_s<srs_pos_rrc_inactive_query_ind_e>              srs_pos_rrc_inactive_query_ind;

  // sequence methods
  positioning_info_request_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PositioningInformationRequest ::= SEQUENCE
using positioning_info_request_s = elementary_procedure_option<positioning_info_request_ies_container>;

struct positioning_info_resp_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                                      srs_cfg_present                  = false;
  bool                                                      sfn_initisation_time_present     = false;
  bool                                                      crit_diagnostics_present         = false;
  bool                                                      srs_pos_rrc_inactive_cfg_present = false;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_cu_ue_f1ap_id;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_du_ue_f1ap_id;
  ie_field_s<srs_cfg_s>                                     srs_cfg;
  ie_field_s<fixed_bitstring<64, false, true>>              sfn_initisation_time;
  ie_field_s<crit_diagnostics_s>                            crit_diagnostics;
  ie_field_s<unbounded_octstring<true>>                     srs_pos_rrc_inactive_cfg;

  // sequence methods
  positioning_info_resp_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PositioningInformationResponse ::= SEQUENCE
using positioning_info_resp_s = elementary_procedure_option<positioning_info_resp_ies_container>;

struct positioning_info_upd_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                                      srs_cfg_present              = false;
  bool                                                      sfn_initisation_time_present = false;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_cu_ue_f1ap_id;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_du_ue_f1ap_id;
  ie_field_s<srs_cfg_s>                                     srs_cfg;
  ie_field_s<fixed_bitstring<64, false, true>>              sfn_initisation_time;

  // sequence methods
  positioning_info_upd_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PositioningInformationUpdate ::= SEQUENCE
using positioning_info_upd_s = elementary_procedure_option<positioning_info_upd_ies_container>;

struct positioning_meas_abort_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  ie_field_s<integer<uint16_t, 0, 255, true, true>>   transaction_id;
  ie_field_s<integer<uint32_t, 1, 65536, true, true>> lmf_meas_id;
  ie_field_s<integer<uint32_t, 1, 65536, true, true>> ran_meas_id;

  // sequence methods
  positioning_meas_abort_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PositioningMeasurementAbort ::= SEQUENCE
using positioning_meas_abort_s = elementary_procedure_option<positioning_meas_abort_ies_container>;

struct positioning_meas_fail_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                                crit_diagnostics_present = false;
  ie_field_s<integer<uint16_t, 0, 255, true, true>>   transaction_id;
  ie_field_s<integer<uint32_t, 1, 65536, true, true>> lmf_meas_id;
  ie_field_s<integer<uint32_t, 1, 65536, true, true>> ran_meas_id;
  ie_field_s<cause_c>                                 cause;
  ie_field_s<crit_diagnostics_s>                      crit_diagnostics;

  // sequence methods
  positioning_meas_fail_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PositioningMeasurementFailure ::= SEQUENCE
using positioning_meas_fail_s = elementary_procedure_option<positioning_meas_fail_ies_container>;

struct positioning_meas_fail_ind_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  ie_field_s<integer<uint16_t, 0, 255, true, true>>   transaction_id;
  ie_field_s<integer<uint32_t, 1, 65536, true, true>> lmf_meas_id;
  ie_field_s<integer<uint32_t, 1, 65536, true, true>> ran_meas_id;
  ie_field_s<cause_c>                                 cause;

  // sequence methods
  positioning_meas_fail_ind_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PositioningMeasurementFailureIndication ::= SEQUENCE
using positioning_meas_fail_ind_s = elementary_procedure_option<positioning_meas_fail_ind_ies_container>;

struct positioning_meas_report_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  ie_field_s<integer<uint16_t, 0, 255, true, true>>                transaction_id;
  ie_field_s<integer<uint32_t, 1, 65536, true, true>>              lmf_meas_id;
  ie_field_s<integer<uint32_t, 1, 65536, true, true>>              ran_meas_id;
  ie_field_s<dyn_seq_of<pos_meas_result_list_item_s, 1, 64, true>> pos_meas_result_list;

  // sequence methods
  positioning_meas_report_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PositioningMeasurementReport ::= SEQUENCE
using positioning_meas_report_s = elementary_procedure_option<positioning_meas_report_ies_container>;

struct positioning_meas_request_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                                               pos_meas_periodicity_present             = false;
  bool                                                               sfn_initisation_time_present             = false;
  bool                                                               srs_cfg_present                          = false;
  bool                                                               meas_beam_info_request_present           = false;
  bool                                                               sys_frame_num_present                    = false;
  bool                                                               slot_num_present                         = false;
  bool                                                               pos_meas_periodicity_extended_present    = false;
  bool                                                               resp_time_present                        = false;
  bool                                                               meas_characteristics_request_ind_present = false;
  bool                                                               meas_time_occasion_present               = false;
  bool                                                               pos_meas_amount_present                  = false;
  ie_field_s<integer<uint16_t, 0, 255, true, true>>                  transaction_id;
  ie_field_s<integer<uint32_t, 1, 65536, true, true>>                lmf_meas_id;
  ie_field_s<integer<uint32_t, 1, 65536, true, true>>                ran_meas_id;
  ie_field_s<dyn_seq_of<trp_meas_request_item_s, 1, 64, true>>       trp_meas_request_list;
  ie_field_s<pos_report_characteristics_e>                           pos_report_characteristics;
  ie_field_s<meas_periodicity_e>                                     pos_meas_periodicity;
  ie_field_s<dyn_seq_of<pos_meas_quantities_item_s, 1, 16384, true>> pos_meas_quantities;
  ie_field_s<fixed_bitstring<64, false, true>>                       sfn_initisation_time;
  ie_field_s<srs_cfg_s>                                              srs_cfg;
  ie_field_s<meas_beam_info_request_e>                               meas_beam_info_request;
  ie_field_s<integer<uint16_t, 0, 1023, false, true>>                sys_frame_num;
  ie_field_s<integer<uint8_t, 0, 79, false, true>>                   slot_num;
  ie_field_s<meas_periodicity_extended_e>                            pos_meas_periodicity_extended;
  ie_field_s<resp_time_s>                                            resp_time;
  ie_field_s<fixed_bitstring<16, false, true>>                       meas_characteristics_request_ind;
  ie_field_s<meas_time_occasion_e>                                   meas_time_occasion;
  ie_field_s<pos_meas_amount_e>                                      pos_meas_amount;

  // sequence methods
  positioning_meas_request_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PositioningMeasurementRequest ::= SEQUENCE
using positioning_meas_request_s = elementary_procedure_option<positioning_meas_request_ies_container>;

struct positioning_meas_resp_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                                             pos_meas_result_list_present = false;
  bool                                                             crit_diagnostics_present     = false;
  ie_field_s<integer<uint16_t, 0, 255, true, true>>                transaction_id;
  ie_field_s<integer<uint32_t, 1, 65536, true, true>>              lmf_meas_id;
  ie_field_s<integer<uint32_t, 1, 65536, true, true>>              ran_meas_id;
  ie_field_s<dyn_seq_of<pos_meas_result_list_item_s, 1, 64, true>> pos_meas_result_list;
  ie_field_s<crit_diagnostics_s>                                   crit_diagnostics;

  // sequence methods
  positioning_meas_resp_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PositioningMeasurementResponse ::= SEQUENCE
using positioning_meas_resp_s = elementary_procedure_option<positioning_meas_resp_ies_container>;

struct positioning_meas_upd_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                                     srs_cfg_present                          = false;
  bool                                                     trp_meas_upd_list_present                = false;
  bool                                                     meas_characteristics_request_ind_present = false;
  bool                                                     meas_time_occasion_present               = false;
  ie_field_s<integer<uint16_t, 0, 255, true, true>>        transaction_id;
  ie_field_s<integer<uint32_t, 1, 65536, true, true>>      lmf_meas_id;
  ie_field_s<integer<uint32_t, 1, 65536, true, true>>      ran_meas_id;
  ie_field_s<srs_cfg_s>                                    srs_cfg;
  ie_field_s<dyn_seq_of<trp_meas_upd_item_s, 1, 64, true>> trp_meas_upd_list;
  ie_field_s<fixed_bitstring<16, false, true>>             meas_characteristics_request_ind;
  ie_field_s<meas_time_occasion_e>                         meas_time_occasion;

  // sequence methods
  positioning_meas_upd_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// PositioningMeasurementUpdate ::= SEQUENCE
using positioning_meas_upd_s = elementary_procedure_option<positioning_meas_upd_ies_container>;

template <class valueT_>
struct private_ie_container_item_s {
  private_ie_id_c id;
  crit_e          crit;
  valueT_         value;

  // sequence methods
  private_ie_container_item_s(private_ie_id_c id_, crit_e crit_);
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

struct private_ie_container_empty_l {
  template <class valueT_>
  using ie_field_s = private_ie_container_item_s<valueT_>;

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};
using private_msg_ies_container = private_ie_container_empty_l;

// PrivateMessage ::= SEQUENCE
struct private_msg_s {
  bool                      ext = false;
  private_msg_ies_container private_ies;
  // ...

  // sequence methods
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

struct qo_e_info_transfer_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                                      qo_e_info_present = false;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_cu_ue_f1ap_id;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_du_ue_f1ap_id;
  ie_field_s<qo_e_info_s>                                   qo_e_info;

  // sequence methods
  qo_e_info_transfer_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// QoEInformationTransfer ::= SEQUENCE
using qo_e_info_transfer_s = elementary_procedure_option<qo_e_info_transfer_ies_container>;

struct rrc_delivery_report_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_cu_ue_f1ap_id;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_du_ue_f1ap_id;
  ie_field_s<rrc_delivery_status_s>                         rrc_delivery_status;
  ie_field_s<integer<uint8_t, 0, 3, true, true>>            srb_id;

  // sequence methods
  rrc_delivery_report_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// RRCDeliveryReport ::= SEQUENCE
using rrc_delivery_report_s = elementary_procedure_option<rrc_delivery_report_ies_container>;

struct ref_time_info_report_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  ie_field_s<integer<uint16_t, 0, 255, true, true>> transaction_id;
  ie_field_s<time_ref_info_s>                       time_ref_info;

  // sequence methods
  ref_time_info_report_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// ReferenceTimeInformationReport ::= SEQUENCE
using ref_time_info_report_s = elementary_procedure_option<ref_time_info_report_ies_container>;

struct ref_time_info_report_ctrl_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  ie_field_s<integer<uint16_t, 0, 255, true, true>> transaction_id;
  ie_field_s<report_request_type_s>                 report_request_type;

  // sequence methods
  ref_time_info_report_ctrl_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// ReferenceTimeInformationReportingControl ::= SEQUENCE
using ref_time_info_report_ctrl_s = elementary_procedure_option<ref_time_info_report_ctrl_ies_container>;

struct reset_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  ie_field_s<integer<uint16_t, 0, 255, true, true>> transaction_id;
  ie_field_s<cause_c>                               cause;
  ie_field_s<reset_type_c>                          reset_type;

  // sequence methods
  reset_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// Reset ::= SEQUENCE
using reset_s = elementary_procedure_option<reset_ies_container>;

struct reset_ack_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                              ue_associated_lc_f1_conn_list_res_ack_present = false;
  bool                                              crit_diagnostics_present                      = false;
  ie_field_s<integer<uint16_t, 0, 255, true, true>> transaction_id;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<ue_associated_lc_f1_conn_item_res_ack_o>, 1, 65536, true>>
                                 ue_associated_lc_f1_conn_list_res_ack;
  ie_field_s<crit_diagnostics_s> crit_diagnostics;

  // sequence methods
  reset_ack_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// ResetAcknowledge ::= SEQUENCE
using reset_ack_s = elementary_procedure_option<reset_ack_ies_container>;

struct res_status_fail_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                               crit_diagnostics_present = false;
  ie_field_s<integer<uint16_t, 0, 255, true, true>>  transaction_id;
  ie_field_s<integer<uint16_t, 0, 4095, true, true>> gnb_cu_meas_id;
  ie_field_s<integer<uint16_t, 0, 4095, true, true>> gnb_du_meas_id;
  ie_field_s<cause_c>                                cause;
  ie_field_s<crit_diagnostics_s>                     crit_diagnostics;

  // sequence methods
  res_status_fail_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// ResourceStatusFailure ::= SEQUENCE
using res_status_fail_s = elementary_procedure_option<res_status_fail_ies_container>;

struct res_status_request_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                                        gnb_du_meas_id_present         = false;
  bool                                                        report_characteristics_present = false;
  bool                                                        cell_to_report_list_present    = false;
  bool                                                        report_periodicity_present     = false;
  ie_field_s<integer<uint16_t, 0, 255, true, true>>           transaction_id;
  ie_field_s<integer<uint16_t, 0, 4095, true, true>>          gnb_cu_meas_id;
  ie_field_s<integer<uint16_t, 0, 4095, true, true>>          gnb_du_meas_id;
  ie_field_s<regist_request_e>                                regist_request;
  ie_field_s<fixed_bitstring<32, false, true>>                report_characteristics;
  ie_field_s<dyn_seq_of<cell_to_report_item_s, 1, 512, true>> cell_to_report_list;
  ie_field_s<report_periodicity_e>                            report_periodicity;

  // sequence methods
  res_status_request_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// ResourceStatusRequest ::= SEQUENCE
using res_status_request_s = elementary_procedure_option<res_status_request_ies_container>;

struct res_status_resp_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                               crit_diagnostics_present = false;
  ie_field_s<integer<uint16_t, 0, 255, true, true>>  transaction_id;
  ie_field_s<integer<uint16_t, 0, 4095, true, true>> gnb_cu_meas_id;
  ie_field_s<integer<uint16_t, 0, 4095, true, true>> gnb_du_meas_id;
  ie_field_s<crit_diagnostics_s>                     crit_diagnostics;

  // sequence methods
  res_status_resp_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// ResourceStatusResponse ::= SEQUENCE
using res_status_resp_s = elementary_procedure_option<res_status_resp_ies_container>;

struct res_status_upd_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                                          hardware_load_ind_present     = false;
  bool                                                          tnl_capacity_ind_present      = false;
  bool                                                          cell_meas_result_list_present = false;
  ie_field_s<integer<uint16_t, 0, 255, true, true>>             transaction_id;
  ie_field_s<integer<uint16_t, 0, 4095, true, true>>            gnb_cu_meas_id;
  ie_field_s<integer<uint16_t, 0, 4095, true, true>>            gnb_du_meas_id;
  ie_field_s<hardware_load_ind_s>                               hardware_load_ind;
  ie_field_s<tnl_capacity_ind_s>                                tnl_capacity_ind;
  ie_field_s<dyn_seq_of<cell_meas_result_item_s, 1, 512, true>> cell_meas_result_list;

  // sequence methods
  res_status_upd_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// ResourceStatusUpdate ::= SEQUENCE
using res_status_upd_s = elementary_procedure_option<res_status_upd_ies_container>;

struct sys_info_delivery_cmd_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  ie_field_s<integer<uint16_t, 0, 255, true, true>>         transaction_id;
  ie_field_s<nr_cgi_s>                                      nr_cgi;
  ie_field_s<dyn_seq_of<sitype_item_s, 1, 32, true>>        sitype_list;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> confirmed_ue_id;

  // sequence methods
  sys_info_delivery_cmd_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// SystemInformationDeliveryCommand ::= SEQUENCE
using sys_info_delivery_cmd_s = elementary_procedure_option<sys_info_delivery_cmd_ies_container>;

struct trp_info_fail_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                              crit_diagnostics_present = false;
  ie_field_s<integer<uint16_t, 0, 255, true, true>> transaction_id;
  ie_field_s<cause_c>                               cause;
  ie_field_s<crit_diagnostics_s>                    crit_diagnostics;

  // sequence methods
  trp_info_fail_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// TRPInformationFailure ::= SEQUENCE
using trp_info_fail_s = elementary_procedure_option<trp_info_fail_ies_container>;

struct trp_info_request_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                                    trp_list_present = false;
  ie_field_s<integer<uint16_t, 0, 255, true, true>>       transaction_id;
  ie_field_s<dyn_seq_of<trp_list_item_s, 1, 65535, true>> trp_list;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<trp_info_type_item_trp_req_o>, 1, 64, true>>
      trp_info_type_list_trp_req;

  // sequence methods
  trp_info_request_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// TRPInformationRequest ::= SEQUENCE
using trp_info_request_s = elementary_procedure_option<trp_info_request_ies_container>;

struct trp_info_resp_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                              crit_diagnostics_present = false;
  ie_field_s<integer<uint16_t, 0, 255, true, true>> transaction_id;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<trp_info_item_trp_resp_o>, 1, 65535, true>>
                                 trp_info_list_trp_resp;
  ie_field_s<crit_diagnostics_s> crit_diagnostics;

  // sequence methods
  trp_info_resp_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// TRPInformationResponse ::= SEQUENCE
using trp_info_resp_s = elementary_procedure_option<trp_info_resp_ies_container>;

struct trace_start_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_cu_ue_f1ap_id;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_du_ue_f1ap_id;
  ie_field_s<trace_activation_s>                            trace_activation;

  // sequence methods
  trace_start_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// TraceStart ::= SEQUENCE
using trace_start_s = elementary_procedure_option<trace_start_ies_container>;

struct ue_context_mod_confirm_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool res_coordination_transfer_container_present              = false;
  bool drbs_modified_conf_list_present                          = false;
  bool rrc_container_present                                    = false;
  bool crit_diagnostics_present                                 = false;
  bool execute_dupl_present                                     = false;
  bool res_coordination_transfer_info_present                   = false;
  bool sl_drbs_modified_conf_list_present                       = false;
  bool uu_rlc_ch_modified_list_present                          = false;
  bool pc5_rlc_ch_modified_list_present                         = false;
  bool ue_multicast_m_rbs_confirmed_to_be_modified_list_present = false;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_cu_ue_f1ap_id;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_du_ue_f1ap_id;
  ie_field_s<unbounded_octstring<true>>                     res_coordination_transfer_container;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<drbs_modified_conf_item_ies_o>, 1, 64, true>>
                                               drbs_modified_conf_list;
  ie_field_s<unbounded_octstring<true>>        rrc_container;
  ie_field_s<crit_diagnostics_s>               crit_diagnostics;
  ie_field_s<execute_dupl_e>                   execute_dupl;
  ie_field_s<res_coordination_transfer_info_s> res_coordination_transfer_info;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<sl_drbs_modified_conf_item_ies_o>, 1, 512, true>>
                                                                   sl_drbs_modified_conf_list;
  ie_field_s<dyn_seq_of<uu_rlc_ch_modified_item_s, 1, 32, true>>   uu_rlc_ch_modified_list;
  ie_field_s<dyn_seq_of<pc5_rlc_ch_modified_item_s, 1, 512, true>> pc5_rlc_ch_modified_list;
  ie_field_s<
      dyn_seq_of<protocol_ie_single_container_s<ue_multicast_m_rbs_confirmed_to_be_modified_item_ies_o>, 1, 64, true>>
      ue_multicast_m_rbs_confirmed_to_be_modified_list;

  // sequence methods
  ue_context_mod_confirm_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UEContextModificationConfirm ::= SEQUENCE
using ue_context_mod_confirm_s = elementary_procedure_option<ue_context_mod_confirm_ies_container>;

struct ue_context_mod_fail_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                                      crit_diagnostics_present                = false;
  bool                                                      requested_target_cell_global_id_present = false;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_cu_ue_f1ap_id;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_du_ue_f1ap_id;
  ie_field_s<cause_c>                                       cause;
  ie_field_s<crit_diagnostics_s>                            crit_diagnostics;
  ie_field_s<nr_cgi_s>                                      requested_target_cell_global_id;

  // sequence methods
  ue_context_mod_fail_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UEContextModificationFailure ::= SEQUENCE
using ue_context_mod_fail_s = elementary_procedure_option<ue_context_mod_fail_ies_container>;

struct ue_context_mod_refuse_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                                      crit_diagnostics_present = false;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_cu_ue_f1ap_id;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_du_ue_f1ap_id;
  ie_field_s<cause_c>                                       cause;
  ie_field_s<crit_diagnostics_s>                            crit_diagnostics;

  // sequence methods
  ue_context_mod_refuse_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UEContextModificationRefuse ::= SEQUENCE
using ue_context_mod_refuse_s = elementary_procedure_option<ue_context_mod_refuse_ies_container>;

struct ue_context_mod_request_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool sp_cell_id_present                                    = false;
  bool serv_cell_idx_present                                 = false;
  bool sp_cell_ul_cfg_present                                = false;
  bool drx_cycle_present                                     = false;
  bool cu_to_du_rrc_info_present                             = false;
  bool tx_action_ind_present                                 = false;
  bool res_coordination_transfer_container_present           = false;
  bool rrc_recfg_complete_ind_present                        = false;
  bool rrc_container_present                                 = false;
  bool scell_to_be_setup_mod_list_present                    = false;
  bool scell_to_be_remd_list_present                         = false;
  bool srbs_to_be_setup_mod_list_present                     = false;
  bool drbs_to_be_setup_mod_list_present                     = false;
  bool drbs_to_be_modified_list_present                      = false;
  bool srbs_to_be_released_list_present                      = false;
  bool drbs_to_be_released_list_present                      = false;
  bool inactivity_monitoring_request_present                 = false;
  bool rat_freq_prio_info_present                            = false;
  bool drx_cfg_ind_present                                   = false;
  bool rlc_fail_ind_present                                  = false;
  bool ul_tx_direct_current_list_info_present                = false;
  bool gnb_du_cfg_query_present                              = false;
  bool gnb_du_ue_ambr_ul_present                             = false;
  bool execute_dupl_present                                  = false;
  bool rrc_delivery_status_request_present                   = false;
  bool res_coordination_transfer_info_present                = false;
  bool serving_cell_mo_present                               = false;
  bool needfor_gap_present                                   = false;
  bool full_cfg_present                                      = false;
  bool add_rrm_prio_idx_present                              = false;
  bool lower_layer_presence_status_change_present            = false;
  bool bh_chs_to_be_setup_mod_list_present                   = false;
  bool bh_chs_to_be_modified_list_present                    = false;
  bool bh_chs_to_be_released_list_present                    = false;
  bool nr_v2x_services_authorized_present                    = false;
  bool ltev2x_services_authorized_present                    = false;
  bool nr_ue_sidelink_aggr_max_bitrate_present               = false;
  bool lte_ue_sidelink_aggr_max_bitrate_present              = false;
  bool pc5_link_ambr_present                                 = false;
  bool sl_drbs_to_be_setup_mod_list_present                  = false;
  bool sl_drbs_to_be_modified_list_present                   = false;
  bool sl_drbs_to_be_released_list_present                   = false;
  bool conditional_intra_du_mob_info_present                 = false;
  bool f1_c_transfer_path_present                            = false;
  bool scg_ind_present                                       = false;
  bool ul_tx_direct_current_two_carrier_list_info_present    = false;
  bool iab_conditional_rrc_msg_delivery_ind_present          = false;
  bool f1_c_transfer_path_nr_dc_present                      = false;
  bool mdt_polluted_meas_ind_present                         = false;
  bool scg_activation_request_present                        = false;
  bool cg_sdt_query_ind_present                              = false;
  bool five_g_pro_se_authorized_present                      = false;
  bool five_g_pro_se_ue_pc5_aggr_max_bitrate_present         = false;
  bool five_g_pro_se_pc5_link_ambr_present                   = false;
  bool upd_remote_ue_local_id_present                        = false;
  bool uu_rlc_ch_to_be_setup_list_present                    = false;
  bool uu_rlc_ch_to_be_modified_list_present                 = false;
  bool uu_rlc_ch_to_be_released_list_present                 = false;
  bool pc5_rlc_ch_to_be_setup_list_present                   = false;
  bool pc5_rlc_ch_to_be_modified_list_present                = false;
  bool pc5_rlc_ch_to_be_released_list_present                = false;
  bool path_switch_cfg_present                               = false;
  bool gnb_du_ue_slice_max_bit_rate_list_present             = false;
  bool multicast_mbs_session_setup_list_present              = false;
  bool multicast_mbs_session_rem_list_present                = false;
  bool ue_multicast_m_rbs_to_be_setup_at_modify_list_present = false;
  bool ue_multicast_m_rbs_to_be_released_list_present        = false;
  bool sldrx_cycle_list_present                              = false;
  bool management_based_mdt_plmn_mod_list_present            = false;
  bool sdt_bearer_cfg_query_ind_present                      = false;
  bool daps_ho_status_present                                = false;
  bool serving_cell_mo_list_present                          = false;
  bool ul_tx_direct_current_more_carrier_info_present        = false;
  bool cp_acmcg_info_present                                 = false;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_cu_ue_f1ap_id;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_du_ue_f1ap_id;
  ie_field_s<nr_cgi_s>                                      sp_cell_id;
  ie_field_s<integer<uint8_t, 0, 31, true, true>>           serv_cell_idx;
  ie_field_s<cell_ul_cfg_e>                                 sp_cell_ul_cfg;
  ie_field_s<drx_cycle_s>                                   drx_cycle;
  ie_field_s<cu_to_du_rrc_info_s>                           cu_to_du_rrc_info;
  ie_field_s<tx_action_ind_e>                               tx_action_ind;
  ie_field_s<unbounded_octstring<true>>                     res_coordination_transfer_container;
  ie_field_s<rrc_recfg_complete_ind_e>                      rrc_recfg_complete_ind;
  ie_field_s<unbounded_octstring<true>>                     rrc_container;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<scell_to_be_setup_mod_item_ies_o>, 1, 32, true>>
      scell_to_be_setup_mod_list;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<scell_to_be_remd_item_ies_o>, 1, 32, true>>
      scell_to_be_remd_list;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<srbs_to_be_setup_mod_item_ies_o>, 1, 8, true>>
      srbs_to_be_setup_mod_list;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<drbs_to_be_setup_mod_item_ies_o>, 1, 64, true>>
      drbs_to_be_setup_mod_list;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<drbs_to_be_modified_item_ies_o>, 1, 64, true>>
      drbs_to_be_modified_list;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<srbs_to_be_released_item_ies_o>, 1, 8, true>>
      srbs_to_be_released_list;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<drbs_to_be_released_item_ies_o>, 1, 64, true>>
                                                              drbs_to_be_released_list;
  ie_field_s<inactivity_monitoring_request_e>                 inactivity_monitoring_request;
  ie_field_s<rat_freq_prio_info_c>                            rat_freq_prio_info;
  ie_field_s<drx_cfg_ind_e>                                   drx_cfg_ind;
  ie_field_s<rlc_fail_ind_s>                                  rlc_fail_ind;
  ie_field_s<unbounded_octstring<true>>                       ul_tx_direct_current_list_info;
  ie_field_s<gnb_du_cfg_query_e>                              gnb_du_cfg_query;
  ie_field_s<integer<uint64_t, 0, 4000000000000, true, true>> gnb_du_ue_ambr_ul;
  ie_field_s<execute_dupl_e>                                  execute_dupl;
  ie_field_s<rrc_delivery_status_request_e>                   rrc_delivery_status_request;
  ie_field_s<res_coordination_transfer_info_s>                res_coordination_transfer_info;
  ie_field_s<integer<uint8_t, 1, 64, true, true>>             serving_cell_mo;
  ie_field_s<needfor_gap_e>                                   needfor_gap;
  ie_field_s<full_cfg_e>                                      full_cfg;
  ie_field_s<fixed_bitstring<32, false, true>>                add_rrm_prio_idx;
  ie_field_s<lower_layer_presence_status_change_e>            lower_layer_presence_status_change;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<bh_chs_to_be_setup_mod_item_ies_o>, 1, 65536, true>>
      bh_chs_to_be_setup_mod_list;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<bh_chs_to_be_modified_item_ies_o>, 1, 65536, true>>
      bh_chs_to_be_modified_list;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<bh_chs_to_be_released_item_ies_o>, 1, 65536, true>>
                                                              bh_chs_to_be_released_list;
  ie_field_s<nr_v2x_services_authorized_s>                    nr_v2x_services_authorized;
  ie_field_s<ltev2x_services_authorized_s>                    ltev2x_services_authorized;
  ie_field_s<nr_ue_sidelink_aggr_max_bitrate_s>               nr_ue_sidelink_aggr_max_bitrate;
  ie_field_s<lte_ue_sidelink_aggr_max_bitrate_s>              lte_ue_sidelink_aggr_max_bitrate;
  ie_field_s<integer<uint64_t, 0, 4000000000000, true, true>> pc5_link_ambr;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<sl_drbs_to_be_setup_mod_item_ies_o>, 1, 512, true>>
      sl_drbs_to_be_setup_mod_list;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<sl_drbs_to_be_modified_item_ies_o>, 1, 512, true>>
      sl_drbs_to_be_modified_list;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<sl_drbs_to_be_released_item_ies_o>, 1, 512, true>>
                                                                          sl_drbs_to_be_released_list;
  ie_field_s<conditional_intra_du_mob_info_s>                             conditional_intra_du_mob_info;
  ie_field_s<f1_c_transfer_path_s>                                        f1_c_transfer_path;
  ie_field_s<scg_ind_e>                                                   scg_ind;
  ie_field_s<unbounded_octstring<true>>                                   ul_tx_direct_current_two_carrier_list_info;
  ie_field_s<iab_conditional_rrc_msg_delivery_ind_e>                      iab_conditional_rrc_msg_delivery_ind;
  ie_field_s<f1_c_transfer_path_nr_dc_s>                                  f1_c_transfer_path_nr_dc;
  ie_field_s<mdt_polluted_meas_ind_e>                                     mdt_polluted_meas_ind;
  ie_field_s<scg_activation_request_e>                                    scg_activation_request;
  ie_field_s<cg_sdt_query_ind_e>                                          cg_sdt_query_ind;
  ie_field_s<five_g_pro_se_authorized_s>                                  five_g_pro_se_authorized;
  ie_field_s<nr_ue_sidelink_aggr_max_bitrate_s>                           five_g_pro_se_ue_pc5_aggr_max_bitrate;
  ie_field_s<integer<uint64_t, 0, 4000000000000, true, true>>             five_g_pro_se_pc5_link_ambr;
  ie_field_s<integer<uint16_t, 0, 255, true, true>>                       upd_remote_ue_local_id;
  ie_field_s<dyn_seq_of<uu_rlc_ch_to_be_setup_item_s, 1, 32, true>>       uu_rlc_ch_to_be_setup_list;
  ie_field_s<dyn_seq_of<uu_rlc_ch_to_be_modified_item_s, 1, 32, true>>    uu_rlc_ch_to_be_modified_list;
  ie_field_s<dyn_seq_of<uu_rlc_ch_to_be_released_item_s, 1, 32, true>>    uu_rlc_ch_to_be_released_list;
  ie_field_s<dyn_seq_of<pc5_rlc_ch_to_be_setup_item_s, 1, 512, true>>     pc5_rlc_ch_to_be_setup_list;
  ie_field_s<dyn_seq_of<pc5_rlc_ch_to_be_modified_item_s, 1, 512, true>>  pc5_rlc_ch_to_be_modified_list;
  ie_field_s<dyn_seq_of<pc5_rlc_ch_to_be_released_item_s, 1, 512, true>>  pc5_rlc_ch_to_be_released_list;
  ie_field_s<path_switch_cfg_s>                                           path_switch_cfg;
  ie_field_s<dyn_seq_of<gnb_du_ue_slice_max_bit_rate_item_s, 1, 8, true>> gnb_du_ue_slice_max_bit_rate_list;
  ie_field_s<dyn_seq_of<multicast_mbs_session_list_item_s, 1, 256, true>> multicast_mbs_session_setup_list;
  ie_field_s<dyn_seq_of<multicast_mbs_session_list_item_s, 1, 256, true>> multicast_mbs_session_rem_list;
  ie_field_s<
      dyn_seq_of<protocol_ie_single_container_s<ue_multicast_m_rbs_to_be_setup_at_modify_item_ies_o>, 1, 64, true>>
      ue_multicast_m_rbs_to_be_setup_at_modify_list;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<ue_multicast_m_rbs_to_be_released_item_ies_o>, 1, 64, true>>
                                                                ue_multicast_m_rbs_to_be_released_list;
  ie_field_s<dyn_seq_of<sldrx_cycle_item_s, 1, 32, true>>       sldrx_cycle_list;
  ie_field_s<dyn_seq_of<fixed_octstring<3, true>, 0, 16, true>> management_based_mdt_plmn_mod_list;
  ie_field_s<sdt_bearer_cfg_query_ind_e>                        sdt_bearer_cfg_query_ind;
  ie_field_s<daps_ho_status_e>                                  daps_ho_status;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<serving_cell_mo_list_item_ies_o>, 1, 16, true>>
                                        serving_cell_mo_list;
  ie_field_s<unbounded_octstring<true>> ul_tx_direct_current_more_carrier_info;
  ie_field_s<cp_acmcg_info_s>           cp_acmcg_info;

  // sequence methods
  ue_context_mod_request_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UEContextModificationRequest ::= SEQUENCE
using ue_context_mod_request_s = elementary_procedure_option<ue_context_mod_request_ies_container>;

struct ue_context_mod_required_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool res_coordination_transfer_container_present             = false;
  bool du_to_cu_rrc_info_present                               = false;
  bool drbs_required_to_be_modified_list_present               = false;
  bool srbs_required_to_be_released_list_present               = false;
  bool drbs_required_to_be_released_list_present               = false;
  bool bh_chs_required_to_be_released_list_present             = false;
  bool sl_drbs_required_to_be_modified_list_present            = false;
  bool sl_drbs_required_to_be_released_list_present            = false;
  bool target_cells_to_cancel_present                          = false;
  bool uu_rlc_ch_required_to_be_modified_list_present          = false;
  bool uu_rlc_ch_required_to_be_released_list_present          = false;
  bool pc5_rlc_ch_required_to_be_modified_list_present         = false;
  bool pc5_rlc_ch_required_to_be_released_list_present         = false;
  bool ue_multicast_m_rbs_required_to_be_modified_list_present = false;
  bool ue_multicast_m_rbs_required_to_be_released_list_present = false;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_cu_ue_f1ap_id;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_du_ue_f1ap_id;
  ie_field_s<unbounded_octstring<true>>                     res_coordination_transfer_container;
  ie_field_s<du_to_cu_rrc_info_s>                           du_to_cu_rrc_info;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<drbs_required_to_be_modified_item_ies_o>, 1, 64, true>>
      drbs_required_to_be_modified_list;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<srbs_required_to_be_released_item_ies_o>, 1, 8, true>>
      srbs_required_to_be_released_list;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<drbs_required_to_be_released_item_ies_o>, 1, 64, true>>
                      drbs_required_to_be_released_list;
  ie_field_s<cause_c> cause;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<bh_chs_required_to_be_released_item_ies_o>, 1, 65536, true>>
      bh_chs_required_to_be_released_list;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<sl_drbs_required_to_be_modified_item_ies_o>, 1, 512, true>>
      sl_drbs_required_to_be_modified_list;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<sl_drbs_required_to_be_released_item_ies_o>, 1, 512, true>>
                                                                                sl_drbs_required_to_be_released_list;
  ie_field_s<dyn_seq_of<target_cell_list_item_s, 1, 8, true>>                   target_cells_to_cancel;
  ie_field_s<dyn_seq_of<uu_rlc_ch_required_to_be_modified_item_s, 1, 32, true>> uu_rlc_ch_required_to_be_modified_list;
  ie_field_s<dyn_seq_of<uu_rlc_ch_required_to_be_released_item_s, 1, 32, true>> uu_rlc_ch_required_to_be_released_list;
  ie_field_s<dyn_seq_of<pc5_rlc_ch_required_to_be_modified_item_s, 1, 512, true>>
      pc5_rlc_ch_required_to_be_modified_list;
  ie_field_s<dyn_seq_of<pc5_rlc_ch_required_to_be_released_item_s, 1, 512, true>>
      pc5_rlc_ch_required_to_be_released_list;
  ie_field_s<
      dyn_seq_of<protocol_ie_single_container_s<ue_multicast_m_rbs_required_to_be_modified_item_ies_o>, 1, 64, true>>
      ue_multicast_m_rbs_required_to_be_modified_list;
  ie_field_s<
      dyn_seq_of<protocol_ie_single_container_s<ue_multicast_m_rbs_required_to_be_released_item_ies_o>, 1, 64, true>>
      ue_multicast_m_rbs_required_to_be_released_list;

  // sequence methods
  ue_context_mod_required_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UEContextModificationRequired ::= SEQUENCE
using ue_context_mod_required_s = elementary_procedure_option<ue_context_mod_required_ies_container>;

struct ue_context_mod_resp_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                                      res_coordination_transfer_container_present   = false;
  bool                                                      du_to_cu_rrc_info_present                     = false;
  bool                                                      drbs_setup_mod_list_present                   = false;
  bool                                                      drbs_modified_list_present                    = false;
  bool                                                      srbs_failed_to_be_setup_mod_list_present      = false;
  bool                                                      drbs_failed_to_be_setup_mod_list_present      = false;
  bool                                                      scell_failedto_setup_mod_list_present         = false;
  bool                                                      drbs_failed_to_be_modified_list_present       = false;
  bool                                                      inactivity_monitoring_resp_present            = false;
  bool                                                      crit_diagnostics_present                      = false;
  bool                                                      c_rnti_present                                = false;
  bool                                                      associated_scell_list_present                 = false;
  bool                                                      srbs_setup_mod_list_present                   = false;
  bool                                                      srbs_modified_list_present                    = false;
  bool                                                      full_cfg_present                              = false;
  bool                                                      bh_chs_setup_mod_list_present                 = false;
  bool                                                      bh_chs_modified_list_present                  = false;
  bool                                                      bh_chs_failed_to_be_setup_mod_list_present    = false;
  bool                                                      bh_chs_failed_to_be_modified_list_present     = false;
  bool                                                      sl_drbs_setup_mod_list_present                = false;
  bool                                                      sl_drbs_modified_list_present                 = false;
  bool                                                      sl_drbs_failed_to_be_setup_mod_list_present   = false;
  bool                                                      sl_drbs_failed_to_be_modified_list_present    = false;
  bool                                                      requested_target_cell_global_id_present       = false;
  bool                                                      scg_activation_status_present                 = false;
  bool                                                      uu_rlc_ch_setup_list_present                  = false;
  bool                                                      uu_rlc_ch_failed_to_be_setup_list_present     = false;
  bool                                                      uu_rlc_ch_modified_list_present               = false;
  bool                                                      uu_rlc_ch_failed_to_be_modified_list_present  = false;
  bool                                                      pc5_rlc_ch_setup_list_present                 = false;
  bool                                                      pc5_rlc_ch_failed_to_be_setup_list_present    = false;
  bool                                                      pc5_rlc_ch_modified_list_present              = false;
  bool                                                      pc5_rlc_ch_failed_to_be_modified_list_present = false;
  bool                                                      sdt_bearer_cfg_info_present                   = false;
  bool                                                      ue_multicast_m_rbs_setup_list_present         = false;
  bool                                                      serving_cell_mo_encoded_in_cgc_list_present   = false;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_cu_ue_f1ap_id;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_du_ue_f1ap_id;
  ie_field_s<unbounded_octstring<true>>                     res_coordination_transfer_container;
  ie_field_s<du_to_cu_rrc_info_s>                           du_to_cu_rrc_info;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<drbs_setup_mod_item_ies_o>, 1, 64, true>> drbs_setup_mod_list;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<drbs_modified_item_ies_o>, 1, 64, true>>  drbs_modified_list;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<srbs_failed_to_be_setup_mod_item_ies_o>, 1, 8, true>>
      srbs_failed_to_be_setup_mod_list;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<drbs_failed_to_be_setup_mod_item_ies_o>, 1, 64, true>>
      drbs_failed_to_be_setup_mod_list;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<scell_failedto_setup_mod_item_ies_o>, 1, 32, true>>
      scell_failedto_setup_mod_list;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<drbs_failed_to_be_modified_item_ies_o>, 1, 64, true>>
                                                      drbs_failed_to_be_modified_list;
  ie_field_s<inactivity_monitoring_resp_e>            inactivity_monitoring_resp;
  ie_field_s<crit_diagnostics_s>                      crit_diagnostics;
  ie_field_s<integer<uint32_t, 0, 65535, true, true>> c_rnti;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<associated_scell_item_ies_o>, 1, 32, true>>
                                                                                                associated_scell_list;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<srbs_setup_mod_item_ies_o>, 1, 8, true>> srbs_setup_mod_list;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<srbs_modified_item_ies_o>, 1, 8, true>>  srbs_modified_list;
  ie_field_s<full_cfg_e>                                                                        full_cfg;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<bh_chs_setup_mod_item_ies_o>, 1, 65536, true>>
      bh_chs_setup_mod_list;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<bh_chs_modified_item_ies_o>, 1, 65536, true>>
      bh_chs_modified_list;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<bh_chs_failed_to_be_setup_mod_item_ies_o>, 1, 65536, true>>
      bh_chs_failed_to_be_setup_mod_list;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<bh_chs_failed_to_be_modified_item_ies_o>, 1, 65536, true>>
      bh_chs_failed_to_be_modified_list;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<sl_drbs_setup_mod_item_ies_o>, 1, 512, true>>
      sl_drbs_setup_mod_list;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<sl_drbs_modified_item_ies_o>, 1, 512, true>>
      sl_drbs_modified_list;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<sl_drbs_failed_to_be_setup_mod_item_ies_o>, 1, 512, true>>
      sl_drbs_failed_to_be_setup_mod_list;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<sl_drbs_failed_to_be_modified_item_ies_o>, 1, 512, true>>
                                                                                sl_drbs_failed_to_be_modified_list;
  ie_field_s<nr_cgi_s>                                                          requested_target_cell_global_id;
  ie_field_s<scg_activation_status_e>                                           scg_activation_status;
  ie_field_s<dyn_seq_of<uu_rlc_ch_setup_item_s, 1, 32, true>>                   uu_rlc_ch_setup_list;
  ie_field_s<dyn_seq_of<uu_rlc_ch_failed_to_be_setup_item_s, 1, 32, true>>      uu_rlc_ch_failed_to_be_setup_list;
  ie_field_s<dyn_seq_of<uu_rlc_ch_modified_item_s, 1, 32, true>>                uu_rlc_ch_modified_list;
  ie_field_s<dyn_seq_of<uu_rlc_ch_failed_to_be_modified_item_s, 1, 32, true>>   uu_rlc_ch_failed_to_be_modified_list;
  ie_field_s<dyn_seq_of<pc5_rlc_ch_setup_item_s, 1, 512, true>>                 pc5_rlc_ch_setup_list;
  ie_field_s<dyn_seq_of<pc5_rlc_ch_failed_to_be_setup_item_s, 1, 512, true>>    pc5_rlc_ch_failed_to_be_setup_list;
  ie_field_s<dyn_seq_of<pc5_rlc_ch_modified_item_s, 1, 512, true>>              pc5_rlc_ch_modified_list;
  ie_field_s<dyn_seq_of<pc5_rlc_ch_failed_to_be_modified_item_s, 1, 512, true>> pc5_rlc_ch_failed_to_be_modified_list;
  ie_field_s<sdt_bearer_cfg_info_s>                                             sdt_bearer_cfg_info;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<ue_multicast_m_rbs_setup_item_ies_o>, 1, 64, true>>
                                                                            ue_multicast_m_rbs_setup_list;
  ie_field_s<dyn_seq_of<serving_cell_mo_encoded_in_cgc_item_s, 1, 8, true>> serving_cell_mo_encoded_in_cgc_list;

  // sequence methods
  ue_context_mod_resp_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UEContextModificationResponse ::= SEQUENCE
using ue_context_mod_resp_s = elementary_procedure_option<ue_context_mod_resp_ies_container>;

struct ue_context_release_cmd_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                                        rrc_container_present               = false;
  bool                                                        srb_id_present                      = false;
  bool                                                        old_gnb_du_ue_f1ap_id_present       = false;
  bool                                                        execute_dupl_present                = false;
  bool                                                        rrc_delivery_status_request_present = false;
  bool                                                        target_cells_to_cancel_present      = false;
  bool                                                        pos_conext_rev_ind_present          = false;
  bool                                                        cg_sdt_kept_ind_present             = false;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>>   gnb_cu_ue_f1ap_id;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>>   gnb_du_ue_f1ap_id;
  ie_field_s<cause_c>                                         cause;
  ie_field_s<unbounded_octstring<true>>                       rrc_container;
  ie_field_s<integer<uint8_t, 0, 3, true, true>>              srb_id;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>>   old_gnb_du_ue_f1ap_id;
  ie_field_s<execute_dupl_e>                                  execute_dupl;
  ie_field_s<rrc_delivery_status_request_e>                   rrc_delivery_status_request;
  ie_field_s<dyn_seq_of<target_cell_list_item_s, 1, 8, true>> target_cells_to_cancel;
  ie_field_s<pos_conext_rev_ind_e>                            pos_conext_rev_ind;
  ie_field_s<cg_sdt_kept_ind_e>                               cg_sdt_kept_ind;

  // sequence methods
  ue_context_release_cmd_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UEContextReleaseCommand ::= SEQUENCE
using ue_context_release_cmd_s = elementary_procedure_option<ue_context_release_cmd_ies_container>;

struct ue_context_release_complete_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                                      crit_diagnostics_present = false;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_cu_ue_f1ap_id;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_du_ue_f1ap_id;
  ie_field_s<crit_diagnostics_s>                            crit_diagnostics;

  // sequence methods
  ue_context_release_complete_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UEContextReleaseComplete ::= SEQUENCE
using ue_context_release_complete_s = elementary_procedure_option<ue_context_release_complete_ies_container>;

struct ue_context_release_request_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                                        target_cells_to_cancel_present = false;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>>   gnb_cu_ue_f1ap_id;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>>   gnb_du_ue_f1ap_id;
  ie_field_s<cause_c>                                         cause;
  ie_field_s<dyn_seq_of<target_cell_list_item_s, 1, 8, true>> target_cells_to_cancel;

  // sequence methods
  ue_context_release_request_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UEContextReleaseRequest ::= SEQUENCE
using ue_context_release_request_s = elementary_procedure_option<ue_context_release_request_ies_container>;

struct ue_context_setup_fail_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                                      gnb_du_ue_f1ap_id_present               = false;
  bool                                                      crit_diagnostics_present                = false;
  bool                                                      potential_sp_cell_list_present          = false;
  bool                                                      requested_target_cell_global_id_present = false;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_cu_ue_f1ap_id;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_du_ue_f1ap_id;
  ie_field_s<cause_c>                                       cause;
  ie_field_s<crit_diagnostics_s>                            crit_diagnostics;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<potential_sp_cell_item_ies_o>, 0, 64, true>>
                       potential_sp_cell_list;
  ie_field_s<nr_cgi_s> requested_target_cell_global_id;

  // sequence methods
  ue_context_setup_fail_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UEContextSetupFailure ::= SEQUENCE
using ue_context_setup_fail_s = elementary_procedure_option<ue_context_setup_fail_ies_container>;

struct ue_context_setup_request_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                                      gnb_du_ue_f1ap_id_present                     = false;
  bool                                                      sp_cell_ul_cfg_present                        = false;
  bool                                                      candidate_sp_cell_list_present                = false;
  bool                                                      drx_cycle_present                             = false;
  bool                                                      res_coordination_transfer_container_present   = false;
  bool                                                      scell_to_be_setup_list_present                = false;
  bool                                                      srbs_to_be_setup_list_present                 = false;
  bool                                                      drbs_to_be_setup_list_present                 = false;
  bool                                                      inactivity_monitoring_request_present         = false;
  bool                                                      rat_freq_prio_info_present                    = false;
  bool                                                      rrc_container_present                         = false;
  bool                                                      masked_imeisv_present                         = false;
  bool                                                      serving_plmn_present                          = false;
  bool                                                      gnb_du_ue_ambr_ul_present                     = false;
  bool                                                      rrc_delivery_status_request_present           = false;
  bool                                                      res_coordination_transfer_info_present        = false;
  bool                                                      serving_cell_mo_present                       = false;
  bool                                                      new_gnb_cu_ue_f1ap_id_present                 = false;
  bool                                                      ran_ue_id_present                             = false;
  bool                                                      trace_activation_present                      = false;
  bool                                                      add_rrm_prio_idx_present                      = false;
  bool                                                      bh_chs_to_be_setup_list_present               = false;
  bool                                                      cfg_bap_address_present                       = false;
  bool                                                      nr_v2x_services_authorized_present            = false;
  bool                                                      ltev2x_services_authorized_present            = false;
  bool                                                      nr_ue_sidelink_aggr_max_bitrate_present       = false;
  bool                                                      lte_ue_sidelink_aggr_max_bitrate_present      = false;
  bool                                                      pc5_link_ambr_present                         = false;
  bool                                                      sl_drbs_to_be_setup_list_present              = false;
  bool                                                      conditional_inter_du_mob_info_present         = false;
  bool                                                      management_based_mdt_plmn_list_present        = false;
  bool                                                      serving_n_id_present                          = false;
  bool                                                      f1_c_transfer_path_present                    = false;
  bool                                                      f1_c_transfer_path_nr_dc_present              = false;
  bool                                                      mdt_polluted_meas_ind_present                 = false;
  bool                                                      scg_activation_request_present                = false;
  bool                                                      cg_sdt_session_info_old_present               = false;
  bool                                                      five_g_pro_se_authorized_present              = false;
  bool                                                      five_g_pro_se_ue_pc5_aggr_max_bitrate_present = false;
  bool                                                      five_g_pro_se_pc5_link_ambr_present           = false;
  bool                                                      uu_rlc_ch_to_be_setup_list_present            = false;
  bool                                                      pc5_rlc_ch_to_be_setup_list_present           = false;
  bool                                                      path_switch_cfg_present                       = false;
  bool                                                      gnb_du_ue_slice_max_bit_rate_list_present     = false;
  bool                                                      multicast_mbs_session_setup_list_present      = false;
  bool                                                      ue_multicast_m_rbs_to_be_setup_list_present   = false;
  bool                                                      serving_cell_mo_list_present                  = false;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_cu_ue_f1ap_id;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_du_ue_f1ap_id;
  ie_field_s<nr_cgi_s>                                      sp_cell_id;
  ie_field_s<integer<uint8_t, 0, 31, true, true>>           serv_cell_idx;
  ie_field_s<cell_ul_cfg_e>                                 sp_cell_ul_cfg;
  ie_field_s<cu_to_du_rrc_info_s>                           cu_to_du_rrc_info;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<candidate_sp_cell_item_ies_o>, 1, 64, true>>
                                        candidate_sp_cell_list;
  ie_field_s<drx_cycle_s>               drx_cycle;
  ie_field_s<unbounded_octstring<true>> res_coordination_transfer_container;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<scell_to_be_setup_item_ies_o>, 1, 32, true>>
      scell_to_be_setup_list;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<srbs_to_be_setup_item_ies_o>, 1, 8, true>> srbs_to_be_setup_list;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<drbs_to_be_setup_item_ies_o>, 1, 64, true>>
                                                              drbs_to_be_setup_list;
  ie_field_s<inactivity_monitoring_request_e>                 inactivity_monitoring_request;
  ie_field_s<rat_freq_prio_info_c>                            rat_freq_prio_info;
  ie_field_s<unbounded_octstring<true>>                       rrc_container;
  ie_field_s<fixed_bitstring<64, false, true>>                masked_imeisv;
  ie_field_s<fixed_octstring<3, true>>                        serving_plmn;
  ie_field_s<integer<uint64_t, 0, 4000000000000, true, true>> gnb_du_ue_ambr_ul;
  ie_field_s<rrc_delivery_status_request_e>                   rrc_delivery_status_request;
  ie_field_s<res_coordination_transfer_info_s>                res_coordination_transfer_info;
  ie_field_s<integer<uint8_t, 1, 64, true, true>>             serving_cell_mo;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>>   new_gnb_cu_ue_f1ap_id;
  ie_field_s<fixed_octstring<8, true>>                        ran_ue_id;
  ie_field_s<trace_activation_s>                              trace_activation;
  ie_field_s<fixed_bitstring<32, false, true>>                add_rrm_prio_idx;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<bh_chs_to_be_setup_item_ies_o>, 1, 65536, true>>
                                                              bh_chs_to_be_setup_list;
  ie_field_s<fixed_bitstring<10, false, true>>                cfg_bap_address;
  ie_field_s<nr_v2x_services_authorized_s>                    nr_v2x_services_authorized;
  ie_field_s<ltev2x_services_authorized_s>                    ltev2x_services_authorized;
  ie_field_s<nr_ue_sidelink_aggr_max_bitrate_s>               nr_ue_sidelink_aggr_max_bitrate;
  ie_field_s<lte_ue_sidelink_aggr_max_bitrate_s>              lte_ue_sidelink_aggr_max_bitrate;
  ie_field_s<integer<uint64_t, 0, 4000000000000, true, true>> pc5_link_ambr;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<sl_drbs_to_be_setup_item_ies_o>, 1, 512, true>>
                                                                          sl_drbs_to_be_setup_list;
  ie_field_s<conditional_inter_du_mob_info_s>                             conditional_inter_du_mob_info;
  ie_field_s<dyn_seq_of<fixed_octstring<3, true>, 1, 16, true>>           management_based_mdt_plmn_list;
  ie_field_s<fixed_bitstring<44, false, true>>                            serving_n_id;
  ie_field_s<f1_c_transfer_path_s>                                        f1_c_transfer_path;
  ie_field_s<f1_c_transfer_path_nr_dc_s>                                  f1_c_transfer_path_nr_dc;
  ie_field_s<mdt_polluted_meas_ind_e>                                     mdt_polluted_meas_ind;
  ie_field_s<scg_activation_request_e>                                    scg_activation_request;
  ie_field_s<cg_sdt_session_info_s>                                       cg_sdt_session_info_old;
  ie_field_s<five_g_pro_se_authorized_s>                                  five_g_pro_se_authorized;
  ie_field_s<nr_ue_sidelink_aggr_max_bitrate_s>                           five_g_pro_se_ue_pc5_aggr_max_bitrate;
  ie_field_s<integer<uint64_t, 0, 4000000000000, true, true>>             five_g_pro_se_pc5_link_ambr;
  ie_field_s<dyn_seq_of<uu_rlc_ch_to_be_setup_item_s, 1, 32, true>>       uu_rlc_ch_to_be_setup_list;
  ie_field_s<dyn_seq_of<pc5_rlc_ch_to_be_setup_item_s, 1, 512, true>>     pc5_rlc_ch_to_be_setup_list;
  ie_field_s<path_switch_cfg_s>                                           path_switch_cfg;
  ie_field_s<dyn_seq_of<gnb_du_ue_slice_max_bit_rate_item_s, 1, 8, true>> gnb_du_ue_slice_max_bit_rate_list;
  ie_field_s<dyn_seq_of<multicast_mbs_session_list_item_s, 1, 256, true>> multicast_mbs_session_setup_list;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<ue_multicast_m_rbs_to_be_setup_item_ies_o>, 1, 64, true>>
      ue_multicast_m_rbs_to_be_setup_list;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<serving_cell_mo_list_item_ies_o>, 1, 16, true>>
      serving_cell_mo_list;

  // sequence methods
  ue_context_setup_request_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UEContextSetupRequest ::= SEQUENCE
using ue_context_setup_request_s = elementary_procedure_option<ue_context_setup_request_ies_container>;

struct ue_context_setup_resp_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                                      c_rnti_present                              = false;
  bool                                                      res_coordination_transfer_container_present = false;
  bool                                                      full_cfg_present                            = false;
  bool                                                      drbs_setup_list_present                     = false;
  bool                                                      srbs_failed_to_be_setup_list_present        = false;
  bool                                                      drbs_failed_to_be_setup_list_present        = false;
  bool                                                      scell_failedto_setup_list_present           = false;
  bool                                                      inactivity_monitoring_resp_present          = false;
  bool                                                      crit_diagnostics_present                    = false;
  bool                                                      srbs_setup_list_present                     = false;
  bool                                                      bh_chs_setup_list_present                   = false;
  bool                                                      bh_chs_failed_to_be_setup_list_present      = false;
  bool                                                      sl_drbs_setup_list_present                  = false;
  bool                                                      sl_drbs_failed_to_be_setup_list_present     = false;
  bool                                                      requested_target_cell_global_id_present     = false;
  bool                                                      scg_activation_status_present               = false;
  bool                                                      uu_rlc_ch_setup_list_present                = false;
  bool                                                      uu_rlc_ch_failed_to_be_setup_list_present   = false;
  bool                                                      pc5_rlc_ch_setup_list_present               = false;
  bool                                                      pc5_rlc_ch_failed_to_be_setup_list_present  = false;
  bool                                                      serving_cell_mo_encoded_in_cgc_list_present = false;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_cu_ue_f1ap_id;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_du_ue_f1ap_id;
  ie_field_s<du_to_cu_rrc_info_s>                           du_to_cu_rrc_info;
  ie_field_s<integer<uint32_t, 0, 65535, true, true>>       c_rnti;
  ie_field_s<unbounded_octstring<true>>                     res_coordination_transfer_container;
  ie_field_s<full_cfg_e>                                    full_cfg;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<drbs_setup_item_ies_o>, 1, 64, true>> drbs_setup_list;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<srbs_failed_to_be_setup_item_ies_o>, 1, 8, true>>
      srbs_failed_to_be_setup_list;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<drbs_failed_to_be_setup_item_ies_o>, 1, 64, true>>
      drbs_failed_to_be_setup_list;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<scell_failedto_setup_item_ies_o>, 1, 32, true>>
                                                                                            scell_failedto_setup_list;
  ie_field_s<inactivity_monitoring_resp_e>                                                  inactivity_monitoring_resp;
  ie_field_s<crit_diagnostics_s>                                                            crit_diagnostics;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<srbs_setup_item_ies_o>, 1, 8, true>> srbs_setup_list;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<bh_chs_setup_item_ies_o>, 1, 65536, true>> bh_chs_setup_list;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<bh_chs_failed_to_be_setup_item_ies_o>, 1, 65536, true>>
      bh_chs_failed_to_be_setup_list;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<sl_drbs_setup_item_ies_o>, 1, 512, true>> sl_drbs_setup_list;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<sl_drbs_failed_to_be_setup_item_ies_o>, 1, 512, true>>
                                                                             sl_drbs_failed_to_be_setup_list;
  ie_field_s<nr_cgi_s>                                                       requested_target_cell_global_id;
  ie_field_s<scg_activation_status_e>                                        scg_activation_status;
  ie_field_s<dyn_seq_of<uu_rlc_ch_setup_item_s, 1, 32, true>>                uu_rlc_ch_setup_list;
  ie_field_s<dyn_seq_of<uu_rlc_ch_failed_to_be_setup_item_s, 1, 32, true>>   uu_rlc_ch_failed_to_be_setup_list;
  ie_field_s<dyn_seq_of<pc5_rlc_ch_setup_item_s, 1, 512, true>>              pc5_rlc_ch_setup_list;
  ie_field_s<dyn_seq_of<pc5_rlc_ch_failed_to_be_setup_item_s, 1, 512, true>> pc5_rlc_ch_failed_to_be_setup_list;
  ie_field_s<dyn_seq_of<serving_cell_mo_encoded_in_cgc_item_s, 1, 8, true>>  serving_cell_mo_encoded_in_cgc_list;

  // sequence methods
  ue_context_setup_resp_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UEContextSetupResponse ::= SEQUENCE
using ue_context_setup_resp_s = elementary_procedure_option<ue_context_setup_resp_ies_container>;

struct ue_inactivity_notif_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                                      sdt_termination_request_present = false;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_cu_ue_f1ap_id;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_du_ue_f1ap_id;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<drb_activity_item_ies_o>, 1, 64, true>> drb_activity_list;
  ie_field_s<sdt_termination_request_e>                                                        sdt_termination_request;

  // sequence methods
  ue_inactivity_notif_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// UEInactivityNotification ::= SEQUENCE
using ue_inactivity_notif_s = elementary_procedure_option<ue_inactivity_notif_ies_container>;

struct ul_rrc_msg_transfer_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                                      sel_plmn_id_present           = false;
  bool                                                      new_gnb_du_ue_f1ap_id_present = false;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_cu_ue_f1ap_id;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> gnb_du_ue_f1ap_id;
  ie_field_s<integer<uint8_t, 0, 3, true, true>>            srb_id;
  ie_field_s<unbounded_octstring<true>>                     rrc_container;
  ie_field_s<fixed_octstring<3, true>>                      sel_plmn_id;
  ie_field_s<integer<uint64_t, 0, 4294967295, false, true>> new_gnb_du_ue_f1ap_id;

  // sequence methods
  ul_rrc_msg_transfer_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// ULRRCMessageTransfer ::= SEQUENCE
using ul_rrc_msg_transfer_s = elementary_procedure_option<ul_rrc_msg_transfer_ies_container>;

struct write_replace_warning_request_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                                 cells_to_be_broadcast_list_present = false;
  ie_field_s<integer<uint16_t, 0, 255, true, true>>    transaction_id;
  ie_field_s<pws_sys_info_s>                           pws_sys_info;
  ie_field_s<integer<uint32_t, 0, 131071, true, true>> repeat_period;
  ie_field_s<integer<uint32_t, 0, 65535, false, true>> numof_broadcast_request;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<cells_to_be_broadcast_list_item_ies_o>, 1, 512, true>>
      cells_to_be_broadcast_list;

  // sequence methods
  write_replace_warning_request_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// WriteReplaceWarningRequest ::= SEQUENCE
using write_replace_warning_request_s = elementary_procedure_option<write_replace_warning_request_ies_container>;

struct write_replace_warning_resp_ies_container {
  template <class valueT_>
  using ie_field_s = protocol_ie_container_item_s<valueT_>;

  // member variables
  bool                                              cells_broadcast_completed_list_present = false;
  bool                                              crit_diagnostics_present               = false;
  bool                                              ded_si_delivery_needed_ue_list_present = false;
  ie_field_s<integer<uint16_t, 0, 255, true, true>> transaction_id;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<cells_broadcast_completed_list_item_ies_o>, 1, 512, true>>
                                 cells_broadcast_completed_list;
  ie_field_s<crit_diagnostics_s> crit_diagnostics;
  ie_field_s<dyn_seq_of<protocol_ie_single_container_s<ded_si_delivery_needed_ue_item_ies_o>, 1, 65536, true>>
      ded_si_delivery_needed_ue_list;

  // sequence methods
  write_replace_warning_resp_ies_container();
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
};

// WriteReplaceWarningResponse ::= SEQUENCE
using write_replace_warning_resp_s = elementary_procedure_option<write_replace_warning_resp_ies_container>;

// F1AP-ELEMENTARY-PROCEDURES ::= OBJECT SET OF F1AP-ELEMENTARY-PROCEDURE
struct f1ap_elem_procs_o {
  // InitiatingMessage ::= OPEN TYPE
  struct init_msg_c {
    struct types_opts {
      enum options {
        reset,
        f1_setup_request,
        gnb_du_cfg_upd,
        gnb_cu_cfg_upd,
        ue_context_setup_request,
        ue_context_release_cmd,
        ue_context_mod_request,
        ue_context_mod_required,
        write_replace_warning_request,
        pws_cancel_request,
        gnb_du_res_coordination_request,
        f1_removal_request,
        bap_map_cfg,
        gnb_du_res_cfg,
        iab_tnl_address_request,
        iab_up_cfg_upd_request,
        res_status_request,
        positioning_meas_request,
        trp_info_request,
        positioning_info_request,
        positioning_activation_request,
        e_c_id_meas_initiation_request,
        broadcast_context_setup_request,
        broadcast_context_release_cmd,
        broadcast_context_mod_request,
        multicast_context_setup_request,
        multicast_context_release_cmd,
        multicast_context_mod_request,
        multicast_distribution_setup_request,
        multicast_distribution_release_cmd,
        pdc_meas_initiation_request,
        prs_cfg_request,
        meas_precfg_required,
        error_ind,
        ue_context_release_request,
        dl_rrc_msg_transfer,
        ul_rrc_msg_transfer,
        ue_inactivity_notif,
        private_msg,
        init_ul_rrc_msg_transfer,
        sys_info_delivery_cmd,
        paging,
        notify,
        pws_restart_ind,
        pws_fail_ind,
        gnb_du_status_ind,
        rrc_delivery_report,
        network_access_rate_reduction,
        trace_start,
        deactiv_trace,
        du_cu_radio_info_transfer,
        cu_du_radio_info_transfer,
        res_status_upd,
        access_and_mob_ind,
        ref_time_info_report_ctrl,
        ref_time_info_report,
        access_success,
        cell_traffic_trace,
        positioning_assist_info_ctrl,
        positioning_assist_info_feedback,
        positioning_meas_report,
        positioning_meas_abort,
        positioning_meas_fail_ind,
        positioning_meas_upd,
        positioning_deactivation,
        e_c_id_meas_fail_ind,
        e_c_id_meas_report,
        e_c_id_meas_termination_cmd,
        positioning_info_upd,
        multicast_group_paging,
        broadcast_context_release_request,
        multicast_context_release_request,
        pdc_meas_report,
        pdc_meas_termination_cmd,
        pdc_meas_fail_ind,
        meas_activation,
        qo_e_info_transfer,
        pos_sys_info_delivery_cmd,
        nulltype
      } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    init_msg_c() = default;
    init_msg_c(const init_msg_c& other);
    init_msg_c& operator=(const init_msg_c& other);
    ~init_msg_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    reset_s&                                      reset();
    f1_setup_request_s&                           f1_setup_request();
    gnb_du_cfg_upd_s&                             gnb_du_cfg_upd();
    gnb_cu_cfg_upd_s&                             gnb_cu_cfg_upd();
    ue_context_setup_request_s&                   ue_context_setup_request();
    ue_context_release_cmd_s&                     ue_context_release_cmd();
    ue_context_mod_request_s&                     ue_context_mod_request();
    ue_context_mod_required_s&                    ue_context_mod_required();
    write_replace_warning_request_s&              write_replace_warning_request();
    pws_cancel_request_s&                         pws_cancel_request();
    gnb_du_res_coordination_request_s&            gnb_du_res_coordination_request();
    f1_removal_request_s&                         f1_removal_request();
    bap_map_cfg_s&                                bap_map_cfg();
    gnb_du_res_cfg_s&                             gnb_du_res_cfg();
    iab_tnl_address_request_s&                    iab_tnl_address_request();
    iab_up_cfg_upd_request_s&                     iab_up_cfg_upd_request();
    res_status_request_s&                         res_status_request();
    positioning_meas_request_s&                   positioning_meas_request();
    trp_info_request_s&                           trp_info_request();
    positioning_info_request_s&                   positioning_info_request();
    positioning_activation_request_s&             positioning_activation_request();
    e_c_id_meas_initiation_request_s&             e_c_id_meas_initiation_request();
    broadcast_context_setup_request_s&            broadcast_context_setup_request();
    broadcast_context_release_cmd_s&              broadcast_context_release_cmd();
    broadcast_context_mod_request_s&              broadcast_context_mod_request();
    multicast_context_setup_request_s&            multicast_context_setup_request();
    multicast_context_release_cmd_s&              multicast_context_release_cmd();
    multicast_context_mod_request_s&              multicast_context_mod_request();
    multicast_distribution_setup_request_s&       multicast_distribution_setup_request();
    multicast_distribution_release_cmd_s&         multicast_distribution_release_cmd();
    pdc_meas_initiation_request_s&                pdc_meas_initiation_request();
    prs_cfg_request_s&                            prs_cfg_request();
    meas_precfg_required_s&                       meas_precfg_required();
    error_ind_s&                                  error_ind();
    ue_context_release_request_s&                 ue_context_release_request();
    dl_rrc_msg_transfer_s&                        dl_rrc_msg_transfer();
    ul_rrc_msg_transfer_s&                        ul_rrc_msg_transfer();
    ue_inactivity_notif_s&                        ue_inactivity_notif();
    private_msg_s&                                private_msg();
    init_ul_rrc_msg_transfer_s&                   init_ul_rrc_msg_transfer();
    sys_info_delivery_cmd_s&                      sys_info_delivery_cmd();
    paging_s&                                     paging();
    notify_s&                                     notify();
    pws_restart_ind_s&                            pws_restart_ind();
    pws_fail_ind_s&                               pws_fail_ind();
    gnb_du_status_ind_s&                          gnb_du_status_ind();
    rrc_delivery_report_s&                        rrc_delivery_report();
    network_access_rate_reduction_s&              network_access_rate_reduction();
    trace_start_s&                                trace_start();
    deactiv_trace_s&                              deactiv_trace();
    du_cu_radio_info_transfer_s&                  du_cu_radio_info_transfer();
    cu_du_radio_info_transfer_s&                  cu_du_radio_info_transfer();
    res_status_upd_s&                             res_status_upd();
    access_and_mob_ind_s&                         access_and_mob_ind();
    ref_time_info_report_ctrl_s&                  ref_time_info_report_ctrl();
    ref_time_info_report_s&                       ref_time_info_report();
    access_success_s&                             access_success();
    cell_traffic_trace_s&                         cell_traffic_trace();
    positioning_assist_info_ctrl_s&               positioning_assist_info_ctrl();
    positioning_assist_info_feedback_s&           positioning_assist_info_feedback();
    positioning_meas_report_s&                    positioning_meas_report();
    positioning_meas_abort_s&                     positioning_meas_abort();
    positioning_meas_fail_ind_s&                  positioning_meas_fail_ind();
    positioning_meas_upd_s&                       positioning_meas_upd();
    positioning_deactivation_s&                   positioning_deactivation();
    e_c_id_meas_fail_ind_s&                       e_c_id_meas_fail_ind();
    e_c_id_meas_report_s&                         e_c_id_meas_report();
    e_c_id_meas_termination_cmd_s&                e_c_id_meas_termination_cmd();
    positioning_info_upd_s&                       positioning_info_upd();
    multicast_group_paging_s&                     multicast_group_paging();
    broadcast_context_release_request_s&          broadcast_context_release_request();
    multicast_context_release_request_s&          multicast_context_release_request();
    pdc_meas_report_s&                            pdc_meas_report();
    pdc_meas_termination_cmd_s&                   pdc_meas_termination_cmd();
    pdc_meas_fail_ind_s&                          pdc_meas_fail_ind();
    meas_activation_s&                            meas_activation();
    qo_e_info_transfer_s&                         qo_e_info_transfer();
    pos_sys_info_delivery_cmd_s&                  pos_sys_info_delivery_cmd();
    const reset_s&                                reset() const;
    const f1_setup_request_s&                     f1_setup_request() const;
    const gnb_du_cfg_upd_s&                       gnb_du_cfg_upd() const;
    const gnb_cu_cfg_upd_s&                       gnb_cu_cfg_upd() const;
    const ue_context_setup_request_s&             ue_context_setup_request() const;
    const ue_context_release_cmd_s&               ue_context_release_cmd() const;
    const ue_context_mod_request_s&               ue_context_mod_request() const;
    const ue_context_mod_required_s&              ue_context_mod_required() const;
    const write_replace_warning_request_s&        write_replace_warning_request() const;
    const pws_cancel_request_s&                   pws_cancel_request() const;
    const gnb_du_res_coordination_request_s&      gnb_du_res_coordination_request() const;
    const f1_removal_request_s&                   f1_removal_request() const;
    const bap_map_cfg_s&                          bap_map_cfg() const;
    const gnb_du_res_cfg_s&                       gnb_du_res_cfg() const;
    const iab_tnl_address_request_s&              iab_tnl_address_request() const;
    const iab_up_cfg_upd_request_s&               iab_up_cfg_upd_request() const;
    const res_status_request_s&                   res_status_request() const;
    const positioning_meas_request_s&             positioning_meas_request() const;
    const trp_info_request_s&                     trp_info_request() const;
    const positioning_info_request_s&             positioning_info_request() const;
    const positioning_activation_request_s&       positioning_activation_request() const;
    const e_c_id_meas_initiation_request_s&       e_c_id_meas_initiation_request() const;
    const broadcast_context_setup_request_s&      broadcast_context_setup_request() const;
    const broadcast_context_release_cmd_s&        broadcast_context_release_cmd() const;
    const broadcast_context_mod_request_s&        broadcast_context_mod_request() const;
    const multicast_context_setup_request_s&      multicast_context_setup_request() const;
    const multicast_context_release_cmd_s&        multicast_context_release_cmd() const;
    const multicast_context_mod_request_s&        multicast_context_mod_request() const;
    const multicast_distribution_setup_request_s& multicast_distribution_setup_request() const;
    const multicast_distribution_release_cmd_s&   multicast_distribution_release_cmd() const;
    const pdc_meas_initiation_request_s&          pdc_meas_initiation_request() const;
    const prs_cfg_request_s&                      prs_cfg_request() const;
    const meas_precfg_required_s&                 meas_precfg_required() const;
    const error_ind_s&                            error_ind() const;
    const ue_context_release_request_s&           ue_context_release_request() const;
    const dl_rrc_msg_transfer_s&                  dl_rrc_msg_transfer() const;
    const ul_rrc_msg_transfer_s&                  ul_rrc_msg_transfer() const;
    const ue_inactivity_notif_s&                  ue_inactivity_notif() const;
    const private_msg_s&                          private_msg() const;
    const init_ul_rrc_msg_transfer_s&             init_ul_rrc_msg_transfer() const;
    const sys_info_delivery_cmd_s&                sys_info_delivery_cmd() const;
    const paging_s&                               paging() const;
    const notify_s&                               notify() const;
    const pws_restart_ind_s&                      pws_restart_ind() const;
    const pws_fail_ind_s&                         pws_fail_ind() const;
    const gnb_du_status_ind_s&                    gnb_du_status_ind() const;
    const rrc_delivery_report_s&                  rrc_delivery_report() const;
    const network_access_rate_reduction_s&        network_access_rate_reduction() const;
    const trace_start_s&                          trace_start() const;
    const deactiv_trace_s&                        deactiv_trace() const;
    const du_cu_radio_info_transfer_s&            du_cu_radio_info_transfer() const;
    const cu_du_radio_info_transfer_s&            cu_du_radio_info_transfer() const;
    const res_status_upd_s&                       res_status_upd() const;
    const access_and_mob_ind_s&                   access_and_mob_ind() const;
    const ref_time_info_report_ctrl_s&            ref_time_info_report_ctrl() const;
    const ref_time_info_report_s&                 ref_time_info_report() const;
    const access_success_s&                       access_success() const;
    const cell_traffic_trace_s&                   cell_traffic_trace() const;
    const positioning_assist_info_ctrl_s&         positioning_assist_info_ctrl() const;
    const positioning_assist_info_feedback_s&     positioning_assist_info_feedback() const;
    const positioning_meas_report_s&              positioning_meas_report() const;
    const positioning_meas_abort_s&               positioning_meas_abort() const;
    const positioning_meas_fail_ind_s&            positioning_meas_fail_ind() const;
    const positioning_meas_upd_s&                 positioning_meas_upd() const;
    const positioning_deactivation_s&             positioning_deactivation() const;
    const e_c_id_meas_fail_ind_s&                 e_c_id_meas_fail_ind() const;
    const e_c_id_meas_report_s&                   e_c_id_meas_report() const;
    const e_c_id_meas_termination_cmd_s&          e_c_id_meas_termination_cmd() const;
    const positioning_info_upd_s&                 positioning_info_upd() const;
    const multicast_group_paging_s&               multicast_group_paging() const;
    const broadcast_context_release_request_s&    broadcast_context_release_request() const;
    const multicast_context_release_request_s&    multicast_context_release_request() const;
    const pdc_meas_report_s&                      pdc_meas_report() const;
    const pdc_meas_termination_cmd_s&             pdc_meas_termination_cmd() const;
    const pdc_meas_fail_ind_s&                    pdc_meas_fail_ind() const;
    const meas_activation_s&                      meas_activation() const;
    const qo_e_info_transfer_s&                   qo_e_info_transfer() const;
    const pos_sys_info_delivery_cmd_s&            pos_sys_info_delivery_cmd() const;

  private:
    types type_;
    choice_buffer_t<access_and_mob_ind_s,
                    access_success_s,
                    bap_map_cfg_s,
                    broadcast_context_mod_request_s,
                    broadcast_context_release_cmd_s,
                    broadcast_context_release_request_s,
                    broadcast_context_setup_request_s,
                    cell_traffic_trace_s,
                    cu_du_radio_info_transfer_s,
                    deactiv_trace_s,
                    dl_rrc_msg_transfer_s,
                    du_cu_radio_info_transfer_s,
                    e_c_id_meas_fail_ind_s,
                    e_c_id_meas_initiation_request_s,
                    e_c_id_meas_report_s,
                    e_c_id_meas_termination_cmd_s,
                    error_ind_s,
                    f1_removal_request_s,
                    f1_setup_request_s,
                    gnb_cu_cfg_upd_s,
                    gnb_du_cfg_upd_s,
                    gnb_du_res_cfg_s,
                    gnb_du_res_coordination_request_s,
                    gnb_du_status_ind_s,
                    iab_tnl_address_request_s,
                    iab_up_cfg_upd_request_s,
                    init_ul_rrc_msg_transfer_s,
                    meas_activation_s,
                    meas_precfg_required_s,
                    multicast_context_mod_request_s,
                    multicast_context_release_cmd_s,
                    multicast_context_release_request_s,
                    multicast_context_setup_request_s,
                    multicast_distribution_release_cmd_s,
                    multicast_distribution_setup_request_s,
                    multicast_group_paging_s,
                    network_access_rate_reduction_s,
                    notify_s,
                    paging_s,
                    pdc_meas_fail_ind_s,
                    pdc_meas_initiation_request_s,
                    pdc_meas_report_s,
                    pdc_meas_termination_cmd_s,
                    pos_sys_info_delivery_cmd_s,
                    positioning_activation_request_s,
                    positioning_assist_info_ctrl_s,
                    positioning_assist_info_feedback_s,
                    positioning_deactivation_s,
                    positioning_info_request_s,
                    positioning_info_upd_s,
                    positioning_meas_abort_s,
                    positioning_meas_fail_ind_s,
                    positioning_meas_report_s,
                    positioning_meas_request_s,
                    positioning_meas_upd_s,
                    private_msg_s,
                    prs_cfg_request_s,
                    pws_cancel_request_s,
                    pws_fail_ind_s,
                    pws_restart_ind_s,
                    qo_e_info_transfer_s,
                    ref_time_info_report_ctrl_s,
                    ref_time_info_report_s,
                    res_status_request_s,
                    res_status_upd_s,
                    reset_s,
                    rrc_delivery_report_s,
                    sys_info_delivery_cmd_s,
                    trace_start_s,
                    trp_info_request_s,
                    ue_context_mod_request_s,
                    ue_context_mod_required_s,
                    ue_context_release_cmd_s,
                    ue_context_release_request_s,
                    ue_context_setup_request_s,
                    ue_inactivity_notif_s,
                    ul_rrc_msg_transfer_s,
                    write_replace_warning_request_s>
        c;

    void destroy_();
  };
  // SuccessfulOutcome ::= OPEN TYPE
  struct successful_outcome_c {
    struct types_opts {
      enum options {
        reset_ack,
        f1_setup_resp,
        gnb_du_cfg_upd_ack,
        gnb_cu_cfg_upd_ack,
        ue_context_setup_resp,
        ue_context_release_complete,
        ue_context_mod_resp,
        ue_context_mod_confirm,
        write_replace_warning_resp,
        pws_cancel_resp,
        gnb_du_res_coordination_resp,
        f1_removal_resp,
        bap_map_cfg_ack,
        gnb_du_res_cfg_ack,
        iab_tnl_address_resp,
        iab_up_cfg_upd_resp,
        res_status_resp,
        positioning_meas_resp,
        trp_info_resp,
        positioning_info_resp,
        positioning_activation_resp,
        e_c_id_meas_initiation_resp,
        broadcast_context_setup_resp,
        broadcast_context_release_complete,
        broadcast_context_mod_resp,
        multicast_context_setup_resp,
        multicast_context_release_complete,
        multicast_context_mod_resp,
        multicast_distribution_setup_resp,
        multicast_distribution_release_complete,
        pdc_meas_initiation_resp,
        prs_cfg_resp,
        meas_precfg_confirm,
        nulltype
      } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    successful_outcome_c() = default;
    successful_outcome_c(const successful_outcome_c& other);
    successful_outcome_c& operator=(const successful_outcome_c& other);
    ~successful_outcome_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    reset_ack_s&                                     reset_ack();
    f1_setup_resp_s&                                 f1_setup_resp();
    gnb_du_cfg_upd_ack_s&                            gnb_du_cfg_upd_ack();
    gnb_cu_cfg_upd_ack_s&                            gnb_cu_cfg_upd_ack();
    ue_context_setup_resp_s&                         ue_context_setup_resp();
    ue_context_release_complete_s&                   ue_context_release_complete();
    ue_context_mod_resp_s&                           ue_context_mod_resp();
    ue_context_mod_confirm_s&                        ue_context_mod_confirm();
    write_replace_warning_resp_s&                    write_replace_warning_resp();
    pws_cancel_resp_s&                               pws_cancel_resp();
    gnb_du_res_coordination_resp_s&                  gnb_du_res_coordination_resp();
    f1_removal_resp_s&                               f1_removal_resp();
    bap_map_cfg_ack_s&                               bap_map_cfg_ack();
    gnb_du_res_cfg_ack_s&                            gnb_du_res_cfg_ack();
    iab_tnl_address_resp_s&                          iab_tnl_address_resp();
    iab_up_cfg_upd_resp_s&                           iab_up_cfg_upd_resp();
    res_status_resp_s&                               res_status_resp();
    positioning_meas_resp_s&                         positioning_meas_resp();
    trp_info_resp_s&                                 trp_info_resp();
    positioning_info_resp_s&                         positioning_info_resp();
    positioning_activation_resp_s&                   positioning_activation_resp();
    e_c_id_meas_initiation_resp_s&                   e_c_id_meas_initiation_resp();
    broadcast_context_setup_resp_s&                  broadcast_context_setup_resp();
    broadcast_context_release_complete_s&            broadcast_context_release_complete();
    broadcast_context_mod_resp_s&                    broadcast_context_mod_resp();
    multicast_context_setup_resp_s&                  multicast_context_setup_resp();
    multicast_context_release_complete_s&            multicast_context_release_complete();
    multicast_context_mod_resp_s&                    multicast_context_mod_resp();
    multicast_distribution_setup_resp_s&             multicast_distribution_setup_resp();
    multicast_distribution_release_complete_s&       multicast_distribution_release_complete();
    pdc_meas_initiation_resp_s&                      pdc_meas_initiation_resp();
    prs_cfg_resp_s&                                  prs_cfg_resp();
    meas_precfg_confirm_s&                           meas_precfg_confirm();
    const reset_ack_s&                               reset_ack() const;
    const f1_setup_resp_s&                           f1_setup_resp() const;
    const gnb_du_cfg_upd_ack_s&                      gnb_du_cfg_upd_ack() const;
    const gnb_cu_cfg_upd_ack_s&                      gnb_cu_cfg_upd_ack() const;
    const ue_context_setup_resp_s&                   ue_context_setup_resp() const;
    const ue_context_release_complete_s&             ue_context_release_complete() const;
    const ue_context_mod_resp_s&                     ue_context_mod_resp() const;
    const ue_context_mod_confirm_s&                  ue_context_mod_confirm() const;
    const write_replace_warning_resp_s&              write_replace_warning_resp() const;
    const pws_cancel_resp_s&                         pws_cancel_resp() const;
    const gnb_du_res_coordination_resp_s&            gnb_du_res_coordination_resp() const;
    const f1_removal_resp_s&                         f1_removal_resp() const;
    const bap_map_cfg_ack_s&                         bap_map_cfg_ack() const;
    const gnb_du_res_cfg_ack_s&                      gnb_du_res_cfg_ack() const;
    const iab_tnl_address_resp_s&                    iab_tnl_address_resp() const;
    const iab_up_cfg_upd_resp_s&                     iab_up_cfg_upd_resp() const;
    const res_status_resp_s&                         res_status_resp() const;
    const positioning_meas_resp_s&                   positioning_meas_resp() const;
    const trp_info_resp_s&                           trp_info_resp() const;
    const positioning_info_resp_s&                   positioning_info_resp() const;
    const positioning_activation_resp_s&             positioning_activation_resp() const;
    const e_c_id_meas_initiation_resp_s&             e_c_id_meas_initiation_resp() const;
    const broadcast_context_setup_resp_s&            broadcast_context_setup_resp() const;
    const broadcast_context_release_complete_s&      broadcast_context_release_complete() const;
    const broadcast_context_mod_resp_s&              broadcast_context_mod_resp() const;
    const multicast_context_setup_resp_s&            multicast_context_setup_resp() const;
    const multicast_context_release_complete_s&      multicast_context_release_complete() const;
    const multicast_context_mod_resp_s&              multicast_context_mod_resp() const;
    const multicast_distribution_setup_resp_s&       multicast_distribution_setup_resp() const;
    const multicast_distribution_release_complete_s& multicast_distribution_release_complete() const;
    const pdc_meas_initiation_resp_s&                pdc_meas_initiation_resp() const;
    const prs_cfg_resp_s&                            prs_cfg_resp() const;
    const meas_precfg_confirm_s&                     meas_precfg_confirm() const;

  private:
    types type_;
    choice_buffer_t<bap_map_cfg_ack_s,
                    broadcast_context_mod_resp_s,
                    broadcast_context_release_complete_s,
                    broadcast_context_setup_resp_s,
                    e_c_id_meas_initiation_resp_s,
                    f1_removal_resp_s,
                    f1_setup_resp_s,
                    gnb_cu_cfg_upd_ack_s,
                    gnb_du_cfg_upd_ack_s,
                    gnb_du_res_cfg_ack_s,
                    gnb_du_res_coordination_resp_s,
                    iab_tnl_address_resp_s,
                    iab_up_cfg_upd_resp_s,
                    meas_precfg_confirm_s,
                    multicast_context_mod_resp_s,
                    multicast_context_release_complete_s,
                    multicast_context_setup_resp_s,
                    multicast_distribution_release_complete_s,
                    multicast_distribution_setup_resp_s,
                    pdc_meas_initiation_resp_s,
                    positioning_activation_resp_s,
                    positioning_info_resp_s,
                    positioning_meas_resp_s,
                    prs_cfg_resp_s,
                    pws_cancel_resp_s,
                    res_status_resp_s,
                    reset_ack_s,
                    trp_info_resp_s,
                    ue_context_mod_confirm_s,
                    ue_context_mod_resp_s,
                    ue_context_release_complete_s,
                    ue_context_setup_resp_s,
                    write_replace_warning_resp_s>
        c;

    void destroy_();
  };
  // UnsuccessfulOutcome ::= OPEN TYPE
  struct unsuccessful_outcome_c {
    struct types_opts {
      enum options {
        f1_setup_fail,
        gnb_du_cfg_upd_fail,
        gnb_cu_cfg_upd_fail,
        ue_context_setup_fail,
        ue_context_mod_fail,
        ue_context_mod_refuse,
        f1_removal_fail,
        bap_map_cfg_fail,
        gnb_du_res_cfg_fail,
        iab_tnl_address_fail,
        iab_up_cfg_upd_fail,
        res_status_fail,
        positioning_meas_fail,
        trp_info_fail,
        positioning_info_fail,
        positioning_activation_fail,
        e_c_id_meas_initiation_fail,
        broadcast_context_setup_fail,
        broadcast_context_mod_fail,
        multicast_context_setup_fail,
        multicast_context_mod_fail,
        multicast_distribution_setup_fail,
        pdc_meas_initiation_fail,
        prs_cfg_fail,
        meas_precfg_refuse,
        nulltype
      } value;

      const char* to_string() const;
    };
    typedef enumerated<types_opts> types;

    // choice methods
    unsuccessful_outcome_c() = default;
    unsuccessful_outcome_c(const unsuccessful_outcome_c& other);
    unsuccessful_outcome_c& operator=(const unsuccessful_outcome_c& other);
    ~unsuccessful_outcome_c() { destroy_(); }
    void        set(types::options e = types::nulltype);
    types       type() const { return type_; }
    SRSASN_CODE pack(bit_ref& bref) const;
    SRSASN_CODE unpack(cbit_ref& bref);
    void        to_json(json_writer& j) const;
    // getters
    f1_setup_fail_s&                           f1_setup_fail();
    gnb_du_cfg_upd_fail_s&                     gnb_du_cfg_upd_fail();
    gnb_cu_cfg_upd_fail_s&                     gnb_cu_cfg_upd_fail();
    ue_context_setup_fail_s&                   ue_context_setup_fail();
    ue_context_mod_fail_s&                     ue_context_mod_fail();
    ue_context_mod_refuse_s&                   ue_context_mod_refuse();
    f1_removal_fail_s&                         f1_removal_fail();
    bap_map_cfg_fail_s&                        bap_map_cfg_fail();
    gnb_du_res_cfg_fail_s&                     gnb_du_res_cfg_fail();
    iab_tnl_address_fail_s&                    iab_tnl_address_fail();
    iab_up_cfg_upd_fail_s&                     iab_up_cfg_upd_fail();
    res_status_fail_s&                         res_status_fail();
    positioning_meas_fail_s&                   positioning_meas_fail();
    trp_info_fail_s&                           trp_info_fail();
    positioning_info_fail_s&                   positioning_info_fail();
    positioning_activation_fail_s&             positioning_activation_fail();
    e_c_id_meas_initiation_fail_s&             e_c_id_meas_initiation_fail();
    broadcast_context_setup_fail_s&            broadcast_context_setup_fail();
    broadcast_context_mod_fail_s&              broadcast_context_mod_fail();
    multicast_context_setup_fail_s&            multicast_context_setup_fail();
    multicast_context_mod_fail_s&              multicast_context_mod_fail();
    multicast_distribution_setup_fail_s&       multicast_distribution_setup_fail();
    pdc_meas_initiation_fail_s&                pdc_meas_initiation_fail();
    prs_cfg_fail_s&                            prs_cfg_fail();
    meas_precfg_refuse_s&                      meas_precfg_refuse();
    const f1_setup_fail_s&                     f1_setup_fail() const;
    const gnb_du_cfg_upd_fail_s&               gnb_du_cfg_upd_fail() const;
    const gnb_cu_cfg_upd_fail_s&               gnb_cu_cfg_upd_fail() const;
    const ue_context_setup_fail_s&             ue_context_setup_fail() const;
    const ue_context_mod_fail_s&               ue_context_mod_fail() const;
    const ue_context_mod_refuse_s&             ue_context_mod_refuse() const;
    const f1_removal_fail_s&                   f1_removal_fail() const;
    const bap_map_cfg_fail_s&                  bap_map_cfg_fail() const;
    const gnb_du_res_cfg_fail_s&               gnb_du_res_cfg_fail() const;
    const iab_tnl_address_fail_s&              iab_tnl_address_fail() const;
    const iab_up_cfg_upd_fail_s&               iab_up_cfg_upd_fail() const;
    const res_status_fail_s&                   res_status_fail() const;
    const positioning_meas_fail_s&             positioning_meas_fail() const;
    const trp_info_fail_s&                     trp_info_fail() const;
    const positioning_info_fail_s&             positioning_info_fail() const;
    const positioning_activation_fail_s&       positioning_activation_fail() const;
    const e_c_id_meas_initiation_fail_s&       e_c_id_meas_initiation_fail() const;
    const broadcast_context_setup_fail_s&      broadcast_context_setup_fail() const;
    const broadcast_context_mod_fail_s&        broadcast_context_mod_fail() const;
    const multicast_context_setup_fail_s&      multicast_context_setup_fail() const;
    const multicast_context_mod_fail_s&        multicast_context_mod_fail() const;
    const multicast_distribution_setup_fail_s& multicast_distribution_setup_fail() const;
    const pdc_meas_initiation_fail_s&          pdc_meas_initiation_fail() const;
    const prs_cfg_fail_s&                      prs_cfg_fail() const;
    const meas_precfg_refuse_s&                meas_precfg_refuse() const;

  private:
    types type_;
    choice_buffer_t<bap_map_cfg_fail_s,
                    broadcast_context_mod_fail_s,
                    broadcast_context_setup_fail_s,
                    e_c_id_meas_initiation_fail_s,
                    f1_removal_fail_s,
                    f1_setup_fail_s,
                    gnb_cu_cfg_upd_fail_s,
                    gnb_du_cfg_upd_fail_s,
                    gnb_du_res_cfg_fail_s,
                    iab_tnl_address_fail_s,
                    iab_up_cfg_upd_fail_s,
                    meas_precfg_refuse_s,
                    multicast_context_mod_fail_s,
                    multicast_context_setup_fail_s,
                    multicast_distribution_setup_fail_s,
                    pdc_meas_initiation_fail_s,
                    positioning_activation_fail_s,
                    positioning_info_fail_s,
                    positioning_meas_fail_s,
                    prs_cfg_fail_s,
                    res_status_fail_s,
                    trp_info_fail_s,
                    ue_context_mod_fail_s,
                    ue_context_mod_refuse_s,
                    ue_context_setup_fail_s>
        c;

    void destroy_();
  };

  // members lookup methods
  static uint16_t               idx_to_proc_code(uint32_t idx);
  static bool                   is_proc_code_valid(const uint16_t& proc_code);
  static init_msg_c             get_init_msg(const uint16_t& proc_code);
  static successful_outcome_c   get_successful_outcome(const uint16_t& proc_code);
  static unsuccessful_outcome_c get_unsuccessful_outcome(const uint16_t& proc_code);
  static crit_e                 get_crit(const uint16_t& proc_code);
};

// F1AP-PDU-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
using f1ap_pdu_ext_ies_o = protocol_ies_empty_o;

// InitiatingMessage ::= SEQUENCE{{F1AP-ELEMENTARY-PROCEDURE}}
struct init_msg_s {
  uint16_t                      proc_code = 0;
  crit_e                        crit;
  f1ap_elem_procs_o::init_msg_c value;

  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
  bool        load_info_obj(const uint16_t& proc_code_);
};

// SuccessfulOutcome ::= SEQUENCE{{F1AP-ELEMENTARY-PROCEDURE}}
struct successful_outcome_s {
  uint16_t                                proc_code = 0;
  crit_e                                  crit;
  f1ap_elem_procs_o::successful_outcome_c value;

  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
  bool        load_info_obj(const uint16_t& proc_code_);
};

// UnsuccessfulOutcome ::= SEQUENCE{{F1AP-ELEMENTARY-PROCEDURE}}
struct unsuccessful_outcome_s {
  uint16_t                                  proc_code = 0;
  crit_e                                    crit;
  f1ap_elem_procs_o::unsuccessful_outcome_c value;

  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
  bool        load_info_obj(const uint16_t& proc_code_);
};

// F1AP-PDU ::= CHOICE
struct f1ap_pdu_c {
  struct types_opts {
    enum options { init_msg, successful_outcome, unsuccessful_outcome, choice_ext, nulltype } value;

    const char* to_string() const;
  };
  typedef enumerated<types_opts> types;

  // choice methods
  f1ap_pdu_c() = default;
  f1ap_pdu_c(const f1ap_pdu_c& other);
  f1ap_pdu_c& operator=(const f1ap_pdu_c& other);
  ~f1ap_pdu_c() { destroy_(); }
  void        set(types::options e = types::nulltype);
  types       type() const { return type_; }
  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
  // getters
  init_msg_s& init_msg()
  {
    assert_choice_type(types::init_msg, type_, "F1AP-PDU");
    return c.get<init_msg_s>();
  }
  successful_outcome_s& successful_outcome()
  {
    assert_choice_type(types::successful_outcome, type_, "F1AP-PDU");
    return c.get<successful_outcome_s>();
  }
  unsuccessful_outcome_s& unsuccessful_outcome()
  {
    assert_choice_type(types::unsuccessful_outcome, type_, "F1AP-PDU");
    return c.get<unsuccessful_outcome_s>();
  }
  protocol_ie_single_container_s<f1ap_pdu_ext_ies_o>& choice_ext()
  {
    assert_choice_type(types::choice_ext, type_, "F1AP-PDU");
    return c.get<protocol_ie_single_container_s<f1ap_pdu_ext_ies_o>>();
  }
  const init_msg_s& init_msg() const
  {
    assert_choice_type(types::init_msg, type_, "F1AP-PDU");
    return c.get<init_msg_s>();
  }
  const successful_outcome_s& successful_outcome() const
  {
    assert_choice_type(types::successful_outcome, type_, "F1AP-PDU");
    return c.get<successful_outcome_s>();
  }
  const unsuccessful_outcome_s& unsuccessful_outcome() const
  {
    assert_choice_type(types::unsuccessful_outcome, type_, "F1AP-PDU");
    return c.get<unsuccessful_outcome_s>();
  }
  const protocol_ie_single_container_s<f1ap_pdu_ext_ies_o>& choice_ext() const
  {
    assert_choice_type(types::choice_ext, type_, "F1AP-PDU");
    return c.get<protocol_ie_single_container_s<f1ap_pdu_ext_ies_o>>();
  }
  init_msg_s&                                         set_init_msg();
  successful_outcome_s&                               set_successful_outcome();
  unsuccessful_outcome_s&                             set_unsuccessful_outcome();
  protocol_ie_single_container_s<f1ap_pdu_ext_ies_o>& set_choice_ext();

private:
  types type_;
  choice_buffer_t<init_msg_s,
                  protocol_ie_single_container_s<f1ap_pdu_ext_ies_o>,
                  successful_outcome_s,
                  unsuccessful_outcome_s>
      c;

  void destroy_();
};

// ProtocolIE-FieldPair{F1AP-PROTOCOL-IES-PAIR : IEsSetParam} ::= SEQUENCE{{F1AP-PROTOCOL-IES-PAIR}}
template <class ies_set_paramT_>
struct protocol_ie_field_pair_s {
  uint32_t                                 id = 0;
  crit_e                                   first_crit;
  typename ies_set_paramT_::first_value_c  first_value;
  crit_e                                   second_crit;
  typename ies_set_paramT_::second_value_c second_value;

  SRSASN_CODE pack(bit_ref& bref) const;
  SRSASN_CODE unpack(cbit_ref& bref);
  void        to_json(json_writer& j) const;
  bool        load_info_obj(const uint32_t& id_);
};

// ProtocolIE-ContainerPair{F1AP-PROTOCOL-IES-PAIR : IEsSetParam} ::= SEQUENCE (SIZE (0..65535)) OF ProtocolIE-FieldPair
template <class ies_set_paramT_>
using protocol_ie_container_pair_l = dyn_seq_of<protocol_ie_field_pair_s<ies_set_paramT_>, 0, 65535, true>;

} // namespace f1ap
} // namespace asn1

extern template struct asn1::protocol_ie_field_s<asn1::f1ap::access_and_mob_ind_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::access_success_ies_o>;
extern template struct asn1::protocol_ext_field_s<asn1::f1ap::sul_info_ext_ies_o>;
extern template struct asn1::protocol_ext_field_s<asn1::f1ap::gnb_du_cell_res_cfg_ext_ies_o>;
extern template struct asn1::protocol_ext_field_s<asn1::f1ap::iab_du_cell_res_cfg_fdd_info_ext_ies_o>;
extern template struct asn1::protocol_ext_field_s<asn1::f1ap::iab_du_cell_res_cfg_tdd_info_ext_ies_o>;
extern template struct asn1::protocol_ext_field_s<asn1::f1ap::add_path_item_ext_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::associated_scell_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::bap_hdr_rewriting_added_list_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::bap_hdr_rewriting_remd_list_item_ies_o>;
extern template struct asn1::protocol_ext_field_s<asn1::f1ap::ba_player_bh_rlc_ch_map_info_item_ext_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::bh_routing_info_added_list_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::bh_routing_info_remd_list_item_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::bap_map_cfg_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::bap_map_cfg_ack_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::bap_map_cfg_fail_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::bh_chs_failed_to_be_modified_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::bh_chs_failed_to_be_setup_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::bh_chs_failed_to_be_setup_mod_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::bh_chs_modified_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::bh_chs_required_to_be_released_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::bh_chs_setup_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::bh_chs_setup_mod_item_ies_o>;
extern template struct asn1::protocol_ext_field_s<asn1::f1ap::dyn_5qi_descriptor_ext_ies_o>;
extern template struct asn1::protocol_ext_field_s<asn1::f1ap::non_dyn_5qi_descriptor_ext_ies_o>;
extern template struct asn1::protocol_ext_field_s<asn1::f1ap::qos_flow_level_qos_params_ext_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::bh_chs_to_be_modified_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::bh_chs_to_be_released_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::bh_chs_to_be_setup_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::bh_chs_to_be_setup_mod_item_ies_o>;
extern template struct asn1::protocol_ext_field_s<asn1::f1ap::bplmn_id_info_item_ext_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::broadcast_to_be_cancelled_list_item_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::broadcast_context_mod_fail_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::broadcast_m_rbs_to_be_modified_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::broadcast_m_rbs_to_be_released_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::broadcast_m_rbs_to_be_setup_mod_item_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::broadcast_context_mod_request_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<
    asn1::f1ap::broadcast_m_rbs_failed_to_be_modified_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<
    asn1::f1ap::broadcast_m_rbs_failed_to_be_setup_mod_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::broadcast_m_rbs_modified_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::broadcast_m_rbs_setup_mod_item_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::broadcast_context_mod_resp_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::broadcast_context_release_cmd_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::broadcast_context_release_complete_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::broadcast_context_release_request_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::broadcast_context_setup_fail_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::broadcast_m_rbs_to_be_setup_item_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::broadcast_context_setup_request_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::broadcast_m_rbs_failed_to_be_setup_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::broadcast_m_rbs_setup_item_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::broadcast_context_setup_resp_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::cu_du_radio_info_transfer_ies_o>;
extern template struct asn1::protocol_ext_field_s<asn1::f1ap::cu_to_du_rrc_info_ext_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::candidate_sp_cell_item_ies_o>;
extern template struct asn1::protocol_ext_field_s<asn1::f1ap::rr_status_ext_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::cell_traffic_trace_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::cells_broadcast_cancelled_list_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::cells_broadcast_completed_list_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::cells_failed_to_be_activ_list_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::cells_status_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::cells_to_be_broadcast_list_item_ies_o>;
extern template struct asn1::protocol_ext_field_s<asn1::f1ap::cells_to_be_activ_list_item_ext_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::cells_to_be_activ_list_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::cells_to_be_barred_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::cells_to_be_deactiv_list_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::freq_domain_len_ext_ies_o>;
extern template struct asn1::protocol_ext_field_s<asn1::f1ap::iab_mt_cell_list_item_ext_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::dl_up_tnl_address_to_upd_list_item_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::dl_rrc_msg_transfer_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::drb_activity_item_ies_o>;
extern template struct asn1::protocol_ext_field_s<asn1::f1ap::flows_mapped_to_drb_item_ext_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::drb_notify_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::drbs_failed_to_be_modified_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::drbs_failed_to_be_setup_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::drbs_failed_to_be_setup_mod_item_ies_o>;
extern template struct asn1::protocol_ext_field_s<asn1::f1ap::drbs_modified_item_ext_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::drbs_modified_item_ies_o>;
extern template struct asn1::protocol_ext_field_s<asn1::f1ap::ul_up_tnl_info_to_be_setup_item_ext_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::drbs_modified_conf_item_ies_o>;
extern template struct asn1::protocol_ext_field_s<asn1::f1ap::drbs_required_to_be_modified_item_ext_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::drbs_required_to_be_modified_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::drbs_required_to_be_released_item_ies_o>;
extern template struct asn1::protocol_ext_field_s<asn1::f1ap::drbs_setup_item_ext_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::drbs_setup_item_ies_o>;
extern template struct asn1::protocol_ext_field_s<asn1::f1ap::drbs_setup_mod_item_ext_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::drbs_setup_mod_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::qos_info_ext_ies_o>;
extern template struct asn1::protocol_ext_field_s<asn1::f1ap::drbs_to_be_modified_item_ext_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::drbs_to_be_modified_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::drbs_to_be_released_item_ies_o>;
extern template struct asn1::protocol_ext_field_s<asn1::f1ap::drbs_to_be_setup_item_ext_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::drbs_to_be_setup_item_ies_o>;
extern template struct asn1::protocol_ext_field_s<asn1::f1ap::drbs_to_be_setup_mod_item_ext_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::drbs_to_be_setup_mod_item_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::du_cu_radio_info_transfer_ies_o>;
extern template struct asn1::protocol_ext_field_s<asn1::f1ap::du_to_cu_rrc_info_ext_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::deactiv_trace_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::ded_si_delivery_needed_ue_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::e_c_id_measured_results_value_ext_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::e_c_id_meas_quantities_item_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::e_c_id_meas_fail_ind_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::e_c_id_meas_initiation_fail_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::e_c_id_meas_initiation_request_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::e_c_id_meas_initiation_resp_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::e_c_id_meas_report_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::e_c_id_meas_termination_cmd_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::error_ind_ies_o>;
extern template struct asn1::protocol_ext_field_s<asn1::f1ap::extended_served_plmns_item_ext_ies_o>;
extern template struct asn1::protocol_ext_field_s<asn1::f1ap::fdd_info_ext_ies_o>;
extern template struct asn1::protocol_ext_field_s<asn1::f1ap::gnb_rx_tx_time_diff_ext_ies_o>;
extern template struct asn1::protocol_ext_field_s<asn1::f1ap::served_plmns_item_ext_ies_o>;
extern template struct asn1::protocol_ext_field_s<asn1::f1ap::tdd_info_ext_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::trp_info_type_resp_item_ext_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::time_stamp_slot_idx_ext_ies_o>;
extern template struct asn1::protocol_ext_field_s<asn1::f1ap::ul_rtoa_meas_ext_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::measured_results_value_ext_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::nr_mode_info_ext_ies_o>;
extern template struct asn1::protocol_ext_field_s<asn1::f1ap::gnb_du_sys_info_ext_ies_o>;
extern template struct asn1::protocol_ext_field_s<asn1::f1ap::pos_meas_result_item_ext_ies_o>;
extern template struct asn1::protocol_ext_field_s<asn1::f1ap::served_cell_info_ext_ies_o>;
extern template struct asn1::protocol_ext_field_s<asn1::f1ap::paging_cell_item_ext_ies_o>;
extern template struct asn1::protocol_ext_field_s<asn1::f1ap::srbs_to_be_setup_item_ext_ies_o>;
extern template struct asn1::protocol_ext_field_s<asn1::f1ap::srbs_to_be_setup_mod_item_ext_ies_o>;
extern template struct asn1::protocol_ext_field_s<asn1::f1ap::trp_meas_request_item_ext_ies_o>;
extern template struct asn1::protocol_ext_field_s<asn1::f1ap::trp_meas_upd_item_ext_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::ue_associated_lc_f1_conn_item_res_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::gnb_cu_tnl_assoc_failed_to_setup_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::gnb_cu_tnl_assoc_setup_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::gnb_cu_tnl_assoc_to_add_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::gnb_cu_tnl_assoc_to_rem_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::gnb_cu_tnl_assoc_to_upd_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::gnb_du_served_cells_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::gnb_du_tnl_assoc_to_rem_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::iab_allocated_tnl_address_list_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::iab_tnl_addresses_to_rem_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::mc_paging_cell_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<
    asn1::f1ap::multicast_f1_u_context_failed_to_be_setup_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::multicast_f1_u_context_setup_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::multicast_f1_u_context_to_be_setup_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<
    asn1::f1ap::multicast_m_rbs_failed_to_be_modified_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::multicast_m_rbs_failed_to_be_setup_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<
    asn1::f1ap::multicast_m_rbs_failed_to_be_setup_mod_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::multicast_m_rbs_modified_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::multicast_m_rbs_setup_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::multicast_m_rbs_setup_mod_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::multicast_m_rbs_to_be_modified_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::multicast_m_rbs_to_be_released_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::multicast_m_rbs_to_be_setup_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::multicast_m_rbs_to_be_setup_mod_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::nr_cgi_list_for_restart_list_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::neighbour_cell_info_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::pdc_meas_quantities_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::pws_failed_nr_cgi_list_item_ies_o>;
extern template struct asn1::protocol_ext_field_s<asn1::f1ap::pws_sys_info_ext_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::paging_cell_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::potential_sp_cell_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::protected_eutra_res_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::scell_failedto_setup_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::scell_failedto_setup_mod_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::scell_to_be_remd_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::scell_to_be_setup_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::scell_to_be_setup_mod_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::sl_drbs_failed_to_be_modified_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::sl_drbs_failed_to_be_setup_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::sl_drbs_failed_to_be_setup_mod_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::sl_drbs_modified_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::sl_drbs_modified_conf_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::sl_drbs_required_to_be_modified_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::sl_drbs_required_to_be_released_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::sl_drbs_setup_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::sl_drbs_setup_mod_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::sl_drbs_to_be_modified_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::sl_drbs_to_be_released_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::sl_drbs_to_be_setup_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::sl_drbs_to_be_setup_mod_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::srbs_failed_to_be_setup_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::srbs_failed_to_be_setup_mod_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::srbs_modified_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::srbs_required_to_be_released_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::srbs_setup_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::srbs_setup_mod_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::srbs_to_be_released_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::srbs_to_be_setup_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::srbs_to_be_setup_mod_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::served_cells_to_add_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::served_cells_to_delete_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::served_cells_to_modify_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::serving_cell_mo_list_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::trp_info_item_trp_resp_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::trp_info_type_item_trp_req_o>;
extern template struct asn1::protocol_ext_field_s<asn1::f1ap::trace_activation_ext_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<
    asn1::f1ap::ue_multicast_m_rbs_confirmed_to_be_modified_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<
    asn1::f1ap::ue_multicast_m_rbs_required_to_be_modified_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<
    asn1::f1ap::ue_multicast_m_rbs_required_to_be_released_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::ue_multicast_m_rbs_setup_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::ue_multicast_m_rbs_to_be_released_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::ue_multicast_m_rbs_to_be_setup_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<
    asn1::f1ap::ue_multicast_m_rbs_to_be_setup_at_modify_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::ue_associated_lc_f1_conn_item_res_ack_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::ue_id_list_for_paging_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::ul_up_tnl_address_to_upd_list_item_ies_o>;
extern template struct asn1::protocol_ie_single_container_s<asn1::f1ap::ul_up_tnl_info_to_upd_list_item_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::f1_removal_fail_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::f1_removal_resp_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::f1_setup_fail_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::f1_setup_request_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::f1_setup_resp_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::gnb_cu_cfg_upd_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::gnb_cu_cfg_upd_ack_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::gnb_cu_cfg_upd_fail_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::gnb_du_cfg_upd_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::gnb_du_cfg_upd_ack_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::gnb_du_cfg_upd_fail_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::gnb_du_res_cfg_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::gnb_du_res_cfg_ack_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::gnb_du_res_cfg_fail_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::gnb_du_res_coordination_request_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::gnb_du_res_coordination_resp_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::gnb_du_status_ind_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::iab_tnl_address_fail_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::iab_tnl_address_request_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::iab_tnl_address_resp_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::iab_up_cfg_upd_fail_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::iab_up_cfg_upd_request_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::iab_up_cfg_upd_resp_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::init_ul_rrc_msg_transfer_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::meas_activation_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::meas_precfg_confirm_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::meas_precfg_refuse_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::meas_precfg_required_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::multicast_context_mod_fail_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::multicast_context_mod_request_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::multicast_context_mod_resp_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::multicast_context_release_cmd_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::multicast_context_release_complete_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::multicast_context_release_request_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::multicast_context_setup_fail_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::multicast_context_setup_request_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::multicast_context_setup_resp_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::multicast_distribution_release_cmd_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::multicast_distribution_release_complete_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::multicast_distribution_setup_fail_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::multicast_distribution_setup_request_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::multicast_distribution_setup_resp_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::multicast_group_paging_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::network_access_rate_reduction_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::notify_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::pdc_meas_fail_ind_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::pdc_meas_initiation_fail_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::pdc_meas_initiation_request_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::pdc_meas_initiation_resp_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::pdc_meas_report_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::pdc_meas_termination_cmd_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::prs_cfg_fail_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::prs_cfg_request_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::prs_cfg_resp_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::pws_cancel_request_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::pws_cancel_resp_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::pws_fail_ind_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::pws_restart_ind_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::paging_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::pos_sys_info_delivery_cmd_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::positioning_activation_fail_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::positioning_activation_request_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::positioning_activation_resp_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::positioning_assist_info_ctrl_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::positioning_assist_info_feedback_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::positioning_deactivation_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::positioning_info_fail_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::positioning_info_request_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::positioning_info_resp_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::positioning_info_upd_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::positioning_meas_abort_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::positioning_meas_fail_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::positioning_meas_fail_ind_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::positioning_meas_report_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::positioning_meas_request_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::positioning_meas_resp_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::positioning_meas_upd_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::qo_e_info_transfer_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::rrc_delivery_report_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::ref_time_info_report_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::ref_time_info_report_ctrl_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::reset_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::reset_ack_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::res_status_fail_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::res_status_request_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::res_status_resp_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::res_status_upd_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::sys_info_delivery_cmd_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::trp_info_fail_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::trp_info_request_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::trp_info_resp_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::trace_start_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::ue_context_mod_confirm_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::ue_context_mod_fail_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::ue_context_mod_refuse_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::ue_context_mod_request_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::ue_context_mod_required_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::ue_context_mod_resp_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::ue_context_release_cmd_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::ue_context_release_complete_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::ue_context_release_request_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::ue_context_setup_fail_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::ue_context_setup_request_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::ue_context_setup_resp_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::ue_inactivity_notif_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::ul_rrc_msg_transfer_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::write_replace_warning_request_ies_o>;
extern template struct asn1::protocol_ie_field_s<asn1::f1ap::write_replace_warning_resp_ies_o>;
