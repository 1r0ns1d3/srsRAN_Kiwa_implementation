# How to test nighlt/weekly schedules
# Generate a schedule for your branch whit a CI_DESCRIPTION variable
# that contains "Nightly"/"Weekly" and an extra word
# Ex: "Test Weekly", "Nighlty add feature"

include:
  - project: softwareradiosystems/testing-tools
    ref: "27"
    file: .gitlab/ci-shared/setup/all.yml
  - project: softwareradiosystems/testing-tools
    ref: "27"
    file: .gitlab/ci-shared/features/all.yml
  - local: .gitlab/ci/build.yml

stages:
  - ci
  - static
  - build
  - tests
  - documentation

################################################################################
## Static
################################################################################
include-guards:
  extends: .include-guards
  parallel:
    matrix:
      - INPUT_PATH: "include/srsgnb"
        INPUT_IGNORE: "/bundled/"
      - INPUT_PATH: "."
        INPUT_IGNORE: "^\\(include\\|docs\\)/.*"

.cppcheck:
  stage: static
  image:
    name: registry.gitlab.com/softwareradiosystems/testing-tools/cppcheck:$DOCKER_CPPCHECK_VERSION
    entrypoint: [""]
  needs: []
  before_script:
    - |
      run_cppcheck() {
        cd ${CI_PROJECT_DIR}
        mkdir -p cppcheck_build cppcheck_html
        cppcheck --enable=all --template=gcc --xml --cppcheck-build-dir=cppcheck_build -I ${CI_PROJECT_DIR} \
          -i unittests -i integrationtests -i benchmarks -i apps/examples \
          -i lib/asn1/ -i lib/phy/generic_functions/fftx/lib_fftx_dftbat_srcs/ -i lib/phy/generic_functions/fftx/lib_fftx_idftbat_srcs/ \
          "$@" 2>cppcheck.xml
        cppcheck-htmlreport --source-dir=. --title=srsGNB --file=cppcheck.xml --report-dir=cppcheck_html
      }
    - |
      count_cppcheck_errors() {
        cd ${CI_PROJECT_DIR}
        num_errors=$(python3 -c 'import xml.etree.ElementTree as ET; import sys; print(sum([it.attrib["severity"] == "error" for it in ET.ElementTree(file=sys.argv[1]).getroot().find("errors").findall("error")]))' ./cppcheck.xml)
        echo $num_errors
      }
  script:
    - run_cppcheck .
    - exit $(count_cppcheck_errors)
  artifacts: &cppcheck_artifacts
    paths:
      - cppcheck_html
    when: always
    expire_in: 10 minutes
  cache: &cppcheck_cache
    key: cppcheck-${DOCKER_CPPCHECK_VERSION}
    paths:
      - cppcheck_build

cppcheck [cached]:
  extends: .cppcheck
  artifacts:
    <<: *cppcheck_artifacts
    paths:
      - cppcheck_html/index.html
      - cppcheck_html/style.css
  rules:
    - if: $CI_MERGE_REQUEST_LABELS =~ /no-cache/
      when: never
    - if: $ON_MR
  cache:
    <<: *cppcheck_cache
    policy: pull

cppcheck [clean and update cache]:
  extends: .cppcheck
  rules:
    - if: $CI_DESCRIPTION =~ /Nightly/
  cache:
    <<: *cppcheck_cache
    policy: push

cppcheck [clean]:
  # Fresh build with no interacton with the cache
  extends: .build
  rules:
    - if: $CI_MERGE_REQUEST_LABELS =~ /no-cache/
  cache: []

################################################################################
## Build + Unit Tests + Integration tests
################################################################################
intermediate commits:
  extends: .build
  rules:
    - if: $ON_MR
      # allow_failure: true
  script:
    - DEBIAN_FRONTEND=noninteractive apt-get update && apt-get install -y --no-install-recommends git git-lfs
    - git lfs install
    - git config advice.detachedHead false
    - git fetch origin $CI_MERGE_REQUEST_TARGET_BRANCH_NAME $CI_MERGE_REQUEST_SOURCE_BRANCH_NAME
    - |
      for rev in $(git rev-list --reverse origin/$CI_MERGE_REQUEST_TARGET_BRANCH_NAME..origin/$CI_MERGE_REQUEST_SOURCE_BRANCH_NAME^1)
      do
        echo "##################################################"
        echo "#### $rev ####"
        echo "##################################################"
        git checkout $rev
        sed -i "s/-Wall -Werror/-Wall/" CMakeLists.txt
        build_srsgnb
        sed -i "s/-Wall/-Wall -Werror/" CMakeLists.txt
      done
  after_script:
    - rm -Rf build

.trigger build:
  stage: build
  trigger:
    include: .gitlab/ci/build.yml
    strategy: depend
  variables:
    # Schedule variables are not inherited by default
    CI_DESCRIPTION: $CI_DESCRIPTION
  needs: []

.trigger build on mr:
  extends: .trigger build
  rules:
    - if: $ON_MR
    - if: $CI_DESCRIPTION =~ /Nightly/
      # Nightly will update the cache

.trigger build on nightly:
  extends: .trigger build
  rules:
    - if: $CI_DESCRIPTION =~ /Nightly/
  variables:
    # By default, nightly builds push cache. Force 'no cache' mode
    CI_MERGE_REQUEST_LABELS: no-cache

.trigger build on weekly:
  extends: .trigger build
  rules:
    - if: $CI_DESCRIPTION =~ /Weekly/

# Default build in build.yml

build custom [launcher]:
  image: alpine:3.16.0 # sh entrypoint
  stage: build
  rules:
    - if: $ON_MR
      when: manual
      allow_failure: true
  variables:
    OS: ""
    COMPILER: ""
    TEST_MODE: ""
    BUILD_ARGS: ""
  script:
    - |
      error=0
      if [ "$OS" = !"ubuntu-22.04" ] && [ "$OS" != "ubuntu-20.04" ] && [ "$OS" != "archlinux-latest" ]; then
          error=1
      elif [ "$COMPILER" != "gcc" ] && [ "$COMPILER" != "clang" ]; then
          error=1
      elif [ "$TEST_MODE" != "default" ] && [ "$TEST_MODE" != "coverage" ] && [ "$TEST_MODE" != "asan" ] && [ "$TEST_MODE" != "tsan" ] && [ "$TEST_MODE" != "valgrind" ] && [ "$TEST_MODE" != "none" ]; then
          error=1
      elif [ "$BUILD_ARGS" = "" ]; then
          error=1
      fi
    - |
      if [ $error = 1 ]; then
          echo "Invalid flags:"
          echo "OS [$OS] must be one of ubuntu-22.04, ubuntu-20.04, archlinux-latest"
          echo "COMPILER [$COMPILER] must be one of gcc, clang"
          echo "TEST_MODE [$TEST_MODE] must be one of default, coverage, asan, tsan, valgrind, none"
          echo "BUILD_ARGS [$BUILD_ARGS] must not be empty and it will be pased to cmake"
      fi
    - |
      {
          echo "CUSTOM_OS=$OS"
          echo "CUSTOM_COMPILER=$COMPILER"
          echo "CUSTOM_TEST_MODE=$TEST_MODE"
          echo "CUSTOM_BUILD_ARGS= $BUILD_ARGS"
      } >>custom.env
    - cat custom.env
    - exit $error
  artifacts:
    reports:
      dotenv: custom.env
  needs: []

build custom [trigger job]:
  extends: .trigger build
  needs:
    - build custom [launcher]
  rules:
    - if: $ON_MR
      allow_failure: true
  variables:
    OS: $CUSTOM_OS
    COMPILER: $CUSTOM_COMPILER
    TEST_MODE: $CUSTOM_TEST_MODE
    BUILD_ARGS: $CUSTOM_BUILD_ARGS
    ENABLE_GCOV: ""
    ASSERT_LEVEL: ""
    AUTO_DETECT_ISA: ""
    CI_MERGE_REQUEST_LABELS: no-cache

build [next]:
  extends: .trigger build on mr
  rules:
    - if: $ON_MR
    - if: $CI_DESCRIPTION =~ /Nightly/
  variables:
    OS: archlinux-latest
    COMPILER: gcc
    ENABLE_GCOV: "False"
    TEST_MODE: default

build [asan]:
  extends: .trigger build on mr
  variables:
    OS: ubuntu-22.04
    COMPILER: gcc
    BUILD_TYPE: Debug
    ENABLE_GCOV: "False"
    ENABLE_ASAN: "True"
    TEST_MODE: asan

build [tsan]:
  extends: .trigger build on mr
  variables:
    OS: ubuntu-22.04
    COMPILER: clang
    BUILD_TYPE: Debug
    ENABLE_GCOV: "False"
    ENABLE_TSAN: "True"
    TEST_MODE: tsan

build alt [ubuntu 22.04]:
  extends: .trigger build on nightly
  variables:
    OS: ubuntu-22.04
  parallel: &os-flags
    matrix:
      - COMPILER: [gcc, clang]
        BUILD_TYPE: [Debug, Release]
        ASSERT_LEVEL: [MINIMAL, NORMAL, PARANOID]
        ENABLE_EXPORT: ["True", "False"]
        ENABLE_GCOV: "False"
        TEST_MODE: default

build alt [archlinux-latest]:
  extends: .trigger build on nightly
  variables:
    OS: archlinux-latest
  parallel: *os-flags

build alt [ubuntu-22.04, arm64v8]:
  extends: .trigger build on nightly
  variables:
    OS: ubuntu-22.04
    TAG_EXTENSION: "-pi4"
  parallel: *os-flags

build alt [ubuntu-20.04]:
  extends: .trigger build on weekly
  variables:
    OS: ubuntu-20.04
  parallel: *os-flags

build alt [uhd]:
  extends: .trigger build on weekly
  parallel:
    matrix:
      - OS: ubuntu-22.04
        COMPILER: [gcc, clang]
        ENABLE_GCOV: "False"
        UHD_VERSION: "4.2.0.0"
        TEST_MODE: none
      - OS: ubuntu-20.04
        COMPILER: [gcc, clang]
        ENABLE_GCOV: "False"
        UHD_VERSION: ["4.2.0.0", "4.1.0.5"]
        TEST_MODE: none

build [valgrind]:
  extends: .trigger build on weekly
  variables:
    OS: ubuntu-22.04
    COMPILER: gcc
    AUTO_DETECT_ISA: "False"
    ENABLE_GCOV: "False"
    BUILD_TYPE: Debug
    TEST_MODE: valgrind

################################################################################
# Doc generation
################################################################################
.depends on unit test jobs:
  # Here we handled how jobs in .gitlab-ci.yml depends on jobs inside build.yml
  # If unit tests related jobs change in build.yml, we'll need to change this one too
  needs:
    - job: unit tests
      artifacts: true

unit requirements:
  stage: documentation
  rules:
    - if: $CI_DESCRIPTION =~ /Nightly/
      when: always # Even if previous stages/required jobs fail
  image: registry.gitlab.com/softwareradiosystems/testing-tools/srs-tools:$SRS_TOOLS_VERSION
  script:
    - test-reporter --input unittests --output ./requirement_report.html
  needs: []
  artifacts:
    paths:
      - requirement_report.html
    expire_in: 10 minutes

unit coverage:
  stage: documentation
  extends: .depends on unit test jobs
  image:
    name: registry.gitlab.com/softwareradiosystems/testing-tools/report_generator:$DOCKER_REPORT_GEN_VERSION
    entrypoint: ["/bin/sh", "-c"]
  rules:
    - if: $ON_MR
      variables:
        coverage_report: summary
      when: always # Even if previous stages/required jobs fail
    - if: $CI_DESCRIPTION =~ /Nightly/
      variables:
        coverage_report: full
      when: always # Even if previous stages/required jobs fail
  before_script:
    - PACKAGE_URL=${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/coverage/${CI_COMMIT_BRANCH}${CI_MERGE_REQUEST_SOURCE_BRANCH_NAME}/coverage_history.tar.gz
    # Download coverage history from the registry
    - |
      download_from_registry() {
        apk add --update curl
        
        cd ${CI_PROJECT_DIR}
        http_code=$(curl -w "%{http_code}" --header "PRIVATE-TOKEN: $CODEBOT_TOKEN" "${PACKAGE_URL}" -o output.tar.gz)
        if [[ $http_code == "200" ]]; then
          tar -xf output.tar.gz
        fi
      }
    # Publish coverage history folder to the registry
    - |
      publish_to_registry() {
        cd ${CI_PROJECT_DIR}
        tar -czf coverage_history.tar.gz coverage_history
        curl --fail --header "JOB-TOKEN: $CI_JOB_TOKEN" --upload-file coverage_history.tar.gz "${PACKAGE_URL}"
      }
  script:
    - |
      if [[ $coverage_report = "full" ]]; then
        download_from_registry
        HTML_TYPE=Html
        HISTORY=-historydir:coverage_history
      else
        HTML_TYPE=HtmlSummary
        HISTORY=
      fi
    - |
      ReportGenerator -reports:*coverage.xml -targetdir:coverage_html ${HISTORY} \
        -title:${CI_PROJECT_NAME} -tag:${CI_COMMIT_SHA} \
        -reporttypes:"${HTML_TYPE};TextSummary"
    - cat coverage_html/Summary.txt
    - |
      if [[ $coverage_report = "full" ]]; then
        publish_to_registry
      fi
  coverage: /^\s*Line coverage:\s*\d+.\d+\%/
  artifacts:
    paths:
      - coverage_html
    expire_in: 10 minutes

unit tests web:
  stage: documentation
  extends: .depends on unit test jobs
  rules:
    - if: $CI_DESCRIPTION =~ /Nightly/
      when: always # Even if previous stages/required jobs fail
  image: python:3.9-alpine # sh entrypoint
  variables:
    GIT_STRATEGY: none
  before_script:
    - pip install junit2html
  script:
    - junit2html *xunit.xml --merge merged_xunit.xml
    - junit2html merged_xunit.xml ./test_report.html
  artifacts:
    paths:
      - test_report.html
    expire_in: 10 minutes

pages:
  stage: documentation
  rules:
    - if: $CI_DESCRIPTION == "Nightly"
      when: always # Even if previous stages/required jobs fail
  image: registry.gitlab.com/softwareradiosystems/testing-tools/doxygen:$DOCKER_DOXYGEN_VERSION
  script:
    - doxygen_generator.sh
    - mv build/public .
    - mv coverage_html public/
    - mv cppcheck_html public/
    - mv test_report.html public/
    - mv requirement_report.html public/
    - mv public/index.html public/index_doxygen.html
    - mv docs/index.html public/index.html
  after_script:
    - |
      if [ $CI_JOB_STATUS = "failed" ]; then
        mkdir -p public
        mv docs/fail.html public/index.html
      fi
    - mv docs/*.png public/
    - sed -i 's/commit_hash/'$CI_COMMIT_SHA'/' public/index.html
  needs:
    - job: unit coverage
      artifacts: true
    - job: unit requirements
      artifacts: true
    - job: unit tests web
      artifacts: true
    - job: cppcheck [cached]
      artifacts: true
      optional: true
    - job: cppcheck [clean and update cache]
      artifacts: true
      optional: true
    - job: cppcheck [clean]
      artifacts: true
      optional: true
  artifacts:
    paths:
      - public
    expire_in: 10 minutes

################################################################################
# Git workflow graduation
################################################################################
promote code:
  stage: .post
  rules:
    - if: $GRADUATION_BRANCH
  image: alpine:3.16.0 # sh entrypoint
  before_script:
    - apk add --update --no-cache git git-lfs
  script:
    - git config user.email "${CODEBOT_USERNAME}@srs.io"
    - git config user.name ${CODEBOT_USERNAME}
    - git remote remove origin
    - git remote add origin https://${CODEBOT_USERNAME}:${CODEBOT_TOKEN}@gitlab.com/${CI_PROJECT_NAMESPACE}/${CI_PROJECT_NAME}.git
    - git fetch origin $GRADUATION_BRANCH
    - git checkout -t origin/$GRADUATION_BRANCH
    - git rebase ${CI_COMMIT_SHA}
    - git push
