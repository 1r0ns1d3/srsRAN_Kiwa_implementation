/*
 *
 * Copyright 2021-2023 Software Radio Systems Limited
 *
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the distribution.
 *
 */

#include "srsran/asn1/ngap/ngap.h"
#include <sstream>

using namespace asn1;
using namespace asn1::ngap;

/*******************************************************************************
 *                                Struct Methods
 ******************************************************************************/

// EndpointIPAddressAndPort ::= SEQUENCE
SRSASN_CODE endpoint_ip_address_and_port_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(endpoint_ip_address.pack(bref));
  HANDLE_CODE(port_num.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE endpoint_ip_address_and_port_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(endpoint_ip_address.unpack(bref));
  HANDLE_CODE(port_num.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void endpoint_ip_address_and_port_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("endpointIPAddress", endpoint_ip_address.to_string());
  j.write_str("portNumber", port_num.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CPTransportLayerInformation-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t cp_transport_layer_info_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {169};
  return map_enum_number(names, 1, idx, "id");
}
bool cp_transport_layer_info_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 169 == id;
}
crit_e cp_transport_layer_info_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 169) {
    return crit_e::reject;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
cp_transport_layer_info_ext_ies_o::value_c cp_transport_layer_info_ext_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  if (id != 169) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e cp_transport_layer_info_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 169) {
    return presence_e::mandatory;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Value ::= OPEN TYPE
void cp_transport_layer_info_ext_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("EndpointIPAddressAndPort");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE cp_transport_layer_info_ext_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE cp_transport_layer_info_ext_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* cp_transport_layer_info_ext_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"EndpointIPAddressAndPort"};
  return convert_enum_idx(names, 1, value, "cp_transport_layer_info_ext_ies_o::value_c::types");
}

template struct asn1::protocol_ie_single_container_s<cp_transport_layer_info_ext_ies_o>;

// CPTransportLayerInformation ::= CHOICE
void cp_transport_layer_info_c::destroy_()
{
  switch (type_) {
    case types::endpoint_ip_address:
      c.destroy<bounded_bitstring<1, 160, true, true>>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<cp_transport_layer_info_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void cp_transport_layer_info_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::endpoint_ip_address:
      c.init<bounded_bitstring<1, 160, true, true>>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<cp_transport_layer_info_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "cp_transport_layer_info_c");
  }
}
cp_transport_layer_info_c::cp_transport_layer_info_c(const cp_transport_layer_info_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::endpoint_ip_address:
      c.init(other.c.get<bounded_bitstring<1, 160, true, true>>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<cp_transport_layer_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "cp_transport_layer_info_c");
  }
}
cp_transport_layer_info_c& cp_transport_layer_info_c::operator=(const cp_transport_layer_info_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::endpoint_ip_address:
      c.set(other.c.get<bounded_bitstring<1, 160, true, true>>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<cp_transport_layer_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "cp_transport_layer_info_c");
  }

  return *this;
}
bounded_bitstring<1, 160, true, true>& cp_transport_layer_info_c::set_endpoint_ip_address()
{
  set(types::endpoint_ip_address);
  return c.get<bounded_bitstring<1, 160, true, true>>();
}
protocol_ie_single_container_s<cp_transport_layer_info_ext_ies_o>& cp_transport_layer_info_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<cp_transport_layer_info_ext_ies_o>>();
}
void cp_transport_layer_info_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::endpoint_ip_address:
      j.write_str("endpointIPAddress", c.get<bounded_bitstring<1, 160, true, true>>().to_string());
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<cp_transport_layer_info_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "cp_transport_layer_info_c");
  }
  j.end_obj();
}
SRSASN_CODE cp_transport_layer_info_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::endpoint_ip_address:
      HANDLE_CODE((c.get<bounded_bitstring<1, 160, true, true>>().pack(bref)));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<cp_transport_layer_info_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "cp_transport_layer_info_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE cp_transport_layer_info_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::endpoint_ip_address:
      HANDLE_CODE((c.get<bounded_bitstring<1, 160, true, true>>().unpack(bref)));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<cp_transport_layer_info_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "cp_transport_layer_info_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* cp_transport_layer_info_c::types_opts::to_string() const
{
  static const char* names[] = {"endpointIPAddress", "choice-Extensions"};
  return convert_enum_idx(names, 2, value, "cp_transport_layer_info_c::types");
}

// AMF-TNLAssociationSetupItem ::= SEQUENCE
SRSASN_CODE amf_tnl_assoc_setup_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(amf_tnl_assoc_address.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE amf_tnl_assoc_setup_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(amf_tnl_assoc_address.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void amf_tnl_assoc_setup_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("aMF-TNLAssociationAddress");
  amf_tnl_assoc_address.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TNLAssociationUsage ::= ENUMERATED
const char* tnl_assoc_usage_opts::to_string() const
{
  static const char* names[] = {"ue", "non-ue", "both"};
  return convert_enum_idx(names, 3, value, "tnl_assoc_usage_e");
}

// AMF-TNLAssociationToAddItem ::= SEQUENCE
SRSASN_CODE amf_tnl_assoc_to_add_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(tnl_assoc_usage_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(amf_tnl_assoc_address.pack(bref));
  if (tnl_assoc_usage_present) {
    HANDLE_CODE(tnl_assoc_usage.pack(bref));
  }
  HANDLE_CODE(pack_integer(bref, tnla_ddress_weight_factor, (uint16_t)0u, (uint16_t)255u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE amf_tnl_assoc_to_add_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(tnl_assoc_usage_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(amf_tnl_assoc_address.unpack(bref));
  if (tnl_assoc_usage_present) {
    HANDLE_CODE(tnl_assoc_usage.unpack(bref));
  }
  HANDLE_CODE(unpack_integer(tnla_ddress_weight_factor, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void amf_tnl_assoc_to_add_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("aMF-TNLAssociationAddress");
  amf_tnl_assoc_address.to_json(j);
  if (tnl_assoc_usage_present) {
    j.write_str("tNLAssociationUsage", tnl_assoc_usage.to_string());
  }
  j.write_int("tNLAddressWeightFactor", tnla_ddress_weight_factor);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// AMF-TNLAssociationToRemoveItem-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t amf_tnl_assoc_to_rem_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {168};
  return map_enum_number(names, 1, idx, "id");
}
bool amf_tnl_assoc_to_rem_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 168 == id;
}
crit_e amf_tnl_assoc_to_rem_item_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 168) {
    return crit_e::reject;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
amf_tnl_assoc_to_rem_item_ext_ies_o::ext_c amf_tnl_assoc_to_rem_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 168) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e amf_tnl_assoc_to_rem_item_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 168) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void amf_tnl_assoc_to_rem_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("CPTransportLayerInformation");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE amf_tnl_assoc_to_rem_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE amf_tnl_assoc_to_rem_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* amf_tnl_assoc_to_rem_item_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"CPTransportLayerInformation"};
  return convert_enum_idx(names, 1, value, "amf_tnl_assoc_to_rem_item_ext_ies_o::ext_c::types");
}

// AMF-TNLAssociationToRemoveItem ::= SEQUENCE
SRSASN_CODE amf_tnl_assoc_to_rem_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(amf_tnl_assoc_address.pack(bref));
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE amf_tnl_assoc_to_rem_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(amf_tnl_assoc_address.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void amf_tnl_assoc_to_rem_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("aMF-TNLAssociationAddress");
  amf_tnl_assoc_address.to_json(j);
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// AMF-TNLAssociationToUpdateItem ::= SEQUENCE
SRSASN_CODE amf_tnl_assoc_to_upd_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(tnl_assoc_usage_present, 1));
  HANDLE_CODE(bref.pack(tnla_ddress_weight_factor_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(amf_tnl_assoc_address.pack(bref));
  if (tnl_assoc_usage_present) {
    HANDLE_CODE(tnl_assoc_usage.pack(bref));
  }
  if (tnla_ddress_weight_factor_present) {
    HANDLE_CODE(pack_integer(bref, tnla_ddress_weight_factor, (uint16_t)0u, (uint16_t)255u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE amf_tnl_assoc_to_upd_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(tnl_assoc_usage_present, 1));
  HANDLE_CODE(bref.unpack(tnla_ddress_weight_factor_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(amf_tnl_assoc_address.unpack(bref));
  if (tnl_assoc_usage_present) {
    HANDLE_CODE(tnl_assoc_usage.unpack(bref));
  }
  if (tnla_ddress_weight_factor_present) {
    HANDLE_CODE(unpack_integer(tnla_ddress_weight_factor, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void amf_tnl_assoc_to_upd_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("aMF-TNLAssociationAddress");
  amf_tnl_assoc_address.to_json(j);
  if (tnl_assoc_usage_present) {
    j.write_str("tNLAssociationUsage", tnl_assoc_usage.to_string());
  }
  if (tnla_ddress_weight_factor_present) {
    j.write_int("tNLAddressWeightFactor", tnla_ddress_weight_factor);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// S-NSSAI ::= SEQUENCE
SRSASN_CODE s_nssai_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(sd_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(sst.pack(bref));
  if (sd_present) {
    HANDLE_CODE(sd.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE s_nssai_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(sd_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(sst.unpack(bref));
  if (sd_present) {
    HANDLE_CODE(sd.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void s_nssai_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("sST", sst.to_string());
  if (sd_present) {
    j.write_str("sD", sd.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// AllowedNSSAI-Item ::= SEQUENCE
SRSASN_CODE allowed_nssai_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(s_nssai.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE allowed_nssai_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(s_nssai.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void allowed_nssai_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("s-NSSAI");
  s_nssai.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// AMFCPRelocationIndicationIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t amf_cp_relocation_ind_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 148, 0};
  return map_enum_number(names, 4, idx, "id");
}
bool amf_cp_relocation_ind_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 148, 0};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e amf_cp_relocation_ind_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 148:
      return crit_e::ignore;
    case 0:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
amf_cp_relocation_ind_ies_o::value_c amf_cp_relocation_ind_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 148:
      ret.set(value_c::types::s_nssai);
      break;
    case 0:
      ret.set(value_c::types::allowed_nssai);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e amf_cp_relocation_ind_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 148:
      return presence_e::optional;
    case 0:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void amf_cp_relocation_ind_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::s_nssai:
      c.destroy<s_nssai_s>();
      break;
    case types::allowed_nssai:
      c.destroy<allowed_nssai_l>();
      break;
    default:
      break;
  }
}
void amf_cp_relocation_ind_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::s_nssai:
      c.init<s_nssai_s>();
      break;
    case types::allowed_nssai:
      c.init<allowed_nssai_l>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "amf_cp_relocation_ind_ies_o::value_c");
  }
}
amf_cp_relocation_ind_ies_o::value_c::value_c(const amf_cp_relocation_ind_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::s_nssai:
      c.init(other.c.get<s_nssai_s>());
      break;
    case types::allowed_nssai:
      c.init(other.c.get<allowed_nssai_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "amf_cp_relocation_ind_ies_o::value_c");
  }
}
amf_cp_relocation_ind_ies_o::value_c&
amf_cp_relocation_ind_ies_o::value_c::operator=(const amf_cp_relocation_ind_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::s_nssai:
      c.set(other.c.get<s_nssai_s>());
      break;
    case types::allowed_nssai:
      c.set(other.c.get<allowed_nssai_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "amf_cp_relocation_ind_ies_o::value_c");
  }

  return *this;
}
uint64_t& amf_cp_relocation_ind_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& amf_cp_relocation_ind_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
s_nssai_s& amf_cp_relocation_ind_ies_o::value_c::s_nssai()
{
  assert_choice_type(types::s_nssai, type_, "Value");
  return c.get<s_nssai_s>();
}
allowed_nssai_l& amf_cp_relocation_ind_ies_o::value_c::allowed_nssai()
{
  assert_choice_type(types::allowed_nssai, type_, "Value");
  return c.get<allowed_nssai_l>();
}
const uint64_t& amf_cp_relocation_ind_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& amf_cp_relocation_ind_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const s_nssai_s& amf_cp_relocation_ind_ies_o::value_c::s_nssai() const
{
  assert_choice_type(types::s_nssai, type_, "Value");
  return c.get<s_nssai_s>();
}
const allowed_nssai_l& amf_cp_relocation_ind_ies_o::value_c::allowed_nssai() const
{
  assert_choice_type(types::allowed_nssai, type_, "Value");
  return c.get<allowed_nssai_l>();
}
void amf_cp_relocation_ind_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::s_nssai:
      j.write_fieldname("S-NSSAI");
      c.get<s_nssai_s>().to_json(j);
      break;
    case types::allowed_nssai:
      j.start_array("AllowedNSSAI");
      for (const auto& e1 : c.get<allowed_nssai_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    default:
      log_invalid_choice_id(type_, "amf_cp_relocation_ind_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE amf_cp_relocation_ind_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::s_nssai:
      HANDLE_CODE(c.get<s_nssai_s>().pack(bref));
      break;
    case types::allowed_nssai:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<allowed_nssai_l>(), 1, 8, true));
      break;
    default:
      log_invalid_choice_id(type_, "amf_cp_relocation_ind_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE amf_cp_relocation_ind_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::s_nssai:
      HANDLE_CODE(c.get<s_nssai_s>().unpack(bref));
      break;
    case types::allowed_nssai:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<allowed_nssai_l>(), bref, 1, 8, true));
      break;
    default:
      log_invalid_choice_id(type_, "amf_cp_relocation_ind_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* amf_cp_relocation_ind_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..1099511627775)", "INTEGER (0..4294967295)", "S-NSSAI", "AllowedNSSAI"};
  return convert_enum_idx(names, 4, value, "amf_cp_relocation_ind_ies_o::value_c::types");
}

template struct asn1::protocol_ie_field_s<amf_cp_relocation_ind_ies_o>;

amf_cp_relocation_ind_ies_container::amf_cp_relocation_ind_ies_container() :
  amf_ue_ngap_id(10, crit_e::reject),
  ran_ue_ngap_id(85, crit_e::reject),
  s_nssai(148, crit_e::ignore),
  allowed_nssai(0, crit_e::ignore)
{
}
SRSASN_CODE amf_cp_relocation_ind_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += s_nssai_present ? 1 : 0;
  nof_ies += allowed_nssai_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  if (s_nssai_present) {
    HANDLE_CODE(s_nssai.pack(bref));
  }
  if (allowed_nssai_present) {
    HANDLE_CODE(allowed_nssai.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE amf_cp_relocation_ind_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 148: {
        s_nssai_present = true;
        s_nssai.id      = id;
        HANDLE_CODE(s_nssai.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(s_nssai.value.unpack(bref));
        break;
      }
      case 0: {
        allowed_nssai_present = true;
        allowed_nssai.id      = id;
        HANDLE_CODE(allowed_nssai.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(allowed_nssai.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void amf_cp_relocation_ind_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  if (s_nssai_present) {
    j.write_fieldname("");
    s_nssai.to_json(j);
  }
  if (allowed_nssai_present) {
    j.write_fieldname("");
    allowed_nssai.to_json(j);
  }
  j.end_obj();
}

// SliceSupportItem ::= SEQUENCE
SRSASN_CODE slice_support_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(s_nssai.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE slice_support_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(s_nssai.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void slice_support_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("s-NSSAI");
  s_nssai.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// GUAMIType ::= ENUMERATED
const char* guami_type_opts::to_string() const
{
  static const char* names[] = {"native", "mapped"};
  return convert_enum_idx(names, 2, value, "guami_type_e");
}

// NPN-Support ::= CHOICE
void npn_support_c::destroy_()
{
  switch (type_) {
    case types::sn_pn:
      c.destroy<fixed_bitstring<44, false, true>>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<npn_support_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void npn_support_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::sn_pn:
      c.init<fixed_bitstring<44, false, true>>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<npn_support_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "npn_support_c");
  }
}
npn_support_c::npn_support_c(const npn_support_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::sn_pn:
      c.init(other.c.get<fixed_bitstring<44, false, true>>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<npn_support_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "npn_support_c");
  }
}
npn_support_c& npn_support_c::operator=(const npn_support_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::sn_pn:
      c.set(other.c.get<fixed_bitstring<44, false, true>>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<npn_support_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "npn_support_c");
  }

  return *this;
}
fixed_bitstring<44, false, true>& npn_support_c::set_sn_pn()
{
  set(types::sn_pn);
  return c.get<fixed_bitstring<44, false, true>>();
}
protocol_ie_single_container_s<npn_support_ext_ies_o>& npn_support_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<npn_support_ext_ies_o>>();
}
void npn_support_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::sn_pn:
      j.write_str("sNPN", c.get<fixed_bitstring<44, false, true>>().to_string());
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<npn_support_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "npn_support_c");
  }
  j.end_obj();
}
SRSASN_CODE npn_support_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::sn_pn:
      HANDLE_CODE((c.get<fixed_bitstring<44, false, true>>().pack(bref)));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<npn_support_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "npn_support_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE npn_support_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::sn_pn:
      HANDLE_CODE((c.get<fixed_bitstring<44, false, true>>().unpack(bref)));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<npn_support_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "npn_support_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* npn_support_c::types_opts::to_string() const
{
  static const char* names[] = {"sNPN", "choice-Extensions"};
  return convert_enum_idx(names, 2, value, "npn_support_c::types");
}

// OnboardingSupport ::= ENUMERATED
const char* onboarding_support_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "onboarding_support_e");
}

// GUAMI ::= SEQUENCE
SRSASN_CODE guami_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.pack(bref));
  HANDLE_CODE(amf_region_id.pack(bref));
  HANDLE_CODE(amf_set_id.pack(bref));
  HANDLE_CODE(amf_pointer.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE guami_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.unpack(bref));
  HANDLE_CODE(amf_region_id.unpack(bref));
  HANDLE_CODE(amf_set_id.unpack(bref));
  HANDLE_CODE(amf_pointer.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void guami_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("pLMNIdentity", plmn_id.to_string());
  j.write_str("aMFRegionID", amf_region_id.to_string());
  j.write_str("aMFSetID", amf_set_id.to_string());
  j.write_str("aMFPointer", amf_pointer.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PLMNSupportItem-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t plmn_support_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {258, 270, 325};
  return map_enum_number(names, 3, idx, "id");
}
bool plmn_support_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {258, 270, 325};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e plmn_support_item_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 258:
      return crit_e::reject;
    case 270:
      return crit_e::reject;
    case 325:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
plmn_support_item_ext_ies_o::ext_c plmn_support_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 258:
      ret.set(ext_c::types::npn_support);
      break;
    case 270:
      ret.set(ext_c::types::extended_slice_support_list);
      break;
    case 325:
      ret.set(ext_c::types::onboarding_support);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e plmn_support_item_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 258:
      return presence_e::optional;
    case 270:
      return presence_e::optional;
    case 325:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void plmn_support_item_ext_ies_o::ext_c::destroy_()
{
  switch (type_) {
    case types::npn_support:
      c.destroy<npn_support_c>();
      break;
    case types::extended_slice_support_list:
      c.destroy<extended_slice_support_list_l>();
      break;
    default:
      break;
  }
}
void plmn_support_item_ext_ies_o::ext_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::npn_support:
      c.init<npn_support_c>();
      break;
    case types::extended_slice_support_list:
      c.init<extended_slice_support_list_l>();
      break;
    case types::onboarding_support:
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "plmn_support_item_ext_ies_o::ext_c");
  }
}
plmn_support_item_ext_ies_o::ext_c::ext_c(const plmn_support_item_ext_ies_o::ext_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::npn_support:
      c.init(other.c.get<npn_support_c>());
      break;
    case types::extended_slice_support_list:
      c.init(other.c.get<extended_slice_support_list_l>());
      break;
    case types::onboarding_support:
      c.init(other.c.get<onboarding_support_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "plmn_support_item_ext_ies_o::ext_c");
  }
}
plmn_support_item_ext_ies_o::ext_c&
plmn_support_item_ext_ies_o::ext_c::operator=(const plmn_support_item_ext_ies_o::ext_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::npn_support:
      c.set(other.c.get<npn_support_c>());
      break;
    case types::extended_slice_support_list:
      c.set(other.c.get<extended_slice_support_list_l>());
      break;
    case types::onboarding_support:
      c.set(other.c.get<onboarding_support_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "plmn_support_item_ext_ies_o::ext_c");
  }

  return *this;
}
npn_support_c& plmn_support_item_ext_ies_o::ext_c::npn_support()
{
  assert_choice_type(types::npn_support, type_, "Extension");
  return c.get<npn_support_c>();
}
extended_slice_support_list_l& plmn_support_item_ext_ies_o::ext_c::extended_slice_support_list()
{
  assert_choice_type(types::extended_slice_support_list, type_, "Extension");
  return c.get<extended_slice_support_list_l>();
}
onboarding_support_e& plmn_support_item_ext_ies_o::ext_c::onboarding_support()
{
  assert_choice_type(types::onboarding_support, type_, "Extension");
  return c.get<onboarding_support_e>();
}
const npn_support_c& plmn_support_item_ext_ies_o::ext_c::npn_support() const
{
  assert_choice_type(types::npn_support, type_, "Extension");
  return c.get<npn_support_c>();
}
const extended_slice_support_list_l& plmn_support_item_ext_ies_o::ext_c::extended_slice_support_list() const
{
  assert_choice_type(types::extended_slice_support_list, type_, "Extension");
  return c.get<extended_slice_support_list_l>();
}
const onboarding_support_e& plmn_support_item_ext_ies_o::ext_c::onboarding_support() const
{
  assert_choice_type(types::onboarding_support, type_, "Extension");
  return c.get<onboarding_support_e>();
}
void plmn_support_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::npn_support:
      j.write_fieldname("NPN-Support");
      c.get<npn_support_c>().to_json(j);
      break;
    case types::extended_slice_support_list:
      j.start_array("ExtendedSliceSupportList");
      for (const auto& e1 : c.get<extended_slice_support_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::onboarding_support:
      j.write_str("OnboardingSupport", "true");
      break;
    default:
      log_invalid_choice_id(type_, "plmn_support_item_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE plmn_support_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::npn_support:
      HANDLE_CODE(c.get<npn_support_c>().pack(bref));
      break;
    case types::extended_slice_support_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<extended_slice_support_list_l>(), 1, 65535, true));
      break;
    case types::onboarding_support:
      HANDLE_CODE(c.get<onboarding_support_e>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "plmn_support_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE plmn_support_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::npn_support:
      HANDLE_CODE(c.get<npn_support_c>().unpack(bref));
      break;
    case types::extended_slice_support_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<extended_slice_support_list_l>(), bref, 1, 65535, true));
      break;
    case types::onboarding_support:
      HANDLE_CODE(c.get<onboarding_support_e>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "plmn_support_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* plmn_support_item_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"NPN-Support", "ExtendedSliceSupportList", "OnboardingSupport"};
  return convert_enum_idx(names, 3, value, "plmn_support_item_ext_ies_o::ext_c::types");
}

// ServedGUAMIItem-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t served_guami_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {176};
  return map_enum_number(names, 1, idx, "id");
}
bool served_guami_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 176 == id;
}
crit_e served_guami_item_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 176) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
served_guami_item_ext_ies_o::ext_c served_guami_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 176) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e served_guami_item_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 176) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void served_guami_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("GUAMIType", c.to_string());
  j.end_obj();
}
SRSASN_CODE served_guami_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE served_guami_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* served_guami_item_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"GUAMIType"};
  return convert_enum_idx(names, 1, value, "served_guami_item_ext_ies_o::ext_c::types");
}

template struct asn1::protocol_ext_field_s<plmn_support_item_ext_ies_o>;

plmn_support_item_ext_ies_container::plmn_support_item_ext_ies_container() :
  npn_support(258, crit_e::reject),
  extended_slice_support_list(270, crit_e::reject),
  onboarding_support(325, crit_e::ignore)
{
}
SRSASN_CODE plmn_support_item_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += npn_support_present ? 1 : 0;
  nof_ies += extended_slice_support_list_present ? 1 : 0;
  nof_ies += onboarding_support_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (npn_support_present) {
    HANDLE_CODE(npn_support.pack(bref));
  }
  if (extended_slice_support_list_present) {
    HANDLE_CODE(extended_slice_support_list.pack(bref));
  }
  if (onboarding_support_present) {
    HANDLE_CODE(onboarding_support.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE plmn_support_item_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 258: {
        npn_support_present = true;
        npn_support.id      = id;
        HANDLE_CODE(npn_support.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(npn_support.ext.unpack(bref));
        break;
      }
      case 270: {
        extended_slice_support_list_present = true;
        extended_slice_support_list.id      = id;
        HANDLE_CODE(extended_slice_support_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(extended_slice_support_list.ext.unpack(bref));
        break;
      }
      case 325: {
        onboarding_support_present = true;
        onboarding_support.id      = id;
        HANDLE_CODE(onboarding_support.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(onboarding_support.ext.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void plmn_support_item_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (npn_support_present) {
    j.write_fieldname("");
    npn_support.to_json(j);
  }
  if (extended_slice_support_list_present) {
    j.write_fieldname("");
    extended_slice_support_list.to_json(j);
  }
  if (onboarding_support_present) {
    j.write_fieldname("");
    onboarding_support.to_json(j);
  }
  j.end_obj();
}

// PLMNSupportItem ::= SEQUENCE
SRSASN_CODE plmn_support_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.pack(bref));
  HANDLE_CODE(pack_dyn_seq_of(bref, slice_support_list, 1, 1024, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE plmn_support_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.unpack(bref));
  HANDLE_CODE(unpack_dyn_seq_of(slice_support_list, bref, 1, 1024, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void plmn_support_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("pLMNIdentity", plmn_id.to_string());
  j.start_array("sliceSupportList");
  for (const auto& e1 : slice_support_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// ServedGUAMIItem ::= SEQUENCE
SRSASN_CODE served_guami_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(backup_amf_name_present, 1));
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(guami.pack(bref));
  if (backup_amf_name_present) {
    HANDLE_CODE(backup_amf_name.pack(bref));
  }
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE served_guami_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(backup_amf_name_present, 1));
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(guami.unpack(bref));
  if (backup_amf_name_present) {
    HANDLE_CODE(backup_amf_name.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void served_guami_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("gUAMI");
  guami.to_json(j);
  if (backup_amf_name_present) {
    j.write_str("backupAMFName", backup_amf_name.to_string());
  }
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// Extended-AMFName ::= SEQUENCE
SRSASN_CODE extended_amf_name_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(amf_name_visible_string_present, 1));
  HANDLE_CODE(bref.pack(amf_name_utf8_string_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (amf_name_visible_string_present) {
    HANDLE_CODE(amf_name_visible_string.pack(bref));
  }
  if (amf_name_utf8_string_present) {
    HANDLE_CODE(amf_name_utf8_string.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE extended_amf_name_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(amf_name_visible_string_present, 1));
  HANDLE_CODE(bref.unpack(amf_name_utf8_string_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (amf_name_visible_string_present) {
    HANDLE_CODE(amf_name_visible_string.unpack(bref));
  }
  if (amf_name_utf8_string_present) {
    HANDLE_CODE(amf_name_utf8_string.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void extended_amf_name_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (amf_name_visible_string_present) {
    j.write_str("aMFNameVisibleString", amf_name_visible_string.to_string());
  }
  if (amf_name_utf8_string_present) {
    j.write_str("aMFNameUTF8String", amf_name_utf8_string.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// AMFConfigurationUpdateIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t amf_cfg_upd_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {1, 96, 86, 80, 6, 7, 8, 274};
  return map_enum_number(names, 8, idx, "id");
}
bool amf_cfg_upd_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {1, 96, 86, 80, 6, 7, 8, 274};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e amf_cfg_upd_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 1:
      return crit_e::reject;
    case 96:
      return crit_e::reject;
    case 86:
      return crit_e::ignore;
    case 80:
      return crit_e::reject;
    case 6:
      return crit_e::ignore;
    case 7:
      return crit_e::ignore;
    case 8:
      return crit_e::ignore;
    case 274:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
amf_cfg_upd_ies_o::value_c amf_cfg_upd_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 1:
      ret.set(value_c::types::amf_name);
      break;
    case 96:
      ret.set(value_c::types::served_guami_list);
      break;
    case 86:
      ret.set(value_c::types::relative_amf_capacity);
      break;
    case 80:
      ret.set(value_c::types::plmn_support_list);
      break;
    case 6:
      ret.set(value_c::types::amf_tnl_assoc_to_add_list);
      break;
    case 7:
      ret.set(value_c::types::amf_tnl_assoc_to_rem_list);
      break;
    case 8:
      ret.set(value_c::types::amf_tnl_assoc_to_upd_list);
      break;
    case 274:
      ret.set(value_c::types::extended_amf_name);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e amf_cfg_upd_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 1:
      return presence_e::optional;
    case 96:
      return presence_e::optional;
    case 86:
      return presence_e::optional;
    case 80:
      return presence_e::optional;
    case 6:
      return presence_e::optional;
    case 7:
      return presence_e::optional;
    case 8:
      return presence_e::optional;
    case 274:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void amf_cfg_upd_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::amf_name:
      c.destroy<printable_string<1, 150, true, true>>();
      break;
    case types::served_guami_list:
      c.destroy<served_guami_list_l>();
      break;
    case types::plmn_support_list:
      c.destroy<plmn_support_list_l>();
      break;
    case types::amf_tnl_assoc_to_add_list:
      c.destroy<amf_tnl_assoc_to_add_list_l>();
      break;
    case types::amf_tnl_assoc_to_rem_list:
      c.destroy<amf_tnl_assoc_to_rem_list_l>();
      break;
    case types::amf_tnl_assoc_to_upd_list:
      c.destroy<amf_tnl_assoc_to_upd_list_l>();
      break;
    case types::extended_amf_name:
      c.destroy<extended_amf_name_s>();
      break;
    default:
      break;
  }
}
void amf_cfg_upd_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_name:
      c.init<printable_string<1, 150, true, true>>();
      break;
    case types::served_guami_list:
      c.init<served_guami_list_l>();
      break;
    case types::relative_amf_capacity:
      break;
    case types::plmn_support_list:
      c.init<plmn_support_list_l>();
      break;
    case types::amf_tnl_assoc_to_add_list:
      c.init<amf_tnl_assoc_to_add_list_l>();
      break;
    case types::amf_tnl_assoc_to_rem_list:
      c.init<amf_tnl_assoc_to_rem_list_l>();
      break;
    case types::amf_tnl_assoc_to_upd_list:
      c.init<amf_tnl_assoc_to_upd_list_l>();
      break;
    case types::extended_amf_name:
      c.init<extended_amf_name_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "amf_cfg_upd_ies_o::value_c");
  }
}
amf_cfg_upd_ies_o::value_c::value_c(const amf_cfg_upd_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_name:
      c.init(other.c.get<printable_string<1, 150, true, true>>());
      break;
    case types::served_guami_list:
      c.init(other.c.get<served_guami_list_l>());
      break;
    case types::relative_amf_capacity:
      c.init(other.c.get<uint16_t>());
      break;
    case types::plmn_support_list:
      c.init(other.c.get<plmn_support_list_l>());
      break;
    case types::amf_tnl_assoc_to_add_list:
      c.init(other.c.get<amf_tnl_assoc_to_add_list_l>());
      break;
    case types::amf_tnl_assoc_to_rem_list:
      c.init(other.c.get<amf_tnl_assoc_to_rem_list_l>());
      break;
    case types::amf_tnl_assoc_to_upd_list:
      c.init(other.c.get<amf_tnl_assoc_to_upd_list_l>());
      break;
    case types::extended_amf_name:
      c.init(other.c.get<extended_amf_name_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "amf_cfg_upd_ies_o::value_c");
  }
}
amf_cfg_upd_ies_o::value_c& amf_cfg_upd_ies_o::value_c::operator=(const amf_cfg_upd_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_name:
      c.set(other.c.get<printable_string<1, 150, true, true>>());
      break;
    case types::served_guami_list:
      c.set(other.c.get<served_guami_list_l>());
      break;
    case types::relative_amf_capacity:
      c.set(other.c.get<uint16_t>());
      break;
    case types::plmn_support_list:
      c.set(other.c.get<plmn_support_list_l>());
      break;
    case types::amf_tnl_assoc_to_add_list:
      c.set(other.c.get<amf_tnl_assoc_to_add_list_l>());
      break;
    case types::amf_tnl_assoc_to_rem_list:
      c.set(other.c.get<amf_tnl_assoc_to_rem_list_l>());
      break;
    case types::amf_tnl_assoc_to_upd_list:
      c.set(other.c.get<amf_tnl_assoc_to_upd_list_l>());
      break;
    case types::extended_amf_name:
      c.set(other.c.get<extended_amf_name_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "amf_cfg_upd_ies_o::value_c");
  }

  return *this;
}
printable_string<1, 150, true, true>& amf_cfg_upd_ies_o::value_c::amf_name()
{
  assert_choice_type(types::amf_name, type_, "Value");
  return c.get<printable_string<1, 150, true, true>>();
}
served_guami_list_l& amf_cfg_upd_ies_o::value_c::served_guami_list()
{
  assert_choice_type(types::served_guami_list, type_, "Value");
  return c.get<served_guami_list_l>();
}
uint16_t& amf_cfg_upd_ies_o::value_c::relative_amf_capacity()
{
  assert_choice_type(types::relative_amf_capacity, type_, "Value");
  return c.get<uint16_t>();
}
plmn_support_list_l& amf_cfg_upd_ies_o::value_c::plmn_support_list()
{
  assert_choice_type(types::plmn_support_list, type_, "Value");
  return c.get<plmn_support_list_l>();
}
amf_tnl_assoc_to_add_list_l& amf_cfg_upd_ies_o::value_c::amf_tnl_assoc_to_add_list()
{
  assert_choice_type(types::amf_tnl_assoc_to_add_list, type_, "Value");
  return c.get<amf_tnl_assoc_to_add_list_l>();
}
amf_tnl_assoc_to_rem_list_l& amf_cfg_upd_ies_o::value_c::amf_tnl_assoc_to_rem_list()
{
  assert_choice_type(types::amf_tnl_assoc_to_rem_list, type_, "Value");
  return c.get<amf_tnl_assoc_to_rem_list_l>();
}
amf_tnl_assoc_to_upd_list_l& amf_cfg_upd_ies_o::value_c::amf_tnl_assoc_to_upd_list()
{
  assert_choice_type(types::amf_tnl_assoc_to_upd_list, type_, "Value");
  return c.get<amf_tnl_assoc_to_upd_list_l>();
}
extended_amf_name_s& amf_cfg_upd_ies_o::value_c::extended_amf_name()
{
  assert_choice_type(types::extended_amf_name, type_, "Value");
  return c.get<extended_amf_name_s>();
}
const printable_string<1, 150, true, true>& amf_cfg_upd_ies_o::value_c::amf_name() const
{
  assert_choice_type(types::amf_name, type_, "Value");
  return c.get<printable_string<1, 150, true, true>>();
}
const served_guami_list_l& amf_cfg_upd_ies_o::value_c::served_guami_list() const
{
  assert_choice_type(types::served_guami_list, type_, "Value");
  return c.get<served_guami_list_l>();
}
const uint16_t& amf_cfg_upd_ies_o::value_c::relative_amf_capacity() const
{
  assert_choice_type(types::relative_amf_capacity, type_, "Value");
  return c.get<uint16_t>();
}
const plmn_support_list_l& amf_cfg_upd_ies_o::value_c::plmn_support_list() const
{
  assert_choice_type(types::plmn_support_list, type_, "Value");
  return c.get<plmn_support_list_l>();
}
const amf_tnl_assoc_to_add_list_l& amf_cfg_upd_ies_o::value_c::amf_tnl_assoc_to_add_list() const
{
  assert_choice_type(types::amf_tnl_assoc_to_add_list, type_, "Value");
  return c.get<amf_tnl_assoc_to_add_list_l>();
}
const amf_tnl_assoc_to_rem_list_l& amf_cfg_upd_ies_o::value_c::amf_tnl_assoc_to_rem_list() const
{
  assert_choice_type(types::amf_tnl_assoc_to_rem_list, type_, "Value");
  return c.get<amf_tnl_assoc_to_rem_list_l>();
}
const amf_tnl_assoc_to_upd_list_l& amf_cfg_upd_ies_o::value_c::amf_tnl_assoc_to_upd_list() const
{
  assert_choice_type(types::amf_tnl_assoc_to_upd_list, type_, "Value");
  return c.get<amf_tnl_assoc_to_upd_list_l>();
}
const extended_amf_name_s& amf_cfg_upd_ies_o::value_c::extended_amf_name() const
{
  assert_choice_type(types::extended_amf_name, type_, "Value");
  return c.get<extended_amf_name_s>();
}
void amf_cfg_upd_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_name:
      j.write_str("PrintableString", c.get<printable_string<1, 150, true, true>>().to_string());
      break;
    case types::served_guami_list:
      j.start_array("ServedGUAMIList");
      for (const auto& e1 : c.get<served_guami_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::relative_amf_capacity:
      j.write_int("INTEGER (0..255)", c.get<uint16_t>());
      break;
    case types::plmn_support_list:
      j.start_array("PLMNSupportList");
      for (const auto& e1 : c.get<plmn_support_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::amf_tnl_assoc_to_add_list:
      j.start_array("AMF-TNLAssociationToAddList");
      for (const auto& e1 : c.get<amf_tnl_assoc_to_add_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::amf_tnl_assoc_to_rem_list:
      j.start_array("AMF-TNLAssociationToRemoveList");
      for (const auto& e1 : c.get<amf_tnl_assoc_to_rem_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::amf_tnl_assoc_to_upd_list:
      j.start_array("AMF-TNLAssociationToUpdateList");
      for (const auto& e1 : c.get<amf_tnl_assoc_to_upd_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::extended_amf_name:
      j.write_fieldname("Extended-AMFName");
      c.get<extended_amf_name_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "amf_cfg_upd_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE amf_cfg_upd_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_name:
      HANDLE_CODE((c.get<printable_string<1, 150, true, true>>().pack(bref)));
      break;
    case types::served_guami_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<served_guami_list_l>(), 1, 256, true));
      break;
    case types::relative_amf_capacity:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)0u, (uint16_t)255u, false, true));
      break;
    case types::plmn_support_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<plmn_support_list_l>(), 1, 12, true));
      break;
    case types::amf_tnl_assoc_to_add_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<amf_tnl_assoc_to_add_list_l>(), 1, 32, true));
      break;
    case types::amf_tnl_assoc_to_rem_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<amf_tnl_assoc_to_rem_list_l>(), 1, 32, true));
      break;
    case types::amf_tnl_assoc_to_upd_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<amf_tnl_assoc_to_upd_list_l>(), 1, 32, true));
      break;
    case types::extended_amf_name:
      HANDLE_CODE(c.get<extended_amf_name_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "amf_cfg_upd_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE amf_cfg_upd_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_name:
      HANDLE_CODE((c.get<printable_string<1, 150, true, true>>().unpack(bref)));
      break;
    case types::served_guami_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<served_guami_list_l>(), bref, 1, 256, true));
      break;
    case types::relative_amf_capacity:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)0u, (uint16_t)255u, false, true));
      break;
    case types::plmn_support_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<plmn_support_list_l>(), bref, 1, 12, true));
      break;
    case types::amf_tnl_assoc_to_add_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<amf_tnl_assoc_to_add_list_l>(), bref, 1, 32, true));
      break;
    case types::amf_tnl_assoc_to_rem_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<amf_tnl_assoc_to_rem_list_l>(), bref, 1, 32, true));
      break;
    case types::amf_tnl_assoc_to_upd_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<amf_tnl_assoc_to_upd_list_l>(), bref, 1, 32, true));
      break;
    case types::extended_amf_name:
      HANDLE_CODE(c.get<extended_amf_name_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "amf_cfg_upd_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* amf_cfg_upd_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"PrintableString",
                                "ServedGUAMIList",
                                "INTEGER (0..255)",
                                "PLMNSupportList",
                                "AMF-TNLAssociationToAddList",
                                "AMF-TNLAssociationToRemoveList",
                                "AMF-TNLAssociationToUpdateList",
                                "Extended-AMFName"};
  return convert_enum_idx(names, 8, value, "amf_cfg_upd_ies_o::value_c::types");
}
uint8_t amf_cfg_upd_ies_o::value_c::types_opts::to_number() const
{
  if (value == relative_amf_capacity) {
    return 0;
  }
  invalid_enum_number(value, "amf_cfg_upd_ies_o::value_c::types");
  return 0;
}

template struct asn1::protocol_ie_field_s<amf_cfg_upd_ies_o>;

amf_cfg_upd_ies_container::amf_cfg_upd_ies_container() :
  amf_name(1, crit_e::reject),
  served_guami_list(96, crit_e::reject),
  relative_amf_capacity(86, crit_e::ignore),
  plmn_support_list(80, crit_e::reject),
  amf_tnl_assoc_to_add_list(6, crit_e::ignore),
  amf_tnl_assoc_to_rem_list(7, crit_e::ignore),
  amf_tnl_assoc_to_upd_list(8, crit_e::ignore),
  extended_amf_name(274, crit_e::ignore)
{
}
SRSASN_CODE amf_cfg_upd_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += amf_name_present ? 1 : 0;
  nof_ies += served_guami_list_present ? 1 : 0;
  nof_ies += relative_amf_capacity_present ? 1 : 0;
  nof_ies += plmn_support_list_present ? 1 : 0;
  nof_ies += amf_tnl_assoc_to_add_list_present ? 1 : 0;
  nof_ies += amf_tnl_assoc_to_rem_list_present ? 1 : 0;
  nof_ies += amf_tnl_assoc_to_upd_list_present ? 1 : 0;
  nof_ies += extended_amf_name_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  if (amf_name_present) {
    HANDLE_CODE(amf_name.pack(bref));
  }
  if (served_guami_list_present) {
    HANDLE_CODE(served_guami_list.pack(bref));
  }
  if (relative_amf_capacity_present) {
    HANDLE_CODE(relative_amf_capacity.pack(bref));
  }
  if (plmn_support_list_present) {
    HANDLE_CODE(plmn_support_list.pack(bref));
  }
  if (amf_tnl_assoc_to_add_list_present) {
    HANDLE_CODE(amf_tnl_assoc_to_add_list.pack(bref));
  }
  if (amf_tnl_assoc_to_rem_list_present) {
    HANDLE_CODE(amf_tnl_assoc_to_rem_list.pack(bref));
  }
  if (amf_tnl_assoc_to_upd_list_present) {
    HANDLE_CODE(amf_tnl_assoc_to_upd_list.pack(bref));
  }
  if (extended_amf_name_present) {
    HANDLE_CODE(extended_amf_name.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE amf_cfg_upd_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 1: {
        amf_name_present = true;
        amf_name.id      = id;
        HANDLE_CODE(amf_name.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_name.value.unpack(bref));
        break;
      }
      case 96: {
        served_guami_list_present = true;
        served_guami_list.id      = id;
        HANDLE_CODE(served_guami_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(served_guami_list.value.unpack(bref));
        break;
      }
      case 86: {
        relative_amf_capacity_present = true;
        relative_amf_capacity.id      = id;
        HANDLE_CODE(relative_amf_capacity.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(relative_amf_capacity.value.unpack(bref));
        break;
      }
      case 80: {
        plmn_support_list_present = true;
        plmn_support_list.id      = id;
        HANDLE_CODE(plmn_support_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(plmn_support_list.value.unpack(bref));
        break;
      }
      case 6: {
        amf_tnl_assoc_to_add_list_present = true;
        amf_tnl_assoc_to_add_list.id      = id;
        HANDLE_CODE(amf_tnl_assoc_to_add_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_tnl_assoc_to_add_list.value.unpack(bref));
        break;
      }
      case 7: {
        amf_tnl_assoc_to_rem_list_present = true;
        amf_tnl_assoc_to_rem_list.id      = id;
        HANDLE_CODE(amf_tnl_assoc_to_rem_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_tnl_assoc_to_rem_list.value.unpack(bref));
        break;
      }
      case 8: {
        amf_tnl_assoc_to_upd_list_present = true;
        amf_tnl_assoc_to_upd_list.id      = id;
        HANDLE_CODE(amf_tnl_assoc_to_upd_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_tnl_assoc_to_upd_list.value.unpack(bref));
        break;
      }
      case 274: {
        extended_amf_name_present = true;
        extended_amf_name.id      = id;
        HANDLE_CODE(extended_amf_name.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(extended_amf_name.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void amf_cfg_upd_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (amf_name_present) {
    j.write_fieldname("");
    amf_name.to_json(j);
  }
  if (served_guami_list_present) {
    j.write_fieldname("");
    served_guami_list.to_json(j);
  }
  if (relative_amf_capacity_present) {
    j.write_fieldname("");
    relative_amf_capacity.to_json(j);
  }
  if (plmn_support_list_present) {
    j.write_fieldname("");
    plmn_support_list.to_json(j);
  }
  if (amf_tnl_assoc_to_add_list_present) {
    j.write_fieldname("");
    amf_tnl_assoc_to_add_list.to_json(j);
  }
  if (amf_tnl_assoc_to_rem_list_present) {
    j.write_fieldname("");
    amf_tnl_assoc_to_rem_list.to_json(j);
  }
  if (amf_tnl_assoc_to_upd_list_present) {
    j.write_fieldname("");
    amf_tnl_assoc_to_upd_list.to_json(j);
  }
  if (extended_amf_name_present) {
    j.write_fieldname("");
    extended_amf_name.to_json(j);
  }
  j.end_obj();
}

// CauseMisc ::= ENUMERATED
const char* cause_misc_opts::to_string() const
{
  static const char* names[] = {"control-processing-overload",
                                "not-enough-user-plane-processing-resources",
                                "hardware-failure",
                                "om-intervention",
                                "unknown-PLMN-or-SNPN",
                                "unspecified"};
  return convert_enum_idx(names, 6, value, "cause_misc_e");
}

// CauseNas ::= ENUMERATED
const char* cause_nas_opts::to_string() const
{
  static const char* names[] = {
      "normal-release", "authentication-failure", "deregister", "unspecified", "uE-not-in-PLMN-serving-area"};
  return convert_enum_idx(names, 5, value, "cause_nas_e");
}

// CauseProtocol ::= ENUMERATED
const char* cause_protocol_opts::to_string() const
{
  static const char* names[] = {"transfer-syntax-error",
                                "abstract-syntax-error-reject",
                                "abstract-syntax-error-ignore-and-notify",
                                "message-not-compatible-with-receiver-state",
                                "semantic-error",
                                "abstract-syntax-error-falsely-constructed-message",
                                "unspecified"};
  return convert_enum_idx(names, 7, value, "cause_protocol_e");
}

// CauseRadioNetwork ::= ENUMERATED
const char* cause_radio_network_opts::to_string() const
{
  static const char* names[] = {"unspecified",
                                "txnrelocoverall-expiry",
                                "successful-handover",
                                "release-due-to-ngran-generated-reason",
                                "release-due-to-5gc-generated-reason",
                                "handover-cancelled",
                                "partial-handover",
                                "ho-failure-in-target-5GC-ngran-node-or-target-system",
                                "ho-target-not-allowed",
                                "tngrelocoverall-expiry",
                                "tngrelocprep-expiry",
                                "cell-not-available",
                                "unknown-targetID",
                                "no-radio-resources-available-in-target-cell",
                                "unknown-local-UE-NGAP-ID",
                                "inconsistent-remote-UE-NGAP-ID",
                                "handover-desirable-for-radio-reason",
                                "time-critical-handover",
                                "resource-optimisation-handover",
                                "reduce-load-in-serving-cell",
                                "user-inactivity",
                                "radio-connection-with-ue-lost",
                                "radio-resources-not-available",
                                "invalid-qos-combination",
                                "failure-in-radio-interface-procedure",
                                "interaction-with-other-procedure",
                                "unknown-PDU-session-ID",
                                "unkown-qos-flow-ID",
                                "multiple-PDU-session-ID-instances",
                                "multiple-qos-flow-ID-instances",
                                "encryption-and-or-integrity-protection-algorithms-not-supported",
                                "ng-intra-system-handover-triggered",
                                "ng-inter-system-handover-triggered",
                                "xn-handover-triggered",
                                "not-supported-5QI-value",
                                "ue-context-transfer",
                                "ims-voice-eps-fallback-or-rat-fallback-triggered",
                                "up-integrity-protection-not-possible",
                                "up-confidentiality-protection-not-possible",
                                "slice-not-supported",
                                "ue-in-rrc-inactive-state-not-reachable",
                                "redirection",
                                "resources-not-available-for-the-slice",
                                "ue-max-integrity-protected-data-rate-reason",
                                "release-due-to-cn-detected-mobility",
                                "n26-interface-not-available",
                                "release-due-to-pre-emption",
                                "multiple-location-reporting-reference-ID-instances",
                                "rsn-not-available-for-the-up",
                                "npn-access-denied",
                                "cag-only-access-denied",
                                "insufficient-ue-capabilities",
                                "redcap-ue-not-supported",
                                "unknown-MBS-Session-ID",
                                "indicated-MBS-session-area-information-not-served-by-the-gNB",
                                "inconsistent-slice-info-for-the-session",
                                "misaligned-association-for-multicast-unicast"};
  return convert_enum_idx(names, 57, value, "cause_radio_network_e");
}

// CauseTransport ::= ENUMERATED
const char* cause_transport_opts::to_string() const
{
  static const char* names[] = {"transport-resource-unavailable", "unspecified"};
  return convert_enum_idx(names, 2, value, "cause_transport_e");
}

// TypeOfError ::= ENUMERATED
const char* type_of_error_opts::to_string() const
{
  static const char* names[] = {"not-understood", "missing"};
  return convert_enum_idx(names, 2, value, "type_of_error_e");
}

// Cause ::= CHOICE
void cause_c::destroy_()
{
  switch (type_) {
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<cause_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void cause_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::radio_network:
      break;
    case types::transport:
      break;
    case types::nas:
      break;
    case types::protocol:
      break;
    case types::misc:
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<cause_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "cause_c");
  }
}
cause_c::cause_c(const cause_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::radio_network:
      c.init(other.c.get<cause_radio_network_e>());
      break;
    case types::transport:
      c.init(other.c.get<cause_transport_e>());
      break;
    case types::nas:
      c.init(other.c.get<cause_nas_e>());
      break;
    case types::protocol:
      c.init(other.c.get<cause_protocol_e>());
      break;
    case types::misc:
      c.init(other.c.get<cause_misc_e>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<cause_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "cause_c");
  }
}
cause_c& cause_c::operator=(const cause_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::radio_network:
      c.set(other.c.get<cause_radio_network_e>());
      break;
    case types::transport:
      c.set(other.c.get<cause_transport_e>());
      break;
    case types::nas:
      c.set(other.c.get<cause_nas_e>());
      break;
    case types::protocol:
      c.set(other.c.get<cause_protocol_e>());
      break;
    case types::misc:
      c.set(other.c.get<cause_misc_e>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<cause_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "cause_c");
  }

  return *this;
}
cause_radio_network_e& cause_c::set_radio_network()
{
  set(types::radio_network);
  return c.get<cause_radio_network_e>();
}
cause_transport_e& cause_c::set_transport()
{
  set(types::transport);
  return c.get<cause_transport_e>();
}
cause_nas_e& cause_c::set_nas()
{
  set(types::nas);
  return c.get<cause_nas_e>();
}
cause_protocol_e& cause_c::set_protocol()
{
  set(types::protocol);
  return c.get<cause_protocol_e>();
}
cause_misc_e& cause_c::set_misc()
{
  set(types::misc);
  return c.get<cause_misc_e>();
}
protocol_ie_single_container_s<cause_ext_ies_o>& cause_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<cause_ext_ies_o>>();
}
void cause_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::radio_network:
      j.write_str("radioNetwork", c.get<cause_radio_network_e>().to_string());
      break;
    case types::transport:
      j.write_str("transport", c.get<cause_transport_e>().to_string());
      break;
    case types::nas:
      j.write_str("nas", c.get<cause_nas_e>().to_string());
      break;
    case types::protocol:
      j.write_str("protocol", c.get<cause_protocol_e>().to_string());
      break;
    case types::misc:
      j.write_str("misc", c.get<cause_misc_e>().to_string());
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<cause_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "cause_c");
  }
  j.end_obj();
}
SRSASN_CODE cause_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::radio_network:
      HANDLE_CODE(c.get<cause_radio_network_e>().pack(bref));
      break;
    case types::transport:
      HANDLE_CODE(c.get<cause_transport_e>().pack(bref));
      break;
    case types::nas:
      HANDLE_CODE(c.get<cause_nas_e>().pack(bref));
      break;
    case types::protocol:
      HANDLE_CODE(c.get<cause_protocol_e>().pack(bref));
      break;
    case types::misc:
      HANDLE_CODE(c.get<cause_misc_e>().pack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<cause_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "cause_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE cause_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::radio_network:
      HANDLE_CODE(c.get<cause_radio_network_e>().unpack(bref));
      break;
    case types::transport:
      HANDLE_CODE(c.get<cause_transport_e>().unpack(bref));
      break;
    case types::nas:
      HANDLE_CODE(c.get<cause_nas_e>().unpack(bref));
      break;
    case types::protocol:
      HANDLE_CODE(c.get<cause_protocol_e>().unpack(bref));
      break;
    case types::misc:
      HANDLE_CODE(c.get<cause_misc_e>().unpack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<cause_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "cause_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* cause_c::types_opts::to_string() const
{
  static const char* names[] = {"radioNetwork", "transport", "nas", "protocol", "misc", "choice-Extensions"};
  return convert_enum_idx(names, 6, value, "cause_c::types");
}
uint8_t cause_c::types_opts::to_number() const
{
  static const uint8_t numbers[] = {2};
  return map_enum_number(numbers, 1, value, "cause_c::types");
}

// CriticalityDiagnostics-IE-Item ::= SEQUENCE
SRSASN_CODE crit_diagnostics_ie_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(ie_crit.pack(bref));
  HANDLE_CODE(pack_integer(bref, ie_id, (uint32_t)0u, (uint32_t)65535u, false, true));
  HANDLE_CODE(type_of_error.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE crit_diagnostics_ie_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(ie_crit.unpack(bref));
  HANDLE_CODE(unpack_integer(ie_id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
  HANDLE_CODE(type_of_error.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void crit_diagnostics_ie_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("iECriticality", ie_crit.to_string());
  j.write_int("iE-ID", ie_id);
  j.write_str("typeOfError", type_of_error.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TNLAssociationItem ::= SEQUENCE
SRSASN_CODE tnl_assoc_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(tnl_assoc_address.pack(bref));
  HANDLE_CODE(cause.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE tnl_assoc_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(tnl_assoc_address.unpack(bref));
  HANDLE_CODE(cause.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void tnl_assoc_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("tNLAssociationAddress");
  tnl_assoc_address.to_json(j);
  j.write_fieldname("cause");
  cause.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TriggeringMessage ::= ENUMERATED
const char* trigger_msg_opts::to_string() const
{
  static const char* names[] = {"initiating-message", "successful-outcome", "unsuccessful-outcome"};
  return convert_enum_idx(names, 3, value, "trigger_msg_e");
}

// CriticalityDiagnostics ::= SEQUENCE
SRSASN_CODE crit_diagnostics_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(proc_code_present, 1));
  HANDLE_CODE(bref.pack(trigger_msg_present, 1));
  HANDLE_CODE(bref.pack(proc_crit_present, 1));
  HANDLE_CODE(bref.pack(ies_crit_diagnostics.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (proc_code_present) {
    HANDLE_CODE(pack_integer(bref, proc_code, (uint16_t)0u, (uint16_t)255u, false, true));
  }
  if (trigger_msg_present) {
    HANDLE_CODE(trigger_msg.pack(bref));
  }
  if (proc_crit_present) {
    HANDLE_CODE(proc_crit.pack(bref));
  }
  if (ies_crit_diagnostics.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ies_crit_diagnostics, 1, 256, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE crit_diagnostics_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(proc_code_present, 1));
  HANDLE_CODE(bref.unpack(trigger_msg_present, 1));
  HANDLE_CODE(bref.unpack(proc_crit_present, 1));
  bool ies_crit_diagnostics_present;
  HANDLE_CODE(bref.unpack(ies_crit_diagnostics_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (proc_code_present) {
    HANDLE_CODE(unpack_integer(proc_code, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  }
  if (trigger_msg_present) {
    HANDLE_CODE(trigger_msg.unpack(bref));
  }
  if (proc_crit_present) {
    HANDLE_CODE(proc_crit.unpack(bref));
  }
  if (ies_crit_diagnostics_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ies_crit_diagnostics, bref, 1, 256, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void crit_diagnostics_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (proc_code_present) {
    j.write_int("procedureCode", proc_code);
  }
  if (trigger_msg_present) {
    j.write_str("triggeringMessage", trigger_msg.to_string());
  }
  if (proc_crit_present) {
    j.write_str("procedureCriticality", proc_crit.to_string());
  }
  if (ies_crit_diagnostics.size() > 0) {
    j.start_array("iEsCriticalityDiagnostics");
    for (const auto& e1 : ies_crit_diagnostics) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// AMFConfigurationUpdateAcknowledgeIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t amf_cfg_upd_ack_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {5, 4, 19};
  return map_enum_number(names, 3, idx, "id");
}
bool amf_cfg_upd_ack_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {5, 4, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e amf_cfg_upd_ack_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 5:
      return crit_e::ignore;
    case 4:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
amf_cfg_upd_ack_ies_o::value_c amf_cfg_upd_ack_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 5:
      ret.set(value_c::types::amf_tnl_assoc_setup_list);
      break;
    case 4:
      ret.set(value_c::types::amf_tnl_assoc_failed_to_setup_list);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e amf_cfg_upd_ack_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 5:
      return presence_e::optional;
    case 4:
      return presence_e::optional;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void amf_cfg_upd_ack_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::amf_tnl_assoc_setup_list:
      c.destroy<amf_tnl_assoc_setup_list_l>();
      break;
    case types::amf_tnl_assoc_failed_to_setup_list:
      c.destroy<tnl_assoc_list_l>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void amf_cfg_upd_ack_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_tnl_assoc_setup_list:
      c.init<amf_tnl_assoc_setup_list_l>();
      break;
    case types::amf_tnl_assoc_failed_to_setup_list:
      c.init<tnl_assoc_list_l>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "amf_cfg_upd_ack_ies_o::value_c");
  }
}
amf_cfg_upd_ack_ies_o::value_c::value_c(const amf_cfg_upd_ack_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_tnl_assoc_setup_list:
      c.init(other.c.get<amf_tnl_assoc_setup_list_l>());
      break;
    case types::amf_tnl_assoc_failed_to_setup_list:
      c.init(other.c.get<tnl_assoc_list_l>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "amf_cfg_upd_ack_ies_o::value_c");
  }
}
amf_cfg_upd_ack_ies_o::value_c& amf_cfg_upd_ack_ies_o::value_c::operator=(const amf_cfg_upd_ack_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_tnl_assoc_setup_list:
      c.set(other.c.get<amf_tnl_assoc_setup_list_l>());
      break;
    case types::amf_tnl_assoc_failed_to_setup_list:
      c.set(other.c.get<tnl_assoc_list_l>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "amf_cfg_upd_ack_ies_o::value_c");
  }

  return *this;
}
amf_tnl_assoc_setup_list_l& amf_cfg_upd_ack_ies_o::value_c::amf_tnl_assoc_setup_list()
{
  assert_choice_type(types::amf_tnl_assoc_setup_list, type_, "Value");
  return c.get<amf_tnl_assoc_setup_list_l>();
}
tnl_assoc_list_l& amf_cfg_upd_ack_ies_o::value_c::amf_tnl_assoc_failed_to_setup_list()
{
  assert_choice_type(types::amf_tnl_assoc_failed_to_setup_list, type_, "Value");
  return c.get<tnl_assoc_list_l>();
}
crit_diagnostics_s& amf_cfg_upd_ack_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const amf_tnl_assoc_setup_list_l& amf_cfg_upd_ack_ies_o::value_c::amf_tnl_assoc_setup_list() const
{
  assert_choice_type(types::amf_tnl_assoc_setup_list, type_, "Value");
  return c.get<amf_tnl_assoc_setup_list_l>();
}
const tnl_assoc_list_l& amf_cfg_upd_ack_ies_o::value_c::amf_tnl_assoc_failed_to_setup_list() const
{
  assert_choice_type(types::amf_tnl_assoc_failed_to_setup_list, type_, "Value");
  return c.get<tnl_assoc_list_l>();
}
const crit_diagnostics_s& amf_cfg_upd_ack_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void amf_cfg_upd_ack_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_tnl_assoc_setup_list:
      j.start_array("AMF-TNLAssociationSetupList");
      for (const auto& e1 : c.get<amf_tnl_assoc_setup_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::amf_tnl_assoc_failed_to_setup_list:
      j.start_array("TNLAssociationList");
      for (const auto& e1 : c.get<tnl_assoc_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "amf_cfg_upd_ack_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE amf_cfg_upd_ack_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_tnl_assoc_setup_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<amf_tnl_assoc_setup_list_l>(), 1, 32, true));
      break;
    case types::amf_tnl_assoc_failed_to_setup_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<tnl_assoc_list_l>(), 1, 32, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "amf_cfg_upd_ack_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE amf_cfg_upd_ack_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_tnl_assoc_setup_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<amf_tnl_assoc_setup_list_l>(), bref, 1, 32, true));
      break;
    case types::amf_tnl_assoc_failed_to_setup_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<tnl_assoc_list_l>(), bref, 1, 32, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "amf_cfg_upd_ack_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* amf_cfg_upd_ack_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"AMF-TNLAssociationSetupList", "TNLAssociationList", "CriticalityDiagnostics"};
  return convert_enum_idx(names, 3, value, "amf_cfg_upd_ack_ies_o::value_c::types");
}

template struct asn1::protocol_ie_field_s<amf_cfg_upd_ack_ies_o>;

amf_cfg_upd_ack_ies_container::amf_cfg_upd_ack_ies_container() :
  amf_tnl_assoc_setup_list(5, crit_e::ignore),
  amf_tnl_assoc_failed_to_setup_list(4, crit_e::ignore),
  crit_diagnostics(19, crit_e::ignore)
{
}
SRSASN_CODE amf_cfg_upd_ack_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += amf_tnl_assoc_setup_list_present ? 1 : 0;
  nof_ies += amf_tnl_assoc_failed_to_setup_list_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  if (amf_tnl_assoc_setup_list_present) {
    HANDLE_CODE(amf_tnl_assoc_setup_list.pack(bref));
  }
  if (amf_tnl_assoc_failed_to_setup_list_present) {
    HANDLE_CODE(amf_tnl_assoc_failed_to_setup_list.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE amf_cfg_upd_ack_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 5: {
        amf_tnl_assoc_setup_list_present = true;
        amf_tnl_assoc_setup_list.id      = id;
        HANDLE_CODE(amf_tnl_assoc_setup_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_tnl_assoc_setup_list.value.unpack(bref));
        break;
      }
      case 4: {
        amf_tnl_assoc_failed_to_setup_list_present = true;
        amf_tnl_assoc_failed_to_setup_list.id      = id;
        HANDLE_CODE(amf_tnl_assoc_failed_to_setup_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_tnl_assoc_failed_to_setup_list.value.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        crit_diagnostics.id      = id;
        HANDLE_CODE(crit_diagnostics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void amf_cfg_upd_ack_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (amf_tnl_assoc_setup_list_present) {
    j.write_fieldname("");
    amf_tnl_assoc_setup_list.to_json(j);
  }
  if (amf_tnl_assoc_failed_to_setup_list_present) {
    j.write_fieldname("");
    amf_tnl_assoc_failed_to_setup_list.to_json(j);
  }
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

// TimeToWait ::= ENUMERATED
const char* time_to_wait_opts::to_string() const
{
  static const char* names[] = {"v1s", "v2s", "v5s", "v10s", "v20s", "v60s"};
  return convert_enum_idx(names, 6, value, "time_to_wait_e");
}
uint8_t time_to_wait_opts::to_number() const
{
  static const uint8_t numbers[] = {1, 2, 5, 10, 20, 60};
  return map_enum_number(numbers, 6, value, "time_to_wait_e");
}

// AMFConfigurationUpdateFailureIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t amf_cfg_upd_fail_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {15, 107, 19};
  return map_enum_number(names, 3, idx, "id");
}
bool amf_cfg_upd_fail_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {15, 107, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e amf_cfg_upd_fail_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 15:
      return crit_e::ignore;
    case 107:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
amf_cfg_upd_fail_ies_o::value_c amf_cfg_upd_fail_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 15:
      ret.set(value_c::types::cause);
      break;
    case 107:
      ret.set(value_c::types::time_to_wait);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e amf_cfg_upd_fail_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 15:
      return presence_e::mandatory;
    case 107:
      return presence_e::optional;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void amf_cfg_upd_fail_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::cause:
      c.destroy<cause_c>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void amf_cfg_upd_fail_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::cause:
      c.init<cause_c>();
      break;
    case types::time_to_wait:
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "amf_cfg_upd_fail_ies_o::value_c");
  }
}
amf_cfg_upd_fail_ies_o::value_c::value_c(const amf_cfg_upd_fail_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::time_to_wait:
      c.init(other.c.get<time_to_wait_e>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "amf_cfg_upd_fail_ies_o::value_c");
  }
}
amf_cfg_upd_fail_ies_o::value_c&
amf_cfg_upd_fail_ies_o::value_c::operator=(const amf_cfg_upd_fail_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::time_to_wait:
      c.set(other.c.get<time_to_wait_e>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "amf_cfg_upd_fail_ies_o::value_c");
  }

  return *this;
}
cause_c& amf_cfg_upd_fail_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
time_to_wait_e& amf_cfg_upd_fail_ies_o::value_c::time_to_wait()
{
  assert_choice_type(types::time_to_wait, type_, "Value");
  return c.get<time_to_wait_e>();
}
crit_diagnostics_s& amf_cfg_upd_fail_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const cause_c& amf_cfg_upd_fail_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const time_to_wait_e& amf_cfg_upd_fail_ies_o::value_c::time_to_wait() const
{
  assert_choice_type(types::time_to_wait, type_, "Value");
  return c.get<time_to_wait_e>();
}
const crit_diagnostics_s& amf_cfg_upd_fail_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void amf_cfg_upd_fail_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    case types::time_to_wait:
      j.write_str("TimeToWait", c.get<time_to_wait_e>().to_string());
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "amf_cfg_upd_fail_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE amf_cfg_upd_fail_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    case types::time_to_wait:
      HANDLE_CODE(c.get<time_to_wait_e>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "amf_cfg_upd_fail_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE amf_cfg_upd_fail_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    case types::time_to_wait:
      HANDLE_CODE(c.get<time_to_wait_e>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "amf_cfg_upd_fail_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* amf_cfg_upd_fail_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"Cause", "TimeToWait", "CriticalityDiagnostics"};
  return convert_enum_idx(names, 3, value, "amf_cfg_upd_fail_ies_o::value_c::types");
}

template struct asn1::protocol_ie_field_s<amf_cfg_upd_fail_ies_o>;

amf_cfg_upd_fail_ies_container::amf_cfg_upd_fail_ies_container() :
  cause(15, crit_e::ignore), time_to_wait(107, crit_e::ignore), crit_diagnostics(19, crit_e::ignore)
{
}
SRSASN_CODE amf_cfg_upd_fail_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 1;
  nof_ies += time_to_wait_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(cause.pack(bref));
  if (time_to_wait_present) {
    HANDLE_CODE(time_to_wait.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE amf_cfg_upd_fail_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 1;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 15: {
        nof_mandatory_ies--;
        cause.id = id;
        HANDLE_CODE(cause.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.value.unpack(bref));
        break;
      }
      case 107: {
        time_to_wait_present = true;
        time_to_wait.id      = id;
        HANDLE_CODE(time_to_wait.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(time_to_wait.value.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        crit_diagnostics.id      = id;
        HANDLE_CODE(crit_diagnostics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void amf_cfg_upd_fail_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  cause.to_json(j);
  if (time_to_wait_present) {
    j.write_fieldname("");
    time_to_wait.to_json(j);
  }
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

// TNGF-ID ::= CHOICE
void tngf_id_c::destroy_()
{
  switch (type_) {
    case types::tngf_id:
      c.destroy<fixed_bitstring<32, true, true>>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<tngf_id_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void tngf_id_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::tngf_id:
      c.init<fixed_bitstring<32, true, true>>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<tngf_id_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "tngf_id_c");
  }
}
tngf_id_c::tngf_id_c(const tngf_id_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::tngf_id:
      c.init(other.c.get<fixed_bitstring<32, true, true>>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<tngf_id_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "tngf_id_c");
  }
}
tngf_id_c& tngf_id_c::operator=(const tngf_id_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::tngf_id:
      c.set(other.c.get<fixed_bitstring<32, true, true>>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<tngf_id_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "tngf_id_c");
  }

  return *this;
}
fixed_bitstring<32, true, true>& tngf_id_c::set_tngf_id()
{
  set(types::tngf_id);
  return c.get<fixed_bitstring<32, true, true>>();
}
protocol_ie_single_container_s<tngf_id_ext_ies_o>& tngf_id_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<tngf_id_ext_ies_o>>();
}
void tngf_id_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::tngf_id:
      j.write_str("tNGF-ID", c.get<fixed_bitstring<32, true, true>>().to_string());
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<tngf_id_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "tngf_id_c");
  }
  j.end_obj();
}
SRSASN_CODE tngf_id_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::tngf_id:
      HANDLE_CODE((c.get<fixed_bitstring<32, true, true>>().pack(bref)));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<tngf_id_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "tngf_id_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE tngf_id_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::tngf_id:
      HANDLE_CODE((c.get<fixed_bitstring<32, true, true>>().unpack(bref)));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<tngf_id_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "tngf_id_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* tngf_id_c::types_opts::to_string() const
{
  static const char* names[] = {"tNGF-ID", "choice-Extensions"};
  return convert_enum_idx(names, 2, value, "tngf_id_c::types");
}

// TWIF-ID ::= CHOICE
void twif_id_c::destroy_()
{
  switch (type_) {
    case types::twif_id:
      c.destroy<fixed_bitstring<32, true, true>>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<twif_id_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void twif_id_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::twif_id:
      c.init<fixed_bitstring<32, true, true>>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<twif_id_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "twif_id_c");
  }
}
twif_id_c::twif_id_c(const twif_id_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::twif_id:
      c.init(other.c.get<fixed_bitstring<32, true, true>>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<twif_id_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "twif_id_c");
  }
}
twif_id_c& twif_id_c::operator=(const twif_id_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::twif_id:
      c.set(other.c.get<fixed_bitstring<32, true, true>>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<twif_id_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "twif_id_c");
  }

  return *this;
}
fixed_bitstring<32, true, true>& twif_id_c::set_twif_id()
{
  set(types::twif_id);
  return c.get<fixed_bitstring<32, true, true>>();
}
protocol_ie_single_container_s<twif_id_ext_ies_o>& twif_id_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<twif_id_ext_ies_o>>();
}
void twif_id_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::twif_id:
      j.write_str("tWIF-ID", c.get<fixed_bitstring<32, true, true>>().to_string());
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<twif_id_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "twif_id_c");
  }
  j.end_obj();
}
SRSASN_CODE twif_id_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::twif_id:
      HANDLE_CODE((c.get<fixed_bitstring<32, true, true>>().pack(bref)));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<twif_id_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "twif_id_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE twif_id_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::twif_id:
      HANDLE_CODE((c.get<fixed_bitstring<32, true, true>>().unpack(bref)));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<twif_id_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "twif_id_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* twif_id_c::types_opts::to_string() const
{
  static const char* names[] = {"tWIF-ID", "choice-Extensions"};
  return convert_enum_idx(names, 2, value, "twif_id_c::types");
}

// W-AGF-ID ::= CHOICE
void w_agf_id_c::destroy_()
{
  switch (type_) {
    case types::w_agf_id:
      c.destroy<fixed_bitstring<16, true, true>>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<w_agf_id_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void w_agf_id_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::w_agf_id:
      c.init<fixed_bitstring<16, true, true>>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<w_agf_id_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "w_agf_id_c");
  }
}
w_agf_id_c::w_agf_id_c(const w_agf_id_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::w_agf_id:
      c.init(other.c.get<fixed_bitstring<16, true, true>>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<w_agf_id_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "w_agf_id_c");
  }
}
w_agf_id_c& w_agf_id_c::operator=(const w_agf_id_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::w_agf_id:
      c.set(other.c.get<fixed_bitstring<16, true, true>>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<w_agf_id_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "w_agf_id_c");
  }

  return *this;
}
fixed_bitstring<16, true, true>& w_agf_id_c::set_w_agf_id()
{
  set(types::w_agf_id);
  return c.get<fixed_bitstring<16, true, true>>();
}
protocol_ie_single_container_s<w_agf_id_ext_ies_o>& w_agf_id_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<w_agf_id_ext_ies_o>>();
}
void w_agf_id_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::w_agf_id:
      j.write_str("w-AGF-ID", c.get<fixed_bitstring<16, true, true>>().to_string());
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<w_agf_id_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "w_agf_id_c");
  }
  j.end_obj();
}
SRSASN_CODE w_agf_id_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::w_agf_id:
      HANDLE_CODE((c.get<fixed_bitstring<16, true, true>>().pack(bref)));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<w_agf_id_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "w_agf_id_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE w_agf_id_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::w_agf_id:
      HANDLE_CODE((c.get<fixed_bitstring<16, true, true>>().unpack(bref)));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<w_agf_id_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "w_agf_id_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* w_agf_id_c::types_opts::to_string() const
{
  static const char* names[] = {"w-AGF-ID", "choice-Extensions"};
  return convert_enum_idx(names, 2, value, "w_agf_id_c::types");
}

// GNB-ID ::= CHOICE
void gnb_id_c::destroy_()
{
  switch (type_) {
    case types::gnb_id:
      c.destroy<bounded_bitstring<22, 32, false, true>>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<gnb_id_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void gnb_id_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::gnb_id:
      c.init<bounded_bitstring<22, 32, false, true>>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<gnb_id_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "gnb_id_c");
  }
}
gnb_id_c::gnb_id_c(const gnb_id_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::gnb_id:
      c.init(other.c.get<bounded_bitstring<22, 32, false, true>>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<gnb_id_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "gnb_id_c");
  }
}
gnb_id_c& gnb_id_c::operator=(const gnb_id_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::gnb_id:
      c.set(other.c.get<bounded_bitstring<22, 32, false, true>>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<gnb_id_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "gnb_id_c");
  }

  return *this;
}
bounded_bitstring<22, 32, false, true>& gnb_id_c::set_gnb_id()
{
  set(types::gnb_id);
  return c.get<bounded_bitstring<22, 32, false, true>>();
}
protocol_ie_single_container_s<gnb_id_ext_ies_o>& gnb_id_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<gnb_id_ext_ies_o>>();
}
void gnb_id_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::gnb_id:
      j.write_str("gNB-ID", c.get<bounded_bitstring<22, 32, false, true>>().to_string());
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<gnb_id_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "gnb_id_c");
  }
  j.end_obj();
}
SRSASN_CODE gnb_id_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::gnb_id:
      HANDLE_CODE((c.get<bounded_bitstring<22, 32, false, true>>().pack(bref)));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<gnb_id_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "gnb_id_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE gnb_id_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::gnb_id:
      HANDLE_CODE((c.get<bounded_bitstring<22, 32, false, true>>().unpack(bref)));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<gnb_id_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "gnb_id_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* gnb_id_c::types_opts::to_string() const
{
  static const char* names[] = {"gNB-ID", "choice-Extensions"};
  return convert_enum_idx(names, 2, value, "gnb_id_c::types");
}

// GlobalTNGF-ID ::= SEQUENCE
SRSASN_CODE global_tngf_id_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.pack(bref));
  HANDLE_CODE(tngf_id.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE global_tngf_id_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.unpack(bref));
  HANDLE_CODE(tngf_id.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void global_tngf_id_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("pLMNIdentity", plmn_id.to_string());
  j.write_fieldname("tNGF-ID");
  tngf_id.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// GlobalTWIF-ID ::= SEQUENCE
SRSASN_CODE global_twif_id_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.pack(bref));
  HANDLE_CODE(twif_id.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE global_twif_id_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.unpack(bref));
  HANDLE_CODE(twif_id.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void global_twif_id_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("pLMNIdentity", plmn_id.to_string());
  j.write_fieldname("tWIF-ID");
  twif_id.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// GlobalW-AGF-ID ::= SEQUENCE
SRSASN_CODE global_w_agf_id_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.pack(bref));
  HANDLE_CODE(w_agf_id.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE global_w_agf_id_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.unpack(bref));
  HANDLE_CODE(w_agf_id.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void global_w_agf_id_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("pLMNIdentity", plmn_id.to_string());
  j.write_fieldname("w-AGF-ID");
  w_agf_id.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// N3IWF-ID ::= CHOICE
void n3_iwf_id_c::destroy_()
{
  switch (type_) {
    case types::n3_iwf_id:
      c.destroy<fixed_bitstring<16, false, true>>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<n3_iwf_id_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void n3_iwf_id_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::n3_iwf_id:
      c.init<fixed_bitstring<16, false, true>>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<n3_iwf_id_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "n3_iwf_id_c");
  }
}
n3_iwf_id_c::n3_iwf_id_c(const n3_iwf_id_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::n3_iwf_id:
      c.init(other.c.get<fixed_bitstring<16, false, true>>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<n3_iwf_id_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "n3_iwf_id_c");
  }
}
n3_iwf_id_c& n3_iwf_id_c::operator=(const n3_iwf_id_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::n3_iwf_id:
      c.set(other.c.get<fixed_bitstring<16, false, true>>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<n3_iwf_id_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "n3_iwf_id_c");
  }

  return *this;
}
fixed_bitstring<16, false, true>& n3_iwf_id_c::set_n3_iwf_id()
{
  set(types::n3_iwf_id);
  return c.get<fixed_bitstring<16, false, true>>();
}
protocol_ie_single_container_s<n3_iwf_id_ext_ies_o>& n3_iwf_id_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<n3_iwf_id_ext_ies_o>>();
}
void n3_iwf_id_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::n3_iwf_id:
      j.write_str("n3IWF-ID", c.get<fixed_bitstring<16, false, true>>().to_string());
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<n3_iwf_id_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "n3_iwf_id_c");
  }
  j.end_obj();
}
SRSASN_CODE n3_iwf_id_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::n3_iwf_id:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true>>().pack(bref)));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<n3_iwf_id_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "n3_iwf_id_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE n3_iwf_id_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::n3_iwf_id:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true>>().unpack(bref)));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<n3_iwf_id_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "n3_iwf_id_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* n3_iwf_id_c::types_opts::to_string() const
{
  static const char* names[] = {"n3IWF-ID", "choice-Extensions"};
  return convert_enum_idx(names, 2, value, "n3_iwf_id_c::types");
}
uint8_t n3_iwf_id_c::types_opts::to_number() const
{
  static const uint8_t numbers[] = {3};
  return map_enum_number(numbers, 1, value, "n3_iwf_id_c::types");
}

// NgENB-ID ::= CHOICE
void ng_enb_id_c::destroy_()
{
  switch (type_) {
    case types::macro_ng_enb_id:
      c.destroy<fixed_bitstring<20, false, true>>();
      break;
    case types::short_macro_ng_enb_id:
      c.destroy<fixed_bitstring<18, false, true>>();
      break;
    case types::long_macro_ng_enb_id:
      c.destroy<fixed_bitstring<21, false, true>>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<ng_enb_id_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void ng_enb_id_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::macro_ng_enb_id:
      c.init<fixed_bitstring<20, false, true>>();
      break;
    case types::short_macro_ng_enb_id:
      c.init<fixed_bitstring<18, false, true>>();
      break;
    case types::long_macro_ng_enb_id:
      c.init<fixed_bitstring<21, false, true>>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<ng_enb_id_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ng_enb_id_c");
  }
}
ng_enb_id_c::ng_enb_id_c(const ng_enb_id_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::macro_ng_enb_id:
      c.init(other.c.get<fixed_bitstring<20, false, true>>());
      break;
    case types::short_macro_ng_enb_id:
      c.init(other.c.get<fixed_bitstring<18, false, true>>());
      break;
    case types::long_macro_ng_enb_id:
      c.init(other.c.get<fixed_bitstring<21, false, true>>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<ng_enb_id_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ng_enb_id_c");
  }
}
ng_enb_id_c& ng_enb_id_c::operator=(const ng_enb_id_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::macro_ng_enb_id:
      c.set(other.c.get<fixed_bitstring<20, false, true>>());
      break;
    case types::short_macro_ng_enb_id:
      c.set(other.c.get<fixed_bitstring<18, false, true>>());
      break;
    case types::long_macro_ng_enb_id:
      c.set(other.c.get<fixed_bitstring<21, false, true>>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<ng_enb_id_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ng_enb_id_c");
  }

  return *this;
}
fixed_bitstring<20, false, true>& ng_enb_id_c::set_macro_ng_enb_id()
{
  set(types::macro_ng_enb_id);
  return c.get<fixed_bitstring<20, false, true>>();
}
fixed_bitstring<18, false, true>& ng_enb_id_c::set_short_macro_ng_enb_id()
{
  set(types::short_macro_ng_enb_id);
  return c.get<fixed_bitstring<18, false, true>>();
}
fixed_bitstring<21, false, true>& ng_enb_id_c::set_long_macro_ng_enb_id()
{
  set(types::long_macro_ng_enb_id);
  return c.get<fixed_bitstring<21, false, true>>();
}
protocol_ie_single_container_s<ng_enb_id_ext_ies_o>& ng_enb_id_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<ng_enb_id_ext_ies_o>>();
}
void ng_enb_id_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::macro_ng_enb_id:
      j.write_str("macroNgENB-ID", c.get<fixed_bitstring<20, false, true>>().to_string());
      break;
    case types::short_macro_ng_enb_id:
      j.write_str("shortMacroNgENB-ID", c.get<fixed_bitstring<18, false, true>>().to_string());
      break;
    case types::long_macro_ng_enb_id:
      j.write_str("longMacroNgENB-ID", c.get<fixed_bitstring<21, false, true>>().to_string());
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<ng_enb_id_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ng_enb_id_c");
  }
  j.end_obj();
}
SRSASN_CODE ng_enb_id_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::macro_ng_enb_id:
      HANDLE_CODE((c.get<fixed_bitstring<20, false, true>>().pack(bref)));
      break;
    case types::short_macro_ng_enb_id:
      HANDLE_CODE((c.get<fixed_bitstring<18, false, true>>().pack(bref)));
      break;
    case types::long_macro_ng_enb_id:
      HANDLE_CODE((c.get<fixed_bitstring<21, false, true>>().pack(bref)));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<ng_enb_id_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ng_enb_id_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ng_enb_id_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::macro_ng_enb_id:
      HANDLE_CODE((c.get<fixed_bitstring<20, false, true>>().unpack(bref)));
      break;
    case types::short_macro_ng_enb_id:
      HANDLE_CODE((c.get<fixed_bitstring<18, false, true>>().unpack(bref)));
      break;
    case types::long_macro_ng_enb_id:
      HANDLE_CODE((c.get<fixed_bitstring<21, false, true>>().unpack(bref)));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<ng_enb_id_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ng_enb_id_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ng_enb_id_c::types_opts::to_string() const
{
  static const char* names[] = {"macroNgENB-ID", "shortMacroNgENB-ID", "longMacroNgENB-ID", "choice-Extensions"};
  return convert_enum_idx(names, 4, value, "ng_enb_id_c::types");
}

// GlobalGNB-ID ::= SEQUENCE
SRSASN_CODE global_gnb_id_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.pack(bref));
  HANDLE_CODE(gnb_id.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE global_gnb_id_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.unpack(bref));
  HANDLE_CODE(gnb_id.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void global_gnb_id_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("pLMNIdentity", plmn_id.to_string());
  j.write_fieldname("gNB-ID");
  gnb_id.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// GlobalN3IWF-ID ::= SEQUENCE
SRSASN_CODE global_n3_iwf_id_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.pack(bref));
  HANDLE_CODE(n3_iwf_id.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE global_n3_iwf_id_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.unpack(bref));
  HANDLE_CODE(n3_iwf_id.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void global_n3_iwf_id_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("pLMNIdentity", plmn_id.to_string());
  j.write_fieldname("n3IWF-ID");
  n3_iwf_id.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// GlobalNgENB-ID ::= SEQUENCE
SRSASN_CODE global_ng_enb_id_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.pack(bref));
  HANDLE_CODE(ng_enb_id.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE global_ng_enb_id_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.unpack(bref));
  HANDLE_CODE(ng_enb_id.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void global_ng_enb_id_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("pLMNIdentity", plmn_id.to_string());
  j.write_fieldname("ngENB-ID");
  ng_enb_id.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// GlobalRANNodeID-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t global_ran_node_id_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {240, 241, 242};
  return map_enum_number(names, 3, idx, "id");
}
bool global_ran_node_id_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {240, 241, 242};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e global_ran_node_id_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 240:
      return crit_e::reject;
    case 241:
      return crit_e::reject;
    case 242:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
global_ran_node_id_ext_ies_o::value_c global_ran_node_id_ext_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 240:
      ret.set(value_c::types::global_tngf_id);
      break;
    case 241:
      ret.set(value_c::types::global_twif_id);
      break;
    case 242:
      ret.set(value_c::types::global_w_agf_id);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e global_ran_node_id_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 240:
      return presence_e::mandatory;
    case 241:
      return presence_e::mandatory;
    case 242:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void global_ran_node_id_ext_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::global_tngf_id:
      c.destroy<global_tngf_id_s>();
      break;
    case types::global_twif_id:
      c.destroy<global_twif_id_s>();
      break;
    case types::global_w_agf_id:
      c.destroy<global_w_agf_id_s>();
      break;
    default:
      break;
  }
}
void global_ran_node_id_ext_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::global_tngf_id:
      c.init<global_tngf_id_s>();
      break;
    case types::global_twif_id:
      c.init<global_twif_id_s>();
      break;
    case types::global_w_agf_id:
      c.init<global_w_agf_id_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "global_ran_node_id_ext_ies_o::value_c");
  }
}
global_ran_node_id_ext_ies_o::value_c::value_c(const global_ran_node_id_ext_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::global_tngf_id:
      c.init(other.c.get<global_tngf_id_s>());
      break;
    case types::global_twif_id:
      c.init(other.c.get<global_twif_id_s>());
      break;
    case types::global_w_agf_id:
      c.init(other.c.get<global_w_agf_id_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "global_ran_node_id_ext_ies_o::value_c");
  }
}
global_ran_node_id_ext_ies_o::value_c&
global_ran_node_id_ext_ies_o::value_c::operator=(const global_ran_node_id_ext_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::global_tngf_id:
      c.set(other.c.get<global_tngf_id_s>());
      break;
    case types::global_twif_id:
      c.set(other.c.get<global_twif_id_s>());
      break;
    case types::global_w_agf_id:
      c.set(other.c.get<global_w_agf_id_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "global_ran_node_id_ext_ies_o::value_c");
  }

  return *this;
}
global_tngf_id_s& global_ran_node_id_ext_ies_o::value_c::global_tngf_id()
{
  assert_choice_type(types::global_tngf_id, type_, "Value");
  return c.get<global_tngf_id_s>();
}
global_twif_id_s& global_ran_node_id_ext_ies_o::value_c::global_twif_id()
{
  assert_choice_type(types::global_twif_id, type_, "Value");
  return c.get<global_twif_id_s>();
}
global_w_agf_id_s& global_ran_node_id_ext_ies_o::value_c::global_w_agf_id()
{
  assert_choice_type(types::global_w_agf_id, type_, "Value");
  return c.get<global_w_agf_id_s>();
}
const global_tngf_id_s& global_ran_node_id_ext_ies_o::value_c::global_tngf_id() const
{
  assert_choice_type(types::global_tngf_id, type_, "Value");
  return c.get<global_tngf_id_s>();
}
const global_twif_id_s& global_ran_node_id_ext_ies_o::value_c::global_twif_id() const
{
  assert_choice_type(types::global_twif_id, type_, "Value");
  return c.get<global_twif_id_s>();
}
const global_w_agf_id_s& global_ran_node_id_ext_ies_o::value_c::global_w_agf_id() const
{
  assert_choice_type(types::global_w_agf_id, type_, "Value");
  return c.get<global_w_agf_id_s>();
}
void global_ran_node_id_ext_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::global_tngf_id:
      j.write_fieldname("GlobalTNGF-ID");
      c.get<global_tngf_id_s>().to_json(j);
      break;
    case types::global_twif_id:
      j.write_fieldname("GlobalTWIF-ID");
      c.get<global_twif_id_s>().to_json(j);
      break;
    case types::global_w_agf_id:
      j.write_fieldname("GlobalW-AGF-ID");
      c.get<global_w_agf_id_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "global_ran_node_id_ext_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE global_ran_node_id_ext_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::global_tngf_id:
      HANDLE_CODE(c.get<global_tngf_id_s>().pack(bref));
      break;
    case types::global_twif_id:
      HANDLE_CODE(c.get<global_twif_id_s>().pack(bref));
      break;
    case types::global_w_agf_id:
      HANDLE_CODE(c.get<global_w_agf_id_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "global_ran_node_id_ext_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE global_ran_node_id_ext_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::global_tngf_id:
      HANDLE_CODE(c.get<global_tngf_id_s>().unpack(bref));
      break;
    case types::global_twif_id:
      HANDLE_CODE(c.get<global_twif_id_s>().unpack(bref));
      break;
    case types::global_w_agf_id:
      HANDLE_CODE(c.get<global_w_agf_id_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "global_ran_node_id_ext_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* global_ran_node_id_ext_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"GlobalTNGF-ID", "GlobalTWIF-ID", "GlobalW-AGF-ID"};
  return convert_enum_idx(names, 3, value, "global_ran_node_id_ext_ies_o::value_c::types");
}

template struct asn1::protocol_ie_single_container_s<global_ran_node_id_ext_ies_o>;

// GlobalRANNodeID ::= CHOICE
void global_ran_node_id_c::destroy_()
{
  switch (type_) {
    case types::global_gnb_id:
      c.destroy<global_gnb_id_s>();
      break;
    case types::global_ng_enb_id:
      c.destroy<global_ng_enb_id_s>();
      break;
    case types::global_n3_iwf_id:
      c.destroy<global_n3_iwf_id_s>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<global_ran_node_id_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void global_ran_node_id_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::global_gnb_id:
      c.init<global_gnb_id_s>();
      break;
    case types::global_ng_enb_id:
      c.init<global_ng_enb_id_s>();
      break;
    case types::global_n3_iwf_id:
      c.init<global_n3_iwf_id_s>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<global_ran_node_id_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "global_ran_node_id_c");
  }
}
global_ran_node_id_c::global_ran_node_id_c(const global_ran_node_id_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::global_gnb_id:
      c.init(other.c.get<global_gnb_id_s>());
      break;
    case types::global_ng_enb_id:
      c.init(other.c.get<global_ng_enb_id_s>());
      break;
    case types::global_n3_iwf_id:
      c.init(other.c.get<global_n3_iwf_id_s>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<global_ran_node_id_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "global_ran_node_id_c");
  }
}
global_ran_node_id_c& global_ran_node_id_c::operator=(const global_ran_node_id_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::global_gnb_id:
      c.set(other.c.get<global_gnb_id_s>());
      break;
    case types::global_ng_enb_id:
      c.set(other.c.get<global_ng_enb_id_s>());
      break;
    case types::global_n3_iwf_id:
      c.set(other.c.get<global_n3_iwf_id_s>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<global_ran_node_id_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "global_ran_node_id_c");
  }

  return *this;
}
global_gnb_id_s& global_ran_node_id_c::set_global_gnb_id()
{
  set(types::global_gnb_id);
  return c.get<global_gnb_id_s>();
}
global_ng_enb_id_s& global_ran_node_id_c::set_global_ng_enb_id()
{
  set(types::global_ng_enb_id);
  return c.get<global_ng_enb_id_s>();
}
global_n3_iwf_id_s& global_ran_node_id_c::set_global_n3_iwf_id()
{
  set(types::global_n3_iwf_id);
  return c.get<global_n3_iwf_id_s>();
}
protocol_ie_single_container_s<global_ran_node_id_ext_ies_o>& global_ran_node_id_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<global_ran_node_id_ext_ies_o>>();
}
void global_ran_node_id_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::global_gnb_id:
      j.write_fieldname("globalGNB-ID");
      c.get<global_gnb_id_s>().to_json(j);
      break;
    case types::global_ng_enb_id:
      j.write_fieldname("globalNgENB-ID");
      c.get<global_ng_enb_id_s>().to_json(j);
      break;
    case types::global_n3_iwf_id:
      j.write_fieldname("globalN3IWF-ID");
      c.get<global_n3_iwf_id_s>().to_json(j);
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<global_ran_node_id_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "global_ran_node_id_c");
  }
  j.end_obj();
}
SRSASN_CODE global_ran_node_id_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::global_gnb_id:
      HANDLE_CODE(c.get<global_gnb_id_s>().pack(bref));
      break;
    case types::global_ng_enb_id:
      HANDLE_CODE(c.get<global_ng_enb_id_s>().pack(bref));
      break;
    case types::global_n3_iwf_id:
      HANDLE_CODE(c.get<global_n3_iwf_id_s>().pack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<global_ran_node_id_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "global_ran_node_id_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE global_ran_node_id_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::global_gnb_id:
      HANDLE_CODE(c.get<global_gnb_id_s>().unpack(bref));
      break;
    case types::global_ng_enb_id:
      HANDLE_CODE(c.get<global_ng_enb_id_s>().unpack(bref));
      break;
    case types::global_n3_iwf_id:
      HANDLE_CODE(c.get<global_n3_iwf_id_s>().unpack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<global_ran_node_id_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "global_ran_node_id_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* global_ran_node_id_c::types_opts::to_string() const
{
  static const char* names[] = {"globalGNB-ID", "globalNgENB-ID", "globalN3IWF-ID", "choice-Extensions"};
  return convert_enum_idx(names, 4, value, "global_ran_node_id_c::types");
}
uint8_t global_ran_node_id_c::types_opts::to_number() const
{
  if (value == global_n3_iwf_id) {
    return 3;
  }
  invalid_enum_number(value, "global_ran_node_id_c::types");
  return 0;
}

// TAI ::= SEQUENCE
SRSASN_CODE tai_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.pack(bref));
  HANDLE_CODE(tac.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE tai_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.unpack(bref));
  HANDLE_CODE(tac.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void tai_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("pLMNIdentity", plmn_id.to_string());
  j.write_str("tAC", tac.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// AMFPagingTarget ::= CHOICE
void amf_paging_target_c::destroy_()
{
  switch (type_) {
    case types::global_ran_node_id:
      c.destroy<global_ran_node_id_c>();
      break;
    case types::tai:
      c.destroy<tai_s>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<amf_paging_target_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void amf_paging_target_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::global_ran_node_id:
      c.init<global_ran_node_id_c>();
      break;
    case types::tai:
      c.init<tai_s>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<amf_paging_target_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "amf_paging_target_c");
  }
}
amf_paging_target_c::amf_paging_target_c(const amf_paging_target_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::global_ran_node_id:
      c.init(other.c.get<global_ran_node_id_c>());
      break;
    case types::tai:
      c.init(other.c.get<tai_s>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<amf_paging_target_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "amf_paging_target_c");
  }
}
amf_paging_target_c& amf_paging_target_c::operator=(const amf_paging_target_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::global_ran_node_id:
      c.set(other.c.get<global_ran_node_id_c>());
      break;
    case types::tai:
      c.set(other.c.get<tai_s>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<amf_paging_target_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "amf_paging_target_c");
  }

  return *this;
}
global_ran_node_id_c& amf_paging_target_c::set_global_ran_node_id()
{
  set(types::global_ran_node_id);
  return c.get<global_ran_node_id_c>();
}
tai_s& amf_paging_target_c::set_tai()
{
  set(types::tai);
  return c.get<tai_s>();
}
protocol_ie_single_container_s<amf_paging_target_ext_ies_o>& amf_paging_target_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<amf_paging_target_ext_ies_o>>();
}
void amf_paging_target_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::global_ran_node_id:
      j.write_fieldname("globalRANNodeID");
      c.get<global_ran_node_id_c>().to_json(j);
      break;
    case types::tai:
      j.write_fieldname("tAI");
      c.get<tai_s>().to_json(j);
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<amf_paging_target_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "amf_paging_target_c");
  }
  j.end_obj();
}
SRSASN_CODE amf_paging_target_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::global_ran_node_id:
      HANDLE_CODE(c.get<global_ran_node_id_c>().pack(bref));
      break;
    case types::tai:
      HANDLE_CODE(c.get<tai_s>().pack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<amf_paging_target_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "amf_paging_target_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE amf_paging_target_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::global_ran_node_id:
      HANDLE_CODE(c.get<global_ran_node_id_c>().unpack(bref));
      break;
    case types::tai:
      HANDLE_CODE(c.get<tai_s>().unpack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<amf_paging_target_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "amf_paging_target_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* amf_paging_target_c::types_opts::to_string() const
{
  static const char* names[] = {"globalRANNodeID", "tAI", "choice-Extensions"};
  return convert_enum_idx(names, 3, value, "amf_paging_target_c::types");
}

// TimerApproachForGUAMIRemoval ::= ENUMERATED
const char* timer_approach_for_guami_removal_opts::to_string() const
{
  static const char* names[] = {"apply-timer"};
  return convert_enum_idx(names, 1, value, "timer_approach_for_guami_removal_e");
}

// UnavailableGUAMIItem ::= SEQUENCE
SRSASN_CODE unavailable_guami_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(timer_approach_for_guami_removal_present, 1));
  HANDLE_CODE(bref.pack(backup_amf_name_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(guami.pack(bref));
  if (timer_approach_for_guami_removal_present) {
    HANDLE_CODE(timer_approach_for_guami_removal.pack(bref));
  }
  if (backup_amf_name_present) {
    HANDLE_CODE(backup_amf_name.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE unavailable_guami_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(timer_approach_for_guami_removal_present, 1));
  HANDLE_CODE(bref.unpack(backup_amf_name_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(guami.unpack(bref));
  if (timer_approach_for_guami_removal_present) {
    HANDLE_CODE(timer_approach_for_guami_removal.unpack(bref));
  }
  if (backup_amf_name_present) {
    HANDLE_CODE(backup_amf_name.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void unavailable_guami_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("gUAMI");
  guami.to_json(j);
  if (timer_approach_for_guami_removal_present) {
    j.write_str("timerApproachForGUAMIRemoval", "apply-timer");
  }
  if (backup_amf_name_present) {
    j.write_str("backupAMFName", backup_amf_name.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// AMFStatusIndicationIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t amf_status_ind_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {120};
  return map_enum_number(names, 1, idx, "id");
}
bool amf_status_ind_ies_o::is_id_valid(const uint32_t& id)
{
  return 120 == id;
}
crit_e amf_status_ind_ies_o::get_crit(const uint32_t& id)
{
  if (id == 120) {
    return crit_e::reject;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
amf_status_ind_ies_o::value_c amf_status_ind_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  if (id != 120) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e amf_status_ind_ies_o::get_presence(const uint32_t& id)
{
  if (id == 120) {
    return presence_e::mandatory;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Value ::= OPEN TYPE
void amf_status_ind_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("UnavailableGUAMIList");
  for (const auto& e1 : c) {
    e1.to_json(j);
  }
  j.end_array();
  j.end_obj();
}
SRSASN_CODE amf_status_ind_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(pack_dyn_seq_of(bref, c, 1, 256, true));
  return SRSASN_SUCCESS;
}
SRSASN_CODE amf_status_ind_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(unpack_dyn_seq_of(c, bref, 1, 256, true));
  return SRSASN_SUCCESS;
}

const char* amf_status_ind_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"UnavailableGUAMIList"};
  return convert_enum_idx(names, 1, value, "amf_status_ind_ies_o::value_c::types");
}

// EUTRA-CGI ::= SEQUENCE
SRSASN_CODE eutra_cgi_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.pack(bref));
  HANDLE_CODE(eutra_cell_id.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE eutra_cgi_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.unpack(bref));
  HANDLE_CODE(eutra_cell_id.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void eutra_cgi_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("pLMNIdentity", plmn_id.to_string());
  j.write_str("eUTRACellIdentity", eutra_cell_id.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// NR-CGI ::= SEQUENCE
SRSASN_CODE nr_cgi_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.pack(bref));
  HANDLE_CODE(nr_cell_id.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE nr_cgi_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.unpack(bref));
  HANDLE_CODE(nr_cell_id.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void nr_cgi_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("pLMNIdentity", plmn_id.to_string());
  j.write_str("nRCellIdentity", nr_cell_id.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// NGRAN-CGI ::= CHOICE
void ngran_cgi_c::destroy_()
{
  switch (type_) {
    case types::nr_cgi:
      c.destroy<nr_cgi_s>();
      break;
    case types::eutra_cgi:
      c.destroy<eutra_cgi_s>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<ngran_cgi_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void ngran_cgi_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::nr_cgi:
      c.init<nr_cgi_s>();
      break;
    case types::eutra_cgi:
      c.init<eutra_cgi_s>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<ngran_cgi_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ngran_cgi_c");
  }
}
ngran_cgi_c::ngran_cgi_c(const ngran_cgi_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::nr_cgi:
      c.init(other.c.get<nr_cgi_s>());
      break;
    case types::eutra_cgi:
      c.init(other.c.get<eutra_cgi_s>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<ngran_cgi_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ngran_cgi_c");
  }
}
ngran_cgi_c& ngran_cgi_c::operator=(const ngran_cgi_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::nr_cgi:
      c.set(other.c.get<nr_cgi_s>());
      break;
    case types::eutra_cgi:
      c.set(other.c.get<eutra_cgi_s>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<ngran_cgi_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ngran_cgi_c");
  }

  return *this;
}
nr_cgi_s& ngran_cgi_c::set_nr_cgi()
{
  set(types::nr_cgi);
  return c.get<nr_cgi_s>();
}
eutra_cgi_s& ngran_cgi_c::set_eutra_cgi()
{
  set(types::eutra_cgi);
  return c.get<eutra_cgi_s>();
}
protocol_ie_single_container_s<ngran_cgi_ext_ies_o>& ngran_cgi_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<ngran_cgi_ext_ies_o>>();
}
void ngran_cgi_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::nr_cgi:
      j.write_fieldname("nR-CGI");
      c.get<nr_cgi_s>().to_json(j);
      break;
    case types::eutra_cgi:
      j.write_fieldname("eUTRA-CGI");
      c.get<eutra_cgi_s>().to_json(j);
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<ngran_cgi_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ngran_cgi_c");
  }
  j.end_obj();
}
SRSASN_CODE ngran_cgi_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::nr_cgi:
      HANDLE_CODE(c.get<nr_cgi_s>().pack(bref));
      break;
    case types::eutra_cgi:
      HANDLE_CODE(c.get<eutra_cgi_s>().pack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<ngran_cgi_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ngran_cgi_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ngran_cgi_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::nr_cgi:
      HANDLE_CODE(c.get<nr_cgi_s>().unpack(bref));
      break;
    case types::eutra_cgi:
      HANDLE_CODE(c.get<eutra_cgi_s>().unpack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<ngran_cgi_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ngran_cgi_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ngran_cgi_c::types_opts::to_string() const
{
  static const char* names[] = {"nR-CGI", "eUTRA-CGI", "choice-Extensions"};
  return convert_enum_idx(names, 3, value, "ngran_cgi_c::types");
}

// DataForwardingAccepted ::= ENUMERATED
const char* data_forwarding_accepted_opts::to_string() const
{
  static const char* names[] = {"data-forwarding-accepted"};
  return convert_enum_idx(names, 1, value, "data_forwarding_accepted_e");
}

// GTPTunnel ::= SEQUENCE
SRSASN_CODE gtp_tunnel_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(transport_layer_address.pack(bref));
  HANDLE_CODE(gtp_teid.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE gtp_tunnel_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(transport_layer_address.unpack(bref));
  HANDLE_CODE(gtp_teid.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void gtp_tunnel_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("transportLayerAddress", transport_layer_address.to_string());
  j.write_str("gTP-TEID", gtp_teid.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// QosFlowItemWithDataForwarding-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t qos_flow_item_with_data_forwarding_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {221};
  return map_enum_number(names, 1, idx, "id");
}
bool qos_flow_item_with_data_forwarding_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 221 == id;
}
crit_e qos_flow_item_with_data_forwarding_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 221) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
qos_flow_item_with_data_forwarding_ext_ies_o::ext_c
qos_flow_item_with_data_forwarding_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 221) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e qos_flow_item_with_data_forwarding_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 221) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void qos_flow_item_with_data_forwarding_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("INTEGER (1..8,...)", c);
  j.end_obj();
}
SRSASN_CODE qos_flow_item_with_data_forwarding_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(pack_integer(bref, c, (uint8_t)1u, (uint8_t)8u, true, true));
  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_flow_item_with_data_forwarding_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(unpack_integer(c, bref, (uint8_t)1u, (uint8_t)8u, true, true));
  return SRSASN_SUCCESS;
}

const char* qos_flow_item_with_data_forwarding_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (1..8,...)"};
  return convert_enum_idx(names, 1, value, "qos_flow_item_with_data_forwarding_ext_ies_o::ext_c::types");
}
uint8_t qos_flow_item_with_data_forwarding_ext_ies_o::ext_c::types_opts::to_number() const
{
  static const uint8_t numbers[] = {1};
  return map_enum_number(numbers, 1, value, "qos_flow_item_with_data_forwarding_ext_ies_o::ext_c::types");
}

// QosFlowItemWithDataForwarding ::= SEQUENCE
SRSASN_CODE qos_flow_item_with_data_forwarding_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(data_forwarding_accepted_present, 1));
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(pack_integer(bref, qos_flow_id, (uint8_t)0u, (uint8_t)63u, true, true));
  if (data_forwarding_accepted_present) {
    HANDLE_CODE(data_forwarding_accepted.pack(bref));
  }
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_flow_item_with_data_forwarding_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(data_forwarding_accepted_present, 1));
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(qos_flow_id, bref, (uint8_t)0u, (uint8_t)63u, true, true));
  if (data_forwarding_accepted_present) {
    HANDLE_CODE(data_forwarding_accepted.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void qos_flow_item_with_data_forwarding_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("qosFlowIdentifier", qos_flow_id);
  if (data_forwarding_accepted_present) {
    j.write_str("dataForwardingAccepted", "data-forwarding-accepted");
  }
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// UPTransportLayerInformation ::= CHOICE
void up_transport_layer_info_c::destroy_()
{
  switch (type_) {
    case types::gtp_tunnel:
      c.destroy<gtp_tunnel_s>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<up_transport_layer_info_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void up_transport_layer_info_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::gtp_tunnel:
      c.init<gtp_tunnel_s>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<up_transport_layer_info_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "up_transport_layer_info_c");
  }
}
up_transport_layer_info_c::up_transport_layer_info_c(const up_transport_layer_info_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::gtp_tunnel:
      c.init(other.c.get<gtp_tunnel_s>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<up_transport_layer_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "up_transport_layer_info_c");
  }
}
up_transport_layer_info_c& up_transport_layer_info_c::operator=(const up_transport_layer_info_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::gtp_tunnel:
      c.set(other.c.get<gtp_tunnel_s>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<up_transport_layer_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "up_transport_layer_info_c");
  }

  return *this;
}
gtp_tunnel_s& up_transport_layer_info_c::set_gtp_tunnel()
{
  set(types::gtp_tunnel);
  return c.get<gtp_tunnel_s>();
}
protocol_ie_single_container_s<up_transport_layer_info_ext_ies_o>& up_transport_layer_info_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<up_transport_layer_info_ext_ies_o>>();
}
void up_transport_layer_info_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::gtp_tunnel:
      j.write_fieldname("gTPTunnel");
      c.get<gtp_tunnel_s>().to_json(j);
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<up_transport_layer_info_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "up_transport_layer_info_c");
  }
  j.end_obj();
}
SRSASN_CODE up_transport_layer_info_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::gtp_tunnel:
      HANDLE_CODE(c.get<gtp_tunnel_s>().pack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<up_transport_layer_info_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "up_transport_layer_info_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE up_transport_layer_info_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::gtp_tunnel:
      HANDLE_CODE(c.get<gtp_tunnel_s>().unpack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<up_transport_layer_info_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "up_transport_layer_info_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* up_transport_layer_info_c::types_opts::to_string() const
{
  static const char* names[] = {"gTPTunnel", "choice-Extensions"};
  return convert_enum_idx(names, 2, value, "up_transport_layer_info_c::types");
}

// AdditionalDLUPTNLInformationForHOItem-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t add_dl_up_tnl_info_for_ho_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {183};
  return map_enum_number(names, 1, idx, "id");
}
bool add_dl_up_tnl_info_for_ho_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 183 == id;
}
crit_e add_dl_up_tnl_info_for_ho_item_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 183) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
add_dl_up_tnl_info_for_ho_item_ext_ies_o::ext_c add_dl_up_tnl_info_for_ho_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 183) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e add_dl_up_tnl_info_for_ho_item_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 183) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void add_dl_up_tnl_info_for_ho_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("UPTransportLayerInformation");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE add_dl_up_tnl_info_for_ho_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE add_dl_up_tnl_info_for_ho_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* add_dl_up_tnl_info_for_ho_item_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"UPTransportLayerInformation"};
  return convert_enum_idx(names, 1, value, "add_dl_up_tnl_info_for_ho_item_ext_ies_o::ext_c::types");
}

// AdditionalDLUPTNLInformationForHOItem ::= SEQUENCE
SRSASN_CODE add_dl_up_tnl_info_for_ho_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(add_dl_forwarding_up_tnl_info_present, 1));
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(add_dl_ngu_up_tnl_info.pack(bref));
  HANDLE_CODE(pack_dyn_seq_of(bref, add_qos_flow_setup_resp_list, 1, 64, true));
  if (add_dl_forwarding_up_tnl_info_present) {
    HANDLE_CODE(add_dl_forwarding_up_tnl_info.pack(bref));
  }
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE add_dl_up_tnl_info_for_ho_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(add_dl_forwarding_up_tnl_info_present, 1));
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(add_dl_ngu_up_tnl_info.unpack(bref));
  HANDLE_CODE(unpack_dyn_seq_of(add_qos_flow_setup_resp_list, bref, 1, 64, true));
  if (add_dl_forwarding_up_tnl_info_present) {
    HANDLE_CODE(add_dl_forwarding_up_tnl_info.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void add_dl_up_tnl_info_for_ho_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("additionalDL-NGU-UP-TNLInformation");
  add_dl_ngu_up_tnl_info.to_json(j);
  j.start_array("additionalQosFlowSetupResponseList");
  for (const auto& e1 : add_qos_flow_setup_resp_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (add_dl_forwarding_up_tnl_info_present) {
    j.write_fieldname("additionalDLForwardingUPTNLInformation");
    add_dl_forwarding_up_tnl_info.to_json(j);
  }
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// Pre-emptionCapability ::= ENUMERATED
const char* pre_emption_cap_opts::to_string() const
{
  static const char* names[] = {"shall-not-trigger-pre-emption", "may-trigger-pre-emption"};
  return convert_enum_idx(names, 2, value, "pre_emption_cap_e");
}

// Pre-emptionVulnerability ::= ENUMERATED
const char* pre_emption_vulnerability_opts::to_string() const
{
  static const char* names[] = {"not-pre-emptable", "pre-emptable"};
  return convert_enum_idx(names, 2, value, "pre_emption_vulnerability_e");
}

// AllocationAndRetentionPriority ::= SEQUENCE
SRSASN_CODE alloc_and_retention_prio_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, prio_level_arp, (uint8_t)1u, (uint8_t)15u, false, true));
  HANDLE_CODE(pre_emption_cap.pack(bref));
  HANDLE_CODE(pre_emption_vulnerability.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE alloc_and_retention_prio_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(prio_level_arp, bref, (uint8_t)1u, (uint8_t)15u, false, true));
  HANDLE_CODE(pre_emption_cap.unpack(bref));
  HANDLE_CODE(pre_emption_vulnerability.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void alloc_and_retention_prio_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("priorityLevelARP", prio_level_arp);
  j.write_str("pre-emptionCapability", pre_emption_cap.to_string());
  j.write_str("pre-emptionVulnerability", pre_emption_vulnerability.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// Allowed-PNI-NPN-Item ::= SEQUENCE
SRSASN_CODE allowed_pni_npn_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.pack(bref));
  HANDLE_CODE(pni_npn_restricted.pack(bref));
  HANDLE_CODE(pack_dyn_seq_of(bref, allowed_cag_list_per_plmn, 1, 256, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE allowed_pni_npn_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.unpack(bref));
  HANDLE_CODE(pni_npn_restricted.unpack(bref));
  HANDLE_CODE(unpack_dyn_seq_of(allowed_cag_list_per_plmn, bref, 1, 256, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void allowed_pni_npn_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("pLMNIdentity", plmn_id.to_string());
  j.write_str("pNI-NPN-restricted", pni_npn_restricted.to_string());
  j.start_array("allowed-CAG-List-per-PLMN");
  for (const auto& e1 : allowed_cag_list_per_plmn) {
    j.write_str(e1.to_string());
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* allowed_pni_npn_item_s::pni_npn_restricted_opts::to_string() const
{
  static const char* names[] = {"restricted", "not-restricted"};
  return convert_enum_idx(names, 2, value, "allowed_pni_npn_item_s::pni_npn_restricted_e_");
}

// PacketErrorRate ::= SEQUENCE
SRSASN_CODE packet_error_rate_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, per_scalar, (uint8_t)0u, (uint8_t)9u, true, true));
  HANDLE_CODE(pack_integer(bref, per_exponent, (uint8_t)0u, (uint8_t)9u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE packet_error_rate_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(per_scalar, bref, (uint8_t)0u, (uint8_t)9u, true, true));
  HANDLE_CODE(unpack_integer(per_exponent, bref, (uint8_t)0u, (uint8_t)9u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void packet_error_rate_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pERScalar", per_scalar);
  j.write_int("pERExponent", per_exponent);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// AlternativeQoSParaSetItem ::= SEQUENCE
SRSASN_CODE alt_qos_para_set_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(guaranteed_flow_bit_rate_dl_present, 1));
  HANDLE_CODE(bref.pack(guaranteed_flow_bit_rate_ul_present, 1));
  HANDLE_CODE(bref.pack(packet_delay_budget_present, 1));
  HANDLE_CODE(bref.pack(packet_error_rate_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, alt_qos_para_set_idx, (uint8_t)1u, (uint8_t)8u, true, true));
  if (guaranteed_flow_bit_rate_dl_present) {
    HANDLE_CODE(pack_integer(bref, guaranteed_flow_bit_rate_dl, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  }
  if (guaranteed_flow_bit_rate_ul_present) {
    HANDLE_CODE(pack_integer(bref, guaranteed_flow_bit_rate_ul, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  }
  if (packet_delay_budget_present) {
    HANDLE_CODE(pack_integer(bref, packet_delay_budget, (uint16_t)0u, (uint16_t)1023u, true, true));
  }
  if (packet_error_rate_present) {
    HANDLE_CODE(packet_error_rate.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE alt_qos_para_set_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(guaranteed_flow_bit_rate_dl_present, 1));
  HANDLE_CODE(bref.unpack(guaranteed_flow_bit_rate_ul_present, 1));
  HANDLE_CODE(bref.unpack(packet_delay_budget_present, 1));
  HANDLE_CODE(bref.unpack(packet_error_rate_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(alt_qos_para_set_idx, bref, (uint8_t)1u, (uint8_t)8u, true, true));
  if (guaranteed_flow_bit_rate_dl_present) {
    HANDLE_CODE(unpack_integer(guaranteed_flow_bit_rate_dl, bref, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  }
  if (guaranteed_flow_bit_rate_ul_present) {
    HANDLE_CODE(unpack_integer(guaranteed_flow_bit_rate_ul, bref, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  }
  if (packet_delay_budget_present) {
    HANDLE_CODE(unpack_integer(packet_delay_budget, bref, (uint16_t)0u, (uint16_t)1023u, true, true));
  }
  if (packet_error_rate_present) {
    HANDLE_CODE(packet_error_rate.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void alt_qos_para_set_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("alternativeQoSParaSetIndex", alt_qos_para_set_idx);
  if (guaranteed_flow_bit_rate_dl_present) {
    j.write_int("guaranteedFlowBitRateDL", guaranteed_flow_bit_rate_dl);
  }
  if (guaranteed_flow_bit_rate_ul_present) {
    j.write_int("guaranteedFlowBitRateUL", guaranteed_flow_bit_rate_ul);
  }
  if (packet_delay_budget_present) {
    j.write_int("packetDelayBudget", packet_delay_budget);
  }
  if (packet_error_rate_present) {
    j.write_fieldname("packetErrorRate");
    packet_error_rate.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// AreaOfInterestCellItem ::= SEQUENCE
SRSASN_CODE area_of_interest_cell_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(ngran_cgi.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE area_of_interest_cell_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(ngran_cgi.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void area_of_interest_cell_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("nGRAN-CGI");
  ngran_cgi.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// AreaOfInterestRANNodeItem ::= SEQUENCE
SRSASN_CODE area_of_interest_ran_node_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(global_ran_node_id.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE area_of_interest_ran_node_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(global_ran_node_id.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void area_of_interest_ran_node_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("globalRANNodeID");
  global_ran_node_id.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// AreaOfInterestTAIItem ::= SEQUENCE
SRSASN_CODE area_of_interest_tai_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(tai.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE area_of_interest_tai_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(tai.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void area_of_interest_tai_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("tAI");
  tai.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// AreaOfInterest ::= SEQUENCE
SRSASN_CODE area_of_interest_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(area_of_interest_tai_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(area_of_interest_cell_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(area_of_interest_ran_node_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (area_of_interest_tai_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, area_of_interest_tai_list, 1, 16, true));
  }
  if (area_of_interest_cell_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, area_of_interest_cell_list, 1, 256, true));
  }
  if (area_of_interest_ran_node_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, area_of_interest_ran_node_list, 1, 64, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE area_of_interest_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool area_of_interest_tai_list_present;
  HANDLE_CODE(bref.unpack(area_of_interest_tai_list_present, 1));
  bool area_of_interest_cell_list_present;
  HANDLE_CODE(bref.unpack(area_of_interest_cell_list_present, 1));
  bool area_of_interest_ran_node_list_present;
  HANDLE_CODE(bref.unpack(area_of_interest_ran_node_list_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (area_of_interest_tai_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(area_of_interest_tai_list, bref, 1, 16, true));
  }
  if (area_of_interest_cell_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(area_of_interest_cell_list, bref, 1, 256, true));
  }
  if (area_of_interest_ran_node_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(area_of_interest_ran_node_list, bref, 1, 64, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void area_of_interest_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (area_of_interest_tai_list.size() > 0) {
    j.start_array("areaOfInterestTAIList");
    for (const auto& e1 : area_of_interest_tai_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (area_of_interest_cell_list.size() > 0) {
    j.start_array("areaOfInterestCellList");
    for (const auto& e1 : area_of_interest_cell_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (area_of_interest_ran_node_list.size() > 0) {
    j.start_array("areaOfInterestRANNodeList");
    for (const auto& e1 : area_of_interest_ran_node_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// AreaOfInterestItem ::= SEQUENCE
SRSASN_CODE area_of_interest_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(area_of_interest.pack(bref));
  HANDLE_CODE(pack_integer(bref, location_report_ref_id, (uint8_t)1u, (uint8_t)64u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE area_of_interest_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(area_of_interest.unpack(bref));
  HANDLE_CODE(unpack_integer(location_report_ref_id, bref, (uint8_t)1u, (uint8_t)64u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void area_of_interest_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("areaOfInterest");
  area_of_interest.to_json(j);
  j.write_int("locationReportingReferenceID", location_report_ref_id);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CellBasedMDT-EUTRA ::= SEQUENCE
SRSASN_CODE cell_based_mdt_eutra_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, cell_id_listfor_mdt, 1, 32, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE cell_based_mdt_eutra_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(cell_id_listfor_mdt, bref, 1, 32, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void cell_based_mdt_eutra_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("cellIdListforMDT");
  for (const auto& e1 : cell_id_listfor_mdt) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TABasedMDT ::= SEQUENCE
SRSASN_CODE ta_based_mdt_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, ta_listfor_mdt, 1, 8, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ta_based_mdt_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(ta_listfor_mdt, bref, 1, 8, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ta_based_mdt_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("tAListforMDT");
  for (const auto& e1 : ta_listfor_mdt) {
    j.write_str(e1.to_string());
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TAIBasedMDT ::= SEQUENCE
SRSASN_CODE tai_based_mdt_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, tai_listfor_mdt, 1, 8, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE tai_based_mdt_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(tai_listfor_mdt, bref, 1, 8, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void tai_based_mdt_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("tAIListforMDT");
  for (const auto& e1 : tai_listfor_mdt) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// AreaScopeOfMDT-EUTRA ::= CHOICE
void area_scope_of_mdt_eutra_c::destroy_()
{
  switch (type_) {
    case types::cell_based:
      c.destroy<cell_based_mdt_eutra_s>();
      break;
    case types::ta_based:
      c.destroy<ta_based_mdt_s>();
      break;
    case types::tai_based:
      c.destroy<tai_based_mdt_s>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<area_scope_of_mdt_eutra_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void area_scope_of_mdt_eutra_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::cell_based:
      c.init<cell_based_mdt_eutra_s>();
      break;
    case types::ta_based:
      c.init<ta_based_mdt_s>();
      break;
    case types::plmn_wide:
      break;
    case types::tai_based:
      c.init<tai_based_mdt_s>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<area_scope_of_mdt_eutra_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "area_scope_of_mdt_eutra_c");
  }
}
area_scope_of_mdt_eutra_c::area_scope_of_mdt_eutra_c(const area_scope_of_mdt_eutra_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::cell_based:
      c.init(other.c.get<cell_based_mdt_eutra_s>());
      break;
    case types::ta_based:
      c.init(other.c.get<ta_based_mdt_s>());
      break;
    case types::plmn_wide:
      break;
    case types::tai_based:
      c.init(other.c.get<tai_based_mdt_s>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<area_scope_of_mdt_eutra_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "area_scope_of_mdt_eutra_c");
  }
}
area_scope_of_mdt_eutra_c& area_scope_of_mdt_eutra_c::operator=(const area_scope_of_mdt_eutra_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::cell_based:
      c.set(other.c.get<cell_based_mdt_eutra_s>());
      break;
    case types::ta_based:
      c.set(other.c.get<ta_based_mdt_s>());
      break;
    case types::plmn_wide:
      break;
    case types::tai_based:
      c.set(other.c.get<tai_based_mdt_s>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<area_scope_of_mdt_eutra_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "area_scope_of_mdt_eutra_c");
  }

  return *this;
}
cell_based_mdt_eutra_s& area_scope_of_mdt_eutra_c::set_cell_based()
{
  set(types::cell_based);
  return c.get<cell_based_mdt_eutra_s>();
}
ta_based_mdt_s& area_scope_of_mdt_eutra_c::set_ta_based()
{
  set(types::ta_based);
  return c.get<ta_based_mdt_s>();
}
void area_scope_of_mdt_eutra_c::set_plmn_wide()
{
  set(types::plmn_wide);
}
tai_based_mdt_s& area_scope_of_mdt_eutra_c::set_tai_based()
{
  set(types::tai_based);
  return c.get<tai_based_mdt_s>();
}
protocol_ie_single_container_s<area_scope_of_mdt_eutra_ext_ies_o>& area_scope_of_mdt_eutra_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<area_scope_of_mdt_eutra_ext_ies_o>>();
}
void area_scope_of_mdt_eutra_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::cell_based:
      j.write_fieldname("cellBased");
      c.get<cell_based_mdt_eutra_s>().to_json(j);
      break;
    case types::ta_based:
      j.write_fieldname("tABased");
      c.get<ta_based_mdt_s>().to_json(j);
      break;
    case types::plmn_wide:
      break;
    case types::tai_based:
      j.write_fieldname("tAIBased");
      c.get<tai_based_mdt_s>().to_json(j);
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<area_scope_of_mdt_eutra_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "area_scope_of_mdt_eutra_c");
  }
  j.end_obj();
}
SRSASN_CODE area_scope_of_mdt_eutra_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::cell_based:
      HANDLE_CODE(c.get<cell_based_mdt_eutra_s>().pack(bref));
      break;
    case types::ta_based:
      HANDLE_CODE(c.get<ta_based_mdt_s>().pack(bref));
      break;
    case types::plmn_wide:
      break;
    case types::tai_based:
      HANDLE_CODE(c.get<tai_based_mdt_s>().pack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<area_scope_of_mdt_eutra_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "area_scope_of_mdt_eutra_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE area_scope_of_mdt_eutra_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::cell_based:
      HANDLE_CODE(c.get<cell_based_mdt_eutra_s>().unpack(bref));
      break;
    case types::ta_based:
      HANDLE_CODE(c.get<ta_based_mdt_s>().unpack(bref));
      break;
    case types::plmn_wide:
      break;
    case types::tai_based:
      HANDLE_CODE(c.get<tai_based_mdt_s>().unpack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<area_scope_of_mdt_eutra_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "area_scope_of_mdt_eutra_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* area_scope_of_mdt_eutra_c::types_opts::to_string() const
{
  static const char* names[] = {"cellBased", "tABased", "pLMNWide", "tAIBased", "choice-Extensions"};
  return convert_enum_idx(names, 5, value, "area_scope_of_mdt_eutra_c::types");
}

// CellBasedMDT-NR ::= SEQUENCE
SRSASN_CODE cell_based_mdt_nr_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, cell_id_listfor_mdt, 1, 32, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE cell_based_mdt_nr_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(cell_id_listfor_mdt, bref, 1, 32, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void cell_based_mdt_nr_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("cellIdListforMDT");
  for (const auto& e1 : cell_id_listfor_mdt) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// AreaScopeOfMDT-NR ::= CHOICE
void area_scope_of_mdt_nr_c::destroy_()
{
  switch (type_) {
    case types::cell_based:
      c.destroy<cell_based_mdt_nr_s>();
      break;
    case types::ta_based:
      c.destroy<ta_based_mdt_s>();
      break;
    case types::tai_based:
      c.destroy<tai_based_mdt_s>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<area_scope_of_mdt_nr_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void area_scope_of_mdt_nr_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::cell_based:
      c.init<cell_based_mdt_nr_s>();
      break;
    case types::ta_based:
      c.init<ta_based_mdt_s>();
      break;
    case types::plmn_wide:
      break;
    case types::tai_based:
      c.init<tai_based_mdt_s>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<area_scope_of_mdt_nr_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "area_scope_of_mdt_nr_c");
  }
}
area_scope_of_mdt_nr_c::area_scope_of_mdt_nr_c(const area_scope_of_mdt_nr_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::cell_based:
      c.init(other.c.get<cell_based_mdt_nr_s>());
      break;
    case types::ta_based:
      c.init(other.c.get<ta_based_mdt_s>());
      break;
    case types::plmn_wide:
      break;
    case types::tai_based:
      c.init(other.c.get<tai_based_mdt_s>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<area_scope_of_mdt_nr_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "area_scope_of_mdt_nr_c");
  }
}
area_scope_of_mdt_nr_c& area_scope_of_mdt_nr_c::operator=(const area_scope_of_mdt_nr_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::cell_based:
      c.set(other.c.get<cell_based_mdt_nr_s>());
      break;
    case types::ta_based:
      c.set(other.c.get<ta_based_mdt_s>());
      break;
    case types::plmn_wide:
      break;
    case types::tai_based:
      c.set(other.c.get<tai_based_mdt_s>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<area_scope_of_mdt_nr_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "area_scope_of_mdt_nr_c");
  }

  return *this;
}
cell_based_mdt_nr_s& area_scope_of_mdt_nr_c::set_cell_based()
{
  set(types::cell_based);
  return c.get<cell_based_mdt_nr_s>();
}
ta_based_mdt_s& area_scope_of_mdt_nr_c::set_ta_based()
{
  set(types::ta_based);
  return c.get<ta_based_mdt_s>();
}
void area_scope_of_mdt_nr_c::set_plmn_wide()
{
  set(types::plmn_wide);
}
tai_based_mdt_s& area_scope_of_mdt_nr_c::set_tai_based()
{
  set(types::tai_based);
  return c.get<tai_based_mdt_s>();
}
protocol_ie_single_container_s<area_scope_of_mdt_nr_ext_ies_o>& area_scope_of_mdt_nr_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<area_scope_of_mdt_nr_ext_ies_o>>();
}
void area_scope_of_mdt_nr_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::cell_based:
      j.write_fieldname("cellBased");
      c.get<cell_based_mdt_nr_s>().to_json(j);
      break;
    case types::ta_based:
      j.write_fieldname("tABased");
      c.get<ta_based_mdt_s>().to_json(j);
      break;
    case types::plmn_wide:
      break;
    case types::tai_based:
      j.write_fieldname("tAIBased");
      c.get<tai_based_mdt_s>().to_json(j);
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<area_scope_of_mdt_nr_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "area_scope_of_mdt_nr_c");
  }
  j.end_obj();
}
SRSASN_CODE area_scope_of_mdt_nr_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::cell_based:
      HANDLE_CODE(c.get<cell_based_mdt_nr_s>().pack(bref));
      break;
    case types::ta_based:
      HANDLE_CODE(c.get<ta_based_mdt_s>().pack(bref));
      break;
    case types::plmn_wide:
      break;
    case types::tai_based:
      HANDLE_CODE(c.get<tai_based_mdt_s>().pack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<area_scope_of_mdt_nr_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "area_scope_of_mdt_nr_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE area_scope_of_mdt_nr_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::cell_based:
      HANDLE_CODE(c.get<cell_based_mdt_nr_s>().unpack(bref));
      break;
    case types::ta_based:
      HANDLE_CODE(c.get<ta_based_mdt_s>().unpack(bref));
      break;
    case types::plmn_wide:
      break;
    case types::tai_based:
      HANDLE_CODE(c.get<tai_based_mdt_s>().unpack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<area_scope_of_mdt_nr_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "area_scope_of_mdt_nr_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* area_scope_of_mdt_nr_c::types_opts::to_string() const
{
  static const char* names[] = {"cellBased", "tABased", "pLMNWide", "tAIBased", "choice-Extensions"};
  return convert_enum_idx(names, 5, value, "area_scope_of_mdt_nr_c::types");
}

// NRFrequencyBandItem ::= SEQUENCE
SRSASN_CODE nr_freq_band_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(pack_integer(bref, nr_freq_band, (uint16_t)1u, (uint16_t)1024u, true, true));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE nr_freq_band_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(unpack_integer(nr_freq_band, bref, (uint16_t)1u, (uint16_t)1024u, true, true));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void nr_freq_band_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("nr-frequency-band", nr_freq_band);
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// NRFrequencyInfo ::= SEQUENCE
SRSASN_CODE nr_freq_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(pack_integer(bref, nr_arfcn, (uint32_t)0u, (uint32_t)3279165u, false, true));
  HANDLE_CODE(pack_dyn_seq_of(bref, freq_band_list, 1, 32, true));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE nr_freq_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(unpack_integer(nr_arfcn, bref, (uint32_t)0u, (uint32_t)3279165u, false, true));
  HANDLE_CODE(unpack_dyn_seq_of(freq_band_list, bref, 1, 32, true));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void nr_freq_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("nrARFCN", nr_arfcn);
  j.start_array("frequencyBand-List");
  for (const auto& e1 : freq_band_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// AreaScopeOfNeighCellsItem ::= SEQUENCE
SRSASN_CODE area_scope_of_neigh_cells_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(pci_list_for_mdt.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(nr_freq_info.pack(bref));
  if (pci_list_for_mdt.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, pci_list_for_mdt, 1, 32, integer_packer<uint16_t>(0, 1007, true, true)));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE area_scope_of_neigh_cells_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool pci_list_for_mdt_present;
  HANDLE_CODE(bref.unpack(pci_list_for_mdt_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(nr_freq_info.unpack(bref));
  if (pci_list_for_mdt_present) {
    HANDLE_CODE(unpack_dyn_seq_of(pci_list_for_mdt, bref, 1, 32, integer_packer<uint16_t>(0, 1007, true, true)));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void area_scope_of_neigh_cells_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("nrFrequencyInfo");
  nr_freq_info.to_json(j);
  if (pci_list_for_mdt.size() > 0) {
    j.start_array("pciListForMDT");
    for (const auto& e1 : pci_list_for_mdt) {
      j.write_int(e1);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CellBasedQMC ::= SEQUENCE
SRSASN_CODE cell_based_qmc_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, cell_id_listfor_qmc, 1, 32, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE cell_based_qmc_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(cell_id_listfor_qmc, bref, 1, 32, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void cell_based_qmc_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("cellIdListforQMC");
  for (const auto& e1 : cell_id_listfor_qmc) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PLMNAreaBasedQMC ::= SEQUENCE
SRSASN_CODE plmn_area_based_qmc_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, plmn_listfor_qmc, 1, 16, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE plmn_area_based_qmc_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(plmn_listfor_qmc, bref, 1, 16, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void plmn_area_based_qmc_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("plmnListforQMC");
  for (const auto& e1 : plmn_listfor_qmc) {
    j.write_str(e1.to_string());
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TABasedQMC ::= SEQUENCE
SRSASN_CODE ta_based_qmc_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, ta_listfor_qmc, 1, 8, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ta_based_qmc_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(ta_listfor_qmc, bref, 1, 8, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ta_based_qmc_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("tAListforQMC");
  for (const auto& e1 : ta_listfor_qmc) {
    j.write_str(e1.to_string());
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TAIBasedQMC ::= SEQUENCE
SRSASN_CODE tai_based_qmc_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, tai_listfor_qmc, 1, 8, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE tai_based_qmc_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(tai_listfor_qmc, bref, 1, 8, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void tai_based_qmc_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("tAIListforQMC");
  for (const auto& e1 : tai_listfor_qmc) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// AreaScopeOfQMC ::= CHOICE
void area_scope_of_qmc_c::destroy_()
{
  switch (type_) {
    case types::cell_based:
      c.destroy<cell_based_qmc_s>();
      break;
    case types::ta_based:
      c.destroy<ta_based_qmc_s>();
      break;
    case types::tai_based:
      c.destroy<tai_based_qmc_s>();
      break;
    case types::plmn_area_based:
      c.destroy<plmn_area_based_qmc_s>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<area_scope_of_qmc_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void area_scope_of_qmc_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::cell_based:
      c.init<cell_based_qmc_s>();
      break;
    case types::ta_based:
      c.init<ta_based_qmc_s>();
      break;
    case types::tai_based:
      c.init<tai_based_qmc_s>();
      break;
    case types::plmn_area_based:
      c.init<plmn_area_based_qmc_s>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<area_scope_of_qmc_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "area_scope_of_qmc_c");
  }
}
area_scope_of_qmc_c::area_scope_of_qmc_c(const area_scope_of_qmc_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::cell_based:
      c.init(other.c.get<cell_based_qmc_s>());
      break;
    case types::ta_based:
      c.init(other.c.get<ta_based_qmc_s>());
      break;
    case types::tai_based:
      c.init(other.c.get<tai_based_qmc_s>());
      break;
    case types::plmn_area_based:
      c.init(other.c.get<plmn_area_based_qmc_s>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<area_scope_of_qmc_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "area_scope_of_qmc_c");
  }
}
area_scope_of_qmc_c& area_scope_of_qmc_c::operator=(const area_scope_of_qmc_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::cell_based:
      c.set(other.c.get<cell_based_qmc_s>());
      break;
    case types::ta_based:
      c.set(other.c.get<ta_based_qmc_s>());
      break;
    case types::tai_based:
      c.set(other.c.get<tai_based_qmc_s>());
      break;
    case types::plmn_area_based:
      c.set(other.c.get<plmn_area_based_qmc_s>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<area_scope_of_qmc_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "area_scope_of_qmc_c");
  }

  return *this;
}
cell_based_qmc_s& area_scope_of_qmc_c::set_cell_based()
{
  set(types::cell_based);
  return c.get<cell_based_qmc_s>();
}
ta_based_qmc_s& area_scope_of_qmc_c::set_ta_based()
{
  set(types::ta_based);
  return c.get<ta_based_qmc_s>();
}
tai_based_qmc_s& area_scope_of_qmc_c::set_tai_based()
{
  set(types::tai_based);
  return c.get<tai_based_qmc_s>();
}
plmn_area_based_qmc_s& area_scope_of_qmc_c::set_plmn_area_based()
{
  set(types::plmn_area_based);
  return c.get<plmn_area_based_qmc_s>();
}
protocol_ie_single_container_s<area_scope_of_qmc_ext_ies_o>& area_scope_of_qmc_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<area_scope_of_qmc_ext_ies_o>>();
}
void area_scope_of_qmc_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::cell_based:
      j.write_fieldname("cellBased");
      c.get<cell_based_qmc_s>().to_json(j);
      break;
    case types::ta_based:
      j.write_fieldname("tABased");
      c.get<ta_based_qmc_s>().to_json(j);
      break;
    case types::tai_based:
      j.write_fieldname("tAIBased");
      c.get<tai_based_qmc_s>().to_json(j);
      break;
    case types::plmn_area_based:
      j.write_fieldname("pLMNAreaBased");
      c.get<plmn_area_based_qmc_s>().to_json(j);
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<area_scope_of_qmc_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "area_scope_of_qmc_c");
  }
  j.end_obj();
}
SRSASN_CODE area_scope_of_qmc_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::cell_based:
      HANDLE_CODE(c.get<cell_based_qmc_s>().pack(bref));
      break;
    case types::ta_based:
      HANDLE_CODE(c.get<ta_based_qmc_s>().pack(bref));
      break;
    case types::tai_based:
      HANDLE_CODE(c.get<tai_based_qmc_s>().pack(bref));
      break;
    case types::plmn_area_based:
      HANDLE_CODE(c.get<plmn_area_based_qmc_s>().pack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<area_scope_of_qmc_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "area_scope_of_qmc_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE area_scope_of_qmc_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::cell_based:
      HANDLE_CODE(c.get<cell_based_qmc_s>().unpack(bref));
      break;
    case types::ta_based:
      HANDLE_CODE(c.get<ta_based_qmc_s>().unpack(bref));
      break;
    case types::tai_based:
      HANDLE_CODE(c.get<tai_based_qmc_s>().unpack(bref));
      break;
    case types::plmn_area_based:
      HANDLE_CODE(c.get<plmn_area_based_qmc_s>().unpack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<area_scope_of_qmc_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "area_scope_of_qmc_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* area_scope_of_qmc_c::types_opts::to_string() const
{
  static const char* names[] = {"cellBased", "tABased", "tAIBased", "pLMNAreaBased", "choice-Extensions"};
  return convert_enum_idx(names, 5, value, "area_scope_of_qmc_c::types");
}

// RecommendedCellItem ::= SEQUENCE
SRSASN_CODE recommended_cell_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(time_stayed_in_cell_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(ngran_cgi.pack(bref));
  if (time_stayed_in_cell_present) {
    HANDLE_CODE(pack_integer(bref, time_stayed_in_cell, (uint16_t)0u, (uint16_t)4095u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE recommended_cell_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(time_stayed_in_cell_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(ngran_cgi.unpack(bref));
  if (time_stayed_in_cell_present) {
    HANDLE_CODE(unpack_integer(time_stayed_in_cell, bref, (uint16_t)0u, (uint16_t)4095u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void recommended_cell_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("nGRAN-CGI");
  ngran_cgi.to_json(j);
  if (time_stayed_in_cell_present) {
    j.write_int("timeStayedInCell", time_stayed_in_cell);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// NPN-PagingAssistanceInformation ::= CHOICE
void npn_paging_assist_info_c::destroy_()
{
  switch (type_) {
    case types::pni_npn_paging_assist:
      c.destroy<allowed_pni_npn_list_l>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<npn_paging_assist_info_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void npn_paging_assist_info_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::pni_npn_paging_assist:
      c.init<allowed_pni_npn_list_l>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<npn_paging_assist_info_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "npn_paging_assist_info_c");
  }
}
npn_paging_assist_info_c::npn_paging_assist_info_c(const npn_paging_assist_info_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::pni_npn_paging_assist:
      c.init(other.c.get<allowed_pni_npn_list_l>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<npn_paging_assist_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "npn_paging_assist_info_c");
  }
}
npn_paging_assist_info_c& npn_paging_assist_info_c::operator=(const npn_paging_assist_info_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::pni_npn_paging_assist:
      c.set(other.c.get<allowed_pni_npn_list_l>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<npn_paging_assist_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "npn_paging_assist_info_c");
  }

  return *this;
}
allowed_pni_npn_list_l& npn_paging_assist_info_c::set_pni_npn_paging_assist()
{
  set(types::pni_npn_paging_assist);
  return c.get<allowed_pni_npn_list_l>();
}
protocol_ie_single_container_s<npn_paging_assist_info_ext_ies_o>& npn_paging_assist_info_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<npn_paging_assist_info_ext_ies_o>>();
}
void npn_paging_assist_info_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::pni_npn_paging_assist:
      j.start_array("pNI-NPN-PagingAssistance");
      for (const auto& e1 : c.get<allowed_pni_npn_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<npn_paging_assist_info_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "npn_paging_assist_info_c");
  }
  j.end_obj();
}
SRSASN_CODE npn_paging_assist_info_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::pni_npn_paging_assist:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<allowed_pni_npn_list_l>(), 1, 16, true));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<npn_paging_assist_info_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "npn_paging_assist_info_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE npn_paging_assist_info_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::pni_npn_paging_assist:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<allowed_pni_npn_list_l>(), bref, 1, 16, true));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<npn_paging_assist_info_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "npn_paging_assist_info_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* npn_paging_assist_info_c::types_opts::to_string() const
{
  static const char* names[] = {"pNI-NPN-PagingAssistance", "choice-Extensions"};
  return convert_enum_idx(names, 2, value, "npn_paging_assist_info_c::types");
}

// NextPagingAreaScope ::= ENUMERATED
const char* next_paging_area_scope_opts::to_string() const
{
  static const char* names[] = {"same", "changed"};
  return convert_enum_idx(names, 2, value, "next_paging_area_scope_e");
}

// PagingAssisDataforCEcapabUE ::= SEQUENCE
SRSASN_CODE paging_assis_datafor_c_ecapab_ue_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(eutra_cgi.pack(bref));
  HANDLE_CODE(coverage_enhancement_level.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE paging_assis_datafor_c_ecapab_ue_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(eutra_cgi.unpack(bref));
  HANDLE_CODE(coverage_enhancement_level.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void paging_assis_datafor_c_ecapab_ue_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("eUTRA-CGI");
  eutra_cgi.to_json(j);
  j.write_str("coverageEnhancementLevel", coverage_enhancement_level.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// RecommendedCellsForPaging ::= SEQUENCE
SRSASN_CODE recommended_cells_for_paging_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, recommended_cell_list, 1, 16, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE recommended_cells_for_paging_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(recommended_cell_list, bref, 1, 16, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void recommended_cells_for_paging_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("recommendedCellList");
  for (const auto& e1 : recommended_cell_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// AssistanceDataForPaging-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t assist_data_for_paging_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {260, 207};
  return map_enum_number(names, 2, idx, "id");
}
bool assist_data_for_paging_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {260, 207};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e assist_data_for_paging_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 260:
      return crit_e::ignore;
    case 207:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
assist_data_for_paging_ext_ies_o::ext_c assist_data_for_paging_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 260:
      ret.set(ext_c::types::npn_paging_assist_info);
      break;
    case 207:
      ret.set(ext_c::types::paging_assis_datafor_c_ecapab_ue);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e assist_data_for_paging_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 260:
      return presence_e::optional;
    case 207:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void assist_data_for_paging_ext_ies_o::ext_c::destroy_()
{
  switch (type_) {
    case types::npn_paging_assist_info:
      c.destroy<npn_paging_assist_info_c>();
      break;
    case types::paging_assis_datafor_c_ecapab_ue:
      c.destroy<paging_assis_datafor_c_ecapab_ue_s>();
      break;
    default:
      break;
  }
}
void assist_data_for_paging_ext_ies_o::ext_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::npn_paging_assist_info:
      c.init<npn_paging_assist_info_c>();
      break;
    case types::paging_assis_datafor_c_ecapab_ue:
      c.init<paging_assis_datafor_c_ecapab_ue_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "assist_data_for_paging_ext_ies_o::ext_c");
  }
}
assist_data_for_paging_ext_ies_o::ext_c::ext_c(const assist_data_for_paging_ext_ies_o::ext_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::npn_paging_assist_info:
      c.init(other.c.get<npn_paging_assist_info_c>());
      break;
    case types::paging_assis_datafor_c_ecapab_ue:
      c.init(other.c.get<paging_assis_datafor_c_ecapab_ue_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "assist_data_for_paging_ext_ies_o::ext_c");
  }
}
assist_data_for_paging_ext_ies_o::ext_c&
assist_data_for_paging_ext_ies_o::ext_c::operator=(const assist_data_for_paging_ext_ies_o::ext_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::npn_paging_assist_info:
      c.set(other.c.get<npn_paging_assist_info_c>());
      break;
    case types::paging_assis_datafor_c_ecapab_ue:
      c.set(other.c.get<paging_assis_datafor_c_ecapab_ue_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "assist_data_for_paging_ext_ies_o::ext_c");
  }

  return *this;
}
npn_paging_assist_info_c& assist_data_for_paging_ext_ies_o::ext_c::npn_paging_assist_info()
{
  assert_choice_type(types::npn_paging_assist_info, type_, "Extension");
  return c.get<npn_paging_assist_info_c>();
}
paging_assis_datafor_c_ecapab_ue_s& assist_data_for_paging_ext_ies_o::ext_c::paging_assis_datafor_c_ecapab_ue()
{
  assert_choice_type(types::paging_assis_datafor_c_ecapab_ue, type_, "Extension");
  return c.get<paging_assis_datafor_c_ecapab_ue_s>();
}
const npn_paging_assist_info_c& assist_data_for_paging_ext_ies_o::ext_c::npn_paging_assist_info() const
{
  assert_choice_type(types::npn_paging_assist_info, type_, "Extension");
  return c.get<npn_paging_assist_info_c>();
}
const paging_assis_datafor_c_ecapab_ue_s&
assist_data_for_paging_ext_ies_o::ext_c::paging_assis_datafor_c_ecapab_ue() const
{
  assert_choice_type(types::paging_assis_datafor_c_ecapab_ue, type_, "Extension");
  return c.get<paging_assis_datafor_c_ecapab_ue_s>();
}
void assist_data_for_paging_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::npn_paging_assist_info:
      j.write_fieldname("NPN-PagingAssistanceInformation");
      c.get<npn_paging_assist_info_c>().to_json(j);
      break;
    case types::paging_assis_datafor_c_ecapab_ue:
      j.write_fieldname("PagingAssisDataforCEcapabUE");
      c.get<paging_assis_datafor_c_ecapab_ue_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "assist_data_for_paging_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE assist_data_for_paging_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::npn_paging_assist_info:
      HANDLE_CODE(c.get<npn_paging_assist_info_c>().pack(bref));
      break;
    case types::paging_assis_datafor_c_ecapab_ue:
      HANDLE_CODE(c.get<paging_assis_datafor_c_ecapab_ue_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "assist_data_for_paging_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE assist_data_for_paging_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::npn_paging_assist_info:
      HANDLE_CODE(c.get<npn_paging_assist_info_c>().unpack(bref));
      break;
    case types::paging_assis_datafor_c_ecapab_ue:
      HANDLE_CODE(c.get<paging_assis_datafor_c_ecapab_ue_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "assist_data_for_paging_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* assist_data_for_paging_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"NPN-PagingAssistanceInformation", "PagingAssisDataforCEcapabUE"};
  return convert_enum_idx(names, 2, value, "assist_data_for_paging_ext_ies_o::ext_c::types");
}

// AssistanceDataForRecommendedCells ::= SEQUENCE
SRSASN_CODE assist_data_for_recommended_cells_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(recommended_cells_for_paging.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE assist_data_for_recommended_cells_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(recommended_cells_for_paging.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void assist_data_for_recommended_cells_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("recommendedCellsForPaging");
  recommended_cells_for_paging.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PagingAttemptInformation ::= SEQUENCE
SRSASN_CODE paging_attempt_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(next_paging_area_scope_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, paging_attempt_count, (uint8_t)1u, (uint8_t)16u, true, true));
  HANDLE_CODE(pack_integer(bref, intended_nof_paging_attempts, (uint8_t)1u, (uint8_t)16u, true, true));
  if (next_paging_area_scope_present) {
    HANDLE_CODE(next_paging_area_scope.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE paging_attempt_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(next_paging_area_scope_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(paging_attempt_count, bref, (uint8_t)1u, (uint8_t)16u, true, true));
  HANDLE_CODE(unpack_integer(intended_nof_paging_attempts, bref, (uint8_t)1u, (uint8_t)16u, true, true));
  if (next_paging_area_scope_present) {
    HANDLE_CODE(next_paging_area_scope.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void paging_attempt_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pagingAttemptCount", paging_attempt_count);
  j.write_int("intendedNumberOfPagingAttempts", intended_nof_paging_attempts);
  if (next_paging_area_scope_present) {
    j.write_str("nextPagingAreaScope", next_paging_area_scope.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ext_field_s<assist_data_for_paging_ext_ies_o>;

assist_data_for_paging_ext_ies_container::assist_data_for_paging_ext_ies_container() :
  npn_paging_assist_info(260, crit_e::ignore), paging_assis_datafor_c_ecapab_ue(207, crit_e::ignore)
{
}
SRSASN_CODE assist_data_for_paging_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += npn_paging_assist_info_present ? 1 : 0;
  nof_ies += paging_assis_datafor_c_ecapab_ue_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (npn_paging_assist_info_present) {
    HANDLE_CODE(npn_paging_assist_info.pack(bref));
  }
  if (paging_assis_datafor_c_ecapab_ue_present) {
    HANDLE_CODE(paging_assis_datafor_c_ecapab_ue.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE assist_data_for_paging_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 260: {
        npn_paging_assist_info_present = true;
        npn_paging_assist_info.id      = id;
        HANDLE_CODE(npn_paging_assist_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(npn_paging_assist_info.ext.unpack(bref));
        break;
      }
      case 207: {
        paging_assis_datafor_c_ecapab_ue_present = true;
        paging_assis_datafor_c_ecapab_ue.id      = id;
        HANDLE_CODE(paging_assis_datafor_c_ecapab_ue.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(paging_assis_datafor_c_ecapab_ue.ext.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void assist_data_for_paging_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (npn_paging_assist_info_present) {
    j.write_fieldname("");
    npn_paging_assist_info.to_json(j);
  }
  if (paging_assis_datafor_c_ecapab_ue_present) {
    j.write_fieldname("");
    paging_assis_datafor_c_ecapab_ue.to_json(j);
  }
  j.end_obj();
}

// AssistanceDataForPaging ::= SEQUENCE
SRSASN_CODE assist_data_for_paging_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(assist_data_for_recommended_cells_present, 1));
  HANDLE_CODE(bref.pack(paging_attempt_info_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (assist_data_for_recommended_cells_present) {
    HANDLE_CODE(assist_data_for_recommended_cells.pack(bref));
  }
  if (paging_attempt_info_present) {
    HANDLE_CODE(paging_attempt_info.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE assist_data_for_paging_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(assist_data_for_recommended_cells_present, 1));
  HANDLE_CODE(bref.unpack(paging_attempt_info_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (assist_data_for_recommended_cells_present) {
    HANDLE_CODE(assist_data_for_recommended_cells.unpack(bref));
  }
  if (paging_attempt_info_present) {
    HANDLE_CODE(paging_attempt_info.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void assist_data_for_paging_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (assist_data_for_recommended_cells_present) {
    j.write_fieldname("assistanceDataForRecommendedCells");
    assist_data_for_recommended_cells.to_json(j);
  }
  if (paging_attempt_info_present) {
    j.write_fieldname("pagingAttemptInformation");
    paging_attempt_info.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// AssociatedMBSQosFlowSetupRequestItem ::= SEQUENCE
SRSASN_CODE associated_mbs_qos_flow_setup_request_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, mbs_qos_flow_id, (uint8_t)0u, (uint8_t)63u, true, true));
  HANDLE_CODE(pack_integer(bref, associated_unicast_qos_flow_id, (uint8_t)0u, (uint8_t)63u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE associated_mbs_qos_flow_setup_request_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(mbs_qos_flow_id, bref, (uint8_t)0u, (uint8_t)63u, true, true));
  HANDLE_CODE(unpack_integer(associated_unicast_qos_flow_id, bref, (uint8_t)0u, (uint8_t)63u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void associated_mbs_qos_flow_setup_request_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("mBS-QosFlowIdentifier", mbs_qos_flow_id);
  j.write_int("associatedUnicastQosFlowIdentifier", associated_unicast_qos_flow_id);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// AssociatedMBSQosFlowSetuporModifyRequestItem ::= SEQUENCE
SRSASN_CODE associated_mbs_qos_flow_setupor_modify_request_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, mbs_qos_flow_id, (uint8_t)0u, (uint8_t)63u, true, true));
  HANDLE_CODE(pack_integer(bref, associated_unicast_qos_flow_id, (uint8_t)0u, (uint8_t)63u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE associated_mbs_qos_flow_setupor_modify_request_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(mbs_qos_flow_id, bref, (uint8_t)0u, (uint8_t)63u, true, true));
  HANDLE_CODE(unpack_integer(associated_unicast_qos_flow_id, bref, (uint8_t)0u, (uint8_t)63u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void associated_mbs_qos_flow_setupor_modify_request_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("mBS-QosFlowIdentifier", mbs_qos_flow_id);
  j.write_int("associatedUnicastQosFlowIdentifier", associated_unicast_qos_flow_id);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// AssociatedQosFlowItem-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t associated_qos_flow_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {221};
  return map_enum_number(names, 1, idx, "id");
}
bool associated_qos_flow_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 221 == id;
}
crit_e associated_qos_flow_item_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 221) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
associated_qos_flow_item_ext_ies_o::ext_c associated_qos_flow_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 221) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e associated_qos_flow_item_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 221) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void associated_qos_flow_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("INTEGER (1..8,...)", c);
  j.end_obj();
}
SRSASN_CODE associated_qos_flow_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(pack_integer(bref, c, (uint8_t)1u, (uint8_t)8u, true, true));
  return SRSASN_SUCCESS;
}
SRSASN_CODE associated_qos_flow_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(unpack_integer(c, bref, (uint8_t)1u, (uint8_t)8u, true, true));
  return SRSASN_SUCCESS;
}

const char* associated_qos_flow_item_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (1..8,...)"};
  return convert_enum_idx(names, 1, value, "associated_qos_flow_item_ext_ies_o::ext_c::types");
}
uint8_t associated_qos_flow_item_ext_ies_o::ext_c::types_opts::to_number() const
{
  static const uint8_t numbers[] = {1};
  return map_enum_number(numbers, 1, value, "associated_qos_flow_item_ext_ies_o::ext_c::types");
}

// AssociatedQosFlowItem ::= SEQUENCE
SRSASN_CODE associated_qos_flow_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(qos_flow_map_ind_present, 1));
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(pack_integer(bref, qos_flow_id, (uint8_t)0u, (uint8_t)63u, true, true));
  if (qos_flow_map_ind_present) {
    HANDLE_CODE(qos_flow_map_ind.pack(bref));
  }
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE associated_qos_flow_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(qos_flow_map_ind_present, 1));
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(qos_flow_id, bref, (uint8_t)0u, (uint8_t)63u, true, true));
  if (qos_flow_map_ind_present) {
    HANDLE_CODE(qos_flow_map_ind.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void associated_qos_flow_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("qosFlowIdentifier", qos_flow_id);
  if (qos_flow_map_ind_present) {
    j.write_str("qosFlowMappingIndication", qos_flow_map_ind.to_string());
  }
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

const char* associated_qos_flow_item_s::qos_flow_map_ind_opts::to_string() const
{
  static const char* names[] = {"ul", "dl"};
  return convert_enum_idx(names, 2, value, "associated_qos_flow_item_s::qos_flow_map_ind_e_");
}

// AvailableRANVisibleQoEMetrics ::= SEQUENCE
SRSASN_CODE available_ran_visible_qo_e_metrics_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(application_layer_buffer_level_list_present, 1));
  HANDLE_CODE(bref.pack(playout_delay_for_media_startup_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (application_layer_buffer_level_list_present) {
    HANDLE_CODE(application_layer_buffer_level_list.pack(bref));
  }
  if (playout_delay_for_media_startup_present) {
    HANDLE_CODE(playout_delay_for_media_startup.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE available_ran_visible_qo_e_metrics_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(application_layer_buffer_level_list_present, 1));
  HANDLE_CODE(bref.unpack(playout_delay_for_media_startup_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (application_layer_buffer_level_list_present) {
    HANDLE_CODE(application_layer_buffer_level_list.unpack(bref));
  }
  if (playout_delay_for_media_startup_present) {
    HANDLE_CODE(playout_delay_for_media_startup.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void available_ran_visible_qo_e_metrics_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (application_layer_buffer_level_list_present) {
    j.write_str("applicationLayerBufferLevelList", "true");
  }
  if (playout_delay_for_media_startup_present) {
    j.write_str("playoutDelayForMediaStartup", "true");
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* available_ran_visible_qo_e_metrics_s::application_layer_buffer_level_list_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(
      names, 1, value, "available_ran_visible_qo_e_metrics_s::application_layer_buffer_level_list_e_");
}

const char* available_ran_visible_qo_e_metrics_s::playout_delay_for_media_startup_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "available_ran_visible_qo_e_metrics_s::playout_delay_for_media_startup_e_");
}

// BeamMeasurementsReportQuantity ::= SEQUENCE
SRSASN_CODE beam_meass_report_quant_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(rsrp.pack(bref));
  HANDLE_CODE(rsrq.pack(bref));
  HANDLE_CODE(sinr.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE beam_meass_report_quant_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(rsrp.unpack(bref));
  HANDLE_CODE(rsrq.unpack(bref));
  HANDLE_CODE(sinr.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void beam_meass_report_quant_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("rSRP", "true");
  j.write_str("rSRQ", "true");
  j.write_str("sINR", "true");
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* beam_meass_report_quant_s::rsrp_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "beam_meass_report_quant_s::rsrp_e_");
}

const char* beam_meass_report_quant_s::rsrq_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "beam_meass_report_quant_s::rsrq_e_");
}

const char* beam_meass_report_quant_s::sinr_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "beam_meass_report_quant_s::sinr_e_");
}

// BeamMeasurementsReportConfiguration ::= SEQUENCE
SRSASN_CODE beam_meass_report_cfg_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(beam_meass_report_quant_present, 1));
  HANDLE_CODE(bref.pack(max_nrof_rs_idxes_to_report_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (beam_meass_report_quant_present) {
    HANDLE_CODE(beam_meass_report_quant.pack(bref));
  }
  if (max_nrof_rs_idxes_to_report_present) {
    HANDLE_CODE(pack_integer(bref, max_nrof_rs_idxes_to_report, (uint8_t)1u, (uint8_t)64u, true, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE beam_meass_report_cfg_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(beam_meass_report_quant_present, 1));
  HANDLE_CODE(bref.unpack(max_nrof_rs_idxes_to_report_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (beam_meass_report_quant_present) {
    HANDLE_CODE(beam_meass_report_quant.unpack(bref));
  }
  if (max_nrof_rs_idxes_to_report_present) {
    HANDLE_CODE(unpack_integer(max_nrof_rs_idxes_to_report, bref, (uint8_t)1u, (uint8_t)64u, true, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void beam_meass_report_cfg_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (beam_meass_report_quant_present) {
    j.write_fieldname("beamMeasurementsReportQuantity");
    beam_meass_report_quant.to_json(j);
  }
  if (max_nrof_rs_idxes_to_report_present) {
    j.write_int("maxNrofRS-IndexesToReport", max_nrof_rs_idxes_to_report);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// BluetoothMeasConfigNameItem ::= SEQUENCE
SRSASN_CODE bluetooth_meas_cfg_name_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(bluetooth_name.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE bluetooth_meas_cfg_name_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(bluetooth_name.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void bluetooth_meas_cfg_name_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("bluetoothName", bluetooth_name.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// BluetoothMeasConfig ::= ENUMERATED
const char* bluetooth_meas_cfg_opts::to_string() const
{
  static const char* names[] = {"setup"};
  return convert_enum_idx(names, 1, value, "bluetooth_meas_cfg_e");
}

// BluetoothMeasurementConfiguration ::= SEQUENCE
SRSASN_CODE bluetooth_meas_cfg_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(bluetooth_meas_cfg_name_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(bt_rssi_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(bluetooth_meas_cfg.pack(bref));
  if (bluetooth_meas_cfg_name_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, bluetooth_meas_cfg_name_list, 1, 4, true));
  }
  if (bt_rssi_present) {
    HANDLE_CODE(bt_rssi.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE bluetooth_meas_cfg_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool bluetooth_meas_cfg_name_list_present;
  HANDLE_CODE(bref.unpack(bluetooth_meas_cfg_name_list_present, 1));
  HANDLE_CODE(bref.unpack(bt_rssi_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(bluetooth_meas_cfg.unpack(bref));
  if (bluetooth_meas_cfg_name_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(bluetooth_meas_cfg_name_list, bref, 1, 4, true));
  }
  if (bt_rssi_present) {
    HANDLE_CODE(bt_rssi.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void bluetooth_meas_cfg_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("bluetoothMeasConfig", "setup");
  if (bluetooth_meas_cfg_name_list.size() > 0) {
    j.start_array("bluetoothMeasConfigNameList");
    for (const auto& e1 : bluetooth_meas_cfg_name_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (bt_rssi_present) {
    j.write_str("bt-rssi", "true");
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* bluetooth_meas_cfg_s::bt_rssi_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "bluetooth_meas_cfg_s::bt_rssi_e_");
}

// CancelledCellsInEAI-EUTRA-Item ::= SEQUENCE
SRSASN_CODE cancelled_cells_in_eai_eutra_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(eutra_cgi.pack(bref));
  HANDLE_CODE(pack_integer(bref, nof_broadcasts, (uint32_t)0u, (uint32_t)65535u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE cancelled_cells_in_eai_eutra_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(eutra_cgi.unpack(bref));
  HANDLE_CODE(unpack_integer(nof_broadcasts, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void cancelled_cells_in_eai_eutra_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("eUTRA-CGI");
  eutra_cgi.to_json(j);
  j.write_int("numberOfBroadcasts", nof_broadcasts);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CancelledCellsInEAI-NR-Item ::= SEQUENCE
SRSASN_CODE cancelled_cells_in_eai_nr_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(nr_cgi.pack(bref));
  HANDLE_CODE(pack_integer(bref, nof_broadcasts, (uint32_t)0u, (uint32_t)65535u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE cancelled_cells_in_eai_nr_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(nr_cgi.unpack(bref));
  HANDLE_CODE(unpack_integer(nof_broadcasts, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void cancelled_cells_in_eai_nr_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("nR-CGI");
  nr_cgi.to_json(j);
  j.write_int("numberOfBroadcasts", nof_broadcasts);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CancelledCellsInTAI-EUTRA-Item ::= SEQUENCE
SRSASN_CODE cancelled_cells_in_tai_eutra_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(eutra_cgi.pack(bref));
  HANDLE_CODE(pack_integer(bref, nof_broadcasts, (uint32_t)0u, (uint32_t)65535u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE cancelled_cells_in_tai_eutra_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(eutra_cgi.unpack(bref));
  HANDLE_CODE(unpack_integer(nof_broadcasts, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void cancelled_cells_in_tai_eutra_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("eUTRA-CGI");
  eutra_cgi.to_json(j);
  j.write_int("numberOfBroadcasts", nof_broadcasts);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CancelledCellsInTAI-NR-Item ::= SEQUENCE
SRSASN_CODE cancelled_cells_in_tai_nr_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(nr_cgi.pack(bref));
  HANDLE_CODE(pack_integer(bref, nof_broadcasts, (uint32_t)0u, (uint32_t)65535u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE cancelled_cells_in_tai_nr_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(nr_cgi.unpack(bref));
  HANDLE_CODE(unpack_integer(nof_broadcasts, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void cancelled_cells_in_tai_nr_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("nR-CGI");
  nr_cgi.to_json(j);
  j.write_int("numberOfBroadcasts", nof_broadcasts);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CellIDCancelledEUTRA-Item ::= SEQUENCE
SRSASN_CODE cell_id_cancelled_eutra_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(eutra_cgi.pack(bref));
  HANDLE_CODE(pack_integer(bref, nof_broadcasts, (uint32_t)0u, (uint32_t)65535u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE cell_id_cancelled_eutra_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(eutra_cgi.unpack(bref));
  HANDLE_CODE(unpack_integer(nof_broadcasts, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void cell_id_cancelled_eutra_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("eUTRA-CGI");
  eutra_cgi.to_json(j);
  j.write_int("numberOfBroadcasts", nof_broadcasts);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CellIDCancelledNR-Item ::= SEQUENCE
SRSASN_CODE cell_id_cancelled_nr_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(nr_cgi.pack(bref));
  HANDLE_CODE(pack_integer(bref, nof_broadcasts, (uint32_t)0u, (uint32_t)65535u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE cell_id_cancelled_nr_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(nr_cgi.unpack(bref));
  HANDLE_CODE(unpack_integer(nof_broadcasts, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void cell_id_cancelled_nr_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("nR-CGI");
  nr_cgi.to_json(j);
  j.write_int("numberOfBroadcasts", nof_broadcasts);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// EmergencyAreaIDCancelledEUTRA-Item ::= SEQUENCE
SRSASN_CODE emergency_area_id_cancelled_eutra_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(emergency_area_id.pack(bref));
  HANDLE_CODE(pack_dyn_seq_of(bref, cancelled_cells_in_eai_eutra, 1, 65535, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE emergency_area_id_cancelled_eutra_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(emergency_area_id.unpack(bref));
  HANDLE_CODE(unpack_dyn_seq_of(cancelled_cells_in_eai_eutra, bref, 1, 65535, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void emergency_area_id_cancelled_eutra_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("emergencyAreaID", emergency_area_id.to_string());
  j.start_array("cancelledCellsInEAI-EUTRA");
  for (const auto& e1 : cancelled_cells_in_eai_eutra) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// EmergencyAreaIDCancelledNR-Item ::= SEQUENCE
SRSASN_CODE emergency_area_id_cancelled_nr_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(emergency_area_id.pack(bref));
  HANDLE_CODE(pack_dyn_seq_of(bref, cancelled_cells_in_eai_nr, 1, 65535, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE emergency_area_id_cancelled_nr_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(emergency_area_id.unpack(bref));
  HANDLE_CODE(unpack_dyn_seq_of(cancelled_cells_in_eai_nr, bref, 1, 65535, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void emergency_area_id_cancelled_nr_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("emergencyAreaID", emergency_area_id.to_string());
  j.start_array("cancelledCellsInEAI-NR");
  for (const auto& e1 : cancelled_cells_in_eai_nr) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TAICancelledEUTRA-Item ::= SEQUENCE
SRSASN_CODE tai_cancelled_eutra_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(tai.pack(bref));
  HANDLE_CODE(pack_dyn_seq_of(bref, cancelled_cells_in_tai_eutra, 1, 65535, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE tai_cancelled_eutra_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(tai.unpack(bref));
  HANDLE_CODE(unpack_dyn_seq_of(cancelled_cells_in_tai_eutra, bref, 1, 65535, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void tai_cancelled_eutra_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("tAI");
  tai.to_json(j);
  j.start_array("cancelledCellsInTAI-EUTRA");
  for (const auto& e1 : cancelled_cells_in_tai_eutra) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TAICancelledNR-Item ::= SEQUENCE
SRSASN_CODE tai_cancelled_nr_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(tai.pack(bref));
  HANDLE_CODE(pack_dyn_seq_of(bref, cancelled_cells_in_tai_nr, 1, 65535, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE tai_cancelled_nr_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(tai.unpack(bref));
  HANDLE_CODE(unpack_dyn_seq_of(cancelled_cells_in_tai_nr, bref, 1, 65535, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void tai_cancelled_nr_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("tAI");
  tai.to_json(j);
  j.start_array("cancelledCellsInTAI-NR");
  for (const auto& e1 : cancelled_cells_in_tai_nr) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// BroadcastCancelledAreaList ::= CHOICE
void broadcast_cancelled_area_list_c::destroy_()
{
  switch (type_) {
    case types::cell_id_cancelled_eutra:
      c.destroy<cell_id_cancelled_eutra_l>();
      break;
    case types::tai_cancelled_eutra:
      c.destroy<tai_cancelled_eutra_l>();
      break;
    case types::emergency_area_id_cancelled_eutra:
      c.destroy<emergency_area_id_cancelled_eutra_l>();
      break;
    case types::cell_id_cancelled_nr:
      c.destroy<cell_id_cancelled_nr_l>();
      break;
    case types::tai_cancelled_nr:
      c.destroy<tai_cancelled_nr_l>();
      break;
    case types::emergency_area_id_cancelled_nr:
      c.destroy<emergency_area_id_cancelled_nr_l>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<broadcast_cancelled_area_list_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void broadcast_cancelled_area_list_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::cell_id_cancelled_eutra:
      c.init<cell_id_cancelled_eutra_l>();
      break;
    case types::tai_cancelled_eutra:
      c.init<tai_cancelled_eutra_l>();
      break;
    case types::emergency_area_id_cancelled_eutra:
      c.init<emergency_area_id_cancelled_eutra_l>();
      break;
    case types::cell_id_cancelled_nr:
      c.init<cell_id_cancelled_nr_l>();
      break;
    case types::tai_cancelled_nr:
      c.init<tai_cancelled_nr_l>();
      break;
    case types::emergency_area_id_cancelled_nr:
      c.init<emergency_area_id_cancelled_nr_l>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<broadcast_cancelled_area_list_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_cancelled_area_list_c");
  }
}
broadcast_cancelled_area_list_c::broadcast_cancelled_area_list_c(const broadcast_cancelled_area_list_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::cell_id_cancelled_eutra:
      c.init(other.c.get<cell_id_cancelled_eutra_l>());
      break;
    case types::tai_cancelled_eutra:
      c.init(other.c.get<tai_cancelled_eutra_l>());
      break;
    case types::emergency_area_id_cancelled_eutra:
      c.init(other.c.get<emergency_area_id_cancelled_eutra_l>());
      break;
    case types::cell_id_cancelled_nr:
      c.init(other.c.get<cell_id_cancelled_nr_l>());
      break;
    case types::tai_cancelled_nr:
      c.init(other.c.get<tai_cancelled_nr_l>());
      break;
    case types::emergency_area_id_cancelled_nr:
      c.init(other.c.get<emergency_area_id_cancelled_nr_l>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<broadcast_cancelled_area_list_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_cancelled_area_list_c");
  }
}
broadcast_cancelled_area_list_c&
broadcast_cancelled_area_list_c::operator=(const broadcast_cancelled_area_list_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::cell_id_cancelled_eutra:
      c.set(other.c.get<cell_id_cancelled_eutra_l>());
      break;
    case types::tai_cancelled_eutra:
      c.set(other.c.get<tai_cancelled_eutra_l>());
      break;
    case types::emergency_area_id_cancelled_eutra:
      c.set(other.c.get<emergency_area_id_cancelled_eutra_l>());
      break;
    case types::cell_id_cancelled_nr:
      c.set(other.c.get<cell_id_cancelled_nr_l>());
      break;
    case types::tai_cancelled_nr:
      c.set(other.c.get<tai_cancelled_nr_l>());
      break;
    case types::emergency_area_id_cancelled_nr:
      c.set(other.c.get<emergency_area_id_cancelled_nr_l>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<broadcast_cancelled_area_list_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_cancelled_area_list_c");
  }

  return *this;
}
cell_id_cancelled_eutra_l& broadcast_cancelled_area_list_c::set_cell_id_cancelled_eutra()
{
  set(types::cell_id_cancelled_eutra);
  return c.get<cell_id_cancelled_eutra_l>();
}
tai_cancelled_eutra_l& broadcast_cancelled_area_list_c::set_tai_cancelled_eutra()
{
  set(types::tai_cancelled_eutra);
  return c.get<tai_cancelled_eutra_l>();
}
emergency_area_id_cancelled_eutra_l& broadcast_cancelled_area_list_c::set_emergency_area_id_cancelled_eutra()
{
  set(types::emergency_area_id_cancelled_eutra);
  return c.get<emergency_area_id_cancelled_eutra_l>();
}
cell_id_cancelled_nr_l& broadcast_cancelled_area_list_c::set_cell_id_cancelled_nr()
{
  set(types::cell_id_cancelled_nr);
  return c.get<cell_id_cancelled_nr_l>();
}
tai_cancelled_nr_l& broadcast_cancelled_area_list_c::set_tai_cancelled_nr()
{
  set(types::tai_cancelled_nr);
  return c.get<tai_cancelled_nr_l>();
}
emergency_area_id_cancelled_nr_l& broadcast_cancelled_area_list_c::set_emergency_area_id_cancelled_nr()
{
  set(types::emergency_area_id_cancelled_nr);
  return c.get<emergency_area_id_cancelled_nr_l>();
}
protocol_ie_single_container_s<broadcast_cancelled_area_list_ext_ies_o>&
broadcast_cancelled_area_list_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<broadcast_cancelled_area_list_ext_ies_o>>();
}
void broadcast_cancelled_area_list_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::cell_id_cancelled_eutra:
      j.start_array("cellIDCancelledEUTRA");
      for (const auto& e1 : c.get<cell_id_cancelled_eutra_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::tai_cancelled_eutra:
      j.start_array("tAICancelledEUTRA");
      for (const auto& e1 : c.get<tai_cancelled_eutra_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::emergency_area_id_cancelled_eutra:
      j.start_array("emergencyAreaIDCancelledEUTRA");
      for (const auto& e1 : c.get<emergency_area_id_cancelled_eutra_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::cell_id_cancelled_nr:
      j.start_array("cellIDCancelledNR");
      for (const auto& e1 : c.get<cell_id_cancelled_nr_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::tai_cancelled_nr:
      j.start_array("tAICancelledNR");
      for (const auto& e1 : c.get<tai_cancelled_nr_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::emergency_area_id_cancelled_nr:
      j.start_array("emergencyAreaIDCancelledNR");
      for (const auto& e1 : c.get<emergency_area_id_cancelled_nr_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<broadcast_cancelled_area_list_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_cancelled_area_list_c");
  }
  j.end_obj();
}
SRSASN_CODE broadcast_cancelled_area_list_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::cell_id_cancelled_eutra:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<cell_id_cancelled_eutra_l>(), 1, 65535, true));
      break;
    case types::tai_cancelled_eutra:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<tai_cancelled_eutra_l>(), 1, 65535, true));
      break;
    case types::emergency_area_id_cancelled_eutra:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<emergency_area_id_cancelled_eutra_l>(), 1, 65535, true));
      break;
    case types::cell_id_cancelled_nr:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<cell_id_cancelled_nr_l>(), 1, 65535, true));
      break;
    case types::tai_cancelled_nr:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<tai_cancelled_nr_l>(), 1, 65535, true));
      break;
    case types::emergency_area_id_cancelled_nr:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<emergency_area_id_cancelled_nr_l>(), 1, 65535, true));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<broadcast_cancelled_area_list_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_cancelled_area_list_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_cancelled_area_list_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::cell_id_cancelled_eutra:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<cell_id_cancelled_eutra_l>(), bref, 1, 65535, true));
      break;
    case types::tai_cancelled_eutra:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<tai_cancelled_eutra_l>(), bref, 1, 65535, true));
      break;
    case types::emergency_area_id_cancelled_eutra:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<emergency_area_id_cancelled_eutra_l>(), bref, 1, 65535, true));
      break;
    case types::cell_id_cancelled_nr:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<cell_id_cancelled_nr_l>(), bref, 1, 65535, true));
      break;
    case types::tai_cancelled_nr:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<tai_cancelled_nr_l>(), bref, 1, 65535, true));
      break;
    case types::emergency_area_id_cancelled_nr:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<emergency_area_id_cancelled_nr_l>(), bref, 1, 65535, true));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<broadcast_cancelled_area_list_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_cancelled_area_list_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* broadcast_cancelled_area_list_c::types_opts::to_string() const
{
  static const char* names[] = {"cellIDCancelledEUTRA",
                                "tAICancelledEUTRA",
                                "emergencyAreaIDCancelledEUTRA",
                                "cellIDCancelledNR",
                                "tAICancelledNR",
                                "emergencyAreaIDCancelledNR",
                                "choice-Extensions"};
  return convert_enum_idx(names, 7, value, "broadcast_cancelled_area_list_c::types");
}

// CompletedCellsInEAI-EUTRA-Item ::= SEQUENCE
SRSASN_CODE completed_cells_in_eai_eutra_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(eutra_cgi.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE completed_cells_in_eai_eutra_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(eutra_cgi.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void completed_cells_in_eai_eutra_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("eUTRA-CGI");
  eutra_cgi.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CompletedCellsInEAI-NR-Item ::= SEQUENCE
SRSASN_CODE completed_cells_in_eai_nr_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(nr_cgi.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE completed_cells_in_eai_nr_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(nr_cgi.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void completed_cells_in_eai_nr_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("nR-CGI");
  nr_cgi.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CompletedCellsInTAI-EUTRA-Item ::= SEQUENCE
SRSASN_CODE completed_cells_in_tai_eutra_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(eutra_cgi.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE completed_cells_in_tai_eutra_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(eutra_cgi.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void completed_cells_in_tai_eutra_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("eUTRA-CGI");
  eutra_cgi.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CompletedCellsInTAI-NR-Item ::= SEQUENCE
SRSASN_CODE completed_cells_in_tai_nr_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(nr_cgi.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE completed_cells_in_tai_nr_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(nr_cgi.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void completed_cells_in_tai_nr_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("nR-CGI");
  nr_cgi.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CellIDBroadcastEUTRA-Item ::= SEQUENCE
SRSASN_CODE cell_id_broadcast_eutra_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(eutra_cgi.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE cell_id_broadcast_eutra_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(eutra_cgi.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void cell_id_broadcast_eutra_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("eUTRA-CGI");
  eutra_cgi.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CellIDBroadcastNR-Item ::= SEQUENCE
SRSASN_CODE cell_id_broadcast_nr_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(nr_cgi.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE cell_id_broadcast_nr_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(nr_cgi.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void cell_id_broadcast_nr_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("nR-CGI");
  nr_cgi.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// EmergencyAreaIDBroadcastEUTRA-Item ::= SEQUENCE
SRSASN_CODE emergency_area_id_broadcast_eutra_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(emergency_area_id.pack(bref));
  HANDLE_CODE(pack_dyn_seq_of(bref, completed_cells_in_eai_eutra, 1, 65535, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE emergency_area_id_broadcast_eutra_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(emergency_area_id.unpack(bref));
  HANDLE_CODE(unpack_dyn_seq_of(completed_cells_in_eai_eutra, bref, 1, 65535, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void emergency_area_id_broadcast_eutra_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("emergencyAreaID", emergency_area_id.to_string());
  j.start_array("completedCellsInEAI-EUTRA");
  for (const auto& e1 : completed_cells_in_eai_eutra) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// EmergencyAreaIDBroadcastNR-Item ::= SEQUENCE
SRSASN_CODE emergency_area_id_broadcast_nr_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(emergency_area_id.pack(bref));
  HANDLE_CODE(pack_dyn_seq_of(bref, completed_cells_in_eai_nr, 1, 65535, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE emergency_area_id_broadcast_nr_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(emergency_area_id.unpack(bref));
  HANDLE_CODE(unpack_dyn_seq_of(completed_cells_in_eai_nr, bref, 1, 65535, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void emergency_area_id_broadcast_nr_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("emergencyAreaID", emergency_area_id.to_string());
  j.start_array("completedCellsInEAI-NR");
  for (const auto& e1 : completed_cells_in_eai_nr) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TAIBroadcastEUTRA-Item ::= SEQUENCE
SRSASN_CODE tai_broadcast_eutra_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(tai.pack(bref));
  HANDLE_CODE(pack_dyn_seq_of(bref, completed_cells_in_tai_eutra, 1, 65535, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE tai_broadcast_eutra_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(tai.unpack(bref));
  HANDLE_CODE(unpack_dyn_seq_of(completed_cells_in_tai_eutra, bref, 1, 65535, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void tai_broadcast_eutra_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("tAI");
  tai.to_json(j);
  j.start_array("completedCellsInTAI-EUTRA");
  for (const auto& e1 : completed_cells_in_tai_eutra) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TAIBroadcastNR-Item ::= SEQUENCE
SRSASN_CODE tai_broadcast_nr_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(tai.pack(bref));
  HANDLE_CODE(pack_dyn_seq_of(bref, completed_cells_in_tai_nr, 1, 65535, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE tai_broadcast_nr_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(tai.unpack(bref));
  HANDLE_CODE(unpack_dyn_seq_of(completed_cells_in_tai_nr, bref, 1, 65535, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void tai_broadcast_nr_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("tAI");
  tai.to_json(j);
  j.start_array("completedCellsInTAI-NR");
  for (const auto& e1 : completed_cells_in_tai_nr) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// BroadcastCompletedAreaList ::= CHOICE
void broadcast_completed_area_list_c::destroy_()
{
  switch (type_) {
    case types::cell_id_broadcast_eutra:
      c.destroy<cell_id_broadcast_eutra_l>();
      break;
    case types::tai_broadcast_eutra:
      c.destroy<tai_broadcast_eutra_l>();
      break;
    case types::emergency_area_id_broadcast_eutra:
      c.destroy<emergency_area_id_broadcast_eutra_l>();
      break;
    case types::cell_id_broadcast_nr:
      c.destroy<cell_id_broadcast_nr_l>();
      break;
    case types::tai_broadcast_nr:
      c.destroy<tai_broadcast_nr_l>();
      break;
    case types::emergency_area_id_broadcast_nr:
      c.destroy<emergency_area_id_broadcast_nr_l>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<broadcast_completed_area_list_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void broadcast_completed_area_list_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::cell_id_broadcast_eutra:
      c.init<cell_id_broadcast_eutra_l>();
      break;
    case types::tai_broadcast_eutra:
      c.init<tai_broadcast_eutra_l>();
      break;
    case types::emergency_area_id_broadcast_eutra:
      c.init<emergency_area_id_broadcast_eutra_l>();
      break;
    case types::cell_id_broadcast_nr:
      c.init<cell_id_broadcast_nr_l>();
      break;
    case types::tai_broadcast_nr:
      c.init<tai_broadcast_nr_l>();
      break;
    case types::emergency_area_id_broadcast_nr:
      c.init<emergency_area_id_broadcast_nr_l>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<broadcast_completed_area_list_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_completed_area_list_c");
  }
}
broadcast_completed_area_list_c::broadcast_completed_area_list_c(const broadcast_completed_area_list_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::cell_id_broadcast_eutra:
      c.init(other.c.get<cell_id_broadcast_eutra_l>());
      break;
    case types::tai_broadcast_eutra:
      c.init(other.c.get<tai_broadcast_eutra_l>());
      break;
    case types::emergency_area_id_broadcast_eutra:
      c.init(other.c.get<emergency_area_id_broadcast_eutra_l>());
      break;
    case types::cell_id_broadcast_nr:
      c.init(other.c.get<cell_id_broadcast_nr_l>());
      break;
    case types::tai_broadcast_nr:
      c.init(other.c.get<tai_broadcast_nr_l>());
      break;
    case types::emergency_area_id_broadcast_nr:
      c.init(other.c.get<emergency_area_id_broadcast_nr_l>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<broadcast_completed_area_list_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_completed_area_list_c");
  }
}
broadcast_completed_area_list_c&
broadcast_completed_area_list_c::operator=(const broadcast_completed_area_list_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::cell_id_broadcast_eutra:
      c.set(other.c.get<cell_id_broadcast_eutra_l>());
      break;
    case types::tai_broadcast_eutra:
      c.set(other.c.get<tai_broadcast_eutra_l>());
      break;
    case types::emergency_area_id_broadcast_eutra:
      c.set(other.c.get<emergency_area_id_broadcast_eutra_l>());
      break;
    case types::cell_id_broadcast_nr:
      c.set(other.c.get<cell_id_broadcast_nr_l>());
      break;
    case types::tai_broadcast_nr:
      c.set(other.c.get<tai_broadcast_nr_l>());
      break;
    case types::emergency_area_id_broadcast_nr:
      c.set(other.c.get<emergency_area_id_broadcast_nr_l>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<broadcast_completed_area_list_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_completed_area_list_c");
  }

  return *this;
}
cell_id_broadcast_eutra_l& broadcast_completed_area_list_c::set_cell_id_broadcast_eutra()
{
  set(types::cell_id_broadcast_eutra);
  return c.get<cell_id_broadcast_eutra_l>();
}
tai_broadcast_eutra_l& broadcast_completed_area_list_c::set_tai_broadcast_eutra()
{
  set(types::tai_broadcast_eutra);
  return c.get<tai_broadcast_eutra_l>();
}
emergency_area_id_broadcast_eutra_l& broadcast_completed_area_list_c::set_emergency_area_id_broadcast_eutra()
{
  set(types::emergency_area_id_broadcast_eutra);
  return c.get<emergency_area_id_broadcast_eutra_l>();
}
cell_id_broadcast_nr_l& broadcast_completed_area_list_c::set_cell_id_broadcast_nr()
{
  set(types::cell_id_broadcast_nr);
  return c.get<cell_id_broadcast_nr_l>();
}
tai_broadcast_nr_l& broadcast_completed_area_list_c::set_tai_broadcast_nr()
{
  set(types::tai_broadcast_nr);
  return c.get<tai_broadcast_nr_l>();
}
emergency_area_id_broadcast_nr_l& broadcast_completed_area_list_c::set_emergency_area_id_broadcast_nr()
{
  set(types::emergency_area_id_broadcast_nr);
  return c.get<emergency_area_id_broadcast_nr_l>();
}
protocol_ie_single_container_s<broadcast_completed_area_list_ext_ies_o>&
broadcast_completed_area_list_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<broadcast_completed_area_list_ext_ies_o>>();
}
void broadcast_completed_area_list_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::cell_id_broadcast_eutra:
      j.start_array("cellIDBroadcastEUTRA");
      for (const auto& e1 : c.get<cell_id_broadcast_eutra_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::tai_broadcast_eutra:
      j.start_array("tAIBroadcastEUTRA");
      for (const auto& e1 : c.get<tai_broadcast_eutra_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::emergency_area_id_broadcast_eutra:
      j.start_array("emergencyAreaIDBroadcastEUTRA");
      for (const auto& e1 : c.get<emergency_area_id_broadcast_eutra_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::cell_id_broadcast_nr:
      j.start_array("cellIDBroadcastNR");
      for (const auto& e1 : c.get<cell_id_broadcast_nr_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::tai_broadcast_nr:
      j.start_array("tAIBroadcastNR");
      for (const auto& e1 : c.get<tai_broadcast_nr_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::emergency_area_id_broadcast_nr:
      j.start_array("emergencyAreaIDBroadcastNR");
      for (const auto& e1 : c.get<emergency_area_id_broadcast_nr_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<broadcast_completed_area_list_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_completed_area_list_c");
  }
  j.end_obj();
}
SRSASN_CODE broadcast_completed_area_list_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::cell_id_broadcast_eutra:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<cell_id_broadcast_eutra_l>(), 1, 65535, true));
      break;
    case types::tai_broadcast_eutra:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<tai_broadcast_eutra_l>(), 1, 65535, true));
      break;
    case types::emergency_area_id_broadcast_eutra:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<emergency_area_id_broadcast_eutra_l>(), 1, 65535, true));
      break;
    case types::cell_id_broadcast_nr:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<cell_id_broadcast_nr_l>(), 1, 65535, true));
      break;
    case types::tai_broadcast_nr:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<tai_broadcast_nr_l>(), 1, 65535, true));
      break;
    case types::emergency_area_id_broadcast_nr:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<emergency_area_id_broadcast_nr_l>(), 1, 65535, true));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<broadcast_completed_area_list_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_completed_area_list_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_completed_area_list_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::cell_id_broadcast_eutra:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<cell_id_broadcast_eutra_l>(), bref, 1, 65535, true));
      break;
    case types::tai_broadcast_eutra:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<tai_broadcast_eutra_l>(), bref, 1, 65535, true));
      break;
    case types::emergency_area_id_broadcast_eutra:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<emergency_area_id_broadcast_eutra_l>(), bref, 1, 65535, true));
      break;
    case types::cell_id_broadcast_nr:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<cell_id_broadcast_nr_l>(), bref, 1, 65535, true));
      break;
    case types::tai_broadcast_nr:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<tai_broadcast_nr_l>(), bref, 1, 65535, true));
      break;
    case types::emergency_area_id_broadcast_nr:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<emergency_area_id_broadcast_nr_l>(), bref, 1, 65535, true));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<broadcast_completed_area_list_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_completed_area_list_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* broadcast_completed_area_list_c::types_opts::to_string() const
{
  static const char* names[] = {"cellIDBroadcastEUTRA",
                                "tAIBroadcastEUTRA",
                                "emergencyAreaIDBroadcastEUTRA",
                                "cellIDBroadcastNR",
                                "tAIBroadcastNR",
                                "emergencyAreaIDBroadcastNR",
                                "choice-Extensions"};
  return convert_enum_idx(names, 7, value, "broadcast_completed_area_list_c::types");
}

// TAINSAGSupportItem ::= SEQUENCE
SRSASN_CODE tai_nsag_support_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, nsag_id, (uint16_t)0u, (uint16_t)255u, true, true));
  HANDLE_CODE(pack_dyn_seq_of(bref, nsag_slice_support_list, 1, 65535, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE tai_nsag_support_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(nsag_id, bref, (uint16_t)0u, (uint16_t)255u, true, true));
  HANDLE_CODE(unpack_dyn_seq_of(nsag_slice_support_list, bref, 1, 65535, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void tai_nsag_support_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("nSAG-ID", nsag_id);
  j.start_array("nSAGSliceSupportList");
  for (const auto& e1 : nsag_slice_support_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// BroadcastPLMNItem-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t broadcast_plmn_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {258, 271, 353};
  return map_enum_number(names, 3, idx, "id");
}
bool broadcast_plmn_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {258, 271, 353};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e broadcast_plmn_item_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 258:
      return crit_e::reject;
    case 271:
      return crit_e::reject;
    case 353:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
broadcast_plmn_item_ext_ies_o::ext_c broadcast_plmn_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 258:
      ret.set(ext_c::types::npn_support);
      break;
    case 271:
      ret.set(ext_c::types::extended_tai_slice_support_list);
      break;
    case 353:
      ret.set(ext_c::types::tai_nsag_support_list);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e broadcast_plmn_item_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 258:
      return presence_e::optional;
    case 271:
      return presence_e::optional;
    case 353:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void broadcast_plmn_item_ext_ies_o::ext_c::destroy_()
{
  switch (type_) {
    case types::npn_support:
      c.destroy<npn_support_c>();
      break;
    case types::extended_tai_slice_support_list:
      c.destroy<extended_slice_support_list_l>();
      break;
    case types::tai_nsag_support_list:
      c.destroy<tai_nsag_support_list_l>();
      break;
    default:
      break;
  }
}
void broadcast_plmn_item_ext_ies_o::ext_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::npn_support:
      c.init<npn_support_c>();
      break;
    case types::extended_tai_slice_support_list:
      c.init<extended_slice_support_list_l>();
      break;
    case types::tai_nsag_support_list:
      c.init<tai_nsag_support_list_l>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_plmn_item_ext_ies_o::ext_c");
  }
}
broadcast_plmn_item_ext_ies_o::ext_c::ext_c(const broadcast_plmn_item_ext_ies_o::ext_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::npn_support:
      c.init(other.c.get<npn_support_c>());
      break;
    case types::extended_tai_slice_support_list:
      c.init(other.c.get<extended_slice_support_list_l>());
      break;
    case types::tai_nsag_support_list:
      c.init(other.c.get<tai_nsag_support_list_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_plmn_item_ext_ies_o::ext_c");
  }
}
broadcast_plmn_item_ext_ies_o::ext_c&
broadcast_plmn_item_ext_ies_o::ext_c::operator=(const broadcast_plmn_item_ext_ies_o::ext_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::npn_support:
      c.set(other.c.get<npn_support_c>());
      break;
    case types::extended_tai_slice_support_list:
      c.set(other.c.get<extended_slice_support_list_l>());
      break;
    case types::tai_nsag_support_list:
      c.set(other.c.get<tai_nsag_support_list_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_plmn_item_ext_ies_o::ext_c");
  }

  return *this;
}
npn_support_c& broadcast_plmn_item_ext_ies_o::ext_c::npn_support()
{
  assert_choice_type(types::npn_support, type_, "Extension");
  return c.get<npn_support_c>();
}
extended_slice_support_list_l& broadcast_plmn_item_ext_ies_o::ext_c::extended_tai_slice_support_list()
{
  assert_choice_type(types::extended_tai_slice_support_list, type_, "Extension");
  return c.get<extended_slice_support_list_l>();
}
tai_nsag_support_list_l& broadcast_plmn_item_ext_ies_o::ext_c::tai_nsag_support_list()
{
  assert_choice_type(types::tai_nsag_support_list, type_, "Extension");
  return c.get<tai_nsag_support_list_l>();
}
const npn_support_c& broadcast_plmn_item_ext_ies_o::ext_c::npn_support() const
{
  assert_choice_type(types::npn_support, type_, "Extension");
  return c.get<npn_support_c>();
}
const extended_slice_support_list_l& broadcast_plmn_item_ext_ies_o::ext_c::extended_tai_slice_support_list() const
{
  assert_choice_type(types::extended_tai_slice_support_list, type_, "Extension");
  return c.get<extended_slice_support_list_l>();
}
const tai_nsag_support_list_l& broadcast_plmn_item_ext_ies_o::ext_c::tai_nsag_support_list() const
{
  assert_choice_type(types::tai_nsag_support_list, type_, "Extension");
  return c.get<tai_nsag_support_list_l>();
}
void broadcast_plmn_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::npn_support:
      j.write_fieldname("NPN-Support");
      c.get<npn_support_c>().to_json(j);
      break;
    case types::extended_tai_slice_support_list:
      j.start_array("ExtendedSliceSupportList");
      for (const auto& e1 : c.get<extended_slice_support_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::tai_nsag_support_list:
      j.start_array("TAINSAGSupportList");
      for (const auto& e1 : c.get<tai_nsag_support_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_plmn_item_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE broadcast_plmn_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::npn_support:
      HANDLE_CODE(c.get<npn_support_c>().pack(bref));
      break;
    case types::extended_tai_slice_support_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<extended_slice_support_list_l>(), 1, 65535, true));
      break;
    case types::tai_nsag_support_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<tai_nsag_support_list_l>(), 1, 256, true));
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_plmn_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_plmn_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::npn_support:
      HANDLE_CODE(c.get<npn_support_c>().unpack(bref));
      break;
    case types::extended_tai_slice_support_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<extended_slice_support_list_l>(), bref, 1, 65535, true));
      break;
    case types::tai_nsag_support_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<tai_nsag_support_list_l>(), bref, 1, 256, true));
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_plmn_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* broadcast_plmn_item_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"NPN-Support", "ExtendedSliceSupportList", "TAINSAGSupportList"};
  return convert_enum_idx(names, 3, value, "broadcast_plmn_item_ext_ies_o::ext_c::types");
}

template struct asn1::protocol_ext_field_s<broadcast_plmn_item_ext_ies_o>;

broadcast_plmn_item_ext_ies_container::broadcast_plmn_item_ext_ies_container() :
  npn_support(258, crit_e::reject),
  extended_tai_slice_support_list(271, crit_e::reject),
  tai_nsag_support_list(353, crit_e::ignore)
{
}
SRSASN_CODE broadcast_plmn_item_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += npn_support_present ? 1 : 0;
  nof_ies += extended_tai_slice_support_list_present ? 1 : 0;
  nof_ies += tai_nsag_support_list_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (npn_support_present) {
    HANDLE_CODE(npn_support.pack(bref));
  }
  if (extended_tai_slice_support_list_present) {
    HANDLE_CODE(extended_tai_slice_support_list.pack(bref));
  }
  if (tai_nsag_support_list_present) {
    HANDLE_CODE(tai_nsag_support_list.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_plmn_item_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 258: {
        npn_support_present = true;
        npn_support.id      = id;
        HANDLE_CODE(npn_support.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(npn_support.ext.unpack(bref));
        break;
      }
      case 271: {
        extended_tai_slice_support_list_present = true;
        extended_tai_slice_support_list.id      = id;
        HANDLE_CODE(extended_tai_slice_support_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(extended_tai_slice_support_list.ext.unpack(bref));
        break;
      }
      case 353: {
        tai_nsag_support_list_present = true;
        tai_nsag_support_list.id      = id;
        HANDLE_CODE(tai_nsag_support_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(tai_nsag_support_list.ext.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void broadcast_plmn_item_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (npn_support_present) {
    j.write_fieldname("");
    npn_support.to_json(j);
  }
  if (extended_tai_slice_support_list_present) {
    j.write_fieldname("");
    extended_tai_slice_support_list.to_json(j);
  }
  if (tai_nsag_support_list_present) {
    j.write_fieldname("");
    tai_nsag_support_list.to_json(j);
  }
  j.end_obj();
}

// BroadcastPLMNItem ::= SEQUENCE
SRSASN_CODE broadcast_plmn_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.pack(bref));
  HANDLE_CODE(pack_dyn_seq_of(bref, tai_slice_support_list, 1, 1024, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_plmn_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.unpack(bref));
  HANDLE_CODE(unpack_dyn_seq_of(tai_slice_support_list, bref, 1, 1024, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void broadcast_plmn_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("pLMNIdentity", plmn_id.to_string());
  j.start_array("tAISliceSupportList");
  for (const auto& e1 : tai_slice_support_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MBS-SessionID ::= SEQUENCE
SRSASN_CODE mbs_session_id_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(nid_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(tmgi.pack(bref));
  if (nid_present) {
    HANDLE_CODE(nid.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mbs_session_id_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(nid_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(tmgi.unpack(bref));
  if (nid_present) {
    HANDLE_CODE(nid.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void mbs_session_id_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("tMGI", tmgi.to_string());
  if (nid_present) {
    j.write_str("nID", nid.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// BroadcastSessionModificationFailureIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t broadcast_session_mod_fail_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 348, 15, 19};
  return map_enum_number(names, 4, idx, "id");
}
bool broadcast_session_mod_fail_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 348, 15, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e broadcast_session_mod_fail_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::reject;
    case 348:
      return crit_e::reject;
    case 15:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
broadcast_session_mod_fail_ies_o::value_c broadcast_session_mod_fail_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 348:
      ret.set(value_c::types::mbs_session_mod_fail_transfer);
      break;
    case 15:
      ret.set(value_c::types::cause);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e broadcast_session_mod_fail_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 348:
      return presence_e::optional;
    case 15:
      return presence_e::mandatory;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void broadcast_session_mod_fail_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::mbs_session_id:
      c.destroy<mbs_session_id_s>();
      break;
    case types::mbs_session_mod_fail_transfer:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::cause:
      c.destroy<cause_c>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void broadcast_session_mod_fail_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c.init<mbs_session_id_s>();
      break;
    case types::mbs_session_mod_fail_transfer:
      c.init<unbounded_octstring<true>>();
      break;
    case types::cause:
      c.init<cause_c>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_mod_fail_ies_o::value_c");
  }
}
broadcast_session_mod_fail_ies_o::value_c::value_c(const broadcast_session_mod_fail_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mbs_session_id:
      c.init(other.c.get<mbs_session_id_s>());
      break;
    case types::mbs_session_mod_fail_transfer:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_mod_fail_ies_o::value_c");
  }
}
broadcast_session_mod_fail_ies_o::value_c&
broadcast_session_mod_fail_ies_o::value_c::operator=(const broadcast_session_mod_fail_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mbs_session_id:
      c.set(other.c.get<mbs_session_id_s>());
      break;
    case types::mbs_session_mod_fail_transfer:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_mod_fail_ies_o::value_c");
  }

  return *this;
}
mbs_session_id_s& broadcast_session_mod_fail_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
unbounded_octstring<true>& broadcast_session_mod_fail_ies_o::value_c::mbs_session_mod_fail_transfer()
{
  assert_choice_type(types::mbs_session_mod_fail_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
cause_c& broadcast_session_mod_fail_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
crit_diagnostics_s& broadcast_session_mod_fail_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const mbs_session_id_s& broadcast_session_mod_fail_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const unbounded_octstring<true>& broadcast_session_mod_fail_ies_o::value_c::mbs_session_mod_fail_transfer() const
{
  assert_choice_type(types::mbs_session_mod_fail_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const cause_c& broadcast_session_mod_fail_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const crit_diagnostics_s& broadcast_session_mod_fail_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void broadcast_session_mod_fail_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::mbs_session_mod_fail_transfer:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_mod_fail_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE broadcast_session_mod_fail_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::mbs_session_mod_fail_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_mod_fail_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_session_mod_fail_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::mbs_session_mod_fail_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_mod_fail_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* broadcast_session_mod_fail_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"MBS-SessionID", "OCTET STRING", "Cause", "CriticalityDiagnostics"};
  return convert_enum_idx(names, 4, value, "broadcast_session_mod_fail_ies_o::value_c::types");
}

template struct asn1::protocol_ie_field_s<broadcast_session_mod_fail_ies_o>;

broadcast_session_mod_fail_ies_container::broadcast_session_mod_fail_ies_container() :
  mbs_session_id(299, crit_e::reject),
  mbs_session_mod_fail_transfer(348, crit_e::reject),
  cause(15, crit_e::ignore),
  crit_diagnostics(19, crit_e::ignore)
{
}
SRSASN_CODE broadcast_session_mod_fail_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += mbs_session_mod_fail_transfer_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mbs_session_id.pack(bref));
  if (mbs_session_mod_fail_transfer_present) {
    HANDLE_CODE(mbs_session_mod_fail_transfer.pack(bref));
  }
  HANDLE_CODE(cause.pack(bref));
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_session_mod_fail_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        mbs_session_id.id = id;
        HANDLE_CODE(mbs_session_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.value.unpack(bref));
        break;
      }
      case 348: {
        mbs_session_mod_fail_transfer_present = true;
        mbs_session_mod_fail_transfer.id      = id;
        HANDLE_CODE(mbs_session_mod_fail_transfer.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_mod_fail_transfer.value.unpack(bref));
        break;
      }
      case 15: {
        nof_mandatory_ies--;
        cause.id = id;
        HANDLE_CODE(cause.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.value.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        crit_diagnostics.id      = id;
        HANDLE_CODE(crit_diagnostics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void broadcast_session_mod_fail_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mbs_session_id.to_json(j);
  if (mbs_session_mod_fail_transfer_present) {
    j.write_fieldname("");
    mbs_session_mod_fail_transfer.to_json(j);
  }
  j.write_fieldname("");
  cause.to_json(j);
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

// MBS-ServiceAreaInformation ::= SEQUENCE
SRSASN_CODE mbs_service_area_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(mbs_service_area_cell_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(mbs_service_area_tai_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (mbs_service_area_cell_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, mbs_service_area_cell_list, 1, 8192, true));
  }
  if (mbs_service_area_tai_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, mbs_service_area_tai_list, 1, 1024, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mbs_service_area_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool mbs_service_area_cell_list_present;
  HANDLE_CODE(bref.unpack(mbs_service_area_cell_list_present, 1));
  bool mbs_service_area_tai_list_present;
  HANDLE_CODE(bref.unpack(mbs_service_area_tai_list_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (mbs_service_area_cell_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(mbs_service_area_cell_list, bref, 1, 8192, true));
  }
  if (mbs_service_area_tai_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(mbs_service_area_tai_list, bref, 1, 1024, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void mbs_service_area_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (mbs_service_area_cell_list.size() > 0) {
    j.start_array("mBS-ServiceAreaCellList");
    for (const auto& e1 : mbs_service_area_cell_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (mbs_service_area_tai_list.size() > 0) {
    j.start_array("mBS-ServiceAreaTAIList");
    for (const auto& e1 : mbs_service_area_tai_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MBS-ServiceAreaInformationItem ::= SEQUENCE
SRSASN_CODE mbs_service_area_info_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, mbs_area_session_id, (uint32_t)0u, (uint32_t)65535u, true, true));
  HANDLE_CODE(mbs_service_area_info.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mbs_service_area_info_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(mbs_area_session_id, bref, (uint32_t)0u, (uint32_t)65535u, true, true));
  HANDLE_CODE(mbs_service_area_info.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void mbs_service_area_info_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("mBS-AreaSessionID", mbs_area_session_id);
  j.write_fieldname("mBS-ServiceAreaInformation");
  mbs_service_area_info.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MBS-ServiceArea ::= CHOICE
void mbs_service_area_c::destroy_()
{
  switch (type_) {
    case types::locationindependent:
      c.destroy<mbs_service_area_info_s>();
      break;
    case types::locationdependent:
      c.destroy<mbs_service_area_info_list_l>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<mbs_service_area_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void mbs_service_area_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::locationindependent:
      c.init<mbs_service_area_info_s>();
      break;
    case types::locationdependent:
      c.init<mbs_service_area_info_list_l>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<mbs_service_area_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "mbs_service_area_c");
  }
}
mbs_service_area_c::mbs_service_area_c(const mbs_service_area_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::locationindependent:
      c.init(other.c.get<mbs_service_area_info_s>());
      break;
    case types::locationdependent:
      c.init(other.c.get<mbs_service_area_info_list_l>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<mbs_service_area_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "mbs_service_area_c");
  }
}
mbs_service_area_c& mbs_service_area_c::operator=(const mbs_service_area_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::locationindependent:
      c.set(other.c.get<mbs_service_area_info_s>());
      break;
    case types::locationdependent:
      c.set(other.c.get<mbs_service_area_info_list_l>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<mbs_service_area_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "mbs_service_area_c");
  }

  return *this;
}
mbs_service_area_info_s& mbs_service_area_c::set_locationindependent()
{
  set(types::locationindependent);
  return c.get<mbs_service_area_info_s>();
}
mbs_service_area_info_list_l& mbs_service_area_c::set_locationdependent()
{
  set(types::locationdependent);
  return c.get<mbs_service_area_info_list_l>();
}
protocol_ie_single_container_s<mbs_service_area_ext_ies_o>& mbs_service_area_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<mbs_service_area_ext_ies_o>>();
}
void mbs_service_area_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::locationindependent:
      j.write_fieldname("locationindependent");
      c.get<mbs_service_area_info_s>().to_json(j);
      break;
    case types::locationdependent:
      j.start_array("locationdependent");
      for (const auto& e1 : c.get<mbs_service_area_info_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<mbs_service_area_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "mbs_service_area_c");
  }
  j.end_obj();
}
SRSASN_CODE mbs_service_area_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::locationindependent:
      HANDLE_CODE(c.get<mbs_service_area_info_s>().pack(bref));
      break;
    case types::locationdependent:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<mbs_service_area_info_list_l>(), 1, 256, true));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<mbs_service_area_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "mbs_service_area_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE mbs_service_area_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::locationindependent:
      HANDLE_CODE(c.get<mbs_service_area_info_s>().unpack(bref));
      break;
    case types::locationdependent:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<mbs_service_area_info_list_l>(), bref, 1, 256, true));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<mbs_service_area_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "mbs_service_area_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* mbs_service_area_c::types_opts::to_string() const
{
  static const char* names[] = {"locationindependent", "locationdependent", "choice-Extensions"};
  return convert_enum_idx(names, 3, value, "mbs_service_area_c::types");
}

// BroadcastSessionModificationRequestIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t broadcast_session_mod_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 298, 349};
  return map_enum_number(names, 3, idx, "id");
}
bool broadcast_session_mod_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 298, 349};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e broadcast_session_mod_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::reject;
    case 298:
      return crit_e::reject;
    case 349:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
broadcast_session_mod_request_ies_o::value_c broadcast_session_mod_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 298:
      ret.set(value_c::types::mbs_service_area);
      break;
    case 349:
      ret.set(value_c::types::mbs_session_mod_request_transfer);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e broadcast_session_mod_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 298:
      return presence_e::optional;
    case 349:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void broadcast_session_mod_request_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::mbs_session_id:
      c.destroy<mbs_session_id_s>();
      break;
    case types::mbs_service_area:
      c.destroy<mbs_service_area_c>();
      break;
    case types::mbs_session_mod_request_transfer:
      c.destroy<unbounded_octstring<true>>();
      break;
    default:
      break;
  }
}
void broadcast_session_mod_request_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c.init<mbs_session_id_s>();
      break;
    case types::mbs_service_area:
      c.init<mbs_service_area_c>();
      break;
    case types::mbs_session_mod_request_transfer:
      c.init<unbounded_octstring<true>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_mod_request_ies_o::value_c");
  }
}
broadcast_session_mod_request_ies_o::value_c::value_c(const broadcast_session_mod_request_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mbs_session_id:
      c.init(other.c.get<mbs_session_id_s>());
      break;
    case types::mbs_service_area:
      c.init(other.c.get<mbs_service_area_c>());
      break;
    case types::mbs_session_mod_request_transfer:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_mod_request_ies_o::value_c");
  }
}
broadcast_session_mod_request_ies_o::value_c&
broadcast_session_mod_request_ies_o::value_c::operator=(const broadcast_session_mod_request_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mbs_session_id:
      c.set(other.c.get<mbs_session_id_s>());
      break;
    case types::mbs_service_area:
      c.set(other.c.get<mbs_service_area_c>());
      break;
    case types::mbs_session_mod_request_transfer:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_mod_request_ies_o::value_c");
  }

  return *this;
}
mbs_session_id_s& broadcast_session_mod_request_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
mbs_service_area_c& broadcast_session_mod_request_ies_o::value_c::mbs_service_area()
{
  assert_choice_type(types::mbs_service_area, type_, "Value");
  return c.get<mbs_service_area_c>();
}
unbounded_octstring<true>& broadcast_session_mod_request_ies_o::value_c::mbs_session_mod_request_transfer()
{
  assert_choice_type(types::mbs_session_mod_request_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const mbs_session_id_s& broadcast_session_mod_request_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const mbs_service_area_c& broadcast_session_mod_request_ies_o::value_c::mbs_service_area() const
{
  assert_choice_type(types::mbs_service_area, type_, "Value");
  return c.get<mbs_service_area_c>();
}
const unbounded_octstring<true>& broadcast_session_mod_request_ies_o::value_c::mbs_session_mod_request_transfer() const
{
  assert_choice_type(types::mbs_session_mod_request_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
void broadcast_session_mod_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::mbs_service_area:
      j.write_fieldname("MBS-ServiceArea");
      c.get<mbs_service_area_c>().to_json(j);
      break;
    case types::mbs_session_mod_request_transfer:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_mod_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE broadcast_session_mod_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::mbs_service_area:
      HANDLE_CODE(c.get<mbs_service_area_c>().pack(bref));
      break;
    case types::mbs_session_mod_request_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_mod_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_session_mod_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::mbs_service_area:
      HANDLE_CODE(c.get<mbs_service_area_c>().unpack(bref));
      break;
    case types::mbs_session_mod_request_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_mod_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* broadcast_session_mod_request_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"MBS-SessionID", "MBS-ServiceArea", "OCTET STRING"};
  return convert_enum_idx(names, 3, value, "broadcast_session_mod_request_ies_o::value_c::types");
}

template struct asn1::protocol_ie_field_s<broadcast_session_mod_request_ies_o>;

broadcast_session_mod_request_ies_container::broadcast_session_mod_request_ies_container() :
  mbs_session_id(299, crit_e::reject),
  mbs_service_area(298, crit_e::reject),
  mbs_session_mod_request_transfer(349, crit_e::reject)
{
}
SRSASN_CODE broadcast_session_mod_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 1;
  nof_ies += mbs_service_area_present ? 1 : 0;
  nof_ies += mbs_session_mod_request_transfer_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mbs_session_id.pack(bref));
  if (mbs_service_area_present) {
    HANDLE_CODE(mbs_service_area.pack(bref));
  }
  if (mbs_session_mod_request_transfer_present) {
    HANDLE_CODE(mbs_session_mod_request_transfer.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_session_mod_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 1;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        mbs_session_id.id = id;
        HANDLE_CODE(mbs_session_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.value.unpack(bref));
        break;
      }
      case 298: {
        mbs_service_area_present = true;
        mbs_service_area.id      = id;
        HANDLE_CODE(mbs_service_area.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_service_area.value.unpack(bref));
        break;
      }
      case 349: {
        mbs_session_mod_request_transfer_present = true;
        mbs_session_mod_request_transfer.id      = id;
        HANDLE_CODE(mbs_session_mod_request_transfer.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_mod_request_transfer.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void broadcast_session_mod_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mbs_session_id.to_json(j);
  if (mbs_service_area_present) {
    j.write_fieldname("");
    mbs_service_area.to_json(j);
  }
  if (mbs_session_mod_request_transfer_present) {
    j.write_fieldname("");
    mbs_session_mod_request_transfer.to_json(j);
  }
  j.end_obj();
}

// BroadcastSessionModificationResponseIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t broadcast_session_mod_resp_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 350, 19};
  return map_enum_number(names, 3, idx, "id");
}
bool broadcast_session_mod_resp_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 350, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e broadcast_session_mod_resp_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::reject;
    case 350:
      return crit_e::reject;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
broadcast_session_mod_resp_ies_o::value_c broadcast_session_mod_resp_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 350:
      ret.set(value_c::types::mbs_session_mod_resp_transfer);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e broadcast_session_mod_resp_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 350:
      return presence_e::optional;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void broadcast_session_mod_resp_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::mbs_session_id:
      c.destroy<mbs_session_id_s>();
      break;
    case types::mbs_session_mod_resp_transfer:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void broadcast_session_mod_resp_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c.init<mbs_session_id_s>();
      break;
    case types::mbs_session_mod_resp_transfer:
      c.init<unbounded_octstring<true>>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_mod_resp_ies_o::value_c");
  }
}
broadcast_session_mod_resp_ies_o::value_c::value_c(const broadcast_session_mod_resp_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mbs_session_id:
      c.init(other.c.get<mbs_session_id_s>());
      break;
    case types::mbs_session_mod_resp_transfer:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_mod_resp_ies_o::value_c");
  }
}
broadcast_session_mod_resp_ies_o::value_c&
broadcast_session_mod_resp_ies_o::value_c::operator=(const broadcast_session_mod_resp_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mbs_session_id:
      c.set(other.c.get<mbs_session_id_s>());
      break;
    case types::mbs_session_mod_resp_transfer:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_mod_resp_ies_o::value_c");
  }

  return *this;
}
mbs_session_id_s& broadcast_session_mod_resp_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
unbounded_octstring<true>& broadcast_session_mod_resp_ies_o::value_c::mbs_session_mod_resp_transfer()
{
  assert_choice_type(types::mbs_session_mod_resp_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
crit_diagnostics_s& broadcast_session_mod_resp_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const mbs_session_id_s& broadcast_session_mod_resp_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const unbounded_octstring<true>& broadcast_session_mod_resp_ies_o::value_c::mbs_session_mod_resp_transfer() const
{
  assert_choice_type(types::mbs_session_mod_resp_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const crit_diagnostics_s& broadcast_session_mod_resp_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void broadcast_session_mod_resp_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::mbs_session_mod_resp_transfer:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_mod_resp_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE broadcast_session_mod_resp_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::mbs_session_mod_resp_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_mod_resp_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_session_mod_resp_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::mbs_session_mod_resp_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_mod_resp_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* broadcast_session_mod_resp_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"MBS-SessionID", "OCTET STRING", "CriticalityDiagnostics"};
  return convert_enum_idx(names, 3, value, "broadcast_session_mod_resp_ies_o::value_c::types");
}

template struct asn1::protocol_ie_field_s<broadcast_session_mod_resp_ies_o>;

broadcast_session_mod_resp_ies_container::broadcast_session_mod_resp_ies_container() :
  mbs_session_id(299, crit_e::reject),
  mbs_session_mod_resp_transfer(350, crit_e::reject),
  crit_diagnostics(19, crit_e::ignore)
{
}
SRSASN_CODE broadcast_session_mod_resp_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 1;
  nof_ies += mbs_session_mod_resp_transfer_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mbs_session_id.pack(bref));
  if (mbs_session_mod_resp_transfer_present) {
    HANDLE_CODE(mbs_session_mod_resp_transfer.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_session_mod_resp_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 1;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        mbs_session_id.id = id;
        HANDLE_CODE(mbs_session_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.value.unpack(bref));
        break;
      }
      case 350: {
        mbs_session_mod_resp_transfer_present = true;
        mbs_session_mod_resp_transfer.id      = id;
        HANDLE_CODE(mbs_session_mod_resp_transfer.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_mod_resp_transfer.value.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        crit_diagnostics.id      = id;
        HANDLE_CODE(crit_diagnostics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void broadcast_session_mod_resp_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mbs_session_id.to_json(j);
  if (mbs_session_mod_resp_transfer_present) {
    j.write_fieldname("");
    mbs_session_mod_resp_transfer.to_json(j);
  }
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

// BroadcastSessionReleaseRequestIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t broadcast_session_release_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 15};
  return map_enum_number(names, 2, idx, "id");
}
bool broadcast_session_release_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 15};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e broadcast_session_release_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::reject;
    case 15:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
broadcast_session_release_request_ies_o::value_c broadcast_session_release_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 15:
      ret.set(value_c::types::cause);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e broadcast_session_release_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 15:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void broadcast_session_release_request_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::mbs_session_id:
      c.destroy<mbs_session_id_s>();
      break;
    case types::cause:
      c.destroy<cause_c>();
      break;
    default:
      break;
  }
}
void broadcast_session_release_request_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c.init<mbs_session_id_s>();
      break;
    case types::cause:
      c.init<cause_c>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_release_request_ies_o::value_c");
  }
}
broadcast_session_release_request_ies_o::value_c::value_c(const broadcast_session_release_request_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mbs_session_id:
      c.init(other.c.get<mbs_session_id_s>());
      break;
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_release_request_ies_o::value_c");
  }
}
broadcast_session_release_request_ies_o::value_c& broadcast_session_release_request_ies_o::value_c::operator=(
    const broadcast_session_release_request_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mbs_session_id:
      c.set(other.c.get<mbs_session_id_s>());
      break;
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_release_request_ies_o::value_c");
  }

  return *this;
}
mbs_session_id_s& broadcast_session_release_request_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
cause_c& broadcast_session_release_request_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const mbs_session_id_s& broadcast_session_release_request_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const cause_c& broadcast_session_release_request_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
void broadcast_session_release_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_release_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE broadcast_session_release_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_release_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_session_release_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_release_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* broadcast_session_release_request_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"MBS-SessionID", "Cause"};
  return convert_enum_idx(names, 2, value, "broadcast_session_release_request_ies_o::value_c::types");
}

template struct asn1::protocol_ie_field_s<broadcast_session_release_request_ies_o>;

broadcast_session_release_request_ies_container::broadcast_session_release_request_ies_container() :
  mbs_session_id(299, crit_e::reject), cause(15, crit_e::ignore)
{
}
SRSASN_CODE broadcast_session_release_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mbs_session_id.pack(bref));
  HANDLE_CODE(cause.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_session_release_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        mbs_session_id.id = id;
        HANDLE_CODE(mbs_session_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.value.unpack(bref));
        break;
      }
      case 15: {
        nof_mandatory_ies--;
        cause.id = id;
        HANDLE_CODE(cause.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void broadcast_session_release_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mbs_session_id.to_json(j);
  j.write_fieldname("");
  cause.to_json(j);
  j.end_obj();
}

// BroadcastSessionReleaseRequiredIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t broadcast_session_release_required_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 15};
  return map_enum_number(names, 2, idx, "id");
}
bool broadcast_session_release_required_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 15};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e broadcast_session_release_required_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::reject;
    case 15:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
broadcast_session_release_required_ies_o::value_c
broadcast_session_release_required_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 15:
      ret.set(value_c::types::cause);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e broadcast_session_release_required_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 15:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void broadcast_session_release_required_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::mbs_session_id:
      c.destroy<mbs_session_id_s>();
      break;
    case types::cause:
      c.destroy<cause_c>();
      break;
    default:
      break;
  }
}
void broadcast_session_release_required_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c.init<mbs_session_id_s>();
      break;
    case types::cause:
      c.init<cause_c>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_release_required_ies_o::value_c");
  }
}
broadcast_session_release_required_ies_o::value_c::value_c(
    const broadcast_session_release_required_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mbs_session_id:
      c.init(other.c.get<mbs_session_id_s>());
      break;
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_release_required_ies_o::value_c");
  }
}
broadcast_session_release_required_ies_o::value_c& broadcast_session_release_required_ies_o::value_c::operator=(
    const broadcast_session_release_required_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mbs_session_id:
      c.set(other.c.get<mbs_session_id_s>());
      break;
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_release_required_ies_o::value_c");
  }

  return *this;
}
mbs_session_id_s& broadcast_session_release_required_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
cause_c& broadcast_session_release_required_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const mbs_session_id_s& broadcast_session_release_required_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const cause_c& broadcast_session_release_required_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
void broadcast_session_release_required_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_release_required_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE broadcast_session_release_required_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_release_required_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_session_release_required_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_release_required_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* broadcast_session_release_required_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"MBS-SessionID", "Cause"};
  return convert_enum_idx(names, 2, value, "broadcast_session_release_required_ies_o::value_c::types");
}

template struct asn1::protocol_ie_field_s<broadcast_session_release_required_ies_o>;

broadcast_session_release_required_ies_container::broadcast_session_release_required_ies_container() :
  mbs_session_id(299, crit_e::reject), cause(15, crit_e::ignore)
{
}
SRSASN_CODE broadcast_session_release_required_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mbs_session_id.pack(bref));
  HANDLE_CODE(cause.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_session_release_required_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        mbs_session_id.id = id;
        HANDLE_CODE(mbs_session_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.value.unpack(bref));
        break;
      }
      case 15: {
        nof_mandatory_ies--;
        cause.id = id;
        HANDLE_CODE(cause.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void broadcast_session_release_required_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mbs_session_id.to_json(j);
  j.write_fieldname("");
  cause.to_json(j);
  j.end_obj();
}

// BroadcastSessionReleaseResponseIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t broadcast_session_release_resp_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 358, 19};
  return map_enum_number(names, 3, idx, "id");
}
bool broadcast_session_release_resp_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 358, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e broadcast_session_release_resp_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::reject;
    case 358:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
broadcast_session_release_resp_ies_o::value_c broadcast_session_release_resp_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 358:
      ret.set(value_c::types::mbs_session_release_resp_transfer);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e broadcast_session_release_resp_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 358:
      return presence_e::optional;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void broadcast_session_release_resp_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::mbs_session_id:
      c.destroy<mbs_session_id_s>();
      break;
    case types::mbs_session_release_resp_transfer:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void broadcast_session_release_resp_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c.init<mbs_session_id_s>();
      break;
    case types::mbs_session_release_resp_transfer:
      c.init<unbounded_octstring<true>>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_release_resp_ies_o::value_c");
  }
}
broadcast_session_release_resp_ies_o::value_c::value_c(const broadcast_session_release_resp_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mbs_session_id:
      c.init(other.c.get<mbs_session_id_s>());
      break;
    case types::mbs_session_release_resp_transfer:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_release_resp_ies_o::value_c");
  }
}
broadcast_session_release_resp_ies_o::value_c&
broadcast_session_release_resp_ies_o::value_c::operator=(const broadcast_session_release_resp_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mbs_session_id:
      c.set(other.c.get<mbs_session_id_s>());
      break;
    case types::mbs_session_release_resp_transfer:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_release_resp_ies_o::value_c");
  }

  return *this;
}
mbs_session_id_s& broadcast_session_release_resp_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
unbounded_octstring<true>& broadcast_session_release_resp_ies_o::value_c::mbs_session_release_resp_transfer()
{
  assert_choice_type(types::mbs_session_release_resp_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
crit_diagnostics_s& broadcast_session_release_resp_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const mbs_session_id_s& broadcast_session_release_resp_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const unbounded_octstring<true>&
broadcast_session_release_resp_ies_o::value_c::mbs_session_release_resp_transfer() const
{
  assert_choice_type(types::mbs_session_release_resp_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const crit_diagnostics_s& broadcast_session_release_resp_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void broadcast_session_release_resp_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::mbs_session_release_resp_transfer:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_release_resp_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE broadcast_session_release_resp_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::mbs_session_release_resp_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_release_resp_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_session_release_resp_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::mbs_session_release_resp_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_release_resp_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* broadcast_session_release_resp_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"MBS-SessionID", "OCTET STRING", "CriticalityDiagnostics"};
  return convert_enum_idx(names, 3, value, "broadcast_session_release_resp_ies_o::value_c::types");
}

template struct asn1::protocol_ie_field_s<broadcast_session_release_resp_ies_o>;

broadcast_session_release_resp_ies_container::broadcast_session_release_resp_ies_container() :
  mbs_session_id(299, crit_e::reject),
  mbs_session_release_resp_transfer(358, crit_e::ignore),
  crit_diagnostics(19, crit_e::ignore)
{
}
SRSASN_CODE broadcast_session_release_resp_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 1;
  nof_ies += mbs_session_release_resp_transfer_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mbs_session_id.pack(bref));
  if (mbs_session_release_resp_transfer_present) {
    HANDLE_CODE(mbs_session_release_resp_transfer.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_session_release_resp_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 1;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        mbs_session_id.id = id;
        HANDLE_CODE(mbs_session_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.value.unpack(bref));
        break;
      }
      case 358: {
        mbs_session_release_resp_transfer_present = true;
        mbs_session_release_resp_transfer.id      = id;
        HANDLE_CODE(mbs_session_release_resp_transfer.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_release_resp_transfer.value.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        crit_diagnostics.id      = id;
        HANDLE_CODE(crit_diagnostics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void broadcast_session_release_resp_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mbs_session_id.to_json(j);
  if (mbs_session_release_resp_transfer_present) {
    j.write_fieldname("");
    mbs_session_release_resp_transfer.to_json(j);
  }
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

// BroadcastSessionSetupFailureIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t broadcast_session_setup_fail_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 314, 15, 19};
  return map_enum_number(names, 4, idx, "id");
}
bool broadcast_session_setup_fail_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 314, 15, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e broadcast_session_setup_fail_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::reject;
    case 314:
      return crit_e::reject;
    case 15:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
broadcast_session_setup_fail_ies_o::value_c broadcast_session_setup_fail_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 314:
      ret.set(value_c::types::mbs_session_setup_fail_transfer);
      break;
    case 15:
      ret.set(value_c::types::cause);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e broadcast_session_setup_fail_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 314:
      return presence_e::optional;
    case 15:
      return presence_e::mandatory;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void broadcast_session_setup_fail_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::mbs_session_id:
      c.destroy<mbs_session_id_s>();
      break;
    case types::mbs_session_setup_fail_transfer:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::cause:
      c.destroy<cause_c>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void broadcast_session_setup_fail_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c.init<mbs_session_id_s>();
      break;
    case types::mbs_session_setup_fail_transfer:
      c.init<unbounded_octstring<true>>();
      break;
    case types::cause:
      c.init<cause_c>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_setup_fail_ies_o::value_c");
  }
}
broadcast_session_setup_fail_ies_o::value_c::value_c(const broadcast_session_setup_fail_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mbs_session_id:
      c.init(other.c.get<mbs_session_id_s>());
      break;
    case types::mbs_session_setup_fail_transfer:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_setup_fail_ies_o::value_c");
  }
}
broadcast_session_setup_fail_ies_o::value_c&
broadcast_session_setup_fail_ies_o::value_c::operator=(const broadcast_session_setup_fail_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mbs_session_id:
      c.set(other.c.get<mbs_session_id_s>());
      break;
    case types::mbs_session_setup_fail_transfer:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_setup_fail_ies_o::value_c");
  }

  return *this;
}
mbs_session_id_s& broadcast_session_setup_fail_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
unbounded_octstring<true>& broadcast_session_setup_fail_ies_o::value_c::mbs_session_setup_fail_transfer()
{
  assert_choice_type(types::mbs_session_setup_fail_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
cause_c& broadcast_session_setup_fail_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
crit_diagnostics_s& broadcast_session_setup_fail_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const mbs_session_id_s& broadcast_session_setup_fail_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const unbounded_octstring<true>& broadcast_session_setup_fail_ies_o::value_c::mbs_session_setup_fail_transfer() const
{
  assert_choice_type(types::mbs_session_setup_fail_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const cause_c& broadcast_session_setup_fail_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const crit_diagnostics_s& broadcast_session_setup_fail_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void broadcast_session_setup_fail_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::mbs_session_setup_fail_transfer:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_setup_fail_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE broadcast_session_setup_fail_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::mbs_session_setup_fail_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_setup_fail_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_session_setup_fail_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::mbs_session_setup_fail_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_setup_fail_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* broadcast_session_setup_fail_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"MBS-SessionID", "OCTET STRING", "Cause", "CriticalityDiagnostics"};
  return convert_enum_idx(names, 4, value, "broadcast_session_setup_fail_ies_o::value_c::types");
}

template struct asn1::protocol_ie_field_s<broadcast_session_setup_fail_ies_o>;

broadcast_session_setup_fail_ies_container::broadcast_session_setup_fail_ies_container() :
  mbs_session_id(299, crit_e::reject),
  mbs_session_setup_fail_transfer(314, crit_e::reject),
  cause(15, crit_e::ignore),
  crit_diagnostics(19, crit_e::ignore)
{
}
SRSASN_CODE broadcast_session_setup_fail_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += mbs_session_setup_fail_transfer_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mbs_session_id.pack(bref));
  if (mbs_session_setup_fail_transfer_present) {
    HANDLE_CODE(mbs_session_setup_fail_transfer.pack(bref));
  }
  HANDLE_CODE(cause.pack(bref));
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_session_setup_fail_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        mbs_session_id.id = id;
        HANDLE_CODE(mbs_session_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.value.unpack(bref));
        break;
      }
      case 314: {
        mbs_session_setup_fail_transfer_present = true;
        mbs_session_setup_fail_transfer.id      = id;
        HANDLE_CODE(mbs_session_setup_fail_transfer.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_setup_fail_transfer.value.unpack(bref));
        break;
      }
      case 15: {
        nof_mandatory_ies--;
        cause.id = id;
        HANDLE_CODE(cause.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.value.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        crit_diagnostics.id      = id;
        HANDLE_CODE(crit_diagnostics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void broadcast_session_setup_fail_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mbs_session_id.to_json(j);
  if (mbs_session_setup_fail_transfer_present) {
    j.write_fieldname("");
    mbs_session_setup_fail_transfer.to_json(j);
  }
  j.write_fieldname("");
  cause.to_json(j);
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

// BroadcastSessionSetupRequestIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t broadcast_session_setup_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 148, 298, 315};
  return map_enum_number(names, 4, idx, "id");
}
bool broadcast_session_setup_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 148, 298, 315};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e broadcast_session_setup_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::reject;
    case 148:
      return crit_e::reject;
    case 298:
      return crit_e::reject;
    case 315:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
broadcast_session_setup_request_ies_o::value_c broadcast_session_setup_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 148:
      ret.set(value_c::types::s_nssai);
      break;
    case 298:
      ret.set(value_c::types::mbs_service_area);
      break;
    case 315:
      ret.set(value_c::types::mbs_session_setup_request_transfer);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e broadcast_session_setup_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 148:
      return presence_e::mandatory;
    case 298:
      return presence_e::mandatory;
    case 315:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void broadcast_session_setup_request_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::mbs_session_id:
      c.destroy<mbs_session_id_s>();
      break;
    case types::s_nssai:
      c.destroy<s_nssai_s>();
      break;
    case types::mbs_service_area:
      c.destroy<mbs_service_area_c>();
      break;
    case types::mbs_session_setup_request_transfer:
      c.destroy<unbounded_octstring<true>>();
      break;
    default:
      break;
  }
}
void broadcast_session_setup_request_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c.init<mbs_session_id_s>();
      break;
    case types::s_nssai:
      c.init<s_nssai_s>();
      break;
    case types::mbs_service_area:
      c.init<mbs_service_area_c>();
      break;
    case types::mbs_session_setup_request_transfer:
      c.init<unbounded_octstring<true>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_setup_request_ies_o::value_c");
  }
}
broadcast_session_setup_request_ies_o::value_c::value_c(const broadcast_session_setup_request_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mbs_session_id:
      c.init(other.c.get<mbs_session_id_s>());
      break;
    case types::s_nssai:
      c.init(other.c.get<s_nssai_s>());
      break;
    case types::mbs_service_area:
      c.init(other.c.get<mbs_service_area_c>());
      break;
    case types::mbs_session_setup_request_transfer:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_setup_request_ies_o::value_c");
  }
}
broadcast_session_setup_request_ies_o::value_c&
broadcast_session_setup_request_ies_o::value_c::operator=(const broadcast_session_setup_request_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mbs_session_id:
      c.set(other.c.get<mbs_session_id_s>());
      break;
    case types::s_nssai:
      c.set(other.c.get<s_nssai_s>());
      break;
    case types::mbs_service_area:
      c.set(other.c.get<mbs_service_area_c>());
      break;
    case types::mbs_session_setup_request_transfer:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_setup_request_ies_o::value_c");
  }

  return *this;
}
mbs_session_id_s& broadcast_session_setup_request_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
s_nssai_s& broadcast_session_setup_request_ies_o::value_c::s_nssai()
{
  assert_choice_type(types::s_nssai, type_, "Value");
  return c.get<s_nssai_s>();
}
mbs_service_area_c& broadcast_session_setup_request_ies_o::value_c::mbs_service_area()
{
  assert_choice_type(types::mbs_service_area, type_, "Value");
  return c.get<mbs_service_area_c>();
}
unbounded_octstring<true>& broadcast_session_setup_request_ies_o::value_c::mbs_session_setup_request_transfer()
{
  assert_choice_type(types::mbs_session_setup_request_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const mbs_session_id_s& broadcast_session_setup_request_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const s_nssai_s& broadcast_session_setup_request_ies_o::value_c::s_nssai() const
{
  assert_choice_type(types::s_nssai, type_, "Value");
  return c.get<s_nssai_s>();
}
const mbs_service_area_c& broadcast_session_setup_request_ies_o::value_c::mbs_service_area() const
{
  assert_choice_type(types::mbs_service_area, type_, "Value");
  return c.get<mbs_service_area_c>();
}
const unbounded_octstring<true>&
broadcast_session_setup_request_ies_o::value_c::mbs_session_setup_request_transfer() const
{
  assert_choice_type(types::mbs_session_setup_request_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
void broadcast_session_setup_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::s_nssai:
      j.write_fieldname("S-NSSAI");
      c.get<s_nssai_s>().to_json(j);
      break;
    case types::mbs_service_area:
      j.write_fieldname("MBS-ServiceArea");
      c.get<mbs_service_area_c>().to_json(j);
      break;
    case types::mbs_session_setup_request_transfer:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_setup_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE broadcast_session_setup_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::s_nssai:
      HANDLE_CODE(c.get<s_nssai_s>().pack(bref));
      break;
    case types::mbs_service_area:
      HANDLE_CODE(c.get<mbs_service_area_c>().pack(bref));
      break;
    case types::mbs_session_setup_request_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_setup_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_session_setup_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::s_nssai:
      HANDLE_CODE(c.get<s_nssai_s>().unpack(bref));
      break;
    case types::mbs_service_area:
      HANDLE_CODE(c.get<mbs_service_area_c>().unpack(bref));
      break;
    case types::mbs_session_setup_request_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_setup_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* broadcast_session_setup_request_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"MBS-SessionID", "S-NSSAI", "MBS-ServiceArea", "OCTET STRING"};
  return convert_enum_idx(names, 4, value, "broadcast_session_setup_request_ies_o::value_c::types");
}

template struct asn1::protocol_ie_field_s<broadcast_session_setup_request_ies_o>;

broadcast_session_setup_request_ies_container::broadcast_session_setup_request_ies_container() :
  mbs_session_id(299, crit_e::reject),
  s_nssai(148, crit_e::reject),
  mbs_service_area(298, crit_e::reject),
  mbs_session_setup_request_transfer(315, crit_e::reject)
{
}
SRSASN_CODE broadcast_session_setup_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 4;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mbs_session_id.pack(bref));
  HANDLE_CODE(s_nssai.pack(bref));
  HANDLE_CODE(mbs_service_area.pack(bref));
  HANDLE_CODE(mbs_session_setup_request_transfer.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_session_setup_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 4;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        mbs_session_id.id = id;
        HANDLE_CODE(mbs_session_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.value.unpack(bref));
        break;
      }
      case 148: {
        nof_mandatory_ies--;
        s_nssai.id = id;
        HANDLE_CODE(s_nssai.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(s_nssai.value.unpack(bref));
        break;
      }
      case 298: {
        nof_mandatory_ies--;
        mbs_service_area.id = id;
        HANDLE_CODE(mbs_service_area.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_service_area.value.unpack(bref));
        break;
      }
      case 315: {
        nof_mandatory_ies--;
        mbs_session_setup_request_transfer.id = id;
        HANDLE_CODE(mbs_session_setup_request_transfer.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_setup_request_transfer.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void broadcast_session_setup_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mbs_session_id.to_json(j);
  j.write_fieldname("");
  s_nssai.to_json(j);
  j.write_fieldname("");
  mbs_service_area.to_json(j);
  j.write_fieldname("");
  mbs_session_setup_request_transfer.to_json(j);
  j.end_obj();
}

// BroadcastSessionSetupResponseIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t broadcast_session_setup_resp_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 316, 19};
  return map_enum_number(names, 3, idx, "id");
}
bool broadcast_session_setup_resp_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 316, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e broadcast_session_setup_resp_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::reject;
    case 316:
      return crit_e::reject;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
broadcast_session_setup_resp_ies_o::value_c broadcast_session_setup_resp_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 316:
      ret.set(value_c::types::mbs_session_setup_resp_transfer);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e broadcast_session_setup_resp_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 316:
      return presence_e::optional;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void broadcast_session_setup_resp_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::mbs_session_id:
      c.destroy<mbs_session_id_s>();
      break;
    case types::mbs_session_setup_resp_transfer:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void broadcast_session_setup_resp_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c.init<mbs_session_id_s>();
      break;
    case types::mbs_session_setup_resp_transfer:
      c.init<unbounded_octstring<true>>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_setup_resp_ies_o::value_c");
  }
}
broadcast_session_setup_resp_ies_o::value_c::value_c(const broadcast_session_setup_resp_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mbs_session_id:
      c.init(other.c.get<mbs_session_id_s>());
      break;
    case types::mbs_session_setup_resp_transfer:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_setup_resp_ies_o::value_c");
  }
}
broadcast_session_setup_resp_ies_o::value_c&
broadcast_session_setup_resp_ies_o::value_c::operator=(const broadcast_session_setup_resp_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mbs_session_id:
      c.set(other.c.get<mbs_session_id_s>());
      break;
    case types::mbs_session_setup_resp_transfer:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_setup_resp_ies_o::value_c");
  }

  return *this;
}
mbs_session_id_s& broadcast_session_setup_resp_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
unbounded_octstring<true>& broadcast_session_setup_resp_ies_o::value_c::mbs_session_setup_resp_transfer()
{
  assert_choice_type(types::mbs_session_setup_resp_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
crit_diagnostics_s& broadcast_session_setup_resp_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const mbs_session_id_s& broadcast_session_setup_resp_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const unbounded_octstring<true>& broadcast_session_setup_resp_ies_o::value_c::mbs_session_setup_resp_transfer() const
{
  assert_choice_type(types::mbs_session_setup_resp_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const crit_diagnostics_s& broadcast_session_setup_resp_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void broadcast_session_setup_resp_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::mbs_session_setup_resp_transfer:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_setup_resp_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE broadcast_session_setup_resp_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::mbs_session_setup_resp_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_setup_resp_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_session_setup_resp_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::mbs_session_setup_resp_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_setup_resp_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* broadcast_session_setup_resp_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"MBS-SessionID", "OCTET STRING", "CriticalityDiagnostics"};
  return convert_enum_idx(names, 3, value, "broadcast_session_setup_resp_ies_o::value_c::types");
}

template struct asn1::protocol_ie_field_s<broadcast_session_setup_resp_ies_o>;

broadcast_session_setup_resp_ies_container::broadcast_session_setup_resp_ies_container() :
  mbs_session_id(299, crit_e::reject),
  mbs_session_setup_resp_transfer(316, crit_e::reject),
  crit_diagnostics(19, crit_e::ignore)
{
}
SRSASN_CODE broadcast_session_setup_resp_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 1;
  nof_ies += mbs_session_setup_resp_transfer_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mbs_session_id.pack(bref));
  if (mbs_session_setup_resp_transfer_present) {
    HANDLE_CODE(mbs_session_setup_resp_transfer.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_session_setup_resp_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 1;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        mbs_session_id.id = id;
        HANDLE_CODE(mbs_session_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.value.unpack(bref));
        break;
      }
      case 316: {
        mbs_session_setup_resp_transfer_present = true;
        mbs_session_setup_resp_transfer.id      = id;
        HANDLE_CODE(mbs_session_setup_resp_transfer.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_setup_resp_transfer.value.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        crit_diagnostics.id      = id;
        HANDLE_CODE(crit_diagnostics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void broadcast_session_setup_resp_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mbs_session_id.to_json(j);
  if (mbs_session_setup_resp_transfer_present) {
    j.write_fieldname("");
    mbs_session_setup_resp_transfer.to_json(j);
  }
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

// ExpectedUEMovingTrajectoryItem ::= SEQUENCE
SRSASN_CODE expected_ue_moving_trajectory_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(time_stayed_in_cell_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(ngran_cgi.pack(bref));
  if (time_stayed_in_cell_present) {
    HANDLE_CODE(pack_integer(bref, time_stayed_in_cell, (uint16_t)0u, (uint16_t)4095u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE expected_ue_moving_trajectory_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(time_stayed_in_cell_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(ngran_cgi.unpack(bref));
  if (time_stayed_in_cell_present) {
    HANDLE_CODE(unpack_integer(time_stayed_in_cell, bref, (uint16_t)0u, (uint16_t)4095u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void expected_ue_moving_trajectory_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("nGRAN-CGI");
  ngran_cgi.to_json(j);
  if (time_stayed_in_cell_present) {
    j.write_int("timeStayedInCell", time_stayed_in_cell);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SourceOfUEActivityBehaviourInformation ::= ENUMERATED
const char* source_of_ue_activity_behaviour_info_opts::to_string() const
{
  static const char* names[] = {"subscription-information", "statistics"};
  return convert_enum_idx(names, 2, value, "source_of_ue_activity_behaviour_info_e");
}

// ExpectedHOInterval ::= ENUMERATED
const char* expected_ho_interv_opts::to_string() const
{
  static const char* names[] = {"sec15", "sec30", "sec60", "sec90", "sec120", "sec180", "long-time"};
  return convert_enum_idx(names, 7, value, "expected_ho_interv_e");
}
uint8_t expected_ho_interv_opts::to_number() const
{
  static const uint8_t numbers[] = {15, 30, 60, 90, 120, 180};
  return map_enum_number(numbers, 6, value, "expected_ho_interv_e");
}

// ExpectedUEActivityBehaviour ::= SEQUENCE
SRSASN_CODE expected_ue_activity_behaviour_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(expected_activity_period_present, 1));
  HANDLE_CODE(bref.pack(expected_idle_period_present, 1));
  HANDLE_CODE(bref.pack(source_of_ue_activity_behaviour_info_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (expected_activity_period_present) {
    HANDLE_CODE(pack_integer(bref, expected_activity_period, (uint8_t)1u, (uint8_t)30u, true, true));
  }
  if (expected_idle_period_present) {
    HANDLE_CODE(pack_integer(bref, expected_idle_period, (uint8_t)1u, (uint8_t)30u, true, true));
  }
  if (source_of_ue_activity_behaviour_info_present) {
    HANDLE_CODE(source_of_ue_activity_behaviour_info.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE expected_ue_activity_behaviour_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(expected_activity_period_present, 1));
  HANDLE_CODE(bref.unpack(expected_idle_period_present, 1));
  HANDLE_CODE(bref.unpack(source_of_ue_activity_behaviour_info_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (expected_activity_period_present) {
    HANDLE_CODE(unpack_integer(expected_activity_period, bref, (uint8_t)1u, (uint8_t)30u, true, true));
  }
  if (expected_idle_period_present) {
    HANDLE_CODE(unpack_integer(expected_idle_period, bref, (uint8_t)1u, (uint8_t)30u, true, true));
  }
  if (source_of_ue_activity_behaviour_info_present) {
    HANDLE_CODE(source_of_ue_activity_behaviour_info.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void expected_ue_activity_behaviour_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (expected_activity_period_present) {
    j.write_int("expectedActivityPeriod", expected_activity_period);
  }
  if (expected_idle_period_present) {
    j.write_int("expectedIdlePeriod", expected_idle_period);
  }
  if (source_of_ue_activity_behaviour_info_present) {
    j.write_str("sourceOfUEActivityBehaviourInformation", source_of_ue_activity_behaviour_info.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// ExpectedUEMobility ::= ENUMERATED
const char* expected_ue_mob_opts::to_string() const
{
  static const char* names[] = {"stationary", "mobile"};
  return convert_enum_idx(names, 2, value, "expected_ue_mob_e");
}

// ExpectedUEBehaviour ::= SEQUENCE
SRSASN_CODE expected_ue_behaviour_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(expected_ue_activity_behaviour_present, 1));
  HANDLE_CODE(bref.pack(expected_ho_interv_present, 1));
  HANDLE_CODE(bref.pack(expected_ue_mob_present, 1));
  HANDLE_CODE(bref.pack(expected_ue_moving_trajectory.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (expected_ue_activity_behaviour_present) {
    HANDLE_CODE(expected_ue_activity_behaviour.pack(bref));
  }
  if (expected_ho_interv_present) {
    HANDLE_CODE(expected_ho_interv.pack(bref));
  }
  if (expected_ue_mob_present) {
    HANDLE_CODE(expected_ue_mob.pack(bref));
  }
  if (expected_ue_moving_trajectory.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, expected_ue_moving_trajectory, 1, 16, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE expected_ue_behaviour_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(expected_ue_activity_behaviour_present, 1));
  HANDLE_CODE(bref.unpack(expected_ho_interv_present, 1));
  HANDLE_CODE(bref.unpack(expected_ue_mob_present, 1));
  bool expected_ue_moving_trajectory_present;
  HANDLE_CODE(bref.unpack(expected_ue_moving_trajectory_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (expected_ue_activity_behaviour_present) {
    HANDLE_CODE(expected_ue_activity_behaviour.unpack(bref));
  }
  if (expected_ho_interv_present) {
    HANDLE_CODE(expected_ho_interv.unpack(bref));
  }
  if (expected_ue_mob_present) {
    HANDLE_CODE(expected_ue_mob.unpack(bref));
  }
  if (expected_ue_moving_trajectory_present) {
    HANDLE_CODE(unpack_dyn_seq_of(expected_ue_moving_trajectory, bref, 1, 16, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void expected_ue_behaviour_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (expected_ue_activity_behaviour_present) {
    j.write_fieldname("expectedUEActivityBehaviour");
    expected_ue_activity_behaviour.to_json(j);
  }
  if (expected_ho_interv_present) {
    j.write_str("expectedHOInterval", expected_ho_interv.to_string());
  }
  if (expected_ue_mob_present) {
    j.write_str("expectedUEMobility", expected_ue_mob.to_string());
  }
  if (expected_ue_moving_trajectory.size() > 0) {
    j.start_array("expectedUEMovingTrajectory");
    for (const auto& e1 : expected_ue_moving_trajectory) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CNAssistedRANTuning ::= SEQUENCE
SRSASN_CODE cn_assisted_ran_tuning_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(expected_ue_behaviour_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (expected_ue_behaviour_present) {
    HANDLE_CODE(expected_ue_behaviour.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE cn_assisted_ran_tuning_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(expected_ue_behaviour_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (expected_ue_behaviour_present) {
    HANDLE_CODE(expected_ue_behaviour.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void cn_assisted_ran_tuning_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (expected_ue_behaviour_present) {
    j.write_fieldname("expectedUEBehaviour");
    expected_ue_behaviour.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CNTypeRestrictionsForEquivalentItem ::= SEQUENCE
SRSASN_CODE cn_type_restricts_for_equivalent_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.pack(bref));
  HANDLE_CODE(cn_type.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE cn_type_restricts_for_equivalent_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.unpack(bref));
  HANDLE_CODE(cn_type.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void cn_type_restricts_for_equivalent_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("plmnIdentity", plmn_id.to_string());
  j.write_str("cn-Type", cn_type.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* cn_type_restricts_for_equivalent_item_s::cn_type_opts::to_string() const
{
  static const char* names[] = {"epc-forbidden", "fiveGC-forbidden"};
  return convert_enum_idx(names, 2, value, "cn_type_restricts_for_equivalent_item_s::cn_type_e_");
}
uint8_t cn_type_restricts_for_equivalent_item_s::cn_type_opts::to_number() const
{
  if (value == five_gc_forbidden) {
    return 5;
  }
  invalid_enum_number(value, "cn_type_restricts_for_equivalent_item_s::cn_type_e_");
  return 0;
}

// COUNTValueForPDCP-SN12 ::= SEQUENCE
SRSASN_CODE count_value_for_pdcp_sn12_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pdcp_sn12, (uint16_t)0u, (uint16_t)4095u, false, true));
  HANDLE_CODE(pack_integer(bref, hfn_pdcp_sn12, (uint32_t)0u, (uint32_t)1048575u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE count_value_for_pdcp_sn12_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pdcp_sn12, bref, (uint16_t)0u, (uint16_t)4095u, false, true));
  HANDLE_CODE(unpack_integer(hfn_pdcp_sn12, bref, (uint32_t)0u, (uint32_t)1048575u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void count_value_for_pdcp_sn12_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pDCP-SN12", pdcp_sn12);
  j.write_int("hFN-PDCP-SN12", hfn_pdcp_sn12);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// COUNTValueForPDCP-SN18 ::= SEQUENCE
SRSASN_CODE count_value_for_pdcp_sn18_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pdcp_sn18, (uint32_t)0u, (uint32_t)262143u, false, true));
  HANDLE_CODE(pack_integer(bref, hfn_pdcp_sn18, (uint16_t)0u, (uint16_t)16383u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE count_value_for_pdcp_sn18_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pdcp_sn18, bref, (uint32_t)0u, (uint32_t)262143u, false, true));
  HANDLE_CODE(unpack_integer(hfn_pdcp_sn18, bref, (uint16_t)0u, (uint16_t)16383u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void count_value_for_pdcp_sn18_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pDCP-SN18", pdcp_sn18);
  j.write_int("hFN-PDCP-SN18", hfn_pdcp_sn18);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CandidateCellID ::= SEQUENCE
SRSASN_CODE candidate_cell_id_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(candidate_cell_id.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE candidate_cell_id_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(candidate_cell_id.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void candidate_cell_id_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("candidateCellID");
  candidate_cell_id.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CandidatePCI ::= SEQUENCE
SRSASN_CODE candidate_pci_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, candidate_pci, (uint16_t)0u, (uint16_t)1007u, true, true));
  HANDLE_CODE(pack_integer(bref, candidate_nr_arfcn, (uint32_t)0u, (uint32_t)3279165u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE candidate_pci_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(candidate_pci, bref, (uint16_t)0u, (uint16_t)1007u, true, true));
  HANDLE_CODE(unpack_integer(candidate_nr_arfcn, bref, (uint32_t)0u, (uint32_t)3279165u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void candidate_pci_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("candidatePCI", candidate_pci);
  j.write_int("candidateNRARFCN", candidate_nr_arfcn);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CandidateCell ::= CHOICE
void candidate_cell_c::destroy_()
{
  switch (type_) {
    case types::candidate_cgi:
      c.destroy<candidate_cell_id_s>();
      break;
    case types::candidate_pci:
      c.destroy<candidate_pci_s>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<candidate_cell_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void candidate_cell_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::candidate_cgi:
      c.init<candidate_cell_id_s>();
      break;
    case types::candidate_pci:
      c.init<candidate_pci_s>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<candidate_cell_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "candidate_cell_c");
  }
}
candidate_cell_c::candidate_cell_c(const candidate_cell_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::candidate_cgi:
      c.init(other.c.get<candidate_cell_id_s>());
      break;
    case types::candidate_pci:
      c.init(other.c.get<candidate_pci_s>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<candidate_cell_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "candidate_cell_c");
  }
}
candidate_cell_c& candidate_cell_c::operator=(const candidate_cell_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::candidate_cgi:
      c.set(other.c.get<candidate_cell_id_s>());
      break;
    case types::candidate_pci:
      c.set(other.c.get<candidate_pci_s>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<candidate_cell_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "candidate_cell_c");
  }

  return *this;
}
candidate_cell_id_s& candidate_cell_c::set_candidate_cgi()
{
  set(types::candidate_cgi);
  return c.get<candidate_cell_id_s>();
}
candidate_pci_s& candidate_cell_c::set_candidate_pci()
{
  set(types::candidate_pci);
  return c.get<candidate_pci_s>();
}
protocol_ie_single_container_s<candidate_cell_ext_ies_o>& candidate_cell_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<candidate_cell_ext_ies_o>>();
}
void candidate_cell_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::candidate_cgi:
      j.write_fieldname("candidateCGI");
      c.get<candidate_cell_id_s>().to_json(j);
      break;
    case types::candidate_pci:
      j.write_fieldname("candidatePCI");
      c.get<candidate_pci_s>().to_json(j);
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<candidate_cell_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "candidate_cell_c");
  }
  j.end_obj();
}
SRSASN_CODE candidate_cell_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::candidate_cgi:
      HANDLE_CODE(c.get<candidate_cell_id_s>().pack(bref));
      break;
    case types::candidate_pci:
      HANDLE_CODE(c.get<candidate_pci_s>().pack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<candidate_cell_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "candidate_cell_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE candidate_cell_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::candidate_cgi:
      HANDLE_CODE(c.get<candidate_cell_id_s>().unpack(bref));
      break;
    case types::candidate_pci:
      HANDLE_CODE(c.get<candidate_pci_s>().unpack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<candidate_cell_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "candidate_cell_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* candidate_cell_c::types_opts::to_string() const
{
  static const char* names[] = {"candidateCGI", "candidatePCI", "choice-Extensions"};
  return convert_enum_idx(names, 3, value, "candidate_cell_c::types");
}

// CandidateCellItem ::= SEQUENCE
SRSASN_CODE candidate_cell_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(candidate_cell.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE candidate_cell_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(candidate_cell.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void candidate_cell_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("candidateCell");
  candidate_cell.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// Cell-CAGInformation ::= SEQUENCE
SRSASN_CODE cell_cag_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(ngran_cgi.pack(bref));
  HANDLE_CODE(pack_dyn_seq_of(bref, cell_cag_list, 1, 64, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE cell_cag_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(ngran_cgi.unpack(bref));
  HANDLE_CODE(unpack_dyn_seq_of(cell_cag_list, bref, 1, 64, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void cell_cag_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("nGRAN-CGI");
  ngran_cgi.to_json(j);
  j.start_array("cellCAGList");
  for (const auto& e1 : cell_cag_list) {
    j.write_str(e1.to_string());
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CellIDListForRestart ::= CHOICE
void cell_id_list_for_restart_c::destroy_()
{
  switch (type_) {
    case types::eutra_cgi_listfor_restart:
      c.destroy<eutra_cgi_list_l>();
      break;
    case types::nr_cgi_listfor_restart:
      c.destroy<nr_cgi_list_l>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<cell_id_list_for_restart_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void cell_id_list_for_restart_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::eutra_cgi_listfor_restart:
      c.init<eutra_cgi_list_l>();
      break;
    case types::nr_cgi_listfor_restart:
      c.init<nr_cgi_list_l>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<cell_id_list_for_restart_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "cell_id_list_for_restart_c");
  }
}
cell_id_list_for_restart_c::cell_id_list_for_restart_c(const cell_id_list_for_restart_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::eutra_cgi_listfor_restart:
      c.init(other.c.get<eutra_cgi_list_l>());
      break;
    case types::nr_cgi_listfor_restart:
      c.init(other.c.get<nr_cgi_list_l>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<cell_id_list_for_restart_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "cell_id_list_for_restart_c");
  }
}
cell_id_list_for_restart_c& cell_id_list_for_restart_c::operator=(const cell_id_list_for_restart_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::eutra_cgi_listfor_restart:
      c.set(other.c.get<eutra_cgi_list_l>());
      break;
    case types::nr_cgi_listfor_restart:
      c.set(other.c.get<nr_cgi_list_l>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<cell_id_list_for_restart_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "cell_id_list_for_restart_c");
  }

  return *this;
}
eutra_cgi_list_l& cell_id_list_for_restart_c::set_eutra_cgi_listfor_restart()
{
  set(types::eutra_cgi_listfor_restart);
  return c.get<eutra_cgi_list_l>();
}
nr_cgi_list_l& cell_id_list_for_restart_c::set_nr_cgi_listfor_restart()
{
  set(types::nr_cgi_listfor_restart);
  return c.get<nr_cgi_list_l>();
}
protocol_ie_single_container_s<cell_id_list_for_restart_ext_ies_o>& cell_id_list_for_restart_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<cell_id_list_for_restart_ext_ies_o>>();
}
void cell_id_list_for_restart_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::eutra_cgi_listfor_restart:
      j.start_array("eUTRA-CGIListforRestart");
      for (const auto& e1 : c.get<eutra_cgi_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::nr_cgi_listfor_restart:
      j.start_array("nR-CGIListforRestart");
      for (const auto& e1 : c.get<nr_cgi_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<cell_id_list_for_restart_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "cell_id_list_for_restart_c");
  }
  j.end_obj();
}
SRSASN_CODE cell_id_list_for_restart_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::eutra_cgi_listfor_restart:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<eutra_cgi_list_l>(), 1, 256, true));
      break;
    case types::nr_cgi_listfor_restart:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<nr_cgi_list_l>(), 1, 16384, true));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<cell_id_list_for_restart_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "cell_id_list_for_restart_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE cell_id_list_for_restart_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::eutra_cgi_listfor_restart:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<eutra_cgi_list_l>(), bref, 1, 256, true));
      break;
    case types::nr_cgi_listfor_restart:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<nr_cgi_list_l>(), bref, 1, 16384, true));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<cell_id_list_for_restart_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "cell_id_list_for_restart_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* cell_id_list_for_restart_c::types_opts::to_string() const
{
  static const char* names[] = {"eUTRA-CGIListforRestart", "nR-CGIListforRestart", "choice-Extensions"};
  return convert_enum_idx(names, 3, value, "cell_id_list_for_restart_c::types");
}

// PrivacyIndicator ::= ENUMERATED
const char* privacy_ind_opts::to_string() const
{
  static const char* names[] = {"immediate-MDT", "logged-MDT"};
  return convert_enum_idx(names, 2, value, "privacy_ind_e");
}

// CellTrafficTraceIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t cell_traffic_trace_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 44, 43, 109, 256, 257};
  return map_enum_number(names, 7, idx, "id");
}
bool cell_traffic_trace_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 44, 43, 109, 256, 257};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e cell_traffic_trace_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 44:
      return crit_e::ignore;
    case 43:
      return crit_e::ignore;
    case 109:
      return crit_e::ignore;
    case 256:
      return crit_e::ignore;
    case 257:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
cell_traffic_trace_ies_o::value_c cell_traffic_trace_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 44:
      ret.set(value_c::types::ngran_trace_id);
      break;
    case 43:
      ret.set(value_c::types::ngran_cgi);
      break;
    case 109:
      ret.set(value_c::types::trace_collection_entity_ip_address);
      break;
    case 256:
      ret.set(value_c::types::privacy_ind);
      break;
    case 257:
      ret.set(value_c::types::trace_collection_entity_uri);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e cell_traffic_trace_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 44:
      return presence_e::mandatory;
    case 43:
      return presence_e::mandatory;
    case 109:
      return presence_e::mandatory;
    case 256:
      return presence_e::optional;
    case 257:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void cell_traffic_trace_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::ngran_trace_id:
      c.destroy<fixed_octstring<8, true>>();
      break;
    case types::ngran_cgi:
      c.destroy<ngran_cgi_c>();
      break;
    case types::trace_collection_entity_ip_address:
      c.destroy<bounded_bitstring<1, 160, true, true>>();
      break;
    case types::trace_collection_entity_uri:
      c.destroy<visible_string<0, MAX_ASN_STRING_LENGTH, false, true>>();
      break;
    default:
      break;
  }
}
void cell_traffic_trace_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::ngran_trace_id:
      c.init<fixed_octstring<8, true>>();
      break;
    case types::ngran_cgi:
      c.init<ngran_cgi_c>();
      break;
    case types::trace_collection_entity_ip_address:
      c.init<bounded_bitstring<1, 160, true, true>>();
      break;
    case types::privacy_ind:
      break;
    case types::trace_collection_entity_uri:
      c.init<visible_string<0, MAX_ASN_STRING_LENGTH, false, true>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "cell_traffic_trace_ies_o::value_c");
  }
}
cell_traffic_trace_ies_o::value_c::value_c(const cell_traffic_trace_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ngran_trace_id:
      c.init(other.c.get<fixed_octstring<8, true>>());
      break;
    case types::ngran_cgi:
      c.init(other.c.get<ngran_cgi_c>());
      break;
    case types::trace_collection_entity_ip_address:
      c.init(other.c.get<bounded_bitstring<1, 160, true, true>>());
      break;
    case types::privacy_ind:
      c.init(other.c.get<privacy_ind_e>());
      break;
    case types::trace_collection_entity_uri:
      c.init(other.c.get<visible_string<0, MAX_ASN_STRING_LENGTH, false, true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "cell_traffic_trace_ies_o::value_c");
  }
}
cell_traffic_trace_ies_o::value_c&
cell_traffic_trace_ies_o::value_c::operator=(const cell_traffic_trace_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ngran_trace_id:
      c.set(other.c.get<fixed_octstring<8, true>>());
      break;
    case types::ngran_cgi:
      c.set(other.c.get<ngran_cgi_c>());
      break;
    case types::trace_collection_entity_ip_address:
      c.set(other.c.get<bounded_bitstring<1, 160, true, true>>());
      break;
    case types::privacy_ind:
      c.set(other.c.get<privacy_ind_e>());
      break;
    case types::trace_collection_entity_uri:
      c.set(other.c.get<visible_string<0, MAX_ASN_STRING_LENGTH, false, true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "cell_traffic_trace_ies_o::value_c");
  }

  return *this;
}
uint64_t& cell_traffic_trace_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& cell_traffic_trace_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
fixed_octstring<8, true>& cell_traffic_trace_ies_o::value_c::ngran_trace_id()
{
  assert_choice_type(types::ngran_trace_id, type_, "Value");
  return c.get<fixed_octstring<8, true>>();
}
ngran_cgi_c& cell_traffic_trace_ies_o::value_c::ngran_cgi()
{
  assert_choice_type(types::ngran_cgi, type_, "Value");
  return c.get<ngran_cgi_c>();
}
bounded_bitstring<1, 160, true, true>& cell_traffic_trace_ies_o::value_c::trace_collection_entity_ip_address()
{
  assert_choice_type(types::trace_collection_entity_ip_address, type_, "Value");
  return c.get<bounded_bitstring<1, 160, true, true>>();
}
privacy_ind_e& cell_traffic_trace_ies_o::value_c::privacy_ind()
{
  assert_choice_type(types::privacy_ind, type_, "Value");
  return c.get<privacy_ind_e>();
}
visible_string<0, MAX_ASN_STRING_LENGTH, false, true>& cell_traffic_trace_ies_o::value_c::trace_collection_entity_uri()
{
  assert_choice_type(types::trace_collection_entity_uri, type_, "Value");
  return c.get<visible_string<0, MAX_ASN_STRING_LENGTH, false, true>>();
}
const uint64_t& cell_traffic_trace_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& cell_traffic_trace_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const fixed_octstring<8, true>& cell_traffic_trace_ies_o::value_c::ngran_trace_id() const
{
  assert_choice_type(types::ngran_trace_id, type_, "Value");
  return c.get<fixed_octstring<8, true>>();
}
const ngran_cgi_c& cell_traffic_trace_ies_o::value_c::ngran_cgi() const
{
  assert_choice_type(types::ngran_cgi, type_, "Value");
  return c.get<ngran_cgi_c>();
}
const bounded_bitstring<1, 160, true, true>&
cell_traffic_trace_ies_o::value_c::trace_collection_entity_ip_address() const
{
  assert_choice_type(types::trace_collection_entity_ip_address, type_, "Value");
  return c.get<bounded_bitstring<1, 160, true, true>>();
}
const privacy_ind_e& cell_traffic_trace_ies_o::value_c::privacy_ind() const
{
  assert_choice_type(types::privacy_ind, type_, "Value");
  return c.get<privacy_ind_e>();
}
const visible_string<0, MAX_ASN_STRING_LENGTH, false, true>&
cell_traffic_trace_ies_o::value_c::trace_collection_entity_uri() const
{
  assert_choice_type(types::trace_collection_entity_uri, type_, "Value");
  return c.get<visible_string<0, MAX_ASN_STRING_LENGTH, false, true>>();
}
void cell_traffic_trace_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::ngran_trace_id:
      j.write_str("OCTET STRING", c.get<fixed_octstring<8, true>>().to_string());
      break;
    case types::ngran_cgi:
      j.write_fieldname("NGRAN-CGI");
      c.get<ngran_cgi_c>().to_json(j);
      break;
    case types::trace_collection_entity_ip_address:
      j.write_str("BIT STRING", c.get<bounded_bitstring<1, 160, true, true>>().to_string());
      break;
    case types::privacy_ind:
      j.write_str("PrivacyIndicator", c.get<privacy_ind_e>().to_string());
      break;
    case types::trace_collection_entity_uri:
      j.write_str("VisibleString", c.get<visible_string<0, MAX_ASN_STRING_LENGTH, false, true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "cell_traffic_trace_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE cell_traffic_trace_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ngran_trace_id:
      HANDLE_CODE((c.get<fixed_octstring<8, true>>().pack(bref)));
      break;
    case types::ngran_cgi:
      HANDLE_CODE(c.get<ngran_cgi_c>().pack(bref));
      break;
    case types::trace_collection_entity_ip_address:
      HANDLE_CODE((c.get<bounded_bitstring<1, 160, true, true>>().pack(bref)));
      break;
    case types::privacy_ind:
      HANDLE_CODE(c.get<privacy_ind_e>().pack(bref));
      break;
    case types::trace_collection_entity_uri:
      HANDLE_CODE((c.get<visible_string<0, MAX_ASN_STRING_LENGTH, false, true>>().pack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "cell_traffic_trace_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE cell_traffic_trace_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ngran_trace_id:
      HANDLE_CODE((c.get<fixed_octstring<8, true>>().unpack(bref)));
      break;
    case types::ngran_cgi:
      HANDLE_CODE(c.get<ngran_cgi_c>().unpack(bref));
      break;
    case types::trace_collection_entity_ip_address:
      HANDLE_CODE((c.get<bounded_bitstring<1, 160, true, true>>().unpack(bref)));
      break;
    case types::privacy_ind:
      HANDLE_CODE(c.get<privacy_ind_e>().unpack(bref));
      break;
    case types::trace_collection_entity_uri:
      HANDLE_CODE((c.get<visible_string<0, MAX_ASN_STRING_LENGTH, false, true>>().unpack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "cell_traffic_trace_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* cell_traffic_trace_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..1099511627775)",
                                "INTEGER (0..4294967295)",
                                "OCTET STRING",
                                "NGRAN-CGI",
                                "BIT STRING",
                                "PrivacyIndicator",
                                "VisibleString"};
  return convert_enum_idx(names, 7, value, "cell_traffic_trace_ies_o::value_c::types");
}

template struct asn1::protocol_ie_field_s<cell_traffic_trace_ies_o>;

cell_traffic_trace_ies_container::cell_traffic_trace_ies_container() :
  amf_ue_ngap_id(10, crit_e::reject),
  ran_ue_ngap_id(85, crit_e::reject),
  ngran_trace_id(44, crit_e::ignore),
  ngran_cgi(43, crit_e::ignore),
  trace_collection_entity_ip_address(109, crit_e::ignore),
  privacy_ind(256, crit_e::ignore),
  trace_collection_entity_uri(257, crit_e::ignore)
{
}
SRSASN_CODE cell_traffic_trace_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 5;
  nof_ies += privacy_ind_present ? 1 : 0;
  nof_ies += trace_collection_entity_uri_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  HANDLE_CODE(ngran_trace_id.pack(bref));
  HANDLE_CODE(ngran_cgi.pack(bref));
  HANDLE_CODE(trace_collection_entity_ip_address.pack(bref));
  if (privacy_ind_present) {
    HANDLE_CODE(privacy_ind.pack(bref));
  }
  if (trace_collection_entity_uri_present) {
    HANDLE_CODE(trace_collection_entity_uri.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE cell_traffic_trace_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 5;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 44: {
        nof_mandatory_ies--;
        ngran_trace_id.id = id;
        HANDLE_CODE(ngran_trace_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ngran_trace_id.value.unpack(bref));
        break;
      }
      case 43: {
        nof_mandatory_ies--;
        ngran_cgi.id = id;
        HANDLE_CODE(ngran_cgi.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ngran_cgi.value.unpack(bref));
        break;
      }
      case 109: {
        nof_mandatory_ies--;
        trace_collection_entity_ip_address.id = id;
        HANDLE_CODE(trace_collection_entity_ip_address.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(trace_collection_entity_ip_address.value.unpack(bref));
        break;
      }
      case 256: {
        privacy_ind_present = true;
        privacy_ind.id      = id;
        HANDLE_CODE(privacy_ind.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(privacy_ind.value.unpack(bref));
        break;
      }
      case 257: {
        trace_collection_entity_uri_present = true;
        trace_collection_entity_uri.id      = id;
        HANDLE_CODE(trace_collection_entity_uri.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(trace_collection_entity_uri.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void cell_traffic_trace_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ngran_trace_id.to_json(j);
  j.write_fieldname("");
  ngran_cgi.to_json(j);
  j.write_fieldname("");
  trace_collection_entity_ip_address.to_json(j);
  if (privacy_ind_present) {
    j.write_fieldname("");
    privacy_ind.to_json(j);
  }
  if (trace_collection_entity_uri_present) {
    j.write_fieldname("");
    trace_collection_entity_uri.to_json(j);
  }
  j.end_obj();
}

// CellSize ::= ENUMERATED
const char* cell_size_opts::to_string() const
{
  static const char* names[] = {"verysmall", "small", "medium", "large"};
  return convert_enum_idx(names, 4, value, "cell_size_e");
}

// CellType ::= SEQUENCE
SRSASN_CODE cell_type_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(cell_size.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE cell_type_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(cell_size.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void cell_type_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("cellSize", cell_size.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CompositeAvailableCapacity ::= SEQUENCE
SRSASN_CODE composite_available_capacity_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(cell_capacity_class_value_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (cell_capacity_class_value_present) {
    HANDLE_CODE(pack_integer(bref, cell_capacity_class_value, (uint8_t)1u, (uint8_t)100u, true, true));
  }
  HANDLE_CODE(pack_integer(bref, capacity_value, (uint8_t)0u, (uint8_t)100u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE composite_available_capacity_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(cell_capacity_class_value_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (cell_capacity_class_value_present) {
    HANDLE_CODE(unpack_integer(cell_capacity_class_value, bref, (uint8_t)1u, (uint8_t)100u, true, true));
  }
  HANDLE_CODE(unpack_integer(capacity_value, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void composite_available_capacity_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (cell_capacity_class_value_present) {
    j.write_int("cellCapacityClassValue", cell_capacity_class_value);
  }
  j.write_int("capacityValue", capacity_value);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// ScheduledCommunicationTime ::= SEQUENCE
SRSASN_CODE sched_communication_time_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(dayof_week_present, 1));
  HANDLE_CODE(bref.pack(timeof_day_start_present, 1));
  HANDLE_CODE(bref.pack(timeof_day_end_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (dayof_week_present) {
    HANDLE_CODE(dayof_week.pack(bref));
  }
  if (timeof_day_start_present) {
    HANDLE_CODE(pack_integer(bref, timeof_day_start, (uint32_t)0u, (uint32_t)86399u, true, true));
  }
  if (timeof_day_end_present) {
    HANDLE_CODE(pack_integer(bref, timeof_day_end, (uint32_t)0u, (uint32_t)86399u, true, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE sched_communication_time_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(dayof_week_present, 1));
  HANDLE_CODE(bref.unpack(timeof_day_start_present, 1));
  HANDLE_CODE(bref.unpack(timeof_day_end_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (dayof_week_present) {
    HANDLE_CODE(dayof_week.unpack(bref));
  }
  if (timeof_day_start_present) {
    HANDLE_CODE(unpack_integer(timeof_day_start, bref, (uint32_t)0u, (uint32_t)86399u, true, true));
  }
  if (timeof_day_end_present) {
    HANDLE_CODE(unpack_integer(timeof_day_end, bref, (uint32_t)0u, (uint32_t)86399u, true, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void sched_communication_time_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (dayof_week_present) {
    j.write_str("dayofWeek", dayof_week.to_string());
  }
  if (timeof_day_start_present) {
    j.write_int("timeofDayStart", timeof_day_start);
  }
  if (timeof_day_end_present) {
    j.write_int("timeofDayEnd", timeof_day_end);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CEmodeBrestricted ::= ENUMERATED
const char* ce_mode_brestricted_opts::to_string() const
{
  static const char* names[] = {"restricted", "not-restricted"};
  return convert_enum_idx(names, 2, value, "ce_mode_brestricted_e");
}

// DL-CP-SecurityInformation ::= SEQUENCE
SRSASN_CODE dl_cp_security_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(dl_nas_mac.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE dl_cp_security_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(dl_nas_mac.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void dl_cp_security_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("dl-NAS-MAC", dl_nas_mac.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// EndIndication ::= ENUMERATED
const char* end_ind_opts::to_string() const
{
  static const char* names[] = {"no-further-data", "further-data-exists"};
  return convert_enum_idx(names, 2, value, "end_ind_e");
}

// Enhanced-CoverageRestriction ::= ENUMERATED
const char* enhanced_coverage_restrict_opts::to_string() const
{
  static const char* names[] = {"restricted"};
  return convert_enum_idx(names, 1, value, "enhanced_coverage_restrict_e");
}

// UE-DifferentiationInfo ::= SEQUENCE
SRSASN_CODE ue_diff_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(periodic_communication_ind_present, 1));
  HANDLE_CODE(bref.pack(periodic_time_present, 1));
  HANDLE_CODE(bref.pack(sched_communication_time_present, 1));
  HANDLE_CODE(bref.pack(stationary_ind_present, 1));
  HANDLE_CODE(bref.pack(traffic_profile_present, 1));
  HANDLE_CODE(bref.pack(battery_ind_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (periodic_communication_ind_present) {
    HANDLE_CODE(periodic_communication_ind.pack(bref));
  }
  if (periodic_time_present) {
    HANDLE_CODE(pack_integer(bref, periodic_time, (uint16_t)1u, (uint16_t)3600u, true, true));
  }
  if (sched_communication_time_present) {
    HANDLE_CODE(sched_communication_time.pack(bref));
  }
  if (stationary_ind_present) {
    HANDLE_CODE(stationary_ind.pack(bref));
  }
  if (traffic_profile_present) {
    HANDLE_CODE(traffic_profile.pack(bref));
  }
  if (battery_ind_present) {
    HANDLE_CODE(battery_ind.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_diff_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(periodic_communication_ind_present, 1));
  HANDLE_CODE(bref.unpack(periodic_time_present, 1));
  HANDLE_CODE(bref.unpack(sched_communication_time_present, 1));
  HANDLE_CODE(bref.unpack(stationary_ind_present, 1));
  HANDLE_CODE(bref.unpack(traffic_profile_present, 1));
  HANDLE_CODE(bref.unpack(battery_ind_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (periodic_communication_ind_present) {
    HANDLE_CODE(periodic_communication_ind.unpack(bref));
  }
  if (periodic_time_present) {
    HANDLE_CODE(unpack_integer(periodic_time, bref, (uint16_t)1u, (uint16_t)3600u, true, true));
  }
  if (sched_communication_time_present) {
    HANDLE_CODE(sched_communication_time.unpack(bref));
  }
  if (stationary_ind_present) {
    HANDLE_CODE(stationary_ind.unpack(bref));
  }
  if (traffic_profile_present) {
    HANDLE_CODE(traffic_profile.unpack(bref));
  }
  if (battery_ind_present) {
    HANDLE_CODE(battery_ind.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ue_diff_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (periodic_communication_ind_present) {
    j.write_str("periodicCommunicationIndicator", periodic_communication_ind.to_string());
  }
  if (periodic_time_present) {
    j.write_int("periodicTime", periodic_time);
  }
  if (sched_communication_time_present) {
    j.write_fieldname("scheduledCommunicationTime");
    sched_communication_time.to_json(j);
  }
  if (stationary_ind_present) {
    j.write_str("stationaryIndication", stationary_ind.to_string());
  }
  if (traffic_profile_present) {
    j.write_str("trafficProfile", traffic_profile.to_string());
  }
  if (battery_ind_present) {
    j.write_str("batteryIndication", battery_ind.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* ue_diff_info_s::periodic_communication_ind_opts::to_string() const
{
  static const char* names[] = {"periodically", "ondemand"};
  return convert_enum_idx(names, 2, value, "ue_diff_info_s::periodic_communication_ind_e_");
}

const char* ue_diff_info_s::stationary_ind_opts::to_string() const
{
  static const char* names[] = {"stationary", "mobile"};
  return convert_enum_idx(names, 2, value, "ue_diff_info_s::stationary_ind_e_");
}

const char* ue_diff_info_s::traffic_profile_opts::to_string() const
{
  static const char* names[] = {"single-packet", "dual-packets", "multiple-packets"};
  return convert_enum_idx(names, 3, value, "ue_diff_info_s::traffic_profile_e_");
}

const char* ue_diff_info_s::battery_ind_opts::to_string() const
{
  static const char* names[] = {
      "battery-powered", "battery-powered-not-rechargeable-or-replaceable", "not-battery-powered"};
  return convert_enum_idx(names, 3, value, "ue_diff_info_s::battery_ind_e_");
}

// ConnectionEstablishmentIndicationIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t conn_establishment_ind_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 117, 226, 148, 0, 209, 212, 210, 205, 222, 264, 34};
  return map_enum_number(names, 13, idx, "id");
}
bool conn_establishment_ind_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 117, 226, 148, 0, 209, 212, 210, 205, 222, 264, 34};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e conn_establishment_ind_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 117:
      return crit_e::ignore;
    case 226:
      return crit_e::ignore;
    case 148:
      return crit_e::ignore;
    case 0:
      return crit_e::ignore;
    case 209:
      return crit_e::ignore;
    case 212:
      return crit_e::ignore;
    case 210:
      return crit_e::ignore;
    case 205:
      return crit_e::ignore;
    case 222:
      return crit_e::ignore;
    case 264:
      return crit_e::reject;
    case 34:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
conn_establishment_ind_ies_o::value_c conn_establishment_ind_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 117:
      ret.set(value_c::types::ue_radio_cap);
      break;
    case 226:
      ret.set(value_c::types::end_ind);
      break;
    case 148:
      ret.set(value_c::types::s_nssai);
      break;
    case 0:
      ret.set(value_c::types::allowed_nssai);
      break;
    case 209:
      ret.set(value_c::types::ue_diff_info);
      break;
    case 212:
      ret.set(value_c::types::dl_cp_security_info);
      break;
    case 210:
      ret.set(value_c::types::nb_iot_ue_prio);
      break;
    case 205:
      ret.set(value_c::types::enhanced_coverage_restrict);
      break;
    case 222:
      ret.set(value_c::types::ce_mode_brestricted);
      break;
    case 264:
      ret.set(value_c::types::ue_radio_cap_id);
      break;
    case 34:
      ret.set(value_c::types::masked_imeisv);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e conn_establishment_ind_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 117:
      return presence_e::optional;
    case 226:
      return presence_e::optional;
    case 148:
      return presence_e::optional;
    case 0:
      return presence_e::optional;
    case 209:
      return presence_e::optional;
    case 212:
      return presence_e::optional;
    case 210:
      return presence_e::optional;
    case 205:
      return presence_e::optional;
    case 222:
      return presence_e::optional;
    case 264:
      return presence_e::optional;
    case 34:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void conn_establishment_ind_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::ue_radio_cap:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::s_nssai:
      c.destroy<s_nssai_s>();
      break;
    case types::allowed_nssai:
      c.destroy<allowed_nssai_l>();
      break;
    case types::ue_diff_info:
      c.destroy<ue_diff_info_s>();
      break;
    case types::dl_cp_security_info:
      c.destroy<dl_cp_security_info_s>();
      break;
    case types::ue_radio_cap_id:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::masked_imeisv:
      c.destroy<fixed_bitstring<64, false, true>>();
      break;
    default:
      break;
  }
}
void conn_establishment_ind_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::ue_radio_cap:
      c.init<unbounded_octstring<true>>();
      break;
    case types::end_ind:
      break;
    case types::s_nssai:
      c.init<s_nssai_s>();
      break;
    case types::allowed_nssai:
      c.init<allowed_nssai_l>();
      break;
    case types::ue_diff_info:
      c.init<ue_diff_info_s>();
      break;
    case types::dl_cp_security_info:
      c.init<dl_cp_security_info_s>();
      break;
    case types::nb_iot_ue_prio:
      break;
    case types::enhanced_coverage_restrict:
      break;
    case types::ce_mode_brestricted:
      break;
    case types::ue_radio_cap_id:
      c.init<unbounded_octstring<true>>();
      break;
    case types::masked_imeisv:
      c.init<fixed_bitstring<64, false, true>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "conn_establishment_ind_ies_o::value_c");
  }
}
conn_establishment_ind_ies_o::value_c::value_c(const conn_establishment_ind_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ue_radio_cap:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::end_ind:
      c.init(other.c.get<end_ind_e>());
      break;
    case types::s_nssai:
      c.init(other.c.get<s_nssai_s>());
      break;
    case types::allowed_nssai:
      c.init(other.c.get<allowed_nssai_l>());
      break;
    case types::ue_diff_info:
      c.init(other.c.get<ue_diff_info_s>());
      break;
    case types::dl_cp_security_info:
      c.init(other.c.get<dl_cp_security_info_s>());
      break;
    case types::nb_iot_ue_prio:
      c.init(other.c.get<uint16_t>());
      break;
    case types::enhanced_coverage_restrict:
      c.init(other.c.get<enhanced_coverage_restrict_e>());
      break;
    case types::ce_mode_brestricted:
      c.init(other.c.get<ce_mode_brestricted_e>());
      break;
    case types::ue_radio_cap_id:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::masked_imeisv:
      c.init(other.c.get<fixed_bitstring<64, false, true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "conn_establishment_ind_ies_o::value_c");
  }
}
conn_establishment_ind_ies_o::value_c&
conn_establishment_ind_ies_o::value_c::operator=(const conn_establishment_ind_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ue_radio_cap:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::end_ind:
      c.set(other.c.get<end_ind_e>());
      break;
    case types::s_nssai:
      c.set(other.c.get<s_nssai_s>());
      break;
    case types::allowed_nssai:
      c.set(other.c.get<allowed_nssai_l>());
      break;
    case types::ue_diff_info:
      c.set(other.c.get<ue_diff_info_s>());
      break;
    case types::dl_cp_security_info:
      c.set(other.c.get<dl_cp_security_info_s>());
      break;
    case types::nb_iot_ue_prio:
      c.set(other.c.get<uint16_t>());
      break;
    case types::enhanced_coverage_restrict:
      c.set(other.c.get<enhanced_coverage_restrict_e>());
      break;
    case types::ce_mode_brestricted:
      c.set(other.c.get<ce_mode_brestricted_e>());
      break;
    case types::ue_radio_cap_id:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::masked_imeisv:
      c.set(other.c.get<fixed_bitstring<64, false, true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "conn_establishment_ind_ies_o::value_c");
  }

  return *this;
}
uint64_t& conn_establishment_ind_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& conn_establishment_ind_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
unbounded_octstring<true>& conn_establishment_ind_ies_o::value_c::ue_radio_cap()
{
  assert_choice_type(types::ue_radio_cap, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
end_ind_e& conn_establishment_ind_ies_o::value_c::end_ind()
{
  assert_choice_type(types::end_ind, type_, "Value");
  return c.get<end_ind_e>();
}
s_nssai_s& conn_establishment_ind_ies_o::value_c::s_nssai()
{
  assert_choice_type(types::s_nssai, type_, "Value");
  return c.get<s_nssai_s>();
}
allowed_nssai_l& conn_establishment_ind_ies_o::value_c::allowed_nssai()
{
  assert_choice_type(types::allowed_nssai, type_, "Value");
  return c.get<allowed_nssai_l>();
}
ue_diff_info_s& conn_establishment_ind_ies_o::value_c::ue_diff_info()
{
  assert_choice_type(types::ue_diff_info, type_, "Value");
  return c.get<ue_diff_info_s>();
}
dl_cp_security_info_s& conn_establishment_ind_ies_o::value_c::dl_cp_security_info()
{
  assert_choice_type(types::dl_cp_security_info, type_, "Value");
  return c.get<dl_cp_security_info_s>();
}
uint16_t& conn_establishment_ind_ies_o::value_c::nb_iot_ue_prio()
{
  assert_choice_type(types::nb_iot_ue_prio, type_, "Value");
  return c.get<uint16_t>();
}
enhanced_coverage_restrict_e& conn_establishment_ind_ies_o::value_c::enhanced_coverage_restrict()
{
  assert_choice_type(types::enhanced_coverage_restrict, type_, "Value");
  return c.get<enhanced_coverage_restrict_e>();
}
ce_mode_brestricted_e& conn_establishment_ind_ies_o::value_c::ce_mode_brestricted()
{
  assert_choice_type(types::ce_mode_brestricted, type_, "Value");
  return c.get<ce_mode_brestricted_e>();
}
unbounded_octstring<true>& conn_establishment_ind_ies_o::value_c::ue_radio_cap_id()
{
  assert_choice_type(types::ue_radio_cap_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
fixed_bitstring<64, false, true>& conn_establishment_ind_ies_o::value_c::masked_imeisv()
{
  assert_choice_type(types::masked_imeisv, type_, "Value");
  return c.get<fixed_bitstring<64, false, true>>();
}
const uint64_t& conn_establishment_ind_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& conn_establishment_ind_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const unbounded_octstring<true>& conn_establishment_ind_ies_o::value_c::ue_radio_cap() const
{
  assert_choice_type(types::ue_radio_cap, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const end_ind_e& conn_establishment_ind_ies_o::value_c::end_ind() const
{
  assert_choice_type(types::end_ind, type_, "Value");
  return c.get<end_ind_e>();
}
const s_nssai_s& conn_establishment_ind_ies_o::value_c::s_nssai() const
{
  assert_choice_type(types::s_nssai, type_, "Value");
  return c.get<s_nssai_s>();
}
const allowed_nssai_l& conn_establishment_ind_ies_o::value_c::allowed_nssai() const
{
  assert_choice_type(types::allowed_nssai, type_, "Value");
  return c.get<allowed_nssai_l>();
}
const ue_diff_info_s& conn_establishment_ind_ies_o::value_c::ue_diff_info() const
{
  assert_choice_type(types::ue_diff_info, type_, "Value");
  return c.get<ue_diff_info_s>();
}
const dl_cp_security_info_s& conn_establishment_ind_ies_o::value_c::dl_cp_security_info() const
{
  assert_choice_type(types::dl_cp_security_info, type_, "Value");
  return c.get<dl_cp_security_info_s>();
}
const uint16_t& conn_establishment_ind_ies_o::value_c::nb_iot_ue_prio() const
{
  assert_choice_type(types::nb_iot_ue_prio, type_, "Value");
  return c.get<uint16_t>();
}
const enhanced_coverage_restrict_e& conn_establishment_ind_ies_o::value_c::enhanced_coverage_restrict() const
{
  assert_choice_type(types::enhanced_coverage_restrict, type_, "Value");
  return c.get<enhanced_coverage_restrict_e>();
}
const ce_mode_brestricted_e& conn_establishment_ind_ies_o::value_c::ce_mode_brestricted() const
{
  assert_choice_type(types::ce_mode_brestricted, type_, "Value");
  return c.get<ce_mode_brestricted_e>();
}
const unbounded_octstring<true>& conn_establishment_ind_ies_o::value_c::ue_radio_cap_id() const
{
  assert_choice_type(types::ue_radio_cap_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const fixed_bitstring<64, false, true>& conn_establishment_ind_ies_o::value_c::masked_imeisv() const
{
  assert_choice_type(types::masked_imeisv, type_, "Value");
  return c.get<fixed_bitstring<64, false, true>>();
}
void conn_establishment_ind_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::ue_radio_cap:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::end_ind:
      j.write_str("EndIndication", c.get<end_ind_e>().to_string());
      break;
    case types::s_nssai:
      j.write_fieldname("S-NSSAI");
      c.get<s_nssai_s>().to_json(j);
      break;
    case types::allowed_nssai:
      j.start_array("AllowedNSSAI");
      for (const auto& e1 : c.get<allowed_nssai_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::ue_diff_info:
      j.write_fieldname("UE-DifferentiationInfo");
      c.get<ue_diff_info_s>().to_json(j);
      break;
    case types::dl_cp_security_info:
      j.write_fieldname("DL-CP-SecurityInformation");
      c.get<dl_cp_security_info_s>().to_json(j);
      break;
    case types::nb_iot_ue_prio:
      j.write_int("INTEGER (0..255,...)", c.get<uint16_t>());
      break;
    case types::enhanced_coverage_restrict:
      j.write_str("Enhanced-CoverageRestriction", "restricted");
      break;
    case types::ce_mode_brestricted:
      j.write_str("CEmodeBrestricted", c.get<ce_mode_brestricted_e>().to_string());
      break;
    case types::ue_radio_cap_id:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::masked_imeisv:
      j.write_str("BIT STRING", c.get<fixed_bitstring<64, false, true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "conn_establishment_ind_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE conn_establishment_ind_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ue_radio_cap:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::end_ind:
      HANDLE_CODE(c.get<end_ind_e>().pack(bref));
      break;
    case types::s_nssai:
      HANDLE_CODE(c.get<s_nssai_s>().pack(bref));
      break;
    case types::allowed_nssai:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<allowed_nssai_l>(), 1, 8, true));
      break;
    case types::ue_diff_info:
      HANDLE_CODE(c.get<ue_diff_info_s>().pack(bref));
      break;
    case types::dl_cp_security_info:
      HANDLE_CODE(c.get<dl_cp_security_info_s>().pack(bref));
      break;
    case types::nb_iot_ue_prio:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)0u, (uint16_t)255u, true, true));
      break;
    case types::enhanced_coverage_restrict:
      HANDLE_CODE(c.get<enhanced_coverage_restrict_e>().pack(bref));
      break;
    case types::ce_mode_brestricted:
      HANDLE_CODE(c.get<ce_mode_brestricted_e>().pack(bref));
      break;
    case types::ue_radio_cap_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::masked_imeisv:
      HANDLE_CODE((c.get<fixed_bitstring<64, false, true>>().pack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "conn_establishment_ind_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE conn_establishment_ind_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ue_radio_cap:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::end_ind:
      HANDLE_CODE(c.get<end_ind_e>().unpack(bref));
      break;
    case types::s_nssai:
      HANDLE_CODE(c.get<s_nssai_s>().unpack(bref));
      break;
    case types::allowed_nssai:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<allowed_nssai_l>(), bref, 1, 8, true));
      break;
    case types::ue_diff_info:
      HANDLE_CODE(c.get<ue_diff_info_s>().unpack(bref));
      break;
    case types::dl_cp_security_info:
      HANDLE_CODE(c.get<dl_cp_security_info_s>().unpack(bref));
      break;
    case types::nb_iot_ue_prio:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)0u, (uint16_t)255u, true, true));
      break;
    case types::enhanced_coverage_restrict:
      HANDLE_CODE(c.get<enhanced_coverage_restrict_e>().unpack(bref));
      break;
    case types::ce_mode_brestricted:
      HANDLE_CODE(c.get<ce_mode_brestricted_e>().unpack(bref));
      break;
    case types::ue_radio_cap_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::masked_imeisv:
      HANDLE_CODE((c.get<fixed_bitstring<64, false, true>>().unpack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "conn_establishment_ind_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* conn_establishment_ind_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..1099511627775)",
                                "INTEGER (0..4294967295)",
                                "OCTET STRING",
                                "EndIndication",
                                "S-NSSAI",
                                "AllowedNSSAI",
                                "UE-DifferentiationInfo",
                                "DL-CP-SecurityInformation",
                                "INTEGER (0..255,...)",
                                "Enhanced-CoverageRestriction",
                                "CEmodeBrestricted",
                                "OCTET STRING",
                                "BIT STRING"};
  return convert_enum_idx(names, 13, value, "conn_establishment_ind_ies_o::value_c::types");
}

template struct asn1::protocol_ie_field_s<conn_establishment_ind_ies_o>;

conn_establishment_ind_ies_container::conn_establishment_ind_ies_container() :
  amf_ue_ngap_id(10, crit_e::reject),
  ran_ue_ngap_id(85, crit_e::reject),
  ue_radio_cap(117, crit_e::ignore),
  end_ind(226, crit_e::ignore),
  s_nssai(148, crit_e::ignore),
  allowed_nssai(0, crit_e::ignore),
  ue_diff_info(209, crit_e::ignore),
  dl_cp_security_info(212, crit_e::ignore),
  nb_iot_ue_prio(210, crit_e::ignore),
  enhanced_coverage_restrict(205, crit_e::ignore),
  ce_mode_brestricted(222, crit_e::ignore),
  ue_radio_cap_id(264, crit_e::reject),
  masked_imeisv(34, crit_e::ignore)
{
}
SRSASN_CODE conn_establishment_ind_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += ue_radio_cap_present ? 1 : 0;
  nof_ies += end_ind_present ? 1 : 0;
  nof_ies += s_nssai_present ? 1 : 0;
  nof_ies += allowed_nssai_present ? 1 : 0;
  nof_ies += ue_diff_info_present ? 1 : 0;
  nof_ies += dl_cp_security_info_present ? 1 : 0;
  nof_ies += nb_iot_ue_prio_present ? 1 : 0;
  nof_ies += enhanced_coverage_restrict_present ? 1 : 0;
  nof_ies += ce_mode_brestricted_present ? 1 : 0;
  nof_ies += ue_radio_cap_id_present ? 1 : 0;
  nof_ies += masked_imeisv_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  if (ue_radio_cap_present) {
    HANDLE_CODE(ue_radio_cap.pack(bref));
  }
  if (end_ind_present) {
    HANDLE_CODE(end_ind.pack(bref));
  }
  if (s_nssai_present) {
    HANDLE_CODE(s_nssai.pack(bref));
  }
  if (allowed_nssai_present) {
    HANDLE_CODE(allowed_nssai.pack(bref));
  }
  if (ue_diff_info_present) {
    HANDLE_CODE(ue_diff_info.pack(bref));
  }
  if (dl_cp_security_info_present) {
    HANDLE_CODE(dl_cp_security_info.pack(bref));
  }
  if (nb_iot_ue_prio_present) {
    HANDLE_CODE(nb_iot_ue_prio.pack(bref));
  }
  if (enhanced_coverage_restrict_present) {
    HANDLE_CODE(enhanced_coverage_restrict.pack(bref));
  }
  if (ce_mode_brestricted_present) {
    HANDLE_CODE(ce_mode_brestricted.pack(bref));
  }
  if (ue_radio_cap_id_present) {
    HANDLE_CODE(ue_radio_cap_id.pack(bref));
  }
  if (masked_imeisv_present) {
    HANDLE_CODE(masked_imeisv.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE conn_establishment_ind_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 117: {
        ue_radio_cap_present = true;
        ue_radio_cap.id      = id;
        HANDLE_CODE(ue_radio_cap.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_radio_cap.value.unpack(bref));
        break;
      }
      case 226: {
        end_ind_present = true;
        end_ind.id      = id;
        HANDLE_CODE(end_ind.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(end_ind.value.unpack(bref));
        break;
      }
      case 148: {
        s_nssai_present = true;
        s_nssai.id      = id;
        HANDLE_CODE(s_nssai.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(s_nssai.value.unpack(bref));
        break;
      }
      case 0: {
        allowed_nssai_present = true;
        allowed_nssai.id      = id;
        HANDLE_CODE(allowed_nssai.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(allowed_nssai.value.unpack(bref));
        break;
      }
      case 209: {
        ue_diff_info_present = true;
        ue_diff_info.id      = id;
        HANDLE_CODE(ue_diff_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_diff_info.value.unpack(bref));
        break;
      }
      case 212: {
        dl_cp_security_info_present = true;
        dl_cp_security_info.id      = id;
        HANDLE_CODE(dl_cp_security_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(dl_cp_security_info.value.unpack(bref));
        break;
      }
      case 210: {
        nb_iot_ue_prio_present = true;
        nb_iot_ue_prio.id      = id;
        HANDLE_CODE(nb_iot_ue_prio.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nb_iot_ue_prio.value.unpack(bref));
        break;
      }
      case 205: {
        enhanced_coverage_restrict_present = true;
        enhanced_coverage_restrict.id      = id;
        HANDLE_CODE(enhanced_coverage_restrict.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(enhanced_coverage_restrict.value.unpack(bref));
        break;
      }
      case 222: {
        ce_mode_brestricted_present = true;
        ce_mode_brestricted.id      = id;
        HANDLE_CODE(ce_mode_brestricted.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ce_mode_brestricted.value.unpack(bref));
        break;
      }
      case 264: {
        ue_radio_cap_id_present = true;
        ue_radio_cap_id.id      = id;
        HANDLE_CODE(ue_radio_cap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_radio_cap_id.value.unpack(bref));
        break;
      }
      case 34: {
        masked_imeisv_present = true;
        masked_imeisv.id      = id;
        HANDLE_CODE(masked_imeisv.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(masked_imeisv.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void conn_establishment_ind_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  if (ue_radio_cap_present) {
    j.write_fieldname("");
    ue_radio_cap.to_json(j);
  }
  if (end_ind_present) {
    j.write_fieldname("");
    end_ind.to_json(j);
  }
  if (s_nssai_present) {
    j.write_fieldname("");
    s_nssai.to_json(j);
  }
  if (allowed_nssai_present) {
    j.write_fieldname("");
    allowed_nssai.to_json(j);
  }
  if (ue_diff_info_present) {
    j.write_fieldname("");
    ue_diff_info.to_json(j);
  }
  if (dl_cp_security_info_present) {
    j.write_fieldname("");
    dl_cp_security_info.to_json(j);
  }
  if (nb_iot_ue_prio_present) {
    j.write_fieldname("");
    nb_iot_ue_prio.to_json(j);
  }
  if (enhanced_coverage_restrict_present) {
    j.write_fieldname("");
    enhanced_coverage_restrict.to_json(j);
  }
  if (ce_mode_brestricted_present) {
    j.write_fieldname("");
    ce_mode_brestricted.to_json(j);
  }
  if (ue_radio_cap_id_present) {
    j.write_fieldname("");
    ue_radio_cap_id.to_json(j);
  }
  if (masked_imeisv_present) {
    j.write_fieldname("");
    masked_imeisv.to_json(j);
  }
  j.end_obj();
}

// EUTRA-Paging-Time-Window ::= ENUMERATED
const char* eutra_paging_time_win_opts::to_string() const
{
  static const char* names[] = {
      "s1", "s2", "s3", "s4", "s5", "s6", "s7", "s8", "s9", "s10", "s11", "s12", "s13", "s14", "s15", "s16"};
  return convert_enum_idx(names, 16, value, "eutra_paging_time_win_e");
}
uint8_t eutra_paging_time_win_opts::to_number() const
{
  static const uint8_t numbers[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16};
  return map_enum_number(numbers, 16, value, "eutra_paging_time_win_e");
}

// EUTRA-Paging-eDRX-Cycle ::= ENUMERATED
const char* eutra_paging_e_drx_cycle_opts::to_string() const
{
  static const char* names[] = {
      "hfhalf", "hf1", "hf2", "hf4", "hf6", "hf8", "hf10", "hf12", "hf14", "hf16", "hf32", "hf64", "hf128", "hf256"};
  return convert_enum_idx(names, 14, value, "eutra_paging_e_drx_cycle_e");
}
float eutra_paging_e_drx_cycle_opts::to_number() const
{
  static const float numbers[] = {0.5, 1.0, 2.0, 4.0, 6.0, 8.0, 10.0, 12.0, 14.0, 16.0, 32.0, 64.0, 128.0, 256.0};
  return map_enum_number(numbers, 14, value, "eutra_paging_e_drx_cycle_e");
}
const char* eutra_paging_e_drx_cycle_opts::to_number_string() const
{
  static const char* number_strs[] = {"0.5", "1", "2", "4", "6", "8", "10", "12", "14", "16", "32", "64", "128", "256"};
  return convert_enum_idx(number_strs, 14, value, "eutra_paging_e_drx_cycle_e");
}

// NR-Paging-Time-Window ::= ENUMERATED
const char* nr_paging_time_win_opts::to_string() const
{
  static const char* names[] = {"s1",  "s2",  "s3",  "s4",  "s5",  "s6",  "s7",  "s8",  "s9",  "s10", "s11",
                                "s12", "s13", "s14", "s15", "s16", "s17", "s18", "s19", "s20", "s21", "s22",
                                "s23", "s24", "s25", "s26", "s27", "s28", "s29", "s30", "s31", "s32"};
  return convert_enum_idx(names, 32, value, "nr_paging_time_win_e");
}
uint8_t nr_paging_time_win_opts::to_number() const
{
  static const uint8_t numbers[] = {1,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11, 12, 13, 14, 15, 16,
                                    17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32};
  return map_enum_number(numbers, 32, value, "nr_paging_time_win_e");
}

// NR-Paging-eDRX-Cycle ::= ENUMERATED
const char* nr_paging_e_drx_cycle_opts::to_string() const
{
  static const char* names[] = {
      "hfquarter", "hfhalf", "hf1", "hf2", "hf4", "hf8", "hf16", "hf32", "hf64", "hf128", "hf256", "hf512", "hf1024"};
  return convert_enum_idx(names, 13, value, "nr_paging_e_drx_cycle_e");
}
float nr_paging_e_drx_cycle_opts::to_number() const
{
  static const float numbers[] = {0.25, 0.5, 1.0, 2.0, 4.0, 8.0, 16.0, 32.0, 64.0, 128.0, 256.0, 512.0, 1024.0};
  return map_enum_number(numbers, 13, value, "nr_paging_e_drx_cycle_e");
}
const char* nr_paging_e_drx_cycle_opts::to_number_string() const
{
  static const char* number_strs[] = {"0.25", "0.5", "1", "2", "4", "8", "16", "32", "64", "128", "256", "512", "1024"};
  return convert_enum_idx(number_strs, 13, value, "nr_paging_e_drx_cycle_e");
}

// UERadioCapabilityForPaging-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t ue_radio_cap_for_paging_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {214};
  return map_enum_number(names, 1, idx, "id");
}
bool ue_radio_cap_for_paging_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 214 == id;
}
crit_e ue_radio_cap_for_paging_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 214) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
ue_radio_cap_for_paging_ext_ies_o::ext_c ue_radio_cap_for_paging_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 214) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ue_radio_cap_for_paging_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 214) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void ue_radio_cap_for_paging_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("OCTET STRING", c.to_string());
  j.end_obj();
}
SRSASN_CODE ue_radio_cap_for_paging_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_radio_cap_for_paging_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* ue_radio_cap_for_paging_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"OCTET STRING"};
  return convert_enum_idx(names, 1, value, "ue_radio_cap_for_paging_ext_ies_o::ext_c::types");
}

// EUTRA-PagingeDRXInformation ::= SEQUENCE
SRSASN_CODE eutra_paginge_drx_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(eutra_paging_time_win_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(eutra_paging_e_drx_cycle.pack(bref));
  if (eutra_paging_time_win_present) {
    HANDLE_CODE(eutra_paging_time_win.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE eutra_paginge_drx_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(eutra_paging_time_win_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(eutra_paging_e_drx_cycle.unpack(bref));
  if (eutra_paging_time_win_present) {
    HANDLE_CODE(eutra_paging_time_win.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void eutra_paginge_drx_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("eUTRA-paging-eDRX-Cycle", eutra_paging_e_drx_cycle.to_string());
  if (eutra_paging_time_win_present) {
    j.write_str("eUTRA-paging-Time-Window", eutra_paging_time_win.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MicoAllPLMN ::= ENUMERATED
const char* mico_all_plmn_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "mico_all_plmn_e");
}

// NR-PagingeDRXInformation ::= SEQUENCE
SRSASN_CODE nr_paginge_drx_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(nr_paging_time_win_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(nr_paging_e_drx_cycle.pack(bref));
  if (nr_paging_time_win_present) {
    HANDLE_CODE(nr_paging_time_win.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE nr_paginge_drx_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(nr_paging_time_win_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(nr_paging_e_drx_cycle.unpack(bref));
  if (nr_paging_time_win_present) {
    HANDLE_CODE(nr_paging_time_win.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void nr_paginge_drx_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("nR-paging-eDRX-Cycle", nr_paging_e_drx_cycle.to_string());
  if (nr_paging_time_win_present) {
    j.write_str("nR-paging-Time-Window", nr_paging_time_win.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PEIPSassistanceInformation ::= SEQUENCE
SRSASN_CODE pe_ip_sassist_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, cnsubgroup_id, (uint8_t)0u, (uint8_t)7u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pe_ip_sassist_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(cnsubgroup_id, bref, (uint8_t)0u, (uint8_t)7u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pe_ip_sassist_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("cNsubgroupID", cnsubgroup_id);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PagingCauseIndicationForVoiceService ::= ENUMERATED
const char* paging_cause_ind_for_voice_service_opts::to_string() const
{
  static const char* names[] = {"supported"};
  return convert_enum_idx(names, 1, value, "paging_cause_ind_for_voice_service_e");
}

// TAIListForInactiveItem ::= SEQUENCE
SRSASN_CODE tai_list_for_inactive_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(tai.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE tai_list_for_inactive_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(tai.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void tai_list_for_inactive_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("tAI");
  tai.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// UERadioCapabilityForPaging ::= SEQUENCE
SRSASN_CODE ue_radio_cap_for_paging_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ue_radio_cap_for_paging_of_nr.size() > 0, 1));
  HANDLE_CODE(bref.pack(ue_radio_cap_for_paging_of_eutra.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  if (ue_radio_cap_for_paging_of_nr.size() > 0) {
    HANDLE_CODE(ue_radio_cap_for_paging_of_nr.pack(bref));
  }
  if (ue_radio_cap_for_paging_of_eutra.size() > 0) {
    HANDLE_CODE(ue_radio_cap_for_paging_of_eutra.pack(bref));
  }
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_radio_cap_for_paging_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool ue_radio_cap_for_paging_of_nr_present;
  HANDLE_CODE(bref.unpack(ue_radio_cap_for_paging_of_nr_present, 1));
  bool ue_radio_cap_for_paging_of_eutra_present;
  HANDLE_CODE(bref.unpack(ue_radio_cap_for_paging_of_eutra_present, 1));
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (ue_radio_cap_for_paging_of_nr_present) {
    HANDLE_CODE(ue_radio_cap_for_paging_of_nr.unpack(bref));
  }
  if (ue_radio_cap_for_paging_of_eutra_present) {
    HANDLE_CODE(ue_radio_cap_for_paging_of_eutra.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void ue_radio_cap_for_paging_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (ue_radio_cap_for_paging_of_nr.size() > 0) {
    j.write_str("uERadioCapabilityForPagingOfNR", ue_radio_cap_for_paging_of_nr.to_string());
  }
  if (ue_radio_cap_for_paging_of_eutra.size() > 0) {
    j.write_str("uERadioCapabilityForPagingOfEUTRA", ue_radio_cap_for_paging_of_eutra.to_string());
  }
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// CoreNetworkAssistanceInformationForInactive-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t core_network_assist_info_for_inactive_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {223, 280, 118, 282, 332, 343, 344};
  return map_enum_number(names, 7, idx, "id");
}
bool core_network_assist_info_for_inactive_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {223, 280, 118, 282, 332, 343, 344};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e core_network_assist_info_for_inactive_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 223:
      return crit_e::ignore;
    case 280:
      return crit_e::ignore;
    case 118:
      return crit_e::ignore;
    case 282:
      return crit_e::ignore;
    case 332:
      return crit_e::ignore;
    case 343:
      return crit_e::ignore;
    case 344:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
core_network_assist_info_for_inactive_ext_ies_o::ext_c
core_network_assist_info_for_inactive_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 223:
      ret.set(ext_c::types::eutra_paginge_drx_info);
      break;
    case 280:
      ret.set(ext_c::types::extended_ue_id_idx_value);
      break;
    case 118:
      ret.set(ext_c::types::ue_radio_cap_for_paging);
      break;
    case 282:
      ret.set(ext_c::types::mico_all_plmn);
      break;
    case 332:
      ret.set(ext_c::types::nr_paginge_drx_info);
      break;
    case 343:
      ret.set(ext_c::types::paging_cause_ind_for_voice_service);
      break;
    case 344:
      ret.set(ext_c::types::pe_ip_sassist_info);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e core_network_assist_info_for_inactive_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 223:
      return presence_e::optional;
    case 280:
      return presence_e::optional;
    case 118:
      return presence_e::optional;
    case 282:
      return presence_e::optional;
    case 332:
      return presence_e::optional;
    case 343:
      return presence_e::optional;
    case 344:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void core_network_assist_info_for_inactive_ext_ies_o::ext_c::destroy_()
{
  switch (type_) {
    case types::eutra_paginge_drx_info:
      c.destroy<eutra_paginge_drx_info_s>();
      break;
    case types::extended_ue_id_idx_value:
      c.destroy<fixed_bitstring<16, false, true>>();
      break;
    case types::ue_radio_cap_for_paging:
      c.destroy<ue_radio_cap_for_paging_s>();
      break;
    case types::nr_paginge_drx_info:
      c.destroy<nr_paginge_drx_info_s>();
      break;
    case types::pe_ip_sassist_info:
      c.destroy<pe_ip_sassist_info_s>();
      break;
    default:
      break;
  }
}
void core_network_assist_info_for_inactive_ext_ies_o::ext_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::eutra_paginge_drx_info:
      c.init<eutra_paginge_drx_info_s>();
      break;
    case types::extended_ue_id_idx_value:
      c.init<fixed_bitstring<16, false, true>>();
      break;
    case types::ue_radio_cap_for_paging:
      c.init<ue_radio_cap_for_paging_s>();
      break;
    case types::mico_all_plmn:
      break;
    case types::nr_paginge_drx_info:
      c.init<nr_paginge_drx_info_s>();
      break;
    case types::paging_cause_ind_for_voice_service:
      break;
    case types::pe_ip_sassist_info:
      c.init<pe_ip_sassist_info_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "core_network_assist_info_for_inactive_ext_ies_o::ext_c");
  }
}
core_network_assist_info_for_inactive_ext_ies_o::ext_c::ext_c(
    const core_network_assist_info_for_inactive_ext_ies_o::ext_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::eutra_paginge_drx_info:
      c.init(other.c.get<eutra_paginge_drx_info_s>());
      break;
    case types::extended_ue_id_idx_value:
      c.init(other.c.get<fixed_bitstring<16, false, true>>());
      break;
    case types::ue_radio_cap_for_paging:
      c.init(other.c.get<ue_radio_cap_for_paging_s>());
      break;
    case types::mico_all_plmn:
      c.init(other.c.get<mico_all_plmn_e>());
      break;
    case types::nr_paginge_drx_info:
      c.init(other.c.get<nr_paginge_drx_info_s>());
      break;
    case types::paging_cause_ind_for_voice_service:
      c.init(other.c.get<paging_cause_ind_for_voice_service_e>());
      break;
    case types::pe_ip_sassist_info:
      c.init(other.c.get<pe_ip_sassist_info_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "core_network_assist_info_for_inactive_ext_ies_o::ext_c");
  }
}
core_network_assist_info_for_inactive_ext_ies_o::ext_c&
core_network_assist_info_for_inactive_ext_ies_o::ext_c::operator=(
    const core_network_assist_info_for_inactive_ext_ies_o::ext_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::eutra_paginge_drx_info:
      c.set(other.c.get<eutra_paginge_drx_info_s>());
      break;
    case types::extended_ue_id_idx_value:
      c.set(other.c.get<fixed_bitstring<16, false, true>>());
      break;
    case types::ue_radio_cap_for_paging:
      c.set(other.c.get<ue_radio_cap_for_paging_s>());
      break;
    case types::mico_all_plmn:
      c.set(other.c.get<mico_all_plmn_e>());
      break;
    case types::nr_paginge_drx_info:
      c.set(other.c.get<nr_paginge_drx_info_s>());
      break;
    case types::paging_cause_ind_for_voice_service:
      c.set(other.c.get<paging_cause_ind_for_voice_service_e>());
      break;
    case types::pe_ip_sassist_info:
      c.set(other.c.get<pe_ip_sassist_info_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "core_network_assist_info_for_inactive_ext_ies_o::ext_c");
  }

  return *this;
}
eutra_paginge_drx_info_s& core_network_assist_info_for_inactive_ext_ies_o::ext_c::eutra_paginge_drx_info()
{
  assert_choice_type(types::eutra_paginge_drx_info, type_, "Extension");
  return c.get<eutra_paginge_drx_info_s>();
}
fixed_bitstring<16, false, true>& core_network_assist_info_for_inactive_ext_ies_o::ext_c::extended_ue_id_idx_value()
{
  assert_choice_type(types::extended_ue_id_idx_value, type_, "Extension");
  return c.get<fixed_bitstring<16, false, true>>();
}
ue_radio_cap_for_paging_s& core_network_assist_info_for_inactive_ext_ies_o::ext_c::ue_radio_cap_for_paging()
{
  assert_choice_type(types::ue_radio_cap_for_paging, type_, "Extension");
  return c.get<ue_radio_cap_for_paging_s>();
}
mico_all_plmn_e& core_network_assist_info_for_inactive_ext_ies_o::ext_c::mico_all_plmn()
{
  assert_choice_type(types::mico_all_plmn, type_, "Extension");
  return c.get<mico_all_plmn_e>();
}
nr_paginge_drx_info_s& core_network_assist_info_for_inactive_ext_ies_o::ext_c::nr_paginge_drx_info()
{
  assert_choice_type(types::nr_paginge_drx_info, type_, "Extension");
  return c.get<nr_paginge_drx_info_s>();
}
paging_cause_ind_for_voice_service_e&
core_network_assist_info_for_inactive_ext_ies_o::ext_c::paging_cause_ind_for_voice_service()
{
  assert_choice_type(types::paging_cause_ind_for_voice_service, type_, "Extension");
  return c.get<paging_cause_ind_for_voice_service_e>();
}
pe_ip_sassist_info_s& core_network_assist_info_for_inactive_ext_ies_o::ext_c::pe_ip_sassist_info()
{
  assert_choice_type(types::pe_ip_sassist_info, type_, "Extension");
  return c.get<pe_ip_sassist_info_s>();
}
const eutra_paginge_drx_info_s& core_network_assist_info_for_inactive_ext_ies_o::ext_c::eutra_paginge_drx_info() const
{
  assert_choice_type(types::eutra_paginge_drx_info, type_, "Extension");
  return c.get<eutra_paginge_drx_info_s>();
}
const fixed_bitstring<16, false, true>&
core_network_assist_info_for_inactive_ext_ies_o::ext_c::extended_ue_id_idx_value() const
{
  assert_choice_type(types::extended_ue_id_idx_value, type_, "Extension");
  return c.get<fixed_bitstring<16, false, true>>();
}
const ue_radio_cap_for_paging_s& core_network_assist_info_for_inactive_ext_ies_o::ext_c::ue_radio_cap_for_paging() const
{
  assert_choice_type(types::ue_radio_cap_for_paging, type_, "Extension");
  return c.get<ue_radio_cap_for_paging_s>();
}
const mico_all_plmn_e& core_network_assist_info_for_inactive_ext_ies_o::ext_c::mico_all_plmn() const
{
  assert_choice_type(types::mico_all_plmn, type_, "Extension");
  return c.get<mico_all_plmn_e>();
}
const nr_paginge_drx_info_s& core_network_assist_info_for_inactive_ext_ies_o::ext_c::nr_paginge_drx_info() const
{
  assert_choice_type(types::nr_paginge_drx_info, type_, "Extension");
  return c.get<nr_paginge_drx_info_s>();
}
const paging_cause_ind_for_voice_service_e&
core_network_assist_info_for_inactive_ext_ies_o::ext_c::paging_cause_ind_for_voice_service() const
{
  assert_choice_type(types::paging_cause_ind_for_voice_service, type_, "Extension");
  return c.get<paging_cause_ind_for_voice_service_e>();
}
const pe_ip_sassist_info_s& core_network_assist_info_for_inactive_ext_ies_o::ext_c::pe_ip_sassist_info() const
{
  assert_choice_type(types::pe_ip_sassist_info, type_, "Extension");
  return c.get<pe_ip_sassist_info_s>();
}
void core_network_assist_info_for_inactive_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::eutra_paginge_drx_info:
      j.write_fieldname("EUTRA-PagingeDRXInformation");
      c.get<eutra_paginge_drx_info_s>().to_json(j);
      break;
    case types::extended_ue_id_idx_value:
      j.write_str("BIT STRING", c.get<fixed_bitstring<16, false, true>>().to_string());
      break;
    case types::ue_radio_cap_for_paging:
      j.write_fieldname("UERadioCapabilityForPaging");
      c.get<ue_radio_cap_for_paging_s>().to_json(j);
      break;
    case types::mico_all_plmn:
      j.write_str("MicoAllPLMN", "true");
      break;
    case types::nr_paginge_drx_info:
      j.write_fieldname("NR-PagingeDRXInformation");
      c.get<nr_paginge_drx_info_s>().to_json(j);
      break;
    case types::paging_cause_ind_for_voice_service:
      j.write_str("PagingCauseIndicationForVoiceService", "supported");
      break;
    case types::pe_ip_sassist_info:
      j.write_fieldname("PEIPSassistanceInformation");
      c.get<pe_ip_sassist_info_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "core_network_assist_info_for_inactive_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE core_network_assist_info_for_inactive_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::eutra_paginge_drx_info:
      HANDLE_CODE(c.get<eutra_paginge_drx_info_s>().pack(bref));
      break;
    case types::extended_ue_id_idx_value:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true>>().pack(bref)));
      break;
    case types::ue_radio_cap_for_paging:
      HANDLE_CODE(c.get<ue_radio_cap_for_paging_s>().pack(bref));
      break;
    case types::mico_all_plmn:
      HANDLE_CODE(c.get<mico_all_plmn_e>().pack(bref));
      break;
    case types::nr_paginge_drx_info:
      HANDLE_CODE(c.get<nr_paginge_drx_info_s>().pack(bref));
      break;
    case types::paging_cause_ind_for_voice_service:
      HANDLE_CODE(c.get<paging_cause_ind_for_voice_service_e>().pack(bref));
      break;
    case types::pe_ip_sassist_info:
      HANDLE_CODE(c.get<pe_ip_sassist_info_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "core_network_assist_info_for_inactive_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE core_network_assist_info_for_inactive_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::eutra_paginge_drx_info:
      HANDLE_CODE(c.get<eutra_paginge_drx_info_s>().unpack(bref));
      break;
    case types::extended_ue_id_idx_value:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true>>().unpack(bref)));
      break;
    case types::ue_radio_cap_for_paging:
      HANDLE_CODE(c.get<ue_radio_cap_for_paging_s>().unpack(bref));
      break;
    case types::mico_all_plmn:
      HANDLE_CODE(c.get<mico_all_plmn_e>().unpack(bref));
      break;
    case types::nr_paginge_drx_info:
      HANDLE_CODE(c.get<nr_paginge_drx_info_s>().unpack(bref));
      break;
    case types::paging_cause_ind_for_voice_service:
      HANDLE_CODE(c.get<paging_cause_ind_for_voice_service_e>().unpack(bref));
      break;
    case types::pe_ip_sassist_info:
      HANDLE_CODE(c.get<pe_ip_sassist_info_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "core_network_assist_info_for_inactive_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* core_network_assist_info_for_inactive_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"EUTRA-PagingeDRXInformation",
                                "BIT STRING",
                                "UERadioCapabilityForPaging",
                                "MicoAllPLMN",
                                "NR-PagingeDRXInformation",
                                "PagingCauseIndicationForVoiceService",
                                "PEIPSassistanceInformation"};
  return convert_enum_idx(names, 7, value, "core_network_assist_info_for_inactive_ext_ies_o::ext_c::types");
}

// MICOModeIndication ::= ENUMERATED
const char* mico_mode_ind_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "mico_mode_ind_e");
}

// PagingDRX ::= ENUMERATED
const char* paging_drx_opts::to_string() const
{
  static const char* names[] = {"v32", "v64", "v128", "v256"};
  return convert_enum_idx(names, 4, value, "paging_drx_e");
}
uint16_t paging_drx_opts::to_number() const
{
  static const uint16_t numbers[] = {32, 64, 128, 256};
  return map_enum_number(numbers, 4, value, "paging_drx_e");
}

// UEIdentityIndexValue ::= CHOICE
void ue_id_idx_value_c::destroy_()
{
  switch (type_) {
    case types::idx_len10:
      c.destroy<fixed_bitstring<10, false, true>>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<ue_id_idx_value_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void ue_id_idx_value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::idx_len10:
      c.init<fixed_bitstring<10, false, true>>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<ue_id_idx_value_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_id_idx_value_c");
  }
}
ue_id_idx_value_c::ue_id_idx_value_c(const ue_id_idx_value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::idx_len10:
      c.init(other.c.get<fixed_bitstring<10, false, true>>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<ue_id_idx_value_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_id_idx_value_c");
  }
}
ue_id_idx_value_c& ue_id_idx_value_c::operator=(const ue_id_idx_value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::idx_len10:
      c.set(other.c.get<fixed_bitstring<10, false, true>>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<ue_id_idx_value_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_id_idx_value_c");
  }

  return *this;
}
fixed_bitstring<10, false, true>& ue_id_idx_value_c::set_idx_len10()
{
  set(types::idx_len10);
  return c.get<fixed_bitstring<10, false, true>>();
}
protocol_ie_single_container_s<ue_id_idx_value_ext_ies_o>& ue_id_idx_value_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<ue_id_idx_value_ext_ies_o>>();
}
void ue_id_idx_value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::idx_len10:
      j.write_str("indexLength10", c.get<fixed_bitstring<10, false, true>>().to_string());
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<ue_id_idx_value_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ue_id_idx_value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_id_idx_value_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::idx_len10:
      HANDLE_CODE((c.get<fixed_bitstring<10, false, true>>().pack(bref)));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<ue_id_idx_value_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_id_idx_value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_id_idx_value_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::idx_len10:
      HANDLE_CODE((c.get<fixed_bitstring<10, false, true>>().unpack(bref)));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<ue_id_idx_value_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_id_idx_value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ue_id_idx_value_c::types_opts::to_string() const
{
  static const char* names[] = {"indexLength10", "choice-Extensions"};
  return convert_enum_idx(names, 2, value, "ue_id_idx_value_c::types");
}
uint8_t ue_id_idx_value_c::types_opts::to_number() const
{
  static const uint8_t numbers[] = {10};
  return map_enum_number(numbers, 1, value, "ue_id_idx_value_c::types");
}

template struct asn1::protocol_ext_field_s<core_network_assist_info_for_inactive_ext_ies_o>;

core_network_assist_info_for_inactive_ext_ies_container::core_network_assist_info_for_inactive_ext_ies_container() :
  eutra_paginge_drx_info(223, crit_e::ignore),
  extended_ue_id_idx_value(280, crit_e::ignore),
  ue_radio_cap_for_paging(118, crit_e::ignore),
  mico_all_plmn(282, crit_e::ignore),
  nr_paginge_drx_info(332, crit_e::ignore),
  paging_cause_ind_for_voice_service(343, crit_e::ignore),
  pe_ip_sassist_info(344, crit_e::ignore)
{
}
SRSASN_CODE core_network_assist_info_for_inactive_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += eutra_paginge_drx_info_present ? 1 : 0;
  nof_ies += extended_ue_id_idx_value_present ? 1 : 0;
  nof_ies += ue_radio_cap_for_paging_present ? 1 : 0;
  nof_ies += mico_all_plmn_present ? 1 : 0;
  nof_ies += nr_paginge_drx_info_present ? 1 : 0;
  nof_ies += paging_cause_ind_for_voice_service_present ? 1 : 0;
  nof_ies += pe_ip_sassist_info_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (eutra_paginge_drx_info_present) {
    HANDLE_CODE(eutra_paginge_drx_info.pack(bref));
  }
  if (extended_ue_id_idx_value_present) {
    HANDLE_CODE(extended_ue_id_idx_value.pack(bref));
  }
  if (ue_radio_cap_for_paging_present) {
    HANDLE_CODE(ue_radio_cap_for_paging.pack(bref));
  }
  if (mico_all_plmn_present) {
    HANDLE_CODE(mico_all_plmn.pack(bref));
  }
  if (nr_paginge_drx_info_present) {
    HANDLE_CODE(nr_paginge_drx_info.pack(bref));
  }
  if (paging_cause_ind_for_voice_service_present) {
    HANDLE_CODE(paging_cause_ind_for_voice_service.pack(bref));
  }
  if (pe_ip_sassist_info_present) {
    HANDLE_CODE(pe_ip_sassist_info.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE core_network_assist_info_for_inactive_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 223: {
        eutra_paginge_drx_info_present = true;
        eutra_paginge_drx_info.id      = id;
        HANDLE_CODE(eutra_paginge_drx_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(eutra_paginge_drx_info.ext.unpack(bref));
        break;
      }
      case 280: {
        extended_ue_id_idx_value_present = true;
        extended_ue_id_idx_value.id      = id;
        HANDLE_CODE(extended_ue_id_idx_value.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(extended_ue_id_idx_value.ext.unpack(bref));
        break;
      }
      case 118: {
        ue_radio_cap_for_paging_present = true;
        ue_radio_cap_for_paging.id      = id;
        HANDLE_CODE(ue_radio_cap_for_paging.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_radio_cap_for_paging.ext.unpack(bref));
        break;
      }
      case 282: {
        mico_all_plmn_present = true;
        mico_all_plmn.id      = id;
        HANDLE_CODE(mico_all_plmn.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mico_all_plmn.ext.unpack(bref));
        break;
      }
      case 332: {
        nr_paginge_drx_info_present = true;
        nr_paginge_drx_info.id      = id;
        HANDLE_CODE(nr_paginge_drx_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nr_paginge_drx_info.ext.unpack(bref));
        break;
      }
      case 343: {
        paging_cause_ind_for_voice_service_present = true;
        paging_cause_ind_for_voice_service.id      = id;
        HANDLE_CODE(paging_cause_ind_for_voice_service.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(paging_cause_ind_for_voice_service.ext.unpack(bref));
        break;
      }
      case 344: {
        pe_ip_sassist_info_present = true;
        pe_ip_sassist_info.id      = id;
        HANDLE_CODE(pe_ip_sassist_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pe_ip_sassist_info.ext.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void core_network_assist_info_for_inactive_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (eutra_paginge_drx_info_present) {
    j.write_fieldname("");
    eutra_paginge_drx_info.to_json(j);
  }
  if (extended_ue_id_idx_value_present) {
    j.write_fieldname("");
    extended_ue_id_idx_value.to_json(j);
  }
  if (ue_radio_cap_for_paging_present) {
    j.write_fieldname("");
    ue_radio_cap_for_paging.to_json(j);
  }
  if (mico_all_plmn_present) {
    j.write_fieldname("");
    mico_all_plmn.to_json(j);
  }
  if (nr_paginge_drx_info_present) {
    j.write_fieldname("");
    nr_paginge_drx_info.to_json(j);
  }
  if (paging_cause_ind_for_voice_service_present) {
    j.write_fieldname("");
    paging_cause_ind_for_voice_service.to_json(j);
  }
  if (pe_ip_sassist_info_present) {
    j.write_fieldname("");
    pe_ip_sassist_info.to_json(j);
  }
  j.end_obj();
}

// CoreNetworkAssistanceInformationForInactive ::= SEQUENCE
SRSASN_CODE core_network_assist_info_for_inactive_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ue_specific_drx_present, 1));
  HANDLE_CODE(bref.pack(mico_mode_ind_present, 1));
  HANDLE_CODE(bref.pack(expected_ue_behaviour_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(ue_id_idx_value.pack(bref));
  if (ue_specific_drx_present) {
    HANDLE_CODE(ue_specific_drx.pack(bref));
  }
  HANDLE_CODE(periodic_regist_upd_timer.pack(bref));
  if (mico_mode_ind_present) {
    HANDLE_CODE(mico_mode_ind.pack(bref));
  }
  HANDLE_CODE(pack_dyn_seq_of(bref, tai_list_for_inactive, 1, 16, true));
  if (expected_ue_behaviour_present) {
    HANDLE_CODE(expected_ue_behaviour.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE core_network_assist_info_for_inactive_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ue_specific_drx_present, 1));
  HANDLE_CODE(bref.unpack(mico_mode_ind_present, 1));
  HANDLE_CODE(bref.unpack(expected_ue_behaviour_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(ue_id_idx_value.unpack(bref));
  if (ue_specific_drx_present) {
    HANDLE_CODE(ue_specific_drx.unpack(bref));
  }
  HANDLE_CODE(periodic_regist_upd_timer.unpack(bref));
  if (mico_mode_ind_present) {
    HANDLE_CODE(mico_mode_ind.unpack(bref));
  }
  HANDLE_CODE(unpack_dyn_seq_of(tai_list_for_inactive, bref, 1, 16, true));
  if (expected_ue_behaviour_present) {
    HANDLE_CODE(expected_ue_behaviour.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void core_network_assist_info_for_inactive_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("uEIdentityIndexValue");
  ue_id_idx_value.to_json(j);
  if (ue_specific_drx_present) {
    j.write_str("uESpecificDRX", ue_specific_drx.to_string());
  }
  j.write_str("periodicRegistrationUpdateTimer", periodic_regist_upd_timer.to_string());
  if (mico_mode_ind_present) {
    j.write_str("mICOModeIndication", "true");
  }
  j.start_array("tAIListForInactive");
  for (const auto& e1 : tai_list_for_inactive) {
    e1.to_json(j);
  }
  j.end_array();
  if (expected_ue_behaviour_present) {
    j.write_fieldname("expectedUEBehaviour");
    expected_ue_behaviour.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// DAPSRequestInfo ::= SEQUENCE
SRSASN_CODE daps_request_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(da_psi_ndicator.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE daps_request_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(da_psi_ndicator.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void daps_request_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("dAPSIndicator", "daps-ho-required");
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* daps_request_info_s::da_psi_ndicator_opts::to_string() const
{
  static const char* names[] = {"daps-ho-required"};
  return convert_enum_idx(names, 1, value, "daps_request_info_s::da_psi_ndicator_e_");
}

// DAPSResponseInfo ::= SEQUENCE
SRSASN_CODE daps_resp_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(dapsrespind.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE daps_resp_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(dapsrespind.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void daps_resp_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("dapsresponseindicator", dapsrespind.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* daps_resp_info_s::dapsrespind_opts::to_string() const
{
  static const char* names[] = {"daps-ho-accepted", "daps-ho-not-accepted"};
  return convert_enum_idx(names, 2, value, "daps_resp_info_s::dapsrespind_e_");
}

// DAPSResponseInfoItem ::= SEQUENCE
SRSASN_CODE daps_resp_info_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(pack_integer(bref, drb_id, (uint8_t)1u, (uint8_t)32u, true, true));
  HANDLE_CODE(daps_resp_info.pack(bref));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE daps_resp_info_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(unpack_integer(drb_id, bref, (uint8_t)1u, (uint8_t)32u, true, true));
  HANDLE_CODE(daps_resp_info.unpack(bref));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void daps_resp_info_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("dRB-ID", drb_id);
  j.write_fieldname("dAPSResponseInfo");
  daps_resp_info.to_json(j);
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// DRBStatusDL12 ::= SEQUENCE
SRSASN_CODE drb_status_dl12_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(dl_count_value.pack(bref));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE drb_status_dl12_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(dl_count_value.unpack(bref));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void drb_status_dl12_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("dL-COUNTValue");
  dl_count_value.to_json(j);
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// DRBStatusDL18 ::= SEQUENCE
SRSASN_CODE drb_status_dl18_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(dl_count_value.pack(bref));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE drb_status_dl18_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(dl_count_value.unpack(bref));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void drb_status_dl18_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("dL-COUNTValue");
  dl_count_value.to_json(j);
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// DRBStatusDL ::= CHOICE
void drb_status_dl_c::destroy_()
{
  switch (type_) {
    case types::drb_status_dl12:
      c.destroy<drb_status_dl12_s>();
      break;
    case types::drb_status_dl18:
      c.destroy<drb_status_dl18_s>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<drb_status_dl_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void drb_status_dl_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::drb_status_dl12:
      c.init<drb_status_dl12_s>();
      break;
    case types::drb_status_dl18:
      c.init<drb_status_dl18_s>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<drb_status_dl_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "drb_status_dl_c");
  }
}
drb_status_dl_c::drb_status_dl_c(const drb_status_dl_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::drb_status_dl12:
      c.init(other.c.get<drb_status_dl12_s>());
      break;
    case types::drb_status_dl18:
      c.init(other.c.get<drb_status_dl18_s>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<drb_status_dl_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "drb_status_dl_c");
  }
}
drb_status_dl_c& drb_status_dl_c::operator=(const drb_status_dl_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::drb_status_dl12:
      c.set(other.c.get<drb_status_dl12_s>());
      break;
    case types::drb_status_dl18:
      c.set(other.c.get<drb_status_dl18_s>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<drb_status_dl_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "drb_status_dl_c");
  }

  return *this;
}
drb_status_dl12_s& drb_status_dl_c::set_drb_status_dl12()
{
  set(types::drb_status_dl12);
  return c.get<drb_status_dl12_s>();
}
drb_status_dl18_s& drb_status_dl_c::set_drb_status_dl18()
{
  set(types::drb_status_dl18);
  return c.get<drb_status_dl18_s>();
}
protocol_ie_single_container_s<drb_status_dl_ext_ies_o>& drb_status_dl_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<drb_status_dl_ext_ies_o>>();
}
void drb_status_dl_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::drb_status_dl12:
      j.write_fieldname("dRBStatusDL12");
      c.get<drb_status_dl12_s>().to_json(j);
      break;
    case types::drb_status_dl18:
      j.write_fieldname("dRBStatusDL18");
      c.get<drb_status_dl18_s>().to_json(j);
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<drb_status_dl_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "drb_status_dl_c");
  }
  j.end_obj();
}
SRSASN_CODE drb_status_dl_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::drb_status_dl12:
      HANDLE_CODE(c.get<drb_status_dl12_s>().pack(bref));
      break;
    case types::drb_status_dl18:
      HANDLE_CODE(c.get<drb_status_dl18_s>().pack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<drb_status_dl_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "drb_status_dl_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE drb_status_dl_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::drb_status_dl12:
      HANDLE_CODE(c.get<drb_status_dl12_s>().unpack(bref));
      break;
    case types::drb_status_dl18:
      HANDLE_CODE(c.get<drb_status_dl18_s>().unpack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<drb_status_dl_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "drb_status_dl_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* drb_status_dl_c::types_opts::to_string() const
{
  static const char* names[] = {"dRBStatusDL12", "dRBStatusDL18", "choice-Extensions"};
  return convert_enum_idx(names, 3, value, "drb_status_dl_c::types");
}
uint8_t drb_status_dl_c::types_opts::to_number() const
{
  static const uint8_t numbers[] = {12, 18};
  return map_enum_number(numbers, 2, value, "drb_status_dl_c::types");
}

// DRBStatusUL12 ::= SEQUENCE
SRSASN_CODE drb_status_ul12_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(receive_status_of_ul_pdcp_sdus_present, 1));
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(ul_count_value.pack(bref));
  if (receive_status_of_ul_pdcp_sdus_present) {
    HANDLE_CODE(receive_status_of_ul_pdcp_sdus.pack(bref));
  }
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE drb_status_ul12_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(receive_status_of_ul_pdcp_sdus_present, 1));
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(ul_count_value.unpack(bref));
  if (receive_status_of_ul_pdcp_sdus_present) {
    HANDLE_CODE(receive_status_of_ul_pdcp_sdus.unpack(bref));
  }
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void drb_status_ul12_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("uL-COUNTValue");
  ul_count_value.to_json(j);
  if (receive_status_of_ul_pdcp_sdus_present) {
    j.write_str("receiveStatusOfUL-PDCP-SDUs", receive_status_of_ul_pdcp_sdus.to_string());
  }
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// DRBStatusUL18 ::= SEQUENCE
SRSASN_CODE drb_status_ul18_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(receive_status_of_ul_pdcp_sdus_present, 1));
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(ul_count_value.pack(bref));
  if (receive_status_of_ul_pdcp_sdus_present) {
    HANDLE_CODE(receive_status_of_ul_pdcp_sdus.pack(bref));
  }
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE drb_status_ul18_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(receive_status_of_ul_pdcp_sdus_present, 1));
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(ul_count_value.unpack(bref));
  if (receive_status_of_ul_pdcp_sdus_present) {
    HANDLE_CODE(receive_status_of_ul_pdcp_sdus.unpack(bref));
  }
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void drb_status_ul18_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("uL-COUNTValue");
  ul_count_value.to_json(j);
  if (receive_status_of_ul_pdcp_sdus_present) {
    j.write_str("receiveStatusOfUL-PDCP-SDUs", receive_status_of_ul_pdcp_sdus.to_string());
  }
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// DRBStatusUL ::= CHOICE
void drb_status_ul_c::destroy_()
{
  switch (type_) {
    case types::drb_status_ul12:
      c.destroy<drb_status_ul12_s>();
      break;
    case types::drb_status_ul18:
      c.destroy<drb_status_ul18_s>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<drb_status_ul_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void drb_status_ul_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::drb_status_ul12:
      c.init<drb_status_ul12_s>();
      break;
    case types::drb_status_ul18:
      c.init<drb_status_ul18_s>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<drb_status_ul_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "drb_status_ul_c");
  }
}
drb_status_ul_c::drb_status_ul_c(const drb_status_ul_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::drb_status_ul12:
      c.init(other.c.get<drb_status_ul12_s>());
      break;
    case types::drb_status_ul18:
      c.init(other.c.get<drb_status_ul18_s>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<drb_status_ul_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "drb_status_ul_c");
  }
}
drb_status_ul_c& drb_status_ul_c::operator=(const drb_status_ul_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::drb_status_ul12:
      c.set(other.c.get<drb_status_ul12_s>());
      break;
    case types::drb_status_ul18:
      c.set(other.c.get<drb_status_ul18_s>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<drb_status_ul_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "drb_status_ul_c");
  }

  return *this;
}
drb_status_ul12_s& drb_status_ul_c::set_drb_status_ul12()
{
  set(types::drb_status_ul12);
  return c.get<drb_status_ul12_s>();
}
drb_status_ul18_s& drb_status_ul_c::set_drb_status_ul18()
{
  set(types::drb_status_ul18);
  return c.get<drb_status_ul18_s>();
}
protocol_ie_single_container_s<drb_status_ul_ext_ies_o>& drb_status_ul_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<drb_status_ul_ext_ies_o>>();
}
void drb_status_ul_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::drb_status_ul12:
      j.write_fieldname("dRBStatusUL12");
      c.get<drb_status_ul12_s>().to_json(j);
      break;
    case types::drb_status_ul18:
      j.write_fieldname("dRBStatusUL18");
      c.get<drb_status_ul18_s>().to_json(j);
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<drb_status_ul_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "drb_status_ul_c");
  }
  j.end_obj();
}
SRSASN_CODE drb_status_ul_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::drb_status_ul12:
      HANDLE_CODE(c.get<drb_status_ul12_s>().pack(bref));
      break;
    case types::drb_status_ul18:
      HANDLE_CODE(c.get<drb_status_ul18_s>().pack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<drb_status_ul_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "drb_status_ul_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE drb_status_ul_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::drb_status_ul12:
      HANDLE_CODE(c.get<drb_status_ul12_s>().unpack(bref));
      break;
    case types::drb_status_ul18:
      HANDLE_CODE(c.get<drb_status_ul18_s>().unpack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<drb_status_ul_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "drb_status_ul_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* drb_status_ul_c::types_opts::to_string() const
{
  static const char* names[] = {"dRBStatusUL12", "dRBStatusUL18", "choice-Extensions"};
  return convert_enum_idx(names, 3, value, "drb_status_ul_c::types");
}
uint8_t drb_status_ul_c::types_opts::to_number() const
{
  static const uint8_t numbers[] = {12, 18};
  return map_enum_number(numbers, 2, value, "drb_status_ul_c::types");
}

// DRBsSubjectToEarlyStatusTransfer-Item ::= SEQUENCE
SRSASN_CODE drbs_subject_to_early_status_transfer_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(pack_integer(bref, drb_id, (uint8_t)1u, (uint8_t)32u, true, true));
  HANDLE_CODE(first_dl_count.pack(bref));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE drbs_subject_to_early_status_transfer_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(unpack_integer(drb_id, bref, (uint8_t)1u, (uint8_t)32u, true, true));
  HANDLE_CODE(first_dl_count.unpack(bref));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void drbs_subject_to_early_status_transfer_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("dRB-ID", drb_id);
  j.write_fieldname("firstDLCOUNT");
  first_dl_count.to_json(j);
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// DRBsSubjectToStatusTransferItem-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t drbs_subject_to_status_transfer_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {159};
  return map_enum_number(names, 1, idx, "id");
}
bool drbs_subject_to_status_transfer_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 159 == id;
}
crit_e drbs_subject_to_status_transfer_item_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 159) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
drbs_subject_to_status_transfer_item_ext_ies_o::ext_c
drbs_subject_to_status_transfer_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 159) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e drbs_subject_to_status_transfer_item_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 159) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void drbs_subject_to_status_transfer_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("AssociatedQosFlowList");
  for (const auto& e1 : c) {
    e1.to_json(j);
  }
  j.end_array();
  j.end_obj();
}
SRSASN_CODE drbs_subject_to_status_transfer_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(pack_dyn_seq_of(bref, c, 1, 64, true));
  return SRSASN_SUCCESS;
}
SRSASN_CODE drbs_subject_to_status_transfer_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(unpack_dyn_seq_of(c, bref, 1, 64, true));
  return SRSASN_SUCCESS;
}

const char* drbs_subject_to_status_transfer_item_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"AssociatedQosFlowList"};
  return convert_enum_idx(names, 1, value, "drbs_subject_to_status_transfer_item_ext_ies_o::ext_c::types");
}

// DRBsSubjectToStatusTransferItem ::= SEQUENCE
SRSASN_CODE drbs_subject_to_status_transfer_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_ext.size() > 0, 1));

  HANDLE_CODE(pack_integer(bref, drb_id, (uint8_t)1u, (uint8_t)32u, true, true));
  HANDLE_CODE(drb_status_ul.pack(bref));
  HANDLE_CODE(drb_status_dl.pack(bref));
  if (ie_ext.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_ext, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE drbs_subject_to_status_transfer_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool ie_ext_present;
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(unpack_integer(drb_id, bref, (uint8_t)1u, (uint8_t)32u, true, true));
  HANDLE_CODE(drb_status_ul.unpack(bref));
  HANDLE_CODE(drb_status_dl.unpack(bref));
  if (ie_ext_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_ext, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void drbs_subject_to_status_transfer_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("dRB-ID", drb_id);
  j.write_fieldname("dRBStatusUL");
  drb_status_ul.to_json(j);
  j.write_fieldname("dRBStatusDL");
  drb_status_dl.to_json(j);
  if (ie_ext.size() > 0) {
    j.write_fieldname("iE-Extension");
  }
  j.end_obj();
}

// DRBsToQosFlowsMappingItem-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t drbs_to_qos_flows_map_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {266};
  return map_enum_number(names, 1, idx, "id");
}
bool drbs_to_qos_flows_map_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 266 == id;
}
crit_e drbs_to_qos_flows_map_item_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 266) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
drbs_to_qos_flows_map_item_ext_ies_o::ext_c drbs_to_qos_flows_map_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 266) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e drbs_to_qos_flows_map_item_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 266) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void drbs_to_qos_flows_map_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("DAPSRequestInfo");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE drbs_to_qos_flows_map_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE drbs_to_qos_flows_map_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* drbs_to_qos_flows_map_item_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"DAPSRequestInfo"};
  return convert_enum_idx(names, 1, value, "drbs_to_qos_flows_map_item_ext_ies_o::ext_c::types");
}

// DRBsToQosFlowsMappingItem ::= SEQUENCE
SRSASN_CODE drbs_to_qos_flows_map_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(pack_integer(bref, drb_id, (uint8_t)1u, (uint8_t)32u, true, true));
  HANDLE_CODE(pack_dyn_seq_of(bref, associated_qos_flow_list, 1, 64, true));
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE drbs_to_qos_flows_map_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(drb_id, bref, (uint8_t)1u, (uint8_t)32u, true, true));
  HANDLE_CODE(unpack_dyn_seq_of(associated_qos_flow_list, bref, 1, 64, true));
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void drbs_to_qos_flows_map_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("dRB-ID", drb_id);
  j.start_array("associatedQosFlowList");
  for (const auto& e1 : associated_qos_flow_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// DataForwardingResponseDRBItem ::= SEQUENCE
SRSASN_CODE data_forwarding_resp_drb_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(dl_forwarding_up_tnl_info_present, 1));
  HANDLE_CODE(bref.pack(ul_forwarding_up_tnl_info_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, drb_id, (uint8_t)1u, (uint8_t)32u, true, true));
  if (dl_forwarding_up_tnl_info_present) {
    HANDLE_CODE(dl_forwarding_up_tnl_info.pack(bref));
  }
  if (ul_forwarding_up_tnl_info_present) {
    HANDLE_CODE(ul_forwarding_up_tnl_info.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE data_forwarding_resp_drb_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(dl_forwarding_up_tnl_info_present, 1));
  HANDLE_CODE(bref.unpack(ul_forwarding_up_tnl_info_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(drb_id, bref, (uint8_t)1u, (uint8_t)32u, true, true));
  if (dl_forwarding_up_tnl_info_present) {
    HANDLE_CODE(dl_forwarding_up_tnl_info.unpack(bref));
  }
  if (ul_forwarding_up_tnl_info_present) {
    HANDLE_CODE(ul_forwarding_up_tnl_info.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void data_forwarding_resp_drb_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("dRB-ID", drb_id);
  if (dl_forwarding_up_tnl_info_present) {
    j.write_fieldname("dLForwardingUP-TNLInformation");
    dl_forwarding_up_tnl_info.to_json(j);
  }
  if (ul_forwarding_up_tnl_info_present) {
    j.write_fieldname("uLForwardingUP-TNLInformation");
    ul_forwarding_up_tnl_info.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// DataForwardingResponseERABListItem ::= SEQUENCE
SRSASN_CODE data_forwarding_resp_erab_list_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, erab_id, (uint8_t)0u, (uint8_t)15u, true, true));
  HANDLE_CODE(dl_forwarding_up_tnl_info.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE data_forwarding_resp_erab_list_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(erab_id, bref, (uint8_t)0u, (uint8_t)15u, true, true));
  HANDLE_CODE(dl_forwarding_up_tnl_info.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void data_forwarding_resp_erab_list_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("e-RAB-ID", erab_id);
  j.write_fieldname("dLForwardingUP-TNLInformation");
  dl_forwarding_up_tnl_info.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// DeactivateTraceIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t deactiv_trace_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 44};
  return map_enum_number(names, 3, idx, "id");
}
bool deactiv_trace_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 44};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e deactiv_trace_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 44:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
deactiv_trace_ies_o::value_c deactiv_trace_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 44:
      ret.set(value_c::types::ngran_trace_id);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e deactiv_trace_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 44:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void deactiv_trace_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::ngran_trace_id:
      c.destroy<fixed_octstring<8, true>>();
      break;
    default:
      break;
  }
}
void deactiv_trace_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::ngran_trace_id:
      c.init<fixed_octstring<8, true>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "deactiv_trace_ies_o::value_c");
  }
}
deactiv_trace_ies_o::value_c::value_c(const deactiv_trace_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ngran_trace_id:
      c.init(other.c.get<fixed_octstring<8, true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "deactiv_trace_ies_o::value_c");
  }
}
deactiv_trace_ies_o::value_c& deactiv_trace_ies_o::value_c::operator=(const deactiv_trace_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ngran_trace_id:
      c.set(other.c.get<fixed_octstring<8, true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "deactiv_trace_ies_o::value_c");
  }

  return *this;
}
uint64_t& deactiv_trace_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& deactiv_trace_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
fixed_octstring<8, true>& deactiv_trace_ies_o::value_c::ngran_trace_id()
{
  assert_choice_type(types::ngran_trace_id, type_, "Value");
  return c.get<fixed_octstring<8, true>>();
}
const uint64_t& deactiv_trace_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& deactiv_trace_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const fixed_octstring<8, true>& deactiv_trace_ies_o::value_c::ngran_trace_id() const
{
  assert_choice_type(types::ngran_trace_id, type_, "Value");
  return c.get<fixed_octstring<8, true>>();
}
void deactiv_trace_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::ngran_trace_id:
      j.write_str("OCTET STRING", c.get<fixed_octstring<8, true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "deactiv_trace_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE deactiv_trace_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ngran_trace_id:
      HANDLE_CODE((c.get<fixed_octstring<8, true>>().pack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "deactiv_trace_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE deactiv_trace_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ngran_trace_id:
      HANDLE_CODE((c.get<fixed_octstring<8, true>>().unpack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "deactiv_trace_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* deactiv_trace_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..1099511627775)", "INTEGER (0..4294967295)", "OCTET STRING"};
  return convert_enum_idx(names, 3, value, "deactiv_trace_ies_o::value_c::types");
}

template struct asn1::protocol_ie_field_s<deactiv_trace_ies_o>;

deactiv_trace_ies_container::deactiv_trace_ies_container() :
  amf_ue_ngap_id(10, crit_e::reject), ran_ue_ngap_id(85, crit_e::reject), ngran_trace_id(44, crit_e::ignore)
{
}
SRSASN_CODE deactiv_trace_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  HANDLE_CODE(ngran_trace_id.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE deactiv_trace_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 44: {
        nof_mandatory_ies--;
        ngran_trace_id.id = id;
        HANDLE_CODE(ngran_trace_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ngran_trace_id.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void deactiv_trace_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ngran_trace_id.to_json(j);
  j.end_obj();
}

// DistributionReleaseRequestIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t distribution_release_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 295, 300, 15};
  return map_enum_number(names, 4, idx, "id");
}
bool distribution_release_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 295, 300, 15};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e distribution_release_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::reject;
    case 295:
      return crit_e::reject;
    case 300:
      return crit_e::reject;
    case 15:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
distribution_release_request_ies_o::value_c distribution_release_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 295:
      ret.set(value_c::types::mbs_area_session_id);
      break;
    case 300:
      ret.set(value_c::types::mbs_distribution_release_request_transfer);
      break;
    case 15:
      ret.set(value_c::types::cause);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e distribution_release_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 295:
      return presence_e::optional;
    case 300:
      return presence_e::mandatory;
    case 15:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void distribution_release_request_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::mbs_session_id:
      c.destroy<mbs_session_id_s>();
      break;
    case types::mbs_distribution_release_request_transfer:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::cause:
      c.destroy<cause_c>();
      break;
    default:
      break;
  }
}
void distribution_release_request_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c.init<mbs_session_id_s>();
      break;
    case types::mbs_area_session_id:
      break;
    case types::mbs_distribution_release_request_transfer:
      c.init<unbounded_octstring<true>>();
      break;
    case types::cause:
      c.init<cause_c>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "distribution_release_request_ies_o::value_c");
  }
}
distribution_release_request_ies_o::value_c::value_c(const distribution_release_request_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mbs_session_id:
      c.init(other.c.get<mbs_session_id_s>());
      break;
    case types::mbs_area_session_id:
      c.init(other.c.get<uint32_t>());
      break;
    case types::mbs_distribution_release_request_transfer:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "distribution_release_request_ies_o::value_c");
  }
}
distribution_release_request_ies_o::value_c&
distribution_release_request_ies_o::value_c::operator=(const distribution_release_request_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mbs_session_id:
      c.set(other.c.get<mbs_session_id_s>());
      break;
    case types::mbs_area_session_id:
      c.set(other.c.get<uint32_t>());
      break;
    case types::mbs_distribution_release_request_transfer:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "distribution_release_request_ies_o::value_c");
  }

  return *this;
}
mbs_session_id_s& distribution_release_request_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
uint32_t& distribution_release_request_ies_o::value_c::mbs_area_session_id()
{
  assert_choice_type(types::mbs_area_session_id, type_, "Value");
  return c.get<uint32_t>();
}
unbounded_octstring<true>& distribution_release_request_ies_o::value_c::mbs_distribution_release_request_transfer()
{
  assert_choice_type(types::mbs_distribution_release_request_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
cause_c& distribution_release_request_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const mbs_session_id_s& distribution_release_request_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const uint32_t& distribution_release_request_ies_o::value_c::mbs_area_session_id() const
{
  assert_choice_type(types::mbs_area_session_id, type_, "Value");
  return c.get<uint32_t>();
}
const unbounded_octstring<true>&
distribution_release_request_ies_o::value_c::mbs_distribution_release_request_transfer() const
{
  assert_choice_type(types::mbs_distribution_release_request_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const cause_c& distribution_release_request_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
void distribution_release_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::mbs_area_session_id:
      j.write_int("INTEGER (0..65535,...)", c.get<uint32_t>());
      break;
    case types::mbs_distribution_release_request_transfer:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "distribution_release_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE distribution_release_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::mbs_area_session_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)65535u, true, true));
      break;
    case types::mbs_distribution_release_request_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "distribution_release_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE distribution_release_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::mbs_area_session_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)65535u, true, true));
      break;
    case types::mbs_distribution_release_request_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "distribution_release_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* distribution_release_request_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"MBS-SessionID", "INTEGER (0..65535,...)", "OCTET STRING", "Cause"};
  return convert_enum_idx(names, 4, value, "distribution_release_request_ies_o::value_c::types");
}
uint8_t distribution_release_request_ies_o::value_c::types_opts::to_number() const
{
  if (value == mbs_area_session_id) {
    return 0;
  }
  invalid_enum_number(value, "distribution_release_request_ies_o::value_c::types");
  return 0;
}

template struct asn1::protocol_ie_field_s<distribution_release_request_ies_o>;

distribution_release_request_ies_container::distribution_release_request_ies_container() :
  mbs_session_id(299, crit_e::reject),
  mbs_area_session_id(295, crit_e::reject),
  mbs_distribution_release_request_transfer(300, crit_e::reject),
  cause(15, crit_e::ignore)
{
}
SRSASN_CODE distribution_release_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += mbs_area_session_id_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mbs_session_id.pack(bref));
  if (mbs_area_session_id_present) {
    HANDLE_CODE(mbs_area_session_id.pack(bref));
  }
  HANDLE_CODE(mbs_distribution_release_request_transfer.pack(bref));
  HANDLE_CODE(cause.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE distribution_release_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        mbs_session_id.id = id;
        HANDLE_CODE(mbs_session_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.value.unpack(bref));
        break;
      }
      case 295: {
        mbs_area_session_id_present = true;
        mbs_area_session_id.id      = id;
        HANDLE_CODE(mbs_area_session_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_area_session_id.value.unpack(bref));
        break;
      }
      case 300: {
        nof_mandatory_ies--;
        mbs_distribution_release_request_transfer.id = id;
        HANDLE_CODE(mbs_distribution_release_request_transfer.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_distribution_release_request_transfer.value.unpack(bref));
        break;
      }
      case 15: {
        nof_mandatory_ies--;
        cause.id = id;
        HANDLE_CODE(cause.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void distribution_release_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mbs_session_id.to_json(j);
  if (mbs_area_session_id_present) {
    j.write_fieldname("");
    mbs_area_session_id.to_json(j);
  }
  j.write_fieldname("");
  mbs_distribution_release_request_transfer.to_json(j);
  j.write_fieldname("");
  cause.to_json(j);
  j.end_obj();
}

// DistributionReleaseResponseIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t distribution_release_resp_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 295, 19};
  return map_enum_number(names, 3, idx, "id");
}
bool distribution_release_resp_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 295, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e distribution_release_resp_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::reject;
    case 295:
      return crit_e::reject;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
distribution_release_resp_ies_o::value_c distribution_release_resp_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 295:
      ret.set(value_c::types::mbs_area_session_id);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e distribution_release_resp_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 295:
      return presence_e::optional;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void distribution_release_resp_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::mbs_session_id:
      c.destroy<mbs_session_id_s>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void distribution_release_resp_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c.init<mbs_session_id_s>();
      break;
    case types::mbs_area_session_id:
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "distribution_release_resp_ies_o::value_c");
  }
}
distribution_release_resp_ies_o::value_c::value_c(const distribution_release_resp_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mbs_session_id:
      c.init(other.c.get<mbs_session_id_s>());
      break;
    case types::mbs_area_session_id:
      c.init(other.c.get<uint32_t>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "distribution_release_resp_ies_o::value_c");
  }
}
distribution_release_resp_ies_o::value_c&
distribution_release_resp_ies_o::value_c::operator=(const distribution_release_resp_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mbs_session_id:
      c.set(other.c.get<mbs_session_id_s>());
      break;
    case types::mbs_area_session_id:
      c.set(other.c.get<uint32_t>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "distribution_release_resp_ies_o::value_c");
  }

  return *this;
}
mbs_session_id_s& distribution_release_resp_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
uint32_t& distribution_release_resp_ies_o::value_c::mbs_area_session_id()
{
  assert_choice_type(types::mbs_area_session_id, type_, "Value");
  return c.get<uint32_t>();
}
crit_diagnostics_s& distribution_release_resp_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const mbs_session_id_s& distribution_release_resp_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const uint32_t& distribution_release_resp_ies_o::value_c::mbs_area_session_id() const
{
  assert_choice_type(types::mbs_area_session_id, type_, "Value");
  return c.get<uint32_t>();
}
const crit_diagnostics_s& distribution_release_resp_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void distribution_release_resp_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::mbs_area_session_id:
      j.write_int("INTEGER (0..65535,...)", c.get<uint32_t>());
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "distribution_release_resp_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE distribution_release_resp_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::mbs_area_session_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)65535u, true, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "distribution_release_resp_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE distribution_release_resp_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::mbs_area_session_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)65535u, true, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "distribution_release_resp_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* distribution_release_resp_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"MBS-SessionID", "INTEGER (0..65535,...)", "CriticalityDiagnostics"};
  return convert_enum_idx(names, 3, value, "distribution_release_resp_ies_o::value_c::types");
}
uint8_t distribution_release_resp_ies_o::value_c::types_opts::to_number() const
{
  if (value == mbs_area_session_id) {
    return 0;
  }
  invalid_enum_number(value, "distribution_release_resp_ies_o::value_c::types");
  return 0;
}

template struct asn1::protocol_ie_field_s<distribution_release_resp_ies_o>;

distribution_release_resp_ies_container::distribution_release_resp_ies_container() :
  mbs_session_id(299, crit_e::reject), mbs_area_session_id(295, crit_e::reject), crit_diagnostics(19, crit_e::ignore)
{
}
SRSASN_CODE distribution_release_resp_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 1;
  nof_ies += mbs_area_session_id_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mbs_session_id.pack(bref));
  if (mbs_area_session_id_present) {
    HANDLE_CODE(mbs_area_session_id.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE distribution_release_resp_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 1;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        mbs_session_id.id = id;
        HANDLE_CODE(mbs_session_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.value.unpack(bref));
        break;
      }
      case 295: {
        mbs_area_session_id_present = true;
        mbs_area_session_id.id      = id;
        HANDLE_CODE(mbs_area_session_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_area_session_id.value.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        crit_diagnostics.id      = id;
        HANDLE_CODE(crit_diagnostics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void distribution_release_resp_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mbs_session_id.to_json(j);
  if (mbs_area_session_id_present) {
    j.write_fieldname("");
    mbs_area_session_id.to_json(j);
  }
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

// DistributionSetupFailureIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t distribution_setup_fail_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 295, 303, 15, 19};
  return map_enum_number(names, 5, idx, "id");
}
bool distribution_setup_fail_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 295, 303, 15, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e distribution_setup_fail_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::reject;
    case 295:
      return crit_e::reject;
    case 303:
      return crit_e::ignore;
    case 15:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
distribution_setup_fail_ies_o::value_c distribution_setup_fail_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 295:
      ret.set(value_c::types::mbs_area_session_id);
      break;
    case 303:
      ret.set(value_c::types::mbs_distribution_setup_unsuccessful_transfer);
      break;
    case 15:
      ret.set(value_c::types::cause);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e distribution_setup_fail_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 295:
      return presence_e::optional;
    case 303:
      return presence_e::mandatory;
    case 15:
      return presence_e::mandatory;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void distribution_setup_fail_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::mbs_session_id:
      c.destroy<mbs_session_id_s>();
      break;
    case types::mbs_distribution_setup_unsuccessful_transfer:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::cause:
      c.destroy<cause_c>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void distribution_setup_fail_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c.init<mbs_session_id_s>();
      break;
    case types::mbs_area_session_id:
      break;
    case types::mbs_distribution_setup_unsuccessful_transfer:
      c.init<unbounded_octstring<true>>();
      break;
    case types::cause:
      c.init<cause_c>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "distribution_setup_fail_ies_o::value_c");
  }
}
distribution_setup_fail_ies_o::value_c::value_c(const distribution_setup_fail_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mbs_session_id:
      c.init(other.c.get<mbs_session_id_s>());
      break;
    case types::mbs_area_session_id:
      c.init(other.c.get<uint32_t>());
      break;
    case types::mbs_distribution_setup_unsuccessful_transfer:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "distribution_setup_fail_ies_o::value_c");
  }
}
distribution_setup_fail_ies_o::value_c&
distribution_setup_fail_ies_o::value_c::operator=(const distribution_setup_fail_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mbs_session_id:
      c.set(other.c.get<mbs_session_id_s>());
      break;
    case types::mbs_area_session_id:
      c.set(other.c.get<uint32_t>());
      break;
    case types::mbs_distribution_setup_unsuccessful_transfer:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "distribution_setup_fail_ies_o::value_c");
  }

  return *this;
}
mbs_session_id_s& distribution_setup_fail_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
uint32_t& distribution_setup_fail_ies_o::value_c::mbs_area_session_id()
{
  assert_choice_type(types::mbs_area_session_id, type_, "Value");
  return c.get<uint32_t>();
}
unbounded_octstring<true>& distribution_setup_fail_ies_o::value_c::mbs_distribution_setup_unsuccessful_transfer()
{
  assert_choice_type(types::mbs_distribution_setup_unsuccessful_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
cause_c& distribution_setup_fail_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
crit_diagnostics_s& distribution_setup_fail_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const mbs_session_id_s& distribution_setup_fail_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const uint32_t& distribution_setup_fail_ies_o::value_c::mbs_area_session_id() const
{
  assert_choice_type(types::mbs_area_session_id, type_, "Value");
  return c.get<uint32_t>();
}
const unbounded_octstring<true>&
distribution_setup_fail_ies_o::value_c::mbs_distribution_setup_unsuccessful_transfer() const
{
  assert_choice_type(types::mbs_distribution_setup_unsuccessful_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const cause_c& distribution_setup_fail_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const crit_diagnostics_s& distribution_setup_fail_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void distribution_setup_fail_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::mbs_area_session_id:
      j.write_int("INTEGER (0..65535,...)", c.get<uint32_t>());
      break;
    case types::mbs_distribution_setup_unsuccessful_transfer:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "distribution_setup_fail_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE distribution_setup_fail_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::mbs_area_session_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)65535u, true, true));
      break;
    case types::mbs_distribution_setup_unsuccessful_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "distribution_setup_fail_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE distribution_setup_fail_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::mbs_area_session_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)65535u, true, true));
      break;
    case types::mbs_distribution_setup_unsuccessful_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "distribution_setup_fail_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* distribution_setup_fail_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {
      "MBS-SessionID", "INTEGER (0..65535,...)", "OCTET STRING", "Cause", "CriticalityDiagnostics"};
  return convert_enum_idx(names, 5, value, "distribution_setup_fail_ies_o::value_c::types");
}
uint8_t distribution_setup_fail_ies_o::value_c::types_opts::to_number() const
{
  if (value == mbs_area_session_id) {
    return 0;
  }
  invalid_enum_number(value, "distribution_setup_fail_ies_o::value_c::types");
  return 0;
}

template struct asn1::protocol_ie_field_s<distribution_setup_fail_ies_o>;

distribution_setup_fail_ies_container::distribution_setup_fail_ies_container() :
  mbs_session_id(299, crit_e::reject),
  mbs_area_session_id(295, crit_e::reject),
  mbs_distribution_setup_unsuccessful_transfer(303, crit_e::ignore),
  cause(15, crit_e::ignore),
  crit_diagnostics(19, crit_e::ignore)
{
}
SRSASN_CODE distribution_setup_fail_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += mbs_area_session_id_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mbs_session_id.pack(bref));
  if (mbs_area_session_id_present) {
    HANDLE_CODE(mbs_area_session_id.pack(bref));
  }
  HANDLE_CODE(mbs_distribution_setup_unsuccessful_transfer.pack(bref));
  HANDLE_CODE(cause.pack(bref));
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE distribution_setup_fail_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        mbs_session_id.id = id;
        HANDLE_CODE(mbs_session_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.value.unpack(bref));
        break;
      }
      case 295: {
        mbs_area_session_id_present = true;
        mbs_area_session_id.id      = id;
        HANDLE_CODE(mbs_area_session_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_area_session_id.value.unpack(bref));
        break;
      }
      case 303: {
        nof_mandatory_ies--;
        mbs_distribution_setup_unsuccessful_transfer.id = id;
        HANDLE_CODE(mbs_distribution_setup_unsuccessful_transfer.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_distribution_setup_unsuccessful_transfer.value.unpack(bref));
        break;
      }
      case 15: {
        nof_mandatory_ies--;
        cause.id = id;
        HANDLE_CODE(cause.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.value.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        crit_diagnostics.id      = id;
        HANDLE_CODE(crit_diagnostics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void distribution_setup_fail_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mbs_session_id.to_json(j);
  if (mbs_area_session_id_present) {
    j.write_fieldname("");
    mbs_area_session_id.to_json(j);
  }
  j.write_fieldname("");
  mbs_distribution_setup_unsuccessful_transfer.to_json(j);
  j.write_fieldname("");
  cause.to_json(j);
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

// DistributionSetupRequestIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t distribution_setup_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 295, 301};
  return map_enum_number(names, 3, idx, "id");
}
bool distribution_setup_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 295, 301};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e distribution_setup_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::reject;
    case 295:
      return crit_e::reject;
    case 301:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
distribution_setup_request_ies_o::value_c distribution_setup_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 295:
      ret.set(value_c::types::mbs_area_session_id);
      break;
    case 301:
      ret.set(value_c::types::mbs_distribution_setup_request_transfer);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e distribution_setup_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 295:
      return presence_e::optional;
    case 301:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void distribution_setup_request_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::mbs_session_id:
      c.destroy<mbs_session_id_s>();
      break;
    case types::mbs_distribution_setup_request_transfer:
      c.destroy<unbounded_octstring<true>>();
      break;
    default:
      break;
  }
}
void distribution_setup_request_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c.init<mbs_session_id_s>();
      break;
    case types::mbs_area_session_id:
      break;
    case types::mbs_distribution_setup_request_transfer:
      c.init<unbounded_octstring<true>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "distribution_setup_request_ies_o::value_c");
  }
}
distribution_setup_request_ies_o::value_c::value_c(const distribution_setup_request_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mbs_session_id:
      c.init(other.c.get<mbs_session_id_s>());
      break;
    case types::mbs_area_session_id:
      c.init(other.c.get<uint32_t>());
      break;
    case types::mbs_distribution_setup_request_transfer:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "distribution_setup_request_ies_o::value_c");
  }
}
distribution_setup_request_ies_o::value_c&
distribution_setup_request_ies_o::value_c::operator=(const distribution_setup_request_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mbs_session_id:
      c.set(other.c.get<mbs_session_id_s>());
      break;
    case types::mbs_area_session_id:
      c.set(other.c.get<uint32_t>());
      break;
    case types::mbs_distribution_setup_request_transfer:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "distribution_setup_request_ies_o::value_c");
  }

  return *this;
}
mbs_session_id_s& distribution_setup_request_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
uint32_t& distribution_setup_request_ies_o::value_c::mbs_area_session_id()
{
  assert_choice_type(types::mbs_area_session_id, type_, "Value");
  return c.get<uint32_t>();
}
unbounded_octstring<true>& distribution_setup_request_ies_o::value_c::mbs_distribution_setup_request_transfer()
{
  assert_choice_type(types::mbs_distribution_setup_request_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const mbs_session_id_s& distribution_setup_request_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const uint32_t& distribution_setup_request_ies_o::value_c::mbs_area_session_id() const
{
  assert_choice_type(types::mbs_area_session_id, type_, "Value");
  return c.get<uint32_t>();
}
const unbounded_octstring<true>&
distribution_setup_request_ies_o::value_c::mbs_distribution_setup_request_transfer() const
{
  assert_choice_type(types::mbs_distribution_setup_request_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
void distribution_setup_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::mbs_area_session_id:
      j.write_int("INTEGER (0..65535,...)", c.get<uint32_t>());
      break;
    case types::mbs_distribution_setup_request_transfer:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "distribution_setup_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE distribution_setup_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::mbs_area_session_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)65535u, true, true));
      break;
    case types::mbs_distribution_setup_request_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "distribution_setup_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE distribution_setup_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::mbs_area_session_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)65535u, true, true));
      break;
    case types::mbs_distribution_setup_request_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "distribution_setup_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* distribution_setup_request_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"MBS-SessionID", "INTEGER (0..65535,...)", "OCTET STRING"};
  return convert_enum_idx(names, 3, value, "distribution_setup_request_ies_o::value_c::types");
}
uint8_t distribution_setup_request_ies_o::value_c::types_opts::to_number() const
{
  if (value == mbs_area_session_id) {
    return 0;
  }
  invalid_enum_number(value, "distribution_setup_request_ies_o::value_c::types");
  return 0;
}

template struct asn1::protocol_ie_field_s<distribution_setup_request_ies_o>;

distribution_setup_request_ies_container::distribution_setup_request_ies_container() :
  mbs_session_id(299, crit_e::reject),
  mbs_area_session_id(295, crit_e::reject),
  mbs_distribution_setup_request_transfer(301, crit_e::reject)
{
}
SRSASN_CODE distribution_setup_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += mbs_area_session_id_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mbs_session_id.pack(bref));
  if (mbs_area_session_id_present) {
    HANDLE_CODE(mbs_area_session_id.pack(bref));
  }
  HANDLE_CODE(mbs_distribution_setup_request_transfer.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE distribution_setup_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        mbs_session_id.id = id;
        HANDLE_CODE(mbs_session_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.value.unpack(bref));
        break;
      }
      case 295: {
        mbs_area_session_id_present = true;
        mbs_area_session_id.id      = id;
        HANDLE_CODE(mbs_area_session_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_area_session_id.value.unpack(bref));
        break;
      }
      case 301: {
        nof_mandatory_ies--;
        mbs_distribution_setup_request_transfer.id = id;
        HANDLE_CODE(mbs_distribution_setup_request_transfer.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_distribution_setup_request_transfer.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void distribution_setup_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mbs_session_id.to_json(j);
  if (mbs_area_session_id_present) {
    j.write_fieldname("");
    mbs_area_session_id.to_json(j);
  }
  j.write_fieldname("");
  mbs_distribution_setup_request_transfer.to_json(j);
  j.end_obj();
}

// DistributionSetupResponseIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t distribution_setup_resp_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 295, 302, 19};
  return map_enum_number(names, 4, idx, "id");
}
bool distribution_setup_resp_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 295, 302, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e distribution_setup_resp_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::reject;
    case 295:
      return crit_e::reject;
    case 302:
      return crit_e::reject;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
distribution_setup_resp_ies_o::value_c distribution_setup_resp_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 295:
      ret.set(value_c::types::mbs_area_session_id);
      break;
    case 302:
      ret.set(value_c::types::mbs_distribution_setup_resp_transfer);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e distribution_setup_resp_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 295:
      return presence_e::optional;
    case 302:
      return presence_e::mandatory;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void distribution_setup_resp_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::mbs_session_id:
      c.destroy<mbs_session_id_s>();
      break;
    case types::mbs_distribution_setup_resp_transfer:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void distribution_setup_resp_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c.init<mbs_session_id_s>();
      break;
    case types::mbs_area_session_id:
      break;
    case types::mbs_distribution_setup_resp_transfer:
      c.init<unbounded_octstring<true>>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "distribution_setup_resp_ies_o::value_c");
  }
}
distribution_setup_resp_ies_o::value_c::value_c(const distribution_setup_resp_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mbs_session_id:
      c.init(other.c.get<mbs_session_id_s>());
      break;
    case types::mbs_area_session_id:
      c.init(other.c.get<uint32_t>());
      break;
    case types::mbs_distribution_setup_resp_transfer:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "distribution_setup_resp_ies_o::value_c");
  }
}
distribution_setup_resp_ies_o::value_c&
distribution_setup_resp_ies_o::value_c::operator=(const distribution_setup_resp_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mbs_session_id:
      c.set(other.c.get<mbs_session_id_s>());
      break;
    case types::mbs_area_session_id:
      c.set(other.c.get<uint32_t>());
      break;
    case types::mbs_distribution_setup_resp_transfer:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "distribution_setup_resp_ies_o::value_c");
  }

  return *this;
}
mbs_session_id_s& distribution_setup_resp_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
uint32_t& distribution_setup_resp_ies_o::value_c::mbs_area_session_id()
{
  assert_choice_type(types::mbs_area_session_id, type_, "Value");
  return c.get<uint32_t>();
}
unbounded_octstring<true>& distribution_setup_resp_ies_o::value_c::mbs_distribution_setup_resp_transfer()
{
  assert_choice_type(types::mbs_distribution_setup_resp_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
crit_diagnostics_s& distribution_setup_resp_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const mbs_session_id_s& distribution_setup_resp_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const uint32_t& distribution_setup_resp_ies_o::value_c::mbs_area_session_id() const
{
  assert_choice_type(types::mbs_area_session_id, type_, "Value");
  return c.get<uint32_t>();
}
const unbounded_octstring<true>& distribution_setup_resp_ies_o::value_c::mbs_distribution_setup_resp_transfer() const
{
  assert_choice_type(types::mbs_distribution_setup_resp_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const crit_diagnostics_s& distribution_setup_resp_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void distribution_setup_resp_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::mbs_area_session_id:
      j.write_int("INTEGER (0..65535,...)", c.get<uint32_t>());
      break;
    case types::mbs_distribution_setup_resp_transfer:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "distribution_setup_resp_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE distribution_setup_resp_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::mbs_area_session_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)65535u, true, true));
      break;
    case types::mbs_distribution_setup_resp_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "distribution_setup_resp_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE distribution_setup_resp_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::mbs_area_session_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)65535u, true, true));
      break;
    case types::mbs_distribution_setup_resp_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "distribution_setup_resp_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* distribution_setup_resp_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"MBS-SessionID", "INTEGER (0..65535,...)", "OCTET STRING", "CriticalityDiagnostics"};
  return convert_enum_idx(names, 4, value, "distribution_setup_resp_ies_o::value_c::types");
}
uint8_t distribution_setup_resp_ies_o::value_c::types_opts::to_number() const
{
  if (value == mbs_area_session_id) {
    return 0;
  }
  invalid_enum_number(value, "distribution_setup_resp_ies_o::value_c::types");
  return 0;
}

template struct asn1::protocol_ie_field_s<distribution_setup_resp_ies_o>;

distribution_setup_resp_ies_container::distribution_setup_resp_ies_container() :
  mbs_session_id(299, crit_e::reject),
  mbs_area_session_id(295, crit_e::reject),
  mbs_distribution_setup_resp_transfer(302, crit_e::reject),
  crit_diagnostics(19, crit_e::ignore)
{
}
SRSASN_CODE distribution_setup_resp_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += mbs_area_session_id_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mbs_session_id.pack(bref));
  if (mbs_area_session_id_present) {
    HANDLE_CODE(mbs_area_session_id.pack(bref));
  }
  HANDLE_CODE(mbs_distribution_setup_resp_transfer.pack(bref));
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE distribution_setup_resp_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        mbs_session_id.id = id;
        HANDLE_CODE(mbs_session_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.value.unpack(bref));
        break;
      }
      case 295: {
        mbs_area_session_id_present = true;
        mbs_area_session_id.id      = id;
        HANDLE_CODE(mbs_area_session_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_area_session_id.value.unpack(bref));
        break;
      }
      case 302: {
        nof_mandatory_ies--;
        mbs_distribution_setup_resp_transfer.id = id;
        HANDLE_CODE(mbs_distribution_setup_resp_transfer.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_distribution_setup_resp_transfer.value.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        crit_diagnostics.id      = id;
        HANDLE_CODE(crit_diagnostics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void distribution_setup_resp_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mbs_session_id.to_json(j);
  if (mbs_area_session_id_present) {
    j.write_fieldname("");
    mbs_area_session_id.to_json(j);
  }
  j.write_fieldname("");
  mbs_distribution_setup_resp_transfer.to_json(j);
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

// ExtendedRATRestrictionInformation ::= SEQUENCE
SRSASN_CODE extended_rat_restrict_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(primary_rat_restrict.pack(bref));
  HANDLE_CODE(secondary_rat_restrict.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE extended_rat_restrict_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(primary_rat_restrict.unpack(bref));
  HANDLE_CODE(secondary_rat_restrict.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void extended_rat_restrict_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("primaryRATRestriction", primary_rat_restrict.to_string());
  j.write_str("secondaryRATRestriction", secondary_rat_restrict.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PNI-NPN-MobilityInformation ::= SEQUENCE
SRSASN_CODE pni_npn_mob_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, allowed_pni_npi_list, 1, 16, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pni_npn_mob_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(allowed_pni_npi_list, bref, 1, 16, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pni_npn_mob_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("allowed-PNI-NPI-List");
  for (const auto& e1 : allowed_pni_npi_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// RATRestrictions-Item-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t rat_restricts_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {180};
  return map_enum_number(names, 1, idx, "id");
}
bool rat_restricts_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 180 == id;
}
crit_e rat_restricts_item_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 180) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
rat_restricts_item_ext_ies_o::ext_c rat_restricts_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 180) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e rat_restricts_item_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 180) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void rat_restricts_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("ExtendedRATRestrictionInformation");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE rat_restricts_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE rat_restricts_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* rat_restricts_item_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"ExtendedRATRestrictionInformation"};
  return convert_enum_idx(names, 1, value, "rat_restricts_item_ext_ies_o::ext_c::types");
}

// SNPN-MobilityInformation ::= SEQUENCE
SRSASN_CODE sn_pn_mob_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(serving_n_id.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE sn_pn_mob_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(serving_n_id.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void sn_pn_mob_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("serving-NID", serving_n_id.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CNTypeRestrictionsForServing ::= ENUMERATED
const char* cn_type_restricts_for_serving_opts::to_string() const
{
  static const char* names[] = {"epc-forbidden"};
  return convert_enum_idx(names, 1, value, "cn_type_restricts_for_serving_e");
}

// ForbiddenAreaInformation-Item ::= SEQUENCE
SRSASN_CODE forbidden_area_info_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.pack(bref));
  HANDLE_CODE(pack_dyn_seq_of(bref, forbidden_tacs, 1, 4096, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE forbidden_area_info_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.unpack(bref));
  HANDLE_CODE(unpack_dyn_seq_of(forbidden_tacs, bref, 1, 4096, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void forbidden_area_info_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("pLMNIdentity", plmn_id.to_string());
  j.start_array("forbiddenTACs");
  for (const auto& e1 : forbidden_tacs) {
    j.write_str(e1.to_string());
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// NPN-MobilityInformation ::= CHOICE
void npn_mob_info_c::destroy_()
{
  switch (type_) {
    case types::sn_pn_mob_info:
      c.destroy<sn_pn_mob_info_s>();
      break;
    case types::pni_npn_mob_info:
      c.destroy<pni_npn_mob_info_s>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<npn_mob_info_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void npn_mob_info_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::sn_pn_mob_info:
      c.init<sn_pn_mob_info_s>();
      break;
    case types::pni_npn_mob_info:
      c.init<pni_npn_mob_info_s>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<npn_mob_info_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "npn_mob_info_c");
  }
}
npn_mob_info_c::npn_mob_info_c(const npn_mob_info_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::sn_pn_mob_info:
      c.init(other.c.get<sn_pn_mob_info_s>());
      break;
    case types::pni_npn_mob_info:
      c.init(other.c.get<pni_npn_mob_info_s>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<npn_mob_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "npn_mob_info_c");
  }
}
npn_mob_info_c& npn_mob_info_c::operator=(const npn_mob_info_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::sn_pn_mob_info:
      c.set(other.c.get<sn_pn_mob_info_s>());
      break;
    case types::pni_npn_mob_info:
      c.set(other.c.get<pni_npn_mob_info_s>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<npn_mob_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "npn_mob_info_c");
  }

  return *this;
}
sn_pn_mob_info_s& npn_mob_info_c::set_sn_pn_mob_info()
{
  set(types::sn_pn_mob_info);
  return c.get<sn_pn_mob_info_s>();
}
pni_npn_mob_info_s& npn_mob_info_c::set_pni_npn_mob_info()
{
  set(types::pni_npn_mob_info);
  return c.get<pni_npn_mob_info_s>();
}
protocol_ie_single_container_s<npn_mob_info_ext_ies_o>& npn_mob_info_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<npn_mob_info_ext_ies_o>>();
}
void npn_mob_info_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::sn_pn_mob_info:
      j.write_fieldname("sNPN-MobilityInformation");
      c.get<sn_pn_mob_info_s>().to_json(j);
      break;
    case types::pni_npn_mob_info:
      j.write_fieldname("pNI-NPN-MobilityInformation");
      c.get<pni_npn_mob_info_s>().to_json(j);
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<npn_mob_info_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "npn_mob_info_c");
  }
  j.end_obj();
}
SRSASN_CODE npn_mob_info_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::sn_pn_mob_info:
      HANDLE_CODE(c.get<sn_pn_mob_info_s>().pack(bref));
      break;
    case types::pni_npn_mob_info:
      HANDLE_CODE(c.get<pni_npn_mob_info_s>().pack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<npn_mob_info_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "npn_mob_info_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE npn_mob_info_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::sn_pn_mob_info:
      HANDLE_CODE(c.get<sn_pn_mob_info_s>().unpack(bref));
      break;
    case types::pni_npn_mob_info:
      HANDLE_CODE(c.get<pni_npn_mob_info_s>().unpack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<npn_mob_info_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "npn_mob_info_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* npn_mob_info_c::types_opts::to_string() const
{
  static const char* names[] = {"sNPN-MobilityInformation", "pNI-NPN-MobilityInformation", "choice-Extensions"};
  return convert_enum_idx(names, 3, value, "npn_mob_info_c::types");
}

// RATRestrictions-Item ::= SEQUENCE
SRSASN_CODE rat_restricts_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(plmn_id.pack(bref));
  HANDLE_CODE(rat_restrict_info.pack(bref));
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE rat_restricts_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.unpack(bref));
  HANDLE_CODE(rat_restrict_info.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void rat_restricts_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("pLMNIdentity", plmn_id.to_string());
  j.write_str("rATRestrictionInformation", rat_restrict_info.to_string());
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// ServiceAreaInformation-Item ::= SEQUENCE
SRSASN_CODE service_area_info_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(allowed_tacs.size() > 0, 1));
  HANDLE_CODE(bref.pack(not_allowed_tacs.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.pack(bref));
  if (allowed_tacs.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, allowed_tacs, 1, 16, true));
  }
  if (not_allowed_tacs.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, not_allowed_tacs, 1, 16, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE service_area_info_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool allowed_tacs_present;
  HANDLE_CODE(bref.unpack(allowed_tacs_present, 1));
  bool not_allowed_tacs_present;
  HANDLE_CODE(bref.unpack(not_allowed_tacs_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.unpack(bref));
  if (allowed_tacs_present) {
    HANDLE_CODE(unpack_dyn_seq_of(allowed_tacs, bref, 1, 16, true));
  }
  if (not_allowed_tacs_present) {
    HANDLE_CODE(unpack_dyn_seq_of(not_allowed_tacs, bref, 1, 16, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void service_area_info_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("pLMNIdentity", plmn_id.to_string());
  if (allowed_tacs.size() > 0) {
    j.start_array("allowedTACs");
    for (const auto& e1 : allowed_tacs) {
      j.write_str(e1.to_string());
    }
    j.end_array();
  }
  if (not_allowed_tacs.size() > 0) {
    j.start_array("notAllowedTACs");
    for (const auto& e1 : not_allowed_tacs) {
      j.write_str(e1.to_string());
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TargetNSSAI-Item ::= SEQUENCE
SRSASN_CODE target_nssai_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(s_nssai.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE target_nssai_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(s_nssai.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void target_nssai_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("s-NSSAI");
  s_nssai.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MobilityRestrictionList-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t mob_restrict_list_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {150, 161, 160, 261};
  return map_enum_number(names, 4, idx, "id");
}
bool mob_restrict_list_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {150, 161, 160, 261};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e mob_restrict_list_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 150:
      return crit_e::ignore;
    case 161:
      return crit_e::ignore;
    case 160:
      return crit_e::ignore;
    case 261:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
mob_restrict_list_ext_ies_o::ext_c mob_restrict_list_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 150:
      ret.set(ext_c::types::last_eutran_plmn_id);
      break;
    case 161:
      ret.set(ext_c::types::cn_type_restricts_for_serving);
      break;
    case 160:
      ret.set(ext_c::types::cn_type_restricts_for_equivalent);
      break;
    case 261:
      ret.set(ext_c::types::npn_mob_info);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e mob_restrict_list_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 150:
      return presence_e::optional;
    case 161:
      return presence_e::optional;
    case 160:
      return presence_e::optional;
    case 261:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void mob_restrict_list_ext_ies_o::ext_c::destroy_()
{
  switch (type_) {
    case types::last_eutran_plmn_id:
      c.destroy<fixed_octstring<3, true>>();
      break;
    case types::cn_type_restricts_for_equivalent:
      c.destroy<cn_type_restricts_for_equivalent_l>();
      break;
    case types::npn_mob_info:
      c.destroy<npn_mob_info_c>();
      break;
    default:
      break;
  }
}
void mob_restrict_list_ext_ies_o::ext_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::last_eutran_plmn_id:
      c.init<fixed_octstring<3, true>>();
      break;
    case types::cn_type_restricts_for_serving:
      break;
    case types::cn_type_restricts_for_equivalent:
      c.init<cn_type_restricts_for_equivalent_l>();
      break;
    case types::npn_mob_info:
      c.init<npn_mob_info_c>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "mob_restrict_list_ext_ies_o::ext_c");
  }
}
mob_restrict_list_ext_ies_o::ext_c::ext_c(const mob_restrict_list_ext_ies_o::ext_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::last_eutran_plmn_id:
      c.init(other.c.get<fixed_octstring<3, true>>());
      break;
    case types::cn_type_restricts_for_serving:
      c.init(other.c.get<cn_type_restricts_for_serving_e>());
      break;
    case types::cn_type_restricts_for_equivalent:
      c.init(other.c.get<cn_type_restricts_for_equivalent_l>());
      break;
    case types::npn_mob_info:
      c.init(other.c.get<npn_mob_info_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "mob_restrict_list_ext_ies_o::ext_c");
  }
}
mob_restrict_list_ext_ies_o::ext_c&
mob_restrict_list_ext_ies_o::ext_c::operator=(const mob_restrict_list_ext_ies_o::ext_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::last_eutran_plmn_id:
      c.set(other.c.get<fixed_octstring<3, true>>());
      break;
    case types::cn_type_restricts_for_serving:
      c.set(other.c.get<cn_type_restricts_for_serving_e>());
      break;
    case types::cn_type_restricts_for_equivalent:
      c.set(other.c.get<cn_type_restricts_for_equivalent_l>());
      break;
    case types::npn_mob_info:
      c.set(other.c.get<npn_mob_info_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "mob_restrict_list_ext_ies_o::ext_c");
  }

  return *this;
}
fixed_octstring<3, true>& mob_restrict_list_ext_ies_o::ext_c::last_eutran_plmn_id()
{
  assert_choice_type(types::last_eutran_plmn_id, type_, "Extension");
  return c.get<fixed_octstring<3, true>>();
}
cn_type_restricts_for_serving_e& mob_restrict_list_ext_ies_o::ext_c::cn_type_restricts_for_serving()
{
  assert_choice_type(types::cn_type_restricts_for_serving, type_, "Extension");
  return c.get<cn_type_restricts_for_serving_e>();
}
cn_type_restricts_for_equivalent_l& mob_restrict_list_ext_ies_o::ext_c::cn_type_restricts_for_equivalent()
{
  assert_choice_type(types::cn_type_restricts_for_equivalent, type_, "Extension");
  return c.get<cn_type_restricts_for_equivalent_l>();
}
npn_mob_info_c& mob_restrict_list_ext_ies_o::ext_c::npn_mob_info()
{
  assert_choice_type(types::npn_mob_info, type_, "Extension");
  return c.get<npn_mob_info_c>();
}
const fixed_octstring<3, true>& mob_restrict_list_ext_ies_o::ext_c::last_eutran_plmn_id() const
{
  assert_choice_type(types::last_eutran_plmn_id, type_, "Extension");
  return c.get<fixed_octstring<3, true>>();
}
const cn_type_restricts_for_serving_e& mob_restrict_list_ext_ies_o::ext_c::cn_type_restricts_for_serving() const
{
  assert_choice_type(types::cn_type_restricts_for_serving, type_, "Extension");
  return c.get<cn_type_restricts_for_serving_e>();
}
const cn_type_restricts_for_equivalent_l& mob_restrict_list_ext_ies_o::ext_c::cn_type_restricts_for_equivalent() const
{
  assert_choice_type(types::cn_type_restricts_for_equivalent, type_, "Extension");
  return c.get<cn_type_restricts_for_equivalent_l>();
}
const npn_mob_info_c& mob_restrict_list_ext_ies_o::ext_c::npn_mob_info() const
{
  assert_choice_type(types::npn_mob_info, type_, "Extension");
  return c.get<npn_mob_info_c>();
}
void mob_restrict_list_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::last_eutran_plmn_id:
      j.write_str("OCTET STRING", c.get<fixed_octstring<3, true>>().to_string());
      break;
    case types::cn_type_restricts_for_serving:
      j.write_str("CNTypeRestrictionsForServing", "epc-forbidden");
      break;
    case types::cn_type_restricts_for_equivalent:
      j.start_array("CNTypeRestrictionsForEquivalent");
      for (const auto& e1 : c.get<cn_type_restricts_for_equivalent_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::npn_mob_info:
      j.write_fieldname("NPN-MobilityInformation");
      c.get<npn_mob_info_c>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "mob_restrict_list_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE mob_restrict_list_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::last_eutran_plmn_id:
      HANDLE_CODE((c.get<fixed_octstring<3, true>>().pack(bref)));
      break;
    case types::cn_type_restricts_for_serving:
      HANDLE_CODE(c.get<cn_type_restricts_for_serving_e>().pack(bref));
      break;
    case types::cn_type_restricts_for_equivalent:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<cn_type_restricts_for_equivalent_l>(), 1, 15, true));
      break;
    case types::npn_mob_info:
      HANDLE_CODE(c.get<npn_mob_info_c>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "mob_restrict_list_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE mob_restrict_list_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::last_eutran_plmn_id:
      HANDLE_CODE((c.get<fixed_octstring<3, true>>().unpack(bref)));
      break;
    case types::cn_type_restricts_for_serving:
      HANDLE_CODE(c.get<cn_type_restricts_for_serving_e>().unpack(bref));
      break;
    case types::cn_type_restricts_for_equivalent:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<cn_type_restricts_for_equivalent_l>(), bref, 1, 15, true));
      break;
    case types::npn_mob_info:
      HANDLE_CODE(c.get<npn_mob_info_c>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "mob_restrict_list_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* mob_restrict_list_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {
      "OCTET STRING", "CNTypeRestrictionsForServing", "CNTypeRestrictionsForEquivalent", "NPN-MobilityInformation"};
  return convert_enum_idx(names, 4, value, "mob_restrict_list_ext_ies_o::ext_c::types");
}

template struct asn1::protocol_ext_field_s<mob_restrict_list_ext_ies_o>;

mob_restrict_list_ext_ies_container::mob_restrict_list_ext_ies_container() :
  last_eutran_plmn_id(150, crit_e::ignore),
  cn_type_restricts_for_serving(161, crit_e::ignore),
  cn_type_restricts_for_equivalent(160, crit_e::ignore),
  npn_mob_info(261, crit_e::reject)
{
}
SRSASN_CODE mob_restrict_list_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += last_eutran_plmn_id_present ? 1 : 0;
  nof_ies += cn_type_restricts_for_serving_present ? 1 : 0;
  nof_ies += cn_type_restricts_for_equivalent_present ? 1 : 0;
  nof_ies += npn_mob_info_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (last_eutran_plmn_id_present) {
    HANDLE_CODE(last_eutran_plmn_id.pack(bref));
  }
  if (cn_type_restricts_for_serving_present) {
    HANDLE_CODE(cn_type_restricts_for_serving.pack(bref));
  }
  if (cn_type_restricts_for_equivalent_present) {
    HANDLE_CODE(cn_type_restricts_for_equivalent.pack(bref));
  }
  if (npn_mob_info_present) {
    HANDLE_CODE(npn_mob_info.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mob_restrict_list_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 150: {
        last_eutran_plmn_id_present = true;
        last_eutran_plmn_id.id      = id;
        HANDLE_CODE(last_eutran_plmn_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(last_eutran_plmn_id.ext.unpack(bref));
        break;
      }
      case 161: {
        cn_type_restricts_for_serving_present = true;
        cn_type_restricts_for_serving.id      = id;
        HANDLE_CODE(cn_type_restricts_for_serving.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cn_type_restricts_for_serving.ext.unpack(bref));
        break;
      }
      case 160: {
        cn_type_restricts_for_equivalent_present = true;
        cn_type_restricts_for_equivalent.id      = id;
        HANDLE_CODE(cn_type_restricts_for_equivalent.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cn_type_restricts_for_equivalent.ext.unpack(bref));
        break;
      }
      case 261: {
        npn_mob_info_present = true;
        npn_mob_info.id      = id;
        HANDLE_CODE(npn_mob_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(npn_mob_info.ext.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void mob_restrict_list_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (last_eutran_plmn_id_present) {
    j.write_fieldname("");
    last_eutran_plmn_id.to_json(j);
  }
  if (cn_type_restricts_for_serving_present) {
    j.write_fieldname("");
    cn_type_restricts_for_serving.to_json(j);
  }
  if (cn_type_restricts_for_equivalent_present) {
    j.write_fieldname("");
    cn_type_restricts_for_equivalent.to_json(j);
  }
  if (npn_mob_info_present) {
    j.write_fieldname("");
    npn_mob_info.to_json(j);
  }
  j.end_obj();
}

// MobilityRestrictionList ::= SEQUENCE
SRSASN_CODE mob_restrict_list_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(equivalent_plmns.size() > 0, 1));
  HANDLE_CODE(bref.pack(rat_restricts.size() > 0, 1));
  HANDLE_CODE(bref.pack(forbidden_area_info.size() > 0, 1));
  HANDLE_CODE(bref.pack(service_area_info.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(serving_plmn.pack(bref));
  if (equivalent_plmns.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, equivalent_plmns, 1, 15, true));
  }
  if (rat_restricts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, rat_restricts, 1, 16, true));
  }
  if (forbidden_area_info.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, forbidden_area_info, 1, 16, true));
  }
  if (service_area_info.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, service_area_info, 1, 16, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mob_restrict_list_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool equivalent_plmns_present;
  HANDLE_CODE(bref.unpack(equivalent_plmns_present, 1));
  bool rat_restricts_present;
  HANDLE_CODE(bref.unpack(rat_restricts_present, 1));
  bool forbidden_area_info_present;
  HANDLE_CODE(bref.unpack(forbidden_area_info_present, 1));
  bool service_area_info_present;
  HANDLE_CODE(bref.unpack(service_area_info_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(serving_plmn.unpack(bref));
  if (equivalent_plmns_present) {
    HANDLE_CODE(unpack_dyn_seq_of(equivalent_plmns, bref, 1, 15, true));
  }
  if (rat_restricts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(rat_restricts, bref, 1, 16, true));
  }
  if (forbidden_area_info_present) {
    HANDLE_CODE(unpack_dyn_seq_of(forbidden_area_info, bref, 1, 16, true));
  }
  if (service_area_info_present) {
    HANDLE_CODE(unpack_dyn_seq_of(service_area_info, bref, 1, 16, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void mob_restrict_list_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("servingPLMN", serving_plmn.to_string());
  if (equivalent_plmns.size() > 0) {
    j.start_array("equivalentPLMNs");
    for (const auto& e1 : equivalent_plmns) {
      j.write_str(e1.to_string());
    }
    j.end_array();
  }
  if (rat_restricts.size() > 0) {
    j.start_array("rATRestrictions");
    for (const auto& e1 : rat_restricts) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (forbidden_area_info.size() > 0) {
    j.start_array("forbiddenAreaInformation");
    for (const auto& e1 : forbidden_area_info) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (service_area_info.size() > 0) {
    j.start_array("serviceAreaInformation");
    for (const auto& e1 : service_area_info) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SRVCCOperationPossible ::= ENUMERATED
const char* srvcc_operation_possible_opts::to_string() const
{
  static const char* names[] = {"possible", "notPossible"};
  return convert_enum_idx(names, 2, value, "srvcc_operation_possible_e");
}

// TargetNSSAIInformation ::= SEQUENCE
SRSASN_CODE target_nssai_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, target_nssai, 1, 8, true));
  HANDLE_CODE(pack_integer(bref, idx_to_rfsp, (uint16_t)1u, (uint16_t)256u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE target_nssai_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(target_nssai, bref, 1, 8, true));
  HANDLE_CODE(unpack_integer(idx_to_rfsp, bref, (uint16_t)1u, (uint16_t)256u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void target_nssai_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("targetNSSAI");
  for (const auto& e1 : target_nssai) {
    e1.to_json(j);
  }
  j.end_array();
  j.write_int("indexToRFSP", idx_to_rfsp);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// UEAggregateMaximumBitRate ::= SEQUENCE
SRSASN_CODE ue_aggr_max_bit_rate_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, ue_aggr_max_bit_rate_dl, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  HANDLE_CODE(pack_integer(bref, ue_aggr_max_bit_rate_ul, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_aggr_max_bit_rate_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(ue_aggr_max_bit_rate_dl, bref, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  HANDLE_CODE(unpack_integer(ue_aggr_max_bit_rate_ul, bref, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ue_aggr_max_bit_rate_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("uEAggregateMaximumBitRateDL", ue_aggr_max_bit_rate_dl);
  j.write_int("uEAggregateMaximumBitRateUL", ue_aggr_max_bit_rate_ul);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// UECapabilityInfoRequest ::= ENUMERATED
const char* ue_cap_info_request_opts::to_string() const
{
  static const char* names[] = {"requested"};
  return convert_enum_idx(names, 1, value, "ue_cap_info_request_e");
}

// DownlinkNASTransport-IEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t dl_nas_transport_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10,  85,  48,  83,  38,  36,  31,  110, 0,   177,
                                   205, 206, 209, 222, 117, 228, 226, 264, 334, 34};
  return map_enum_number(names, 20, idx, "id");
}
bool dl_nas_transport_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10,  85,  48,  83,  38,  36,  31,  110, 0,   177,
                                   205, 206, 209, 222, 117, 228, 226, 264, 334, 34};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e dl_nas_transport_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 48:
      return crit_e::reject;
    case 83:
      return crit_e::ignore;
    case 38:
      return crit_e::reject;
    case 36:
      return crit_e::ignore;
    case 31:
      return crit_e::ignore;
    case 110:
      return crit_e::ignore;
    case 0:
      return crit_e::reject;
    case 177:
      return crit_e::ignore;
    case 205:
      return crit_e::ignore;
    case 206:
      return crit_e::ignore;
    case 209:
      return crit_e::ignore;
    case 222:
      return crit_e::ignore;
    case 117:
      return crit_e::ignore;
    case 228:
      return crit_e::ignore;
    case 226:
      return crit_e::ignore;
    case 264:
      return crit_e::reject;
    case 334:
      return crit_e::ignore;
    case 34:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
dl_nas_transport_ies_o::value_c dl_nas_transport_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 48:
      ret.set(value_c::types::old_amf);
      break;
    case 83:
      ret.set(value_c::types::ran_paging_prio);
      break;
    case 38:
      ret.set(value_c::types::nas_pdu);
      break;
    case 36:
      ret.set(value_c::types::mob_restrict_list);
      break;
    case 31:
      ret.set(value_c::types::idx_to_rfsp);
      break;
    case 110:
      ret.set(value_c::types::ue_aggr_max_bit_rate);
      break;
    case 0:
      ret.set(value_c::types::allowed_nssai);
      break;
    case 177:
      ret.set(value_c::types::srvcc_operation_possible);
      break;
    case 205:
      ret.set(value_c::types::enhanced_coverage_restrict);
      break;
    case 206:
      ret.set(value_c::types::extended_connected_time);
      break;
    case 209:
      ret.set(value_c::types::ue_diff_info);
      break;
    case 222:
      ret.set(value_c::types::ce_mode_brestricted);
      break;
    case 117:
      ret.set(value_c::types::ue_radio_cap);
      break;
    case 228:
      ret.set(value_c::types::ue_cap_info_request);
      break;
    case 226:
      ret.set(value_c::types::end_ind);
      break;
    case 264:
      ret.set(value_c::types::ue_radio_cap_id);
      break;
    case 334:
      ret.set(value_c::types::target_nssai_info);
      break;
    case 34:
      ret.set(value_c::types::masked_imeisv);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e dl_nas_transport_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 48:
      return presence_e::optional;
    case 83:
      return presence_e::optional;
    case 38:
      return presence_e::mandatory;
    case 36:
      return presence_e::optional;
    case 31:
      return presence_e::optional;
    case 110:
      return presence_e::optional;
    case 0:
      return presence_e::optional;
    case 177:
      return presence_e::optional;
    case 205:
      return presence_e::optional;
    case 206:
      return presence_e::optional;
    case 209:
      return presence_e::optional;
    case 222:
      return presence_e::optional;
    case 117:
      return presence_e::optional;
    case 228:
      return presence_e::optional;
    case 226:
      return presence_e::optional;
    case 264:
      return presence_e::optional;
    case 334:
      return presence_e::optional;
    case 34:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void dl_nas_transport_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::old_amf:
      c.destroy<printable_string<1, 150, true, true>>();
      break;
    case types::nas_pdu:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::mob_restrict_list:
      c.destroy<mob_restrict_list_s>();
      break;
    case types::ue_aggr_max_bit_rate:
      c.destroy<ue_aggr_max_bit_rate_s>();
      break;
    case types::allowed_nssai:
      c.destroy<allowed_nssai_l>();
      break;
    case types::ue_diff_info:
      c.destroy<ue_diff_info_s>();
      break;
    case types::ue_radio_cap:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::ue_radio_cap_id:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::target_nssai_info:
      c.destroy<target_nssai_info_s>();
      break;
    case types::masked_imeisv:
      c.destroy<fixed_bitstring<64, false, true>>();
      break;
    default:
      break;
  }
}
void dl_nas_transport_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::old_amf:
      c.init<printable_string<1, 150, true, true>>();
      break;
    case types::ran_paging_prio:
      break;
    case types::nas_pdu:
      c.init<unbounded_octstring<true>>();
      break;
    case types::mob_restrict_list:
      c.init<mob_restrict_list_s>();
      break;
    case types::idx_to_rfsp:
      break;
    case types::ue_aggr_max_bit_rate:
      c.init<ue_aggr_max_bit_rate_s>();
      break;
    case types::allowed_nssai:
      c.init<allowed_nssai_l>();
      break;
    case types::srvcc_operation_possible:
      break;
    case types::enhanced_coverage_restrict:
      break;
    case types::extended_connected_time:
      break;
    case types::ue_diff_info:
      c.init<ue_diff_info_s>();
      break;
    case types::ce_mode_brestricted:
      break;
    case types::ue_radio_cap:
      c.init<unbounded_octstring<true>>();
      break;
    case types::ue_cap_info_request:
      break;
    case types::end_ind:
      break;
    case types::ue_radio_cap_id:
      c.init<unbounded_octstring<true>>();
      break;
    case types::target_nssai_info:
      c.init<target_nssai_info_s>();
      break;
    case types::masked_imeisv:
      c.init<fixed_bitstring<64, false, true>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "dl_nas_transport_ies_o::value_c");
  }
}
dl_nas_transport_ies_o::value_c::value_c(const dl_nas_transport_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::old_amf:
      c.init(other.c.get<printable_string<1, 150, true, true>>());
      break;
    case types::ran_paging_prio:
      c.init(other.c.get<uint16_t>());
      break;
    case types::nas_pdu:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::mob_restrict_list:
      c.init(other.c.get<mob_restrict_list_s>());
      break;
    case types::idx_to_rfsp:
      c.init(other.c.get<uint16_t>());
      break;
    case types::ue_aggr_max_bit_rate:
      c.init(other.c.get<ue_aggr_max_bit_rate_s>());
      break;
    case types::allowed_nssai:
      c.init(other.c.get<allowed_nssai_l>());
      break;
    case types::srvcc_operation_possible:
      c.init(other.c.get<srvcc_operation_possible_e>());
      break;
    case types::enhanced_coverage_restrict:
      c.init(other.c.get<enhanced_coverage_restrict_e>());
      break;
    case types::extended_connected_time:
      c.init(other.c.get<uint16_t>());
      break;
    case types::ue_diff_info:
      c.init(other.c.get<ue_diff_info_s>());
      break;
    case types::ce_mode_brestricted:
      c.init(other.c.get<ce_mode_brestricted_e>());
      break;
    case types::ue_radio_cap:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::ue_cap_info_request:
      c.init(other.c.get<ue_cap_info_request_e>());
      break;
    case types::end_ind:
      c.init(other.c.get<end_ind_e>());
      break;
    case types::ue_radio_cap_id:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::target_nssai_info:
      c.init(other.c.get<target_nssai_info_s>());
      break;
    case types::masked_imeisv:
      c.init(other.c.get<fixed_bitstring<64, false, true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "dl_nas_transport_ies_o::value_c");
  }
}
dl_nas_transport_ies_o::value_c&
dl_nas_transport_ies_o::value_c::operator=(const dl_nas_transport_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::old_amf:
      c.set(other.c.get<printable_string<1, 150, true, true>>());
      break;
    case types::ran_paging_prio:
      c.set(other.c.get<uint16_t>());
      break;
    case types::nas_pdu:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::mob_restrict_list:
      c.set(other.c.get<mob_restrict_list_s>());
      break;
    case types::idx_to_rfsp:
      c.set(other.c.get<uint16_t>());
      break;
    case types::ue_aggr_max_bit_rate:
      c.set(other.c.get<ue_aggr_max_bit_rate_s>());
      break;
    case types::allowed_nssai:
      c.set(other.c.get<allowed_nssai_l>());
      break;
    case types::srvcc_operation_possible:
      c.set(other.c.get<srvcc_operation_possible_e>());
      break;
    case types::enhanced_coverage_restrict:
      c.set(other.c.get<enhanced_coverage_restrict_e>());
      break;
    case types::extended_connected_time:
      c.set(other.c.get<uint16_t>());
      break;
    case types::ue_diff_info:
      c.set(other.c.get<ue_diff_info_s>());
      break;
    case types::ce_mode_brestricted:
      c.set(other.c.get<ce_mode_brestricted_e>());
      break;
    case types::ue_radio_cap:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::ue_cap_info_request:
      c.set(other.c.get<ue_cap_info_request_e>());
      break;
    case types::end_ind:
      c.set(other.c.get<end_ind_e>());
      break;
    case types::ue_radio_cap_id:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::target_nssai_info:
      c.set(other.c.get<target_nssai_info_s>());
      break;
    case types::masked_imeisv:
      c.set(other.c.get<fixed_bitstring<64, false, true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "dl_nas_transport_ies_o::value_c");
  }

  return *this;
}
uint64_t& dl_nas_transport_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& dl_nas_transport_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
printable_string<1, 150, true, true>& dl_nas_transport_ies_o::value_c::old_amf()
{
  assert_choice_type(types::old_amf, type_, "Value");
  return c.get<printable_string<1, 150, true, true>>();
}
uint16_t& dl_nas_transport_ies_o::value_c::ran_paging_prio()
{
  assert_choice_type(types::ran_paging_prio, type_, "Value");
  return c.get<uint16_t>();
}
unbounded_octstring<true>& dl_nas_transport_ies_o::value_c::nas_pdu()
{
  assert_choice_type(types::nas_pdu, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
mob_restrict_list_s& dl_nas_transport_ies_o::value_c::mob_restrict_list()
{
  assert_choice_type(types::mob_restrict_list, type_, "Value");
  return c.get<mob_restrict_list_s>();
}
uint16_t& dl_nas_transport_ies_o::value_c::idx_to_rfsp()
{
  assert_choice_type(types::idx_to_rfsp, type_, "Value");
  return c.get<uint16_t>();
}
ue_aggr_max_bit_rate_s& dl_nas_transport_ies_o::value_c::ue_aggr_max_bit_rate()
{
  assert_choice_type(types::ue_aggr_max_bit_rate, type_, "Value");
  return c.get<ue_aggr_max_bit_rate_s>();
}
allowed_nssai_l& dl_nas_transport_ies_o::value_c::allowed_nssai()
{
  assert_choice_type(types::allowed_nssai, type_, "Value");
  return c.get<allowed_nssai_l>();
}
srvcc_operation_possible_e& dl_nas_transport_ies_o::value_c::srvcc_operation_possible()
{
  assert_choice_type(types::srvcc_operation_possible, type_, "Value");
  return c.get<srvcc_operation_possible_e>();
}
enhanced_coverage_restrict_e& dl_nas_transport_ies_o::value_c::enhanced_coverage_restrict()
{
  assert_choice_type(types::enhanced_coverage_restrict, type_, "Value");
  return c.get<enhanced_coverage_restrict_e>();
}
uint16_t& dl_nas_transport_ies_o::value_c::extended_connected_time()
{
  assert_choice_type(types::extended_connected_time, type_, "Value");
  return c.get<uint16_t>();
}
ue_diff_info_s& dl_nas_transport_ies_o::value_c::ue_diff_info()
{
  assert_choice_type(types::ue_diff_info, type_, "Value");
  return c.get<ue_diff_info_s>();
}
ce_mode_brestricted_e& dl_nas_transport_ies_o::value_c::ce_mode_brestricted()
{
  assert_choice_type(types::ce_mode_brestricted, type_, "Value");
  return c.get<ce_mode_brestricted_e>();
}
unbounded_octstring<true>& dl_nas_transport_ies_o::value_c::ue_radio_cap()
{
  assert_choice_type(types::ue_radio_cap, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
ue_cap_info_request_e& dl_nas_transport_ies_o::value_c::ue_cap_info_request()
{
  assert_choice_type(types::ue_cap_info_request, type_, "Value");
  return c.get<ue_cap_info_request_e>();
}
end_ind_e& dl_nas_transport_ies_o::value_c::end_ind()
{
  assert_choice_type(types::end_ind, type_, "Value");
  return c.get<end_ind_e>();
}
unbounded_octstring<true>& dl_nas_transport_ies_o::value_c::ue_radio_cap_id()
{
  assert_choice_type(types::ue_radio_cap_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
target_nssai_info_s& dl_nas_transport_ies_o::value_c::target_nssai_info()
{
  assert_choice_type(types::target_nssai_info, type_, "Value");
  return c.get<target_nssai_info_s>();
}
fixed_bitstring<64, false, true>& dl_nas_transport_ies_o::value_c::masked_imeisv()
{
  assert_choice_type(types::masked_imeisv, type_, "Value");
  return c.get<fixed_bitstring<64, false, true>>();
}
const uint64_t& dl_nas_transport_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& dl_nas_transport_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const printable_string<1, 150, true, true>& dl_nas_transport_ies_o::value_c::old_amf() const
{
  assert_choice_type(types::old_amf, type_, "Value");
  return c.get<printable_string<1, 150, true, true>>();
}
const uint16_t& dl_nas_transport_ies_o::value_c::ran_paging_prio() const
{
  assert_choice_type(types::ran_paging_prio, type_, "Value");
  return c.get<uint16_t>();
}
const unbounded_octstring<true>& dl_nas_transport_ies_o::value_c::nas_pdu() const
{
  assert_choice_type(types::nas_pdu, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const mob_restrict_list_s& dl_nas_transport_ies_o::value_c::mob_restrict_list() const
{
  assert_choice_type(types::mob_restrict_list, type_, "Value");
  return c.get<mob_restrict_list_s>();
}
const uint16_t& dl_nas_transport_ies_o::value_c::idx_to_rfsp() const
{
  assert_choice_type(types::idx_to_rfsp, type_, "Value");
  return c.get<uint16_t>();
}
const ue_aggr_max_bit_rate_s& dl_nas_transport_ies_o::value_c::ue_aggr_max_bit_rate() const
{
  assert_choice_type(types::ue_aggr_max_bit_rate, type_, "Value");
  return c.get<ue_aggr_max_bit_rate_s>();
}
const allowed_nssai_l& dl_nas_transport_ies_o::value_c::allowed_nssai() const
{
  assert_choice_type(types::allowed_nssai, type_, "Value");
  return c.get<allowed_nssai_l>();
}
const srvcc_operation_possible_e& dl_nas_transport_ies_o::value_c::srvcc_operation_possible() const
{
  assert_choice_type(types::srvcc_operation_possible, type_, "Value");
  return c.get<srvcc_operation_possible_e>();
}
const enhanced_coverage_restrict_e& dl_nas_transport_ies_o::value_c::enhanced_coverage_restrict() const
{
  assert_choice_type(types::enhanced_coverage_restrict, type_, "Value");
  return c.get<enhanced_coverage_restrict_e>();
}
const uint16_t& dl_nas_transport_ies_o::value_c::extended_connected_time() const
{
  assert_choice_type(types::extended_connected_time, type_, "Value");
  return c.get<uint16_t>();
}
const ue_diff_info_s& dl_nas_transport_ies_o::value_c::ue_diff_info() const
{
  assert_choice_type(types::ue_diff_info, type_, "Value");
  return c.get<ue_diff_info_s>();
}
const ce_mode_brestricted_e& dl_nas_transport_ies_o::value_c::ce_mode_brestricted() const
{
  assert_choice_type(types::ce_mode_brestricted, type_, "Value");
  return c.get<ce_mode_brestricted_e>();
}
const unbounded_octstring<true>& dl_nas_transport_ies_o::value_c::ue_radio_cap() const
{
  assert_choice_type(types::ue_radio_cap, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const ue_cap_info_request_e& dl_nas_transport_ies_o::value_c::ue_cap_info_request() const
{
  assert_choice_type(types::ue_cap_info_request, type_, "Value");
  return c.get<ue_cap_info_request_e>();
}
const end_ind_e& dl_nas_transport_ies_o::value_c::end_ind() const
{
  assert_choice_type(types::end_ind, type_, "Value");
  return c.get<end_ind_e>();
}
const unbounded_octstring<true>& dl_nas_transport_ies_o::value_c::ue_radio_cap_id() const
{
  assert_choice_type(types::ue_radio_cap_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const target_nssai_info_s& dl_nas_transport_ies_o::value_c::target_nssai_info() const
{
  assert_choice_type(types::target_nssai_info, type_, "Value");
  return c.get<target_nssai_info_s>();
}
const fixed_bitstring<64, false, true>& dl_nas_transport_ies_o::value_c::masked_imeisv() const
{
  assert_choice_type(types::masked_imeisv, type_, "Value");
  return c.get<fixed_bitstring<64, false, true>>();
}
void dl_nas_transport_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::old_amf:
      j.write_str("PrintableString", c.get<printable_string<1, 150, true, true>>().to_string());
      break;
    case types::ran_paging_prio:
      j.write_int("INTEGER (1..256)", c.get<uint16_t>());
      break;
    case types::nas_pdu:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::mob_restrict_list:
      j.write_fieldname("MobilityRestrictionList");
      c.get<mob_restrict_list_s>().to_json(j);
      break;
    case types::idx_to_rfsp:
      j.write_int("INTEGER (1..256,...)", c.get<uint16_t>());
      break;
    case types::ue_aggr_max_bit_rate:
      j.write_fieldname("UEAggregateMaximumBitRate");
      c.get<ue_aggr_max_bit_rate_s>().to_json(j);
      break;
    case types::allowed_nssai:
      j.start_array("AllowedNSSAI");
      for (const auto& e1 : c.get<allowed_nssai_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::srvcc_operation_possible:
      j.write_str("SRVCCOperationPossible", c.get<srvcc_operation_possible_e>().to_string());
      break;
    case types::enhanced_coverage_restrict:
      j.write_str("Enhanced-CoverageRestriction", "restricted");
      break;
    case types::extended_connected_time:
      j.write_int("INTEGER (0..255)", c.get<uint16_t>());
      break;
    case types::ue_diff_info:
      j.write_fieldname("UE-DifferentiationInfo");
      c.get<ue_diff_info_s>().to_json(j);
      break;
    case types::ce_mode_brestricted:
      j.write_str("CEmodeBrestricted", c.get<ce_mode_brestricted_e>().to_string());
      break;
    case types::ue_radio_cap:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::ue_cap_info_request:
      j.write_str("UECapabilityInfoRequest", "requested");
      break;
    case types::end_ind:
      j.write_str("EndIndication", c.get<end_ind_e>().to_string());
      break;
    case types::ue_radio_cap_id:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::target_nssai_info:
      j.write_fieldname("TargetNSSAIInformation");
      c.get<target_nssai_info_s>().to_json(j);
      break;
    case types::masked_imeisv:
      j.write_str("BIT STRING", c.get<fixed_bitstring<64, false, true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "dl_nas_transport_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE dl_nas_transport_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::old_amf:
      HANDLE_CODE((c.get<printable_string<1, 150, true, true>>().pack(bref)));
      break;
    case types::ran_paging_prio:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)1u, (uint16_t)256u, false, true));
      break;
    case types::nas_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::mob_restrict_list:
      HANDLE_CODE(c.get<mob_restrict_list_s>().pack(bref));
      break;
    case types::idx_to_rfsp:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)1u, (uint16_t)256u, true, true));
      break;
    case types::ue_aggr_max_bit_rate:
      HANDLE_CODE(c.get<ue_aggr_max_bit_rate_s>().pack(bref));
      break;
    case types::allowed_nssai:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<allowed_nssai_l>(), 1, 8, true));
      break;
    case types::srvcc_operation_possible:
      HANDLE_CODE(c.get<srvcc_operation_possible_e>().pack(bref));
      break;
    case types::enhanced_coverage_restrict:
      HANDLE_CODE(c.get<enhanced_coverage_restrict_e>().pack(bref));
      break;
    case types::extended_connected_time:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)0u, (uint16_t)255u, false, true));
      break;
    case types::ue_diff_info:
      HANDLE_CODE(c.get<ue_diff_info_s>().pack(bref));
      break;
    case types::ce_mode_brestricted:
      HANDLE_CODE(c.get<ce_mode_brestricted_e>().pack(bref));
      break;
    case types::ue_radio_cap:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::ue_cap_info_request:
      HANDLE_CODE(c.get<ue_cap_info_request_e>().pack(bref));
      break;
    case types::end_ind:
      HANDLE_CODE(c.get<end_ind_e>().pack(bref));
      break;
    case types::ue_radio_cap_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::target_nssai_info:
      HANDLE_CODE(c.get<target_nssai_info_s>().pack(bref));
      break;
    case types::masked_imeisv:
      HANDLE_CODE((c.get<fixed_bitstring<64, false, true>>().pack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "dl_nas_transport_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE dl_nas_transport_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::old_amf:
      HANDLE_CODE((c.get<printable_string<1, 150, true, true>>().unpack(bref)));
      break;
    case types::ran_paging_prio:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)1u, (uint16_t)256u, false, true));
      break;
    case types::nas_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::mob_restrict_list:
      HANDLE_CODE(c.get<mob_restrict_list_s>().unpack(bref));
      break;
    case types::idx_to_rfsp:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)1u, (uint16_t)256u, true, true));
      break;
    case types::ue_aggr_max_bit_rate:
      HANDLE_CODE(c.get<ue_aggr_max_bit_rate_s>().unpack(bref));
      break;
    case types::allowed_nssai:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<allowed_nssai_l>(), bref, 1, 8, true));
      break;
    case types::srvcc_operation_possible:
      HANDLE_CODE(c.get<srvcc_operation_possible_e>().unpack(bref));
      break;
    case types::enhanced_coverage_restrict:
      HANDLE_CODE(c.get<enhanced_coverage_restrict_e>().unpack(bref));
      break;
    case types::extended_connected_time:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)0u, (uint16_t)255u, false, true));
      break;
    case types::ue_diff_info:
      HANDLE_CODE(c.get<ue_diff_info_s>().unpack(bref));
      break;
    case types::ce_mode_brestricted:
      HANDLE_CODE(c.get<ce_mode_brestricted_e>().unpack(bref));
      break;
    case types::ue_radio_cap:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::ue_cap_info_request:
      HANDLE_CODE(c.get<ue_cap_info_request_e>().unpack(bref));
      break;
    case types::end_ind:
      HANDLE_CODE(c.get<end_ind_e>().unpack(bref));
      break;
    case types::ue_radio_cap_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::target_nssai_info:
      HANDLE_CODE(c.get<target_nssai_info_s>().unpack(bref));
      break;
    case types::masked_imeisv:
      HANDLE_CODE((c.get<fixed_bitstring<64, false, true>>().unpack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "dl_nas_transport_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* dl_nas_transport_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..1099511627775)",
                                "INTEGER (0..4294967295)",
                                "PrintableString",
                                "INTEGER (1..256)",
                                "OCTET STRING",
                                "MobilityRestrictionList",
                                "INTEGER (1..256,...)",
                                "UEAggregateMaximumBitRate",
                                "AllowedNSSAI",
                                "SRVCCOperationPossible",
                                "Enhanced-CoverageRestriction",
                                "INTEGER (0..255)",
                                "UE-DifferentiationInfo",
                                "CEmodeBrestricted",
                                "OCTET STRING",
                                "UECapabilityInfoRequest",
                                "EndIndication",
                                "OCTET STRING",
                                "TargetNSSAIInformation",
                                "BIT STRING"};
  return convert_enum_idx(names, 20, value, "dl_nas_transport_ies_o::value_c::types");
}

template struct asn1::protocol_ie_field_s<dl_nas_transport_ies_o>;

dl_nas_transport_ies_container::dl_nas_transport_ies_container() :
  amf_ue_ngap_id(10, crit_e::reject),
  ran_ue_ngap_id(85, crit_e::reject),
  old_amf(48, crit_e::reject),
  ran_paging_prio(83, crit_e::ignore),
  nas_pdu(38, crit_e::reject),
  mob_restrict_list(36, crit_e::ignore),
  idx_to_rfsp(31, crit_e::ignore),
  ue_aggr_max_bit_rate(110, crit_e::ignore),
  allowed_nssai(0, crit_e::reject),
  srvcc_operation_possible(177, crit_e::ignore),
  enhanced_coverage_restrict(205, crit_e::ignore),
  extended_connected_time(206, crit_e::ignore),
  ue_diff_info(209, crit_e::ignore),
  ce_mode_brestricted(222, crit_e::ignore),
  ue_radio_cap(117, crit_e::ignore),
  ue_cap_info_request(228, crit_e::ignore),
  end_ind(226, crit_e::ignore),
  ue_radio_cap_id(264, crit_e::reject),
  target_nssai_info(334, crit_e::ignore),
  masked_imeisv(34, crit_e::ignore)
{
}
SRSASN_CODE dl_nas_transport_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += old_amf_present ? 1 : 0;
  nof_ies += ran_paging_prio_present ? 1 : 0;
  nof_ies += mob_restrict_list_present ? 1 : 0;
  nof_ies += idx_to_rfsp_present ? 1 : 0;
  nof_ies += ue_aggr_max_bit_rate_present ? 1 : 0;
  nof_ies += allowed_nssai_present ? 1 : 0;
  nof_ies += srvcc_operation_possible_present ? 1 : 0;
  nof_ies += enhanced_coverage_restrict_present ? 1 : 0;
  nof_ies += extended_connected_time_present ? 1 : 0;
  nof_ies += ue_diff_info_present ? 1 : 0;
  nof_ies += ce_mode_brestricted_present ? 1 : 0;
  nof_ies += ue_radio_cap_present ? 1 : 0;
  nof_ies += ue_cap_info_request_present ? 1 : 0;
  nof_ies += end_ind_present ? 1 : 0;
  nof_ies += ue_radio_cap_id_present ? 1 : 0;
  nof_ies += target_nssai_info_present ? 1 : 0;
  nof_ies += masked_imeisv_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  if (old_amf_present) {
    HANDLE_CODE(old_amf.pack(bref));
  }
  if (ran_paging_prio_present) {
    HANDLE_CODE(ran_paging_prio.pack(bref));
  }
  HANDLE_CODE(nas_pdu.pack(bref));
  if (mob_restrict_list_present) {
    HANDLE_CODE(mob_restrict_list.pack(bref));
  }
  if (idx_to_rfsp_present) {
    HANDLE_CODE(idx_to_rfsp.pack(bref));
  }
  if (ue_aggr_max_bit_rate_present) {
    HANDLE_CODE(ue_aggr_max_bit_rate.pack(bref));
  }
  if (allowed_nssai_present) {
    HANDLE_CODE(allowed_nssai.pack(bref));
  }
  if (srvcc_operation_possible_present) {
    HANDLE_CODE(srvcc_operation_possible.pack(bref));
  }
  if (enhanced_coverage_restrict_present) {
    HANDLE_CODE(enhanced_coverage_restrict.pack(bref));
  }
  if (extended_connected_time_present) {
    HANDLE_CODE(extended_connected_time.pack(bref));
  }
  if (ue_diff_info_present) {
    HANDLE_CODE(ue_diff_info.pack(bref));
  }
  if (ce_mode_brestricted_present) {
    HANDLE_CODE(ce_mode_brestricted.pack(bref));
  }
  if (ue_radio_cap_present) {
    HANDLE_CODE(ue_radio_cap.pack(bref));
  }
  if (ue_cap_info_request_present) {
    HANDLE_CODE(ue_cap_info_request.pack(bref));
  }
  if (end_ind_present) {
    HANDLE_CODE(end_ind.pack(bref));
  }
  if (ue_radio_cap_id_present) {
    HANDLE_CODE(ue_radio_cap_id.pack(bref));
  }
  if (target_nssai_info_present) {
    HANDLE_CODE(target_nssai_info.pack(bref));
  }
  if (masked_imeisv_present) {
    HANDLE_CODE(masked_imeisv.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE dl_nas_transport_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 48: {
        old_amf_present = true;
        old_amf.id      = id;
        HANDLE_CODE(old_amf.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(old_amf.value.unpack(bref));
        break;
      }
      case 83: {
        ran_paging_prio_present = true;
        ran_paging_prio.id      = id;
        HANDLE_CODE(ran_paging_prio.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_paging_prio.value.unpack(bref));
        break;
      }
      case 38: {
        nof_mandatory_ies--;
        nas_pdu.id = id;
        HANDLE_CODE(nas_pdu.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nas_pdu.value.unpack(bref));
        break;
      }
      case 36: {
        mob_restrict_list_present = true;
        mob_restrict_list.id      = id;
        HANDLE_CODE(mob_restrict_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mob_restrict_list.value.unpack(bref));
        break;
      }
      case 31: {
        idx_to_rfsp_present = true;
        idx_to_rfsp.id      = id;
        HANDLE_CODE(idx_to_rfsp.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(idx_to_rfsp.value.unpack(bref));
        break;
      }
      case 110: {
        ue_aggr_max_bit_rate_present = true;
        ue_aggr_max_bit_rate.id      = id;
        HANDLE_CODE(ue_aggr_max_bit_rate.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_aggr_max_bit_rate.value.unpack(bref));
        break;
      }
      case 0: {
        allowed_nssai_present = true;
        allowed_nssai.id      = id;
        HANDLE_CODE(allowed_nssai.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(allowed_nssai.value.unpack(bref));
        break;
      }
      case 177: {
        srvcc_operation_possible_present = true;
        srvcc_operation_possible.id      = id;
        HANDLE_CODE(srvcc_operation_possible.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(srvcc_operation_possible.value.unpack(bref));
        break;
      }
      case 205: {
        enhanced_coverage_restrict_present = true;
        enhanced_coverage_restrict.id      = id;
        HANDLE_CODE(enhanced_coverage_restrict.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(enhanced_coverage_restrict.value.unpack(bref));
        break;
      }
      case 206: {
        extended_connected_time_present = true;
        extended_connected_time.id      = id;
        HANDLE_CODE(extended_connected_time.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(extended_connected_time.value.unpack(bref));
        break;
      }
      case 209: {
        ue_diff_info_present = true;
        ue_diff_info.id      = id;
        HANDLE_CODE(ue_diff_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_diff_info.value.unpack(bref));
        break;
      }
      case 222: {
        ce_mode_brestricted_present = true;
        ce_mode_brestricted.id      = id;
        HANDLE_CODE(ce_mode_brestricted.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ce_mode_brestricted.value.unpack(bref));
        break;
      }
      case 117: {
        ue_radio_cap_present = true;
        ue_radio_cap.id      = id;
        HANDLE_CODE(ue_radio_cap.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_radio_cap.value.unpack(bref));
        break;
      }
      case 228: {
        ue_cap_info_request_present = true;
        ue_cap_info_request.id      = id;
        HANDLE_CODE(ue_cap_info_request.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_cap_info_request.value.unpack(bref));
        break;
      }
      case 226: {
        end_ind_present = true;
        end_ind.id      = id;
        HANDLE_CODE(end_ind.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(end_ind.value.unpack(bref));
        break;
      }
      case 264: {
        ue_radio_cap_id_present = true;
        ue_radio_cap_id.id      = id;
        HANDLE_CODE(ue_radio_cap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_radio_cap_id.value.unpack(bref));
        break;
      }
      case 334: {
        target_nssai_info_present = true;
        target_nssai_info.id      = id;
        HANDLE_CODE(target_nssai_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(target_nssai_info.value.unpack(bref));
        break;
      }
      case 34: {
        masked_imeisv_present = true;
        masked_imeisv.id      = id;
        HANDLE_CODE(masked_imeisv.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(masked_imeisv.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void dl_nas_transport_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  if (old_amf_present) {
    j.write_fieldname("");
    old_amf.to_json(j);
  }
  if (ran_paging_prio_present) {
    j.write_fieldname("");
    ran_paging_prio.to_json(j);
  }
  j.write_fieldname("");
  nas_pdu.to_json(j);
  if (mob_restrict_list_present) {
    j.write_fieldname("");
    mob_restrict_list.to_json(j);
  }
  if (idx_to_rfsp_present) {
    j.write_fieldname("");
    idx_to_rfsp.to_json(j);
  }
  if (ue_aggr_max_bit_rate_present) {
    j.write_fieldname("");
    ue_aggr_max_bit_rate.to_json(j);
  }
  if (allowed_nssai_present) {
    j.write_fieldname("");
    allowed_nssai.to_json(j);
  }
  if (srvcc_operation_possible_present) {
    j.write_fieldname("");
    srvcc_operation_possible.to_json(j);
  }
  if (enhanced_coverage_restrict_present) {
    j.write_fieldname("");
    enhanced_coverage_restrict.to_json(j);
  }
  if (extended_connected_time_present) {
    j.write_fieldname("");
    extended_connected_time.to_json(j);
  }
  if (ue_diff_info_present) {
    j.write_fieldname("");
    ue_diff_info.to_json(j);
  }
  if (ce_mode_brestricted_present) {
    j.write_fieldname("");
    ce_mode_brestricted.to_json(j);
  }
  if (ue_radio_cap_present) {
    j.write_fieldname("");
    ue_radio_cap.to_json(j);
  }
  if (ue_cap_info_request_present) {
    j.write_fieldname("");
    ue_cap_info_request.to_json(j);
  }
  if (end_ind_present) {
    j.write_fieldname("");
    end_ind.to_json(j);
  }
  if (ue_radio_cap_id_present) {
    j.write_fieldname("");
    ue_radio_cap_id.to_json(j);
  }
  if (target_nssai_info_present) {
    j.write_fieldname("");
    target_nssai_info.to_json(j);
  }
  if (masked_imeisv_present) {
    j.write_fieldname("");
    masked_imeisv.to_json(j);
  }
  j.end_obj();
}

// DownlinkNonUEAssociatedNRPPaTransportIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t dl_non_ue_associated_nrppa_transport_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {89, 46};
  return map_enum_number(names, 2, idx, "id");
}
bool dl_non_ue_associated_nrppa_transport_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {89, 46};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e dl_non_ue_associated_nrppa_transport_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 89:
      return crit_e::reject;
    case 46:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
dl_non_ue_associated_nrppa_transport_ies_o::value_c
dl_non_ue_associated_nrppa_transport_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 89:
      ret.set(value_c::types::routing_id);
      break;
    case 46:
      ret.set(value_c::types::nrppa_pdu);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e dl_non_ue_associated_nrppa_transport_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 89:
      return presence_e::mandatory;
    case 46:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void dl_non_ue_associated_nrppa_transport_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::routing_id:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::nrppa_pdu:
      c.destroy<unbounded_octstring<true>>();
      break;
    default:
      break;
  }
}
void dl_non_ue_associated_nrppa_transport_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::routing_id:
      c.init<unbounded_octstring<true>>();
      break;
    case types::nrppa_pdu:
      c.init<unbounded_octstring<true>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "dl_non_ue_associated_nrppa_transport_ies_o::value_c");
  }
}
dl_non_ue_associated_nrppa_transport_ies_o::value_c::value_c(
    const dl_non_ue_associated_nrppa_transport_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::routing_id:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nrppa_pdu:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "dl_non_ue_associated_nrppa_transport_ies_o::value_c");
  }
}
dl_non_ue_associated_nrppa_transport_ies_o::value_c& dl_non_ue_associated_nrppa_transport_ies_o::value_c::operator=(
    const dl_non_ue_associated_nrppa_transport_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::routing_id:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nrppa_pdu:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "dl_non_ue_associated_nrppa_transport_ies_o::value_c");
  }

  return *this;
}
unbounded_octstring<true>& dl_non_ue_associated_nrppa_transport_ies_o::value_c::routing_id()
{
  assert_choice_type(types::routing_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
unbounded_octstring<true>& dl_non_ue_associated_nrppa_transport_ies_o::value_c::nrppa_pdu()
{
  assert_choice_type(types::nrppa_pdu, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const unbounded_octstring<true>& dl_non_ue_associated_nrppa_transport_ies_o::value_c::routing_id() const
{
  assert_choice_type(types::routing_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const unbounded_octstring<true>& dl_non_ue_associated_nrppa_transport_ies_o::value_c::nrppa_pdu() const
{
  assert_choice_type(types::nrppa_pdu, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
void dl_non_ue_associated_nrppa_transport_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::routing_id:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::nrppa_pdu:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "dl_non_ue_associated_nrppa_transport_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE dl_non_ue_associated_nrppa_transport_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::routing_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::nrppa_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "dl_non_ue_associated_nrppa_transport_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE dl_non_ue_associated_nrppa_transport_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::routing_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::nrppa_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "dl_non_ue_associated_nrppa_transport_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* dl_non_ue_associated_nrppa_transport_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"OCTET STRING", "OCTET STRING"};
  return convert_enum_idx(names, 2, value, "dl_non_ue_associated_nrppa_transport_ies_o::value_c::types");
}

template struct asn1::protocol_ie_field_s<dl_non_ue_associated_nrppa_transport_ies_o>;

dl_non_ue_associated_nrppa_transport_ies_container::dl_non_ue_associated_nrppa_transport_ies_container() :
  routing_id(89, crit_e::reject), nrppa_pdu(46, crit_e::reject)
{
}
SRSASN_CODE dl_non_ue_associated_nrppa_transport_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(routing_id.pack(bref));
  HANDLE_CODE(nrppa_pdu.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE dl_non_ue_associated_nrppa_transport_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 89: {
        nof_mandatory_ies--;
        routing_id.id = id;
        HANDLE_CODE(routing_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(routing_id.value.unpack(bref));
        break;
      }
      case 46: {
        nof_mandatory_ies--;
        nrppa_pdu.id = id;
        HANDLE_CODE(nrppa_pdu.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nrppa_pdu.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void dl_non_ue_associated_nrppa_transport_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  routing_id.to_json(j);
  j.write_fieldname("");
  nrppa_pdu.to_json(j);
  j.end_obj();
}

// EUTRAN-CompositeAvailableCapacityGroup ::= SEQUENCE
SRSASN_CODE eutran_composite_available_capacity_group_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(dl_composite_available_capacity.pack(bref));
  HANDLE_CODE(ul_composite_available_capacity.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE eutran_composite_available_capacity_group_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(dl_composite_available_capacity.unpack(bref));
  HANDLE_CODE(ul_composite_available_capacity.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void eutran_composite_available_capacity_group_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("dL-CompositeAvailableCapacity");
  dl_composite_available_capacity.to_json(j);
  j.write_fieldname("uL-CompositeAvailableCapacity");
  ul_composite_available_capacity.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// EUTRAN-RadioResourceStatus ::= SEQUENCE
SRSASN_CODE eutran_rr_status_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(dl_sched_pdcch_cce_usage_present, 1));
  HANDLE_CODE(bref.pack(ul_sched_pdcch_cce_usage_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, dl_gbr_prb_usage, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(pack_integer(bref, ul_gbr_prb_usage, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(pack_integer(bref, dl_non_gbr_prb_usage, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(pack_integer(bref, ul_non_gbr_prb_usage, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(pack_integer(bref, dl_total_prb_usage, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(pack_integer(bref, ul_total_prb_usage, (uint8_t)0u, (uint8_t)100u, false, true));
  if (dl_sched_pdcch_cce_usage_present) {
    HANDLE_CODE(pack_integer(bref, dl_sched_pdcch_cce_usage, (uint8_t)0u, (uint8_t)100u, false, true));
  }
  if (ul_sched_pdcch_cce_usage_present) {
    HANDLE_CODE(pack_integer(bref, ul_sched_pdcch_cce_usage, (uint8_t)0u, (uint8_t)100u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE eutran_rr_status_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(dl_sched_pdcch_cce_usage_present, 1));
  HANDLE_CODE(bref.unpack(ul_sched_pdcch_cce_usage_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(dl_gbr_prb_usage, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(unpack_integer(ul_gbr_prb_usage, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(unpack_integer(dl_non_gbr_prb_usage, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(unpack_integer(ul_non_gbr_prb_usage, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(unpack_integer(dl_total_prb_usage, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(unpack_integer(ul_total_prb_usage, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  if (dl_sched_pdcch_cce_usage_present) {
    HANDLE_CODE(unpack_integer(dl_sched_pdcch_cce_usage, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  }
  if (ul_sched_pdcch_cce_usage_present) {
    HANDLE_CODE(unpack_integer(ul_sched_pdcch_cce_usage, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void eutran_rr_status_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("dL-GBR-PRB-usage", dl_gbr_prb_usage);
  j.write_int("uL-GBR-PRB-usage", ul_gbr_prb_usage);
  j.write_int("dL-non-GBR-PRB-usage", dl_non_gbr_prb_usage);
  j.write_int("uL-non-GBR-PRB-usage", ul_non_gbr_prb_usage);
  j.write_int("dL-Total-PRB-usage", dl_total_prb_usage);
  j.write_int("uL-Total-PRB-usage", ul_total_prb_usage);
  if (dl_sched_pdcch_cce_usage_present) {
    j.write_int("dL-scheduling-PDCCH-CCE-usage", dl_sched_pdcch_cce_usage);
  }
  if (ul_sched_pdcch_cce_usage_present) {
    j.write_int("uL-scheduling-PDCCH-CCE-usage", ul_sched_pdcch_cce_usage);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// NGRAN-RadioResourceStatus ::= SEQUENCE
SRSASN_CODE ngran_rr_status_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, dl_gbr_prb_usage_for_mimo, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(pack_integer(bref, ul_gbr_prb_usage_for_mimo, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(pack_integer(bref, dl_non_gbr_prb_usage_for_mimo, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(pack_integer(bref, ul_non_gbr_prb_usage_for_mimo, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(pack_integer(bref, dl_total_prb_usage_for_mimo, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(pack_integer(bref, ul_total_prb_usage_for_mimo, (uint8_t)0u, (uint8_t)100u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ngran_rr_status_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(dl_gbr_prb_usage_for_mimo, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(unpack_integer(ul_gbr_prb_usage_for_mimo, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(unpack_integer(dl_non_gbr_prb_usage_for_mimo, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(unpack_integer(ul_non_gbr_prb_usage_for_mimo, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(unpack_integer(dl_total_prb_usage_for_mimo, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(unpack_integer(ul_total_prb_usage_for_mimo, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ngran_rr_status_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("dL-GBR-PRB-usage-for-MIMO", dl_gbr_prb_usage_for_mimo);
  j.write_int("uL-GBR-PRB-usage-for-MIMO", ul_gbr_prb_usage_for_mimo);
  j.write_int("dL-non-GBR-PRB-usage-for-MIMO", dl_non_gbr_prb_usage_for_mimo);
  j.write_int("uL-non-GBR-PRB-usage-for-MIMO", ul_non_gbr_prb_usage_for_mimo);
  j.write_int("dL-Total-PRB-usage-for-MIMO", dl_total_prb_usage_for_mimo);
  j.write_int("uL-Total-PRB-usage-for-MIMO", ul_total_prb_usage_for_mimo);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// EUTRAN-CellReportItem ::= SEQUENCE
SRSASN_CODE eutran_cell_report_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(eutran_nof_active_ues_present, 1));
  HANDLE_CODE(bref.pack(eutran_noof_rrc_conns_present, 1));
  HANDLE_CODE(bref.pack(eutran_rr_status_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(ecgi.pack(bref));
  HANDLE_CODE(eutran_composite_available_capacity_group.pack(bref));
  if (eutran_nof_active_ues_present) {
    HANDLE_CODE(pack_integer(bref, eutran_nof_active_ues, (uint32_t)0u, (uint32_t)16777215u, true, true));
  }
  if (eutran_noof_rrc_conns_present) {
    HANDLE_CODE(pack_integer(bref, eutran_noof_rrc_conns, (uint32_t)1u, (uint32_t)65536u, true, true));
  }
  if (eutran_rr_status_present) {
    HANDLE_CODE(eutran_rr_status.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE eutran_cell_report_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(eutran_nof_active_ues_present, 1));
  HANDLE_CODE(bref.unpack(eutran_noof_rrc_conns_present, 1));
  HANDLE_CODE(bref.unpack(eutran_rr_status_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(ecgi.unpack(bref));
  HANDLE_CODE(eutran_composite_available_capacity_group.unpack(bref));
  if (eutran_nof_active_ues_present) {
    HANDLE_CODE(unpack_integer(eutran_nof_active_ues, bref, (uint32_t)0u, (uint32_t)16777215u, true, true));
  }
  if (eutran_noof_rrc_conns_present) {
    HANDLE_CODE(unpack_integer(eutran_noof_rrc_conns, bref, (uint32_t)1u, (uint32_t)65536u, true, true));
  }
  if (eutran_rr_status_present) {
    HANDLE_CODE(eutran_rr_status.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void eutran_cell_report_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("eCGI");
  ecgi.to_json(j);
  j.write_fieldname("eUTRAN-CompositeAvailableCapacityGroup");
  eutran_composite_available_capacity_group.to_json(j);
  if (eutran_nof_active_ues_present) {
    j.write_int("eUTRAN-NumberOfActiveUEs", eutran_nof_active_ues);
  }
  if (eutran_noof_rrc_conns_present) {
    j.write_int("eUTRAN-NoofRRCConnections", eutran_noof_rrc_conns);
  }
  if (eutran_rr_status_present) {
    j.write_fieldname("eUTRAN-RadioResourceStatus");
    eutran_rr_status.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// EUTRAN-CellToReportItem ::= SEQUENCE
SRSASN_CODE eutran_cell_to_report_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(ecgi.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE eutran_cell_to_report_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(ecgi.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void eutran_cell_to_report_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("eCGI");
  ecgi.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// NGRAN-CellReportItem ::= SEQUENCE
SRSASN_CODE ngran_cell_report_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ngran_nof_active_ues_present, 1));
  HANDLE_CODE(bref.pack(ngran_noof_rrc_conns_present, 1));
  HANDLE_CODE(bref.pack(ngran_rr_status_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(ngran_cgi.pack(bref));
  HANDLE_CODE(ngran_composite_available_capacity_group.pack(bref));
  if (ngran_nof_active_ues_present) {
    HANDLE_CODE(pack_integer(bref, ngran_nof_active_ues, (uint32_t)0u, (uint32_t)16777215u, true, true));
  }
  if (ngran_noof_rrc_conns_present) {
    HANDLE_CODE(pack_integer(bref, ngran_noof_rrc_conns, (uint32_t)1u, (uint32_t)65536u, true, true));
  }
  if (ngran_rr_status_present) {
    HANDLE_CODE(ngran_rr_status.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ngran_cell_report_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ngran_nof_active_ues_present, 1));
  HANDLE_CODE(bref.unpack(ngran_noof_rrc_conns_present, 1));
  HANDLE_CODE(bref.unpack(ngran_rr_status_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(ngran_cgi.unpack(bref));
  HANDLE_CODE(ngran_composite_available_capacity_group.unpack(bref));
  if (ngran_nof_active_ues_present) {
    HANDLE_CODE(unpack_integer(ngran_nof_active_ues, bref, (uint32_t)0u, (uint32_t)16777215u, true, true));
  }
  if (ngran_noof_rrc_conns_present) {
    HANDLE_CODE(unpack_integer(ngran_noof_rrc_conns, bref, (uint32_t)1u, (uint32_t)65536u, true, true));
  }
  if (ngran_rr_status_present) {
    HANDLE_CODE(ngran_rr_status.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ngran_cell_report_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("nGRAN-CGI");
  ngran_cgi.to_json(j);
  j.write_fieldname("nGRAN-CompositeAvailableCapacityGroup");
  ngran_composite_available_capacity_group.to_json(j);
  if (ngran_nof_active_ues_present) {
    j.write_int("nGRAN-NumberOfActiveUEs", ngran_nof_active_ues);
  }
  if (ngran_noof_rrc_conns_present) {
    j.write_int("nGRAN-NoofRRCConnections", ngran_noof_rrc_conns);
  }
  if (ngran_rr_status_present) {
    j.write_fieldname("nGRAN-RadioResourceStatus");
    ngran_rr_status.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// NGRAN-CellToReportItem ::= SEQUENCE
SRSASN_CODE ngran_cell_to_report_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(ngran_cgi.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ngran_cell_to_report_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(ngran_cgi.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ngran_cell_to_report_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("nGRAN-CGI");
  ngran_cgi.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// NumberOfMeasurementReportingLevels ::= ENUMERATED
const char* nof_meas_report_levels_opts::to_string() const
{
  static const char* names[] = {"n2", "n3", "n4", "n5", "n10"};
  return convert_enum_idx(names, 5, value, "nof_meas_report_levels_e");
}
uint8_t nof_meas_report_levels_opts::to_number() const
{
  static const uint8_t numbers[] = {2, 3, 4, 5, 10};
  return map_enum_number(numbers, 5, value, "nof_meas_report_levels_e");
}

// ReportingPeriodicity ::= ENUMERATED
const char* report_periodicity_opts::to_string() const
{
  static const char* names[] = {"stop", "single", "ms1000", "ms2000", "ms5000", "ms10000"};
  return convert_enum_idx(names, 6, value, "report_periodicity_e");
}
uint16_t report_periodicity_opts::to_number() const
{
  switch (value) {
    case ms1000:
      return 1000;
    case ms2000:
      return 2000;
    case ms5000:
      return 5000;
    case ms10000:
      return 10000;
    default:
      invalid_enum_number(value, "report_periodicity_e");
  }
  return 0;
}

// EUTRAN-ReportingStatusIEs ::= SEQUENCE
SRSASN_CODE eutran_report_status_ies_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, eutran_cell_report_list, 1, 256, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE eutran_report_status_ies_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(eutran_cell_report_list, bref, 1, 256, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void eutran_report_status_ies_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("eUTRAN-CellReportList");
  for (const auto& e1 : eutran_cell_report_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// EUTRAN-ReportingSystemIEs ::= SEQUENCE
SRSASN_CODE eutran_report_sys_ies_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, eutran_cell_to_report_list, 1, 256, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE eutran_report_sys_ies_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(eutran_cell_to_report_list, bref, 1, 256, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void eutran_report_sys_ies_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("eUTRAN-CellToReportList");
  for (const auto& e1 : eutran_cell_to_report_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// EventBasedReportingIEs ::= SEQUENCE
SRSASN_CODE event_based_report_ies_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, intersys_res_thres_low, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(pack_integer(bref, intersys_res_thres_high, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(nof_meas_report_levels.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE event_based_report_ies_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(intersys_res_thres_low, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(unpack_integer(intersys_res_thres_high, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(nof_meas_report_levels.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void event_based_report_ies_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("intersystemResourceThresholdLow", intersys_res_thres_low);
  j.write_int("intersystemResourceThresholdHigh", intersys_res_thres_high);
  j.write_str("numberOfMeasurementReportingLevels", nof_meas_report_levels.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// NGRAN-ReportingStatusIEs ::= SEQUENCE
SRSASN_CODE ngran_report_status_ies_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, ngran_cell_report_list, 1, 256, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ngran_report_status_ies_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(ngran_cell_report_list, bref, 1, 256, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ngran_report_status_ies_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("nGRAN-CellReportList");
  for (const auto& e1 : ngran_cell_report_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// NGRAN-ReportingSystemIEs ::= SEQUENCE
SRSASN_CODE ngran_report_sys_ies_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, ngran_cell_to_report_list, 1, 256, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ngran_report_sys_ies_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(ngran_cell_to_report_list, bref, 1, 256, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ngran_report_sys_ies_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("nGRAN-CellToReportList");
  for (const auto& e1 : ngran_cell_to_report_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// NotificationCell-Item ::= SEQUENCE
SRSASN_CODE notif_cell_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(ngran_cgi.pack(bref));
  HANDLE_CODE(notify_flag.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE notif_cell_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(ngran_cgi.unpack(bref));
  HANDLE_CODE(notify_flag.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void notif_cell_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("nGRAN-CGI");
  ngran_cgi.to_json(j);
  j.write_str("notifyFlag", notify_flag.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* notif_cell_item_s::notify_flag_opts::to_string() const
{
  static const char* names[] = {"activated", "deactivated"};
  return convert_enum_idx(names, 2, value, "notif_cell_item_s::notify_flag_e_");
}

// PeriodicReportingIEs ::= SEQUENCE
SRSASN_CODE periodic_report_ies_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(report_periodicity.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE periodic_report_ies_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(report_periodicity.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void periodic_report_ies_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("reportingPeriodicity", report_periodicity.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SuccessfulHandoverReport-Item ::= SEQUENCE
SRSASN_CODE successful_ho_report_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(successful_ho_report_container.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE successful_ho_report_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(successful_ho_report_container.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void successful_ho_report_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("successfulHOReportContainer", successful_ho_report_container.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// UERLFReportContainer ::= CHOICE
void ue_rlf_report_container_c::destroy_()
{
  switch (type_) {
    case types::nr:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::lte:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<ue_rlf_report_container_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void ue_rlf_report_container_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::nr:
      c.init<unbounded_octstring<true>>();
      break;
    case types::lte:
      c.init<unbounded_octstring<true>>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<ue_rlf_report_container_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_rlf_report_container_c");
  }
}
ue_rlf_report_container_c::ue_rlf_report_container_c(const ue_rlf_report_container_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::nr:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::lte:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<ue_rlf_report_container_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_rlf_report_container_c");
  }
}
ue_rlf_report_container_c& ue_rlf_report_container_c::operator=(const ue_rlf_report_container_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::nr:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::lte:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<ue_rlf_report_container_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_rlf_report_container_c");
  }

  return *this;
}
unbounded_octstring<true>& ue_rlf_report_container_c::set_nr()
{
  set(types::nr);
  return c.get<unbounded_octstring<true>>();
}
unbounded_octstring<true>& ue_rlf_report_container_c::set_lte()
{
  set(types::lte);
  return c.get<unbounded_octstring<true>>();
}
protocol_ie_single_container_s<ue_rlf_report_container_ext_ies_o>& ue_rlf_report_container_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<ue_rlf_report_container_ext_ies_o>>();
}
void ue_rlf_report_container_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::nr:
      j.write_str("nR", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::lte:
      j.write_str("lTE", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<ue_rlf_report_container_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ue_rlf_report_container_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_rlf_report_container_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::nr:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::lte:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<ue_rlf_report_container_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_rlf_report_container_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_rlf_report_container_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::nr:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::lte:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<ue_rlf_report_container_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_rlf_report_container_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ue_rlf_report_container_c::types_opts::to_string() const
{
  static const char* names[] = {"nR", "lTE", "choice-Extensions"};
  return convert_enum_idx(names, 3, value, "ue_rlf_report_container_c::types");
}

// XnExtTLA-Item-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t xn_ext_tla_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {173};
  return map_enum_number(names, 1, idx, "id");
}
bool xn_ext_tla_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 173 == id;
}
crit_e xn_ext_tla_item_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 173) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
xn_ext_tla_item_ext_ies_o::ext_c xn_ext_tla_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 173) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e xn_ext_tla_item_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 173) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void xn_ext_tla_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("SCTP-TLAs");
  for (const auto& e1 : c) {
    j.write_str(e1.to_string());
  }
  j.end_array();
  j.end_obj();
}
SRSASN_CODE xn_ext_tla_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(pack_dyn_seq_of(bref, c, 1, 2, true));
  return SRSASN_SUCCESS;
}
SRSASN_CODE xn_ext_tla_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(unpack_dyn_seq_of(c, bref, 1, 2, true));
  return SRSASN_SUCCESS;
}

const char* xn_ext_tla_item_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"SCTP-TLAs"};
  return convert_enum_idx(names, 1, value, "xn_ext_tla_item_ext_ies_o::ext_c::types");
}

// ENB-ID ::= CHOICE
void enb_id_c::destroy_()
{
  switch (type_) {
    case types::macro_enb_id:
      c.destroy<fixed_bitstring<20, false, true>>();
      break;
    case types::home_enb_id:
      c.destroy<fixed_bitstring<28, false, true>>();
      break;
    case types::short_macro_enb_id:
      c.destroy<fixed_bitstring<18, false, true>>();
      break;
    case types::long_macro_enb_id:
      c.destroy<fixed_bitstring<21, false, true>>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<enb_id_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void enb_id_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::macro_enb_id:
      c.init<fixed_bitstring<20, false, true>>();
      break;
    case types::home_enb_id:
      c.init<fixed_bitstring<28, false, true>>();
      break;
    case types::short_macro_enb_id:
      c.init<fixed_bitstring<18, false, true>>();
      break;
    case types::long_macro_enb_id:
      c.init<fixed_bitstring<21, false, true>>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<enb_id_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "enb_id_c");
  }
}
enb_id_c::enb_id_c(const enb_id_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::macro_enb_id:
      c.init(other.c.get<fixed_bitstring<20, false, true>>());
      break;
    case types::home_enb_id:
      c.init(other.c.get<fixed_bitstring<28, false, true>>());
      break;
    case types::short_macro_enb_id:
      c.init(other.c.get<fixed_bitstring<18, false, true>>());
      break;
    case types::long_macro_enb_id:
      c.init(other.c.get<fixed_bitstring<21, false, true>>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<enb_id_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "enb_id_c");
  }
}
enb_id_c& enb_id_c::operator=(const enb_id_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::macro_enb_id:
      c.set(other.c.get<fixed_bitstring<20, false, true>>());
      break;
    case types::home_enb_id:
      c.set(other.c.get<fixed_bitstring<28, false, true>>());
      break;
    case types::short_macro_enb_id:
      c.set(other.c.get<fixed_bitstring<18, false, true>>());
      break;
    case types::long_macro_enb_id:
      c.set(other.c.get<fixed_bitstring<21, false, true>>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<enb_id_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "enb_id_c");
  }

  return *this;
}
fixed_bitstring<20, false, true>& enb_id_c::set_macro_enb_id()
{
  set(types::macro_enb_id);
  return c.get<fixed_bitstring<20, false, true>>();
}
fixed_bitstring<28, false, true>& enb_id_c::set_home_enb_id()
{
  set(types::home_enb_id);
  return c.get<fixed_bitstring<28, false, true>>();
}
fixed_bitstring<18, false, true>& enb_id_c::set_short_macro_enb_id()
{
  set(types::short_macro_enb_id);
  return c.get<fixed_bitstring<18, false, true>>();
}
fixed_bitstring<21, false, true>& enb_id_c::set_long_macro_enb_id()
{
  set(types::long_macro_enb_id);
  return c.get<fixed_bitstring<21, false, true>>();
}
protocol_ie_single_container_s<enb_id_ext_ies_o>& enb_id_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<enb_id_ext_ies_o>>();
}
void enb_id_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::macro_enb_id:
      j.write_str("macroENB-ID", c.get<fixed_bitstring<20, false, true>>().to_string());
      break;
    case types::home_enb_id:
      j.write_str("homeENB-ID", c.get<fixed_bitstring<28, false, true>>().to_string());
      break;
    case types::short_macro_enb_id:
      j.write_str("short-macroENB-ID", c.get<fixed_bitstring<18, false, true>>().to_string());
      break;
    case types::long_macro_enb_id:
      j.write_str("long-macroENB-ID", c.get<fixed_bitstring<21, false, true>>().to_string());
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<enb_id_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "enb_id_c");
  }
  j.end_obj();
}
SRSASN_CODE enb_id_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::macro_enb_id:
      HANDLE_CODE((c.get<fixed_bitstring<20, false, true>>().pack(bref)));
      break;
    case types::home_enb_id:
      HANDLE_CODE((c.get<fixed_bitstring<28, false, true>>().pack(bref)));
      break;
    case types::short_macro_enb_id:
      HANDLE_CODE((c.get<fixed_bitstring<18, false, true>>().pack(bref)));
      break;
    case types::long_macro_enb_id:
      HANDLE_CODE((c.get<fixed_bitstring<21, false, true>>().pack(bref)));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<enb_id_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "enb_id_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE enb_id_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::macro_enb_id:
      HANDLE_CODE((c.get<fixed_bitstring<20, false, true>>().unpack(bref)));
      break;
    case types::home_enb_id:
      HANDLE_CODE((c.get<fixed_bitstring<28, false, true>>().unpack(bref)));
      break;
    case types::short_macro_enb_id:
      HANDLE_CODE((c.get<fixed_bitstring<18, false, true>>().unpack(bref)));
      break;
    case types::long_macro_enb_id:
      HANDLE_CODE((c.get<fixed_bitstring<21, false, true>>().unpack(bref)));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<enb_id_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "enb_id_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* enb_id_c::types_opts::to_string() const
{
  static const char* names[] = {
      "macroENB-ID", "homeENB-ID", "short-macroENB-ID", "long-macroENB-ID", "choice-Extensions"};
  return convert_enum_idx(names, 5, value, "enb_id_c::types");
}

// IntersystemUnnecessaryHO ::= SEQUENCE
SRSASN_CODE intersys_unnecessary_ho_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(sourcecell_id.pack(bref));
  HANDLE_CODE(targetcell_id.pack(bref));
  HANDLE_CODE(early_iratho.pack(bref));
  HANDLE_CODE(pack_dyn_seq_of(bref, candidate_cell_list, 1, 32, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE intersys_unnecessary_ho_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(sourcecell_id.unpack(bref));
  HANDLE_CODE(targetcell_id.unpack(bref));
  HANDLE_CODE(early_iratho.unpack(bref));
  HANDLE_CODE(unpack_dyn_seq_of(candidate_cell_list, bref, 1, 32, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void intersys_unnecessary_ho_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("sourcecellID");
  sourcecell_id.to_json(j);
  j.write_fieldname("targetcellID");
  targetcell_id.to_json(j);
  j.write_str("earlyIRATHO", early_iratho.to_string());
  j.start_array("candidateCellList");
  for (const auto& e1 : candidate_cell_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* intersys_unnecessary_ho_s::early_iratho_opts::to_string() const
{
  static const char* names[] = {"true", "false"};
  return convert_enum_idx(names, 2, value, "intersys_unnecessary_ho_s::early_iratho_e_");
}

// ReportType ::= CHOICE
void report_type_c::destroy_()
{
  switch (type_) {
    case types::event_based_report:
      c.destroy<event_based_report_ies_s>();
      break;
    case types::periodic_report:
      c.destroy<periodic_report_ies_s>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<report_type_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void report_type_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::event_based_report:
      c.init<event_based_report_ies_s>();
      break;
    case types::periodic_report:
      c.init<periodic_report_ies_s>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<report_type_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "report_type_c");
  }
}
report_type_c::report_type_c(const report_type_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::event_based_report:
      c.init(other.c.get<event_based_report_ies_s>());
      break;
    case types::periodic_report:
      c.init(other.c.get<periodic_report_ies_s>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<report_type_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "report_type_c");
  }
}
report_type_c& report_type_c::operator=(const report_type_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::event_based_report:
      c.set(other.c.get<event_based_report_ies_s>());
      break;
    case types::periodic_report:
      c.set(other.c.get<periodic_report_ies_s>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<report_type_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "report_type_c");
  }

  return *this;
}
event_based_report_ies_s& report_type_c::set_event_based_report()
{
  set(types::event_based_report);
  return c.get<event_based_report_ies_s>();
}
periodic_report_ies_s& report_type_c::set_periodic_report()
{
  set(types::periodic_report);
  return c.get<periodic_report_ies_s>();
}
protocol_ie_single_container_s<report_type_ext_ies_o>& report_type_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<report_type_ext_ies_o>>();
}
void report_type_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::event_based_report:
      j.write_fieldname("eventBasedReporting");
      c.get<event_based_report_ies_s>().to_json(j);
      break;
    case types::periodic_report:
      j.write_fieldname("periodicReporting");
      c.get<periodic_report_ies_s>().to_json(j);
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<report_type_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "report_type_c");
  }
  j.end_obj();
}
SRSASN_CODE report_type_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::event_based_report:
      HANDLE_CODE(c.get<event_based_report_ies_s>().pack(bref));
      break;
    case types::periodic_report:
      HANDLE_CODE(c.get<periodic_report_ies_s>().pack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<report_type_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "report_type_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE report_type_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::event_based_report:
      HANDLE_CODE(c.get<event_based_report_ies_s>().unpack(bref));
      break;
    case types::periodic_report:
      HANDLE_CODE(c.get<periodic_report_ies_s>().unpack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<report_type_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "report_type_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* report_type_c::types_opts::to_string() const
{
  static const char* names[] = {"eventBasedReporting", "periodicReporting", "choice-Extensions"};
  return convert_enum_idx(names, 3, value, "report_type_c::types");
}

// ReportingSystem ::= CHOICE
void report_sys_c::destroy_()
{
  switch (type_) {
    case types::eutran:
      c.destroy<eutran_report_sys_ies_s>();
      break;
    case types::ngran:
      c.destroy<ngran_report_sys_ies_s>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<report_sys_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void report_sys_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::eutran:
      c.init<eutran_report_sys_ies_s>();
      break;
    case types::ngran:
      c.init<ngran_report_sys_ies_s>();
      break;
    case types::no_report:
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<report_sys_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "report_sys_c");
  }
}
report_sys_c::report_sys_c(const report_sys_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::eutran:
      c.init(other.c.get<eutran_report_sys_ies_s>());
      break;
    case types::ngran:
      c.init(other.c.get<ngran_report_sys_ies_s>());
      break;
    case types::no_report:
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<report_sys_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "report_sys_c");
  }
}
report_sys_c& report_sys_c::operator=(const report_sys_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::eutran:
      c.set(other.c.get<eutran_report_sys_ies_s>());
      break;
    case types::ngran:
      c.set(other.c.get<ngran_report_sys_ies_s>());
      break;
    case types::no_report:
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<report_sys_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "report_sys_c");
  }

  return *this;
}
eutran_report_sys_ies_s& report_sys_c::set_eutran()
{
  set(types::eutran);
  return c.get<eutran_report_sys_ies_s>();
}
ngran_report_sys_ies_s& report_sys_c::set_ngran()
{
  set(types::ngran);
  return c.get<ngran_report_sys_ies_s>();
}
void report_sys_c::set_no_report()
{
  set(types::no_report);
}
protocol_ie_single_container_s<report_sys_ext_ies_o>& report_sys_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<report_sys_ext_ies_o>>();
}
void report_sys_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::eutran:
      j.write_fieldname("eUTRAN");
      c.get<eutran_report_sys_ies_s>().to_json(j);
      break;
    case types::ngran:
      j.write_fieldname("nGRAN");
      c.get<ngran_report_sys_ies_s>().to_json(j);
      break;
    case types::no_report:
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<report_sys_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "report_sys_c");
  }
  j.end_obj();
}
SRSASN_CODE report_sys_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::eutran:
      HANDLE_CODE(c.get<eutran_report_sys_ies_s>().pack(bref));
      break;
    case types::ngran:
      HANDLE_CODE(c.get<ngran_report_sys_ies_s>().pack(bref));
      break;
    case types::no_report:
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<report_sys_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "report_sys_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE report_sys_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::eutran:
      HANDLE_CODE(c.get<eutran_report_sys_ies_s>().unpack(bref));
      break;
    case types::ngran:
      HANDLE_CODE(c.get<ngran_report_sys_ies_s>().unpack(bref));
      break;
    case types::no_report:
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<report_sys_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "report_sys_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* report_sys_c::types_opts::to_string() const
{
  static const char* names[] = {"eUTRAN", "nGRAN", "noReporting", "choice-Extensions"};
  return convert_enum_idx(names, 4, value, "report_sys_c::types");
}

// ResourceStatusReportingSystem ::= CHOICE
void res_status_report_sys_c::destroy_()
{
  switch (type_) {
    case types::eutran_report_status:
      c.destroy<eutran_report_status_ies_s>();
      break;
    case types::ngran_report_status:
      c.destroy<ngran_report_status_ies_s>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<res_status_report_sys_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void res_status_report_sys_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::eutran_report_status:
      c.init<eutran_report_status_ies_s>();
      break;
    case types::ngran_report_status:
      c.init<ngran_report_status_ies_s>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<res_status_report_sys_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "res_status_report_sys_c");
  }
}
res_status_report_sys_c::res_status_report_sys_c(const res_status_report_sys_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::eutran_report_status:
      c.init(other.c.get<eutran_report_status_ies_s>());
      break;
    case types::ngran_report_status:
      c.init(other.c.get<ngran_report_status_ies_s>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<res_status_report_sys_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "res_status_report_sys_c");
  }
}
res_status_report_sys_c& res_status_report_sys_c::operator=(const res_status_report_sys_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::eutran_report_status:
      c.set(other.c.get<eutran_report_status_ies_s>());
      break;
    case types::ngran_report_status:
      c.set(other.c.get<ngran_report_status_ies_s>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<res_status_report_sys_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "res_status_report_sys_c");
  }

  return *this;
}
eutran_report_status_ies_s& res_status_report_sys_c::set_eutran_report_status()
{
  set(types::eutran_report_status);
  return c.get<eutran_report_status_ies_s>();
}
ngran_report_status_ies_s& res_status_report_sys_c::set_ngran_report_status()
{
  set(types::ngran_report_status);
  return c.get<ngran_report_status_ies_s>();
}
protocol_ie_single_container_s<res_status_report_sys_ext_ies_o>& res_status_report_sys_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<res_status_report_sys_ext_ies_o>>();
}
void res_status_report_sys_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::eutran_report_status:
      j.write_fieldname("eUTRAN-ReportingStatus");
      c.get<eutran_report_status_ies_s>().to_json(j);
      break;
    case types::ngran_report_status:
      j.write_fieldname("nGRAN-ReportingStatus");
      c.get<ngran_report_status_ies_s>().to_json(j);
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<res_status_report_sys_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "res_status_report_sys_c");
  }
  j.end_obj();
}
SRSASN_CODE res_status_report_sys_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::eutran_report_status:
      HANDLE_CODE(c.get<eutran_report_status_ies_s>().pack(bref));
      break;
    case types::ngran_report_status:
      HANDLE_CODE(c.get<ngran_report_status_ies_s>().pack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<res_status_report_sys_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "res_status_report_sys_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE res_status_report_sys_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::eutran_report_status:
      HANDLE_CODE(c.get<eutran_report_status_ies_s>().unpack(bref));
      break;
    case types::ngran_report_status:
      HANDLE_CODE(c.get<ngran_report_status_ies_s>().unpack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<res_status_report_sys_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "res_status_report_sys_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* res_status_report_sys_c::types_opts::to_string() const
{
  static const char* names[] = {"eUTRAN-ReportingStatus", "nGRAN-ReportingStatus", "choice-Extensions"};
  return convert_enum_idx(names, 3, value, "res_status_report_sys_c::types");
}

// TooearlyIntersystemHO ::= SEQUENCE
SRSASN_CODE tooearly_intersys_ho_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ue_rlf_report_container_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(sourcecell_id.pack(bref));
  HANDLE_CODE(failcell_id.pack(bref));
  if (ue_rlf_report_container_present) {
    HANDLE_CODE(ue_rlf_report_container.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE tooearly_intersys_ho_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ue_rlf_report_container_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(sourcecell_id.unpack(bref));
  HANDLE_CODE(failcell_id.unpack(bref));
  if (ue_rlf_report_container_present) {
    HANDLE_CODE(ue_rlf_report_container.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void tooearly_intersys_ho_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("sourcecellID");
  sourcecell_id.to_json(j);
  j.write_fieldname("failurecellID");
  failcell_id.to_json(j);
  if (ue_rlf_report_container_present) {
    j.write_fieldname("uERLFReportContainer");
    ue_rlf_report_container.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// XnExtTLA-Item ::= SEQUENCE
SRSASN_CODE xn_ext_tla_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ip_sec_tla_present, 1));
  HANDLE_CODE(bref.pack(gtp_tlas.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  if (ip_sec_tla_present) {
    HANDLE_CODE(ip_sec_tla.pack(bref));
  }
  if (gtp_tlas.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, gtp_tlas, 1, 16, true));
  }
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE xn_ext_tla_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ip_sec_tla_present, 1));
  bool gtp_tlas_present;
  HANDLE_CODE(bref.unpack(gtp_tlas_present, 1));
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (ip_sec_tla_present) {
    HANDLE_CODE(ip_sec_tla.unpack(bref));
  }
  if (gtp_tlas_present) {
    HANDLE_CODE(unpack_dyn_seq_of(gtp_tlas, bref, 1, 16, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void xn_ext_tla_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (ip_sec_tla_present) {
    j.write_str("iPsecTLA", ip_sec_tla.to_string());
  }
  if (gtp_tlas.size() > 0) {
    j.start_array("gTP-TLAs");
    for (const auto& e1 : gtp_tlas) {
      j.write_str(e1.to_string());
    }
    j.end_array();
  }
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// EPS-TAI ::= SEQUENCE
SRSASN_CODE eps_tai_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.pack(bref));
  HANDLE_CODE(eps_tac.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE eps_tai_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.unpack(bref));
  HANDLE_CODE(eps_tac.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void eps_tai_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("pLMNIdentity", plmn_id.to_string());
  j.write_str("ePS-TAC", eps_tac.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// FailureIndication ::= SEQUENCE
SRSASN_CODE fail_ind_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(ue_rlf_report_container.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE fail_ind_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(ue_rlf_report_container.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void fail_ind_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("uERLFReportContainer");
  ue_rlf_report_container.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// GlobalENB-ID ::= SEQUENCE
SRSASN_CODE global_enb_id_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.pack(bref));
  HANDLE_CODE(enb_id.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE global_enb_id_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.unpack(bref));
  HANDLE_CODE(enb_id.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void global_enb_id_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("pLMNidentity", plmn_id.to_string());
  j.write_fieldname("eNB-ID");
  enb_id.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// HOReport ::= SEQUENCE
SRSASN_CODE ho_report_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(reestcell_cgi_present, 1));
  HANDLE_CODE(bref.pack(sourcecell_c_rnti_present, 1));
  HANDLE_CODE(bref.pack(targetcellin_e_utran_present, 1));
  HANDLE_CODE(bref.pack(mob_info_present, 1));
  HANDLE_CODE(bref.pack(ue_rlf_report_container_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(ho_report_type.pack(bref));
  HANDLE_CODE(ho_cause.pack(bref));
  HANDLE_CODE(sourcecell_cgi.pack(bref));
  HANDLE_CODE(targetcell_cgi.pack(bref));
  if (reestcell_cgi_present) {
    HANDLE_CODE(reestcell_cgi.pack(bref));
  }
  if (sourcecell_c_rnti_present) {
    HANDLE_CODE(sourcecell_c_rnti.pack(bref));
  }
  if (targetcellin_e_utran_present) {
    HANDLE_CODE(targetcellin_e_utran.pack(bref));
  }
  if (mob_info_present) {
    HANDLE_CODE(mob_info.pack(bref));
  }
  if (ue_rlf_report_container_present) {
    HANDLE_CODE(ue_rlf_report_container.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_report_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(reestcell_cgi_present, 1));
  HANDLE_CODE(bref.unpack(sourcecell_c_rnti_present, 1));
  HANDLE_CODE(bref.unpack(targetcellin_e_utran_present, 1));
  HANDLE_CODE(bref.unpack(mob_info_present, 1));
  HANDLE_CODE(bref.unpack(ue_rlf_report_container_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(ho_report_type.unpack(bref));
  HANDLE_CODE(ho_cause.unpack(bref));
  HANDLE_CODE(sourcecell_cgi.unpack(bref));
  HANDLE_CODE(targetcell_cgi.unpack(bref));
  if (reestcell_cgi_present) {
    HANDLE_CODE(reestcell_cgi.unpack(bref));
  }
  if (sourcecell_c_rnti_present) {
    HANDLE_CODE(sourcecell_c_rnti.unpack(bref));
  }
  if (targetcellin_e_utran_present) {
    HANDLE_CODE(targetcellin_e_utran.unpack(bref));
  }
  if (mob_info_present) {
    HANDLE_CODE(mob_info.unpack(bref));
  }
  if (ue_rlf_report_container_present) {
    HANDLE_CODE(ue_rlf_report_container.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ho_report_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("handoverReportType", ho_report_type.to_string());
  j.write_fieldname("handoverCause");
  ho_cause.to_json(j);
  j.write_fieldname("sourcecellCGI");
  sourcecell_cgi.to_json(j);
  j.write_fieldname("targetcellCGI");
  targetcell_cgi.to_json(j);
  if (reestcell_cgi_present) {
    j.write_fieldname("reestablishmentcellCGI");
    reestcell_cgi.to_json(j);
  }
  if (sourcecell_c_rnti_present) {
    j.write_str("sourcecellC-RNTI", sourcecell_c_rnti.to_string());
  }
  if (targetcellin_e_utran_present) {
    j.write_fieldname("targetcellinE-UTRAN");
    targetcellin_e_utran.to_json(j);
  }
  if (mob_info_present) {
    j.write_str("mobilityInformation", mob_info.to_string());
  }
  if (ue_rlf_report_container_present) {
    j.write_fieldname("uERLFReportContainer");
    ue_rlf_report_container.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* ho_report_s::ho_report_type_opts::to_string() const
{
  static const char* names[] = {"ho-too-early", "ho-to-wrong-cell", "intersystem-ping-pong"};
  return convert_enum_idx(names, 3, value, "ho_report_s::ho_report_type_e_");
}

// InterSystemHandoverReportType ::= CHOICE
void inter_sys_ho_report_type_c::destroy_()
{
  switch (type_) {
    case types::tooearly_intersys_ho:
      c.destroy<tooearly_intersys_ho_s>();
      break;
    case types::intersys_unnecessary_ho:
      c.destroy<intersys_unnecessary_ho_s>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<inter_sys_ho_report_type_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void inter_sys_ho_report_type_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::tooearly_intersys_ho:
      c.init<tooearly_intersys_ho_s>();
      break;
    case types::intersys_unnecessary_ho:
      c.init<intersys_unnecessary_ho_s>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<inter_sys_ho_report_type_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "inter_sys_ho_report_type_c");
  }
}
inter_sys_ho_report_type_c::inter_sys_ho_report_type_c(const inter_sys_ho_report_type_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::tooearly_intersys_ho:
      c.init(other.c.get<tooearly_intersys_ho_s>());
      break;
    case types::intersys_unnecessary_ho:
      c.init(other.c.get<intersys_unnecessary_ho_s>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<inter_sys_ho_report_type_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "inter_sys_ho_report_type_c");
  }
}
inter_sys_ho_report_type_c& inter_sys_ho_report_type_c::operator=(const inter_sys_ho_report_type_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::tooearly_intersys_ho:
      c.set(other.c.get<tooearly_intersys_ho_s>());
      break;
    case types::intersys_unnecessary_ho:
      c.set(other.c.get<intersys_unnecessary_ho_s>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<inter_sys_ho_report_type_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "inter_sys_ho_report_type_c");
  }

  return *this;
}
tooearly_intersys_ho_s& inter_sys_ho_report_type_c::set_tooearly_intersys_ho()
{
  set(types::tooearly_intersys_ho);
  return c.get<tooearly_intersys_ho_s>();
}
intersys_unnecessary_ho_s& inter_sys_ho_report_type_c::set_intersys_unnecessary_ho()
{
  set(types::intersys_unnecessary_ho);
  return c.get<intersys_unnecessary_ho_s>();
}
protocol_ie_single_container_s<inter_sys_ho_report_type_ext_ies_o>& inter_sys_ho_report_type_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<inter_sys_ho_report_type_ext_ies_o>>();
}
void inter_sys_ho_report_type_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::tooearly_intersys_ho:
      j.write_fieldname("tooearlyIntersystemHO");
      c.get<tooearly_intersys_ho_s>().to_json(j);
      break;
    case types::intersys_unnecessary_ho:
      j.write_fieldname("intersystemUnnecessaryHO");
      c.get<intersys_unnecessary_ho_s>().to_json(j);
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<inter_sys_ho_report_type_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "inter_sys_ho_report_type_c");
  }
  j.end_obj();
}
SRSASN_CODE inter_sys_ho_report_type_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::tooearly_intersys_ho:
      HANDLE_CODE(c.get<tooearly_intersys_ho_s>().pack(bref));
      break;
    case types::intersys_unnecessary_ho:
      HANDLE_CODE(c.get<intersys_unnecessary_ho_s>().pack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<inter_sys_ho_report_type_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "inter_sys_ho_report_type_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE inter_sys_ho_report_type_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::tooearly_intersys_ho:
      HANDLE_CODE(c.get<tooearly_intersys_ho_s>().unpack(bref));
      break;
    case types::intersys_unnecessary_ho:
      HANDLE_CODE(c.get<intersys_unnecessary_ho_s>().unpack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<inter_sys_ho_report_type_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "inter_sys_ho_report_type_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* inter_sys_ho_report_type_c::types_opts::to_string() const
{
  static const char* names[] = {"tooearlyIntersystemHO", "intersystemUnnecessaryHO", "choice-Extensions"};
  return convert_enum_idx(names, 3, value, "inter_sys_ho_report_type_c::types");
}

// IntersystemCellActivationReply ::= SEQUENCE
SRSASN_CODE intersys_cell_activation_reply_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, activ_cell_list, 1, 16384, true));
  HANDLE_CODE(pack_integer(bref, activation_id, (uint16_t)0u, (uint16_t)16384u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE intersys_cell_activation_reply_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(activ_cell_list, bref, 1, 16384, true));
  HANDLE_CODE(unpack_integer(activation_id, bref, (uint16_t)0u, (uint16_t)16384u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void intersys_cell_activation_reply_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("activatedCellList");
  for (const auto& e1 : activ_cell_list) {
    e1.to_json(j);
  }
  j.end_array();
  j.write_int("activation-ID", activation_id);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// IntersystemCellActivationRequest ::= SEQUENCE
SRSASN_CODE intersys_cell_activation_request_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, activation_id, (uint16_t)0u, (uint16_t)16384u, true, true));
  HANDLE_CODE(pack_dyn_seq_of(bref, cells_to_activ_list, 1, 16384, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE intersys_cell_activation_request_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(activation_id, bref, (uint16_t)0u, (uint16_t)16384u, true, true));
  HANDLE_CODE(unpack_dyn_seq_of(cells_to_activ_list, bref, 1, 16384, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void intersys_cell_activation_request_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("activationID", activation_id);
  j.start_array("cellsToActivateList");
  for (const auto& e1 : cells_to_activ_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// IntersystemCellStateIndication ::= SEQUENCE
SRSASN_CODE intersys_cell_state_ind_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, notif_cell_list, 1, 16384, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE intersys_cell_state_ind_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(notif_cell_list, bref, 1, 16384, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void intersys_cell_state_ind_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("notificationCellList");
  for (const auto& e1 : notif_cell_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// IntersystemResourceStatusReply ::= SEQUENCE
SRSASN_CODE intersys_res_status_reply_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(reportsys.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE intersys_res_status_reply_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(reportsys.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void intersys_res_status_reply_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("reportingsystem");
  reportsys.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// IntersystemResourceStatusReport ::= SEQUENCE
SRSASN_CODE intersys_res_status_report_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(report_sys.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE intersys_res_status_report_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(report_sys.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void intersys_res_status_report_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("reportingSystem");
  report_sys.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// IntersystemResourceStatusRequest ::= SEQUENCE
SRSASN_CODE intersys_res_status_request_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(report_sys.pack(bref));
  HANDLE_CODE(report_characteristics.pack(bref));
  HANDLE_CODE(report_type.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE intersys_res_status_request_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(report_sys.unpack(bref));
  HANDLE_CODE(report_characteristics.unpack(bref));
  HANDLE_CODE(report_type.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void intersys_res_status_request_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("reportingSystem");
  report_sys.to_json(j);
  j.write_str("reportCharacteristics", report_characteristics.to_string());
  j.write_fieldname("reportType");
  report_type.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SONInformationReport-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t son_info_report_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {294};
  return map_enum_number(names, 1, idx, "id");
}
bool son_info_report_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 294 == id;
}
crit_e son_info_report_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 294) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
son_info_report_ext_ies_o::value_c son_info_report_ext_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  if (id != 294) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e son_info_report_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 294) {
    return presence_e::mandatory;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Value ::= OPEN TYPE
void son_info_report_ext_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("SuccessfulHandoverReportList");
  for (const auto& e1 : c) {
    e1.to_json(j);
  }
  j.end_array();
  j.end_obj();
}
SRSASN_CODE son_info_report_ext_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(pack_dyn_seq_of(bref, c, 1, 64, true));
  return SRSASN_SUCCESS;
}
SRSASN_CODE son_info_report_ext_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(unpack_dyn_seq_of(c, bref, 1, 64, true));
  return SRSASN_SUCCESS;
}

const char* son_info_report_ext_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"SuccessfulHandoverReportList"};
  return convert_enum_idx(names, 1, value, "son_info_report_ext_ies_o::value_c::types");
}

// InterSystemFailureIndication ::= SEQUENCE
SRSASN_CODE inter_sys_fail_ind_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ue_rlf_report_container_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (ue_rlf_report_container_present) {
    HANDLE_CODE(ue_rlf_report_container.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE inter_sys_fail_ind_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ue_rlf_report_container_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (ue_rlf_report_container_present) {
    HANDLE_CODE(ue_rlf_report_container.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void inter_sys_fail_ind_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (ue_rlf_report_container_present) {
    j.write_fieldname("uERLFReportContainer");
    ue_rlf_report_container.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// InterSystemHOReport ::= SEQUENCE
SRSASN_CODE inter_sys_ho_report_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(ho_report_type.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE inter_sys_ho_report_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(ho_report_type.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void inter_sys_ho_report_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("handoverReportType");
  ho_report_type.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// IntersystemSONInformationReply ::= CHOICE
void intersys_son_info_reply_c::destroy_()
{
  switch (type_) {
    case types::ngran_cell_activation:
      c.destroy<intersys_cell_activation_reply_s>();
      break;
    case types::res_status:
      c.destroy<intersys_res_status_reply_s>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<intersys_son_info_reply_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void intersys_son_info_reply_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::ngran_cell_activation:
      c.init<intersys_cell_activation_reply_s>();
      break;
    case types::res_status:
      c.init<intersys_res_status_reply_s>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<intersys_son_info_reply_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "intersys_son_info_reply_c");
  }
}
intersys_son_info_reply_c::intersys_son_info_reply_c(const intersys_son_info_reply_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::ngran_cell_activation:
      c.init(other.c.get<intersys_cell_activation_reply_s>());
      break;
    case types::res_status:
      c.init(other.c.get<intersys_res_status_reply_s>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<intersys_son_info_reply_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "intersys_son_info_reply_c");
  }
}
intersys_son_info_reply_c& intersys_son_info_reply_c::operator=(const intersys_son_info_reply_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::ngran_cell_activation:
      c.set(other.c.get<intersys_cell_activation_reply_s>());
      break;
    case types::res_status:
      c.set(other.c.get<intersys_res_status_reply_s>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<intersys_son_info_reply_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "intersys_son_info_reply_c");
  }

  return *this;
}
intersys_cell_activation_reply_s& intersys_son_info_reply_c::set_ngran_cell_activation()
{
  set(types::ngran_cell_activation);
  return c.get<intersys_cell_activation_reply_s>();
}
intersys_res_status_reply_s& intersys_son_info_reply_c::set_res_status()
{
  set(types::res_status);
  return c.get<intersys_res_status_reply_s>();
}
protocol_ie_single_container_s<intersys_son_info_reply_ext_ies_o>& intersys_son_info_reply_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<intersys_son_info_reply_ext_ies_o>>();
}
void intersys_son_info_reply_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::ngran_cell_activation:
      j.write_fieldname("nGRAN-CellActivation");
      c.get<intersys_cell_activation_reply_s>().to_json(j);
      break;
    case types::res_status:
      j.write_fieldname("resourceStatus");
      c.get<intersys_res_status_reply_s>().to_json(j);
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<intersys_son_info_reply_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "intersys_son_info_reply_c");
  }
  j.end_obj();
}
SRSASN_CODE intersys_son_info_reply_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::ngran_cell_activation:
      HANDLE_CODE(c.get<intersys_cell_activation_reply_s>().pack(bref));
      break;
    case types::res_status:
      HANDLE_CODE(c.get<intersys_res_status_reply_s>().pack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<intersys_son_info_reply_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "intersys_son_info_reply_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE intersys_son_info_reply_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::ngran_cell_activation:
      HANDLE_CODE(c.get<intersys_cell_activation_reply_s>().unpack(bref));
      break;
    case types::res_status:
      HANDLE_CODE(c.get<intersys_res_status_reply_s>().unpack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<intersys_son_info_reply_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "intersys_son_info_reply_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* intersys_son_info_reply_c::types_opts::to_string() const
{
  static const char* names[] = {"nGRAN-CellActivation", "resourceStatus", "choice-Extensions"};
  return convert_enum_idx(names, 3, value, "intersys_son_info_reply_c::types");
}

// IntersystemSONInformationReport-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t intersys_son_info_report_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {292, 293};
  return map_enum_number(names, 2, idx, "id");
}
bool intersys_son_info_report_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {292, 293};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e intersys_son_info_report_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 292:
      return crit_e::ignore;
    case 293:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
intersys_son_info_report_ext_ies_o::value_c intersys_son_info_report_ext_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 292:
      ret.set(value_c::types::energy_saving_ind);
      break;
    case 293:
      ret.set(value_c::types::intersys_res_status_upd);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e intersys_son_info_report_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 292:
      return presence_e::mandatory;
    case 293:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void intersys_son_info_report_ext_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::energy_saving_ind:
      c.destroy<intersys_cell_state_ind_s>();
      break;
    case types::intersys_res_status_upd:
      c.destroy<intersys_res_status_report_s>();
      break;
    default:
      break;
  }
}
void intersys_son_info_report_ext_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::energy_saving_ind:
      c.init<intersys_cell_state_ind_s>();
      break;
    case types::intersys_res_status_upd:
      c.init<intersys_res_status_report_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "intersys_son_info_report_ext_ies_o::value_c");
  }
}
intersys_son_info_report_ext_ies_o::value_c::value_c(const intersys_son_info_report_ext_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::energy_saving_ind:
      c.init(other.c.get<intersys_cell_state_ind_s>());
      break;
    case types::intersys_res_status_upd:
      c.init(other.c.get<intersys_res_status_report_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "intersys_son_info_report_ext_ies_o::value_c");
  }
}
intersys_son_info_report_ext_ies_o::value_c&
intersys_son_info_report_ext_ies_o::value_c::operator=(const intersys_son_info_report_ext_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::energy_saving_ind:
      c.set(other.c.get<intersys_cell_state_ind_s>());
      break;
    case types::intersys_res_status_upd:
      c.set(other.c.get<intersys_res_status_report_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "intersys_son_info_report_ext_ies_o::value_c");
  }

  return *this;
}
intersys_cell_state_ind_s& intersys_son_info_report_ext_ies_o::value_c::energy_saving_ind()
{
  assert_choice_type(types::energy_saving_ind, type_, "Value");
  return c.get<intersys_cell_state_ind_s>();
}
intersys_res_status_report_s& intersys_son_info_report_ext_ies_o::value_c::intersys_res_status_upd()
{
  assert_choice_type(types::intersys_res_status_upd, type_, "Value");
  return c.get<intersys_res_status_report_s>();
}
const intersys_cell_state_ind_s& intersys_son_info_report_ext_ies_o::value_c::energy_saving_ind() const
{
  assert_choice_type(types::energy_saving_ind, type_, "Value");
  return c.get<intersys_cell_state_ind_s>();
}
const intersys_res_status_report_s& intersys_son_info_report_ext_ies_o::value_c::intersys_res_status_upd() const
{
  assert_choice_type(types::intersys_res_status_upd, type_, "Value");
  return c.get<intersys_res_status_report_s>();
}
void intersys_son_info_report_ext_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::energy_saving_ind:
      j.write_fieldname("IntersystemCellStateIndication");
      c.get<intersys_cell_state_ind_s>().to_json(j);
      break;
    case types::intersys_res_status_upd:
      j.write_fieldname("IntersystemResourceStatusReport");
      c.get<intersys_res_status_report_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "intersys_son_info_report_ext_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE intersys_son_info_report_ext_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::energy_saving_ind:
      HANDLE_CODE(c.get<intersys_cell_state_ind_s>().pack(bref));
      break;
    case types::intersys_res_status_upd:
      HANDLE_CODE(c.get<intersys_res_status_report_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "intersys_son_info_report_ext_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE intersys_son_info_report_ext_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::energy_saving_ind:
      HANDLE_CODE(c.get<intersys_cell_state_ind_s>().unpack(bref));
      break;
    case types::intersys_res_status_upd:
      HANDLE_CODE(c.get<intersys_res_status_report_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "intersys_son_info_report_ext_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* intersys_son_info_report_ext_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"IntersystemCellStateIndication", "IntersystemResourceStatusReport"};
  return convert_enum_idx(names, 2, value, "intersys_son_info_report_ext_ies_o::value_c::types");
}

// IntersystemSONInformationRequest ::= CHOICE
void intersys_son_info_request_c::destroy_()
{
  switch (type_) {
    case types::ngran_cell_activation:
      c.destroy<intersys_cell_activation_request_s>();
      break;
    case types::res_status:
      c.destroy<intersys_res_status_request_s>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<intersys_son_info_request_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void intersys_son_info_request_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::ngran_cell_activation:
      c.init<intersys_cell_activation_request_s>();
      break;
    case types::res_status:
      c.init<intersys_res_status_request_s>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<intersys_son_info_request_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "intersys_son_info_request_c");
  }
}
intersys_son_info_request_c::intersys_son_info_request_c(const intersys_son_info_request_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::ngran_cell_activation:
      c.init(other.c.get<intersys_cell_activation_request_s>());
      break;
    case types::res_status:
      c.init(other.c.get<intersys_res_status_request_s>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<intersys_son_info_request_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "intersys_son_info_request_c");
  }
}
intersys_son_info_request_c& intersys_son_info_request_c::operator=(const intersys_son_info_request_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::ngran_cell_activation:
      c.set(other.c.get<intersys_cell_activation_request_s>());
      break;
    case types::res_status:
      c.set(other.c.get<intersys_res_status_request_s>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<intersys_son_info_request_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "intersys_son_info_request_c");
  }

  return *this;
}
intersys_cell_activation_request_s& intersys_son_info_request_c::set_ngran_cell_activation()
{
  set(types::ngran_cell_activation);
  return c.get<intersys_cell_activation_request_s>();
}
intersys_res_status_request_s& intersys_son_info_request_c::set_res_status()
{
  set(types::res_status);
  return c.get<intersys_res_status_request_s>();
}
protocol_ie_single_container_s<intersys_son_info_request_ext_ies_o>& intersys_son_info_request_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<intersys_son_info_request_ext_ies_o>>();
}
void intersys_son_info_request_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::ngran_cell_activation:
      j.write_fieldname("nGRAN-CellActivation");
      c.get<intersys_cell_activation_request_s>().to_json(j);
      break;
    case types::res_status:
      j.write_fieldname("resourceStatus");
      c.get<intersys_res_status_request_s>().to_json(j);
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<intersys_son_info_request_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "intersys_son_info_request_c");
  }
  j.end_obj();
}
SRSASN_CODE intersys_son_info_request_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::ngran_cell_activation:
      HANDLE_CODE(c.get<intersys_cell_activation_request_s>().pack(bref));
      break;
    case types::res_status:
      HANDLE_CODE(c.get<intersys_res_status_request_s>().pack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<intersys_son_info_request_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "intersys_son_info_request_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE intersys_son_info_request_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::ngran_cell_activation:
      HANDLE_CODE(c.get<intersys_cell_activation_request_s>().unpack(bref));
      break;
    case types::res_status:
      HANDLE_CODE(c.get<intersys_res_status_request_s>().unpack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<intersys_son_info_request_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "intersys_son_info_request_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* intersys_son_info_request_c::types_opts::to_string() const
{
  static const char* names[] = {"nGRAN-CellActivation", "resourceStatus", "choice-Extensions"};
  return convert_enum_idx(names, 3, value, "intersys_son_info_request_c::types");
}

// IntersystemSONNGRANnodeID ::= SEQUENCE
SRSASN_CODE intersys_son_ngran_node_id_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(global_ran_node_id.pack(bref));
  HANDLE_CODE(sel_tai.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE intersys_son_ngran_node_id_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(global_ran_node_id.unpack(bref));
  HANDLE_CODE(sel_tai.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void intersys_son_ngran_node_id_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("globalRANNodeID");
  global_ran_node_id.to_json(j);
  j.write_fieldname("selectedTAI");
  sel_tai.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// IntersystemSONeNBID ::= SEQUENCE
SRSASN_CODE intersys_son_enb_id_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(global_enb_id.pack(bref));
  HANDLE_CODE(sel_eps_tai.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE intersys_son_enb_id_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(global_enb_id.unpack(bref));
  HANDLE_CODE(sel_eps_tai.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void intersys_son_enb_id_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("globaleNBID");
  global_enb_id.to_json(j);
  j.write_fieldname("selectedEPSTAI");
  sel_eps_tai.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ie_single_container_s<son_info_report_ext_ies_o>;

// SONInformationReport ::= CHOICE
void son_info_report_c::destroy_()
{
  switch (type_) {
    case types::fail_ind_info:
      c.destroy<fail_ind_s>();
      break;
    case types::ho_report_info:
      c.destroy<ho_report_s>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<son_info_report_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void son_info_report_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::fail_ind_info:
      c.init<fail_ind_s>();
      break;
    case types::ho_report_info:
      c.init<ho_report_s>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<son_info_report_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "son_info_report_c");
  }
}
son_info_report_c::son_info_report_c(const son_info_report_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::fail_ind_info:
      c.init(other.c.get<fail_ind_s>());
      break;
    case types::ho_report_info:
      c.init(other.c.get<ho_report_s>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<son_info_report_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "son_info_report_c");
  }
}
son_info_report_c& son_info_report_c::operator=(const son_info_report_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::fail_ind_info:
      c.set(other.c.get<fail_ind_s>());
      break;
    case types::ho_report_info:
      c.set(other.c.get<ho_report_s>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<son_info_report_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "son_info_report_c");
  }

  return *this;
}
fail_ind_s& son_info_report_c::set_fail_ind_info()
{
  set(types::fail_ind_info);
  return c.get<fail_ind_s>();
}
ho_report_s& son_info_report_c::set_ho_report_info()
{
  set(types::ho_report_info);
  return c.get<ho_report_s>();
}
protocol_ie_single_container_s<son_info_report_ext_ies_o>& son_info_report_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<son_info_report_ext_ies_o>>();
}
void son_info_report_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::fail_ind_info:
      j.write_fieldname("failureIndicationInformation");
      c.get<fail_ind_s>().to_json(j);
      break;
    case types::ho_report_info:
      j.write_fieldname("hOReportInformation");
      c.get<ho_report_s>().to_json(j);
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<son_info_report_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "son_info_report_c");
  }
  j.end_obj();
}
SRSASN_CODE son_info_report_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::fail_ind_info:
      HANDLE_CODE(c.get<fail_ind_s>().pack(bref));
      break;
    case types::ho_report_info:
      HANDLE_CODE(c.get<ho_report_s>().pack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<son_info_report_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "son_info_report_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE son_info_report_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::fail_ind_info:
      HANDLE_CODE(c.get<fail_ind_s>().unpack(bref));
      break;
    case types::ho_report_info:
      HANDLE_CODE(c.get<ho_report_s>().unpack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<son_info_report_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "son_info_report_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* son_info_report_c::types_opts::to_string() const
{
  static const char* names[] = {"failureIndicationInformation", "hOReportInformation", "choice-Extensions"};
  return convert_enum_idx(names, 3, value, "son_info_report_c::types");
}

// XnTNLConfigurationInfo ::= SEQUENCE
SRSASN_CODE xn_tnl_cfg_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(xn_extended_transport_layer_addresses.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, xn_transport_layer_addresses, 1, 2, true));
  if (xn_extended_transport_layer_addresses.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, xn_extended_transport_layer_addresses, 1, 16, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE xn_tnl_cfg_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool xn_extended_transport_layer_addresses_present;
  HANDLE_CODE(bref.unpack(xn_extended_transport_layer_addresses_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(xn_transport_layer_addresses, bref, 1, 2, true));
  if (xn_extended_transport_layer_addresses_present) {
    HANDLE_CODE(unpack_dyn_seq_of(xn_extended_transport_layer_addresses, bref, 1, 16, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void xn_tnl_cfg_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("xnTransportLayerAddresses");
  for (const auto& e1 : xn_transport_layer_addresses) {
    j.write_str(e1.to_string());
  }
  j.end_array();
  if (xn_extended_transport_layer_addresses.size() > 0) {
    j.start_array("xnExtendedTransportLayerAddresses");
    for (const auto& e1 : xn_extended_transport_layer_addresses) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// FromEUTRANtoNGRAN ::= SEQUENCE
SRSASN_CODE from_eutran_to_ngran_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(source_enb_id.pack(bref));
  HANDLE_CODE(target_ngran_node_id.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE from_eutran_to_ngran_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(source_enb_id.unpack(bref));
  HANDLE_CODE(target_ngran_node_id.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void from_eutran_to_ngran_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("sourceeNBID");
  source_enb_id.to_json(j);
  j.write_fieldname("targetNGRANnodeID");
  target_ngran_node_id.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// FromNGRANtoEUTRAN ::= SEQUENCE
SRSASN_CODE from_ngran_to_eutran_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(source_ngran_node_id.pack(bref));
  HANDLE_CODE(target_enb_id.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE from_ngran_to_eutran_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(source_ngran_node_id.unpack(bref));
  HANDLE_CODE(target_enb_id.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void from_ngran_to_eutran_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("sourceNGRANnodeID");
  source_ngran_node_id.to_json(j);
  j.write_fieldname("targeteNBID");
  target_enb_id.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// IntersystemSONInformation-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t intersys_son_info_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {290, 291};
  return map_enum_number(names, 2, idx, "id");
}
bool intersys_son_info_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {290, 291};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e intersys_son_info_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 290:
      return crit_e::ignore;
    case 291:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
intersys_son_info_ext_ies_o::value_c intersys_son_info_ext_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 290:
      ret.set(value_c::types::intersys_son_info_request);
      break;
    case 291:
      ret.set(value_c::types::intersys_son_info_reply);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e intersys_son_info_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 290:
      return presence_e::mandatory;
    case 291:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void intersys_son_info_ext_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::intersys_son_info_request:
      c.destroy<intersys_son_info_request_c>();
      break;
    case types::intersys_son_info_reply:
      c.destroy<intersys_son_info_reply_c>();
      break;
    default:
      break;
  }
}
void intersys_son_info_ext_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::intersys_son_info_request:
      c.init<intersys_son_info_request_c>();
      break;
    case types::intersys_son_info_reply:
      c.init<intersys_son_info_reply_c>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "intersys_son_info_ext_ies_o::value_c");
  }
}
intersys_son_info_ext_ies_o::value_c::value_c(const intersys_son_info_ext_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::intersys_son_info_request:
      c.init(other.c.get<intersys_son_info_request_c>());
      break;
    case types::intersys_son_info_reply:
      c.init(other.c.get<intersys_son_info_reply_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "intersys_son_info_ext_ies_o::value_c");
  }
}
intersys_son_info_ext_ies_o::value_c&
intersys_son_info_ext_ies_o::value_c::operator=(const intersys_son_info_ext_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::intersys_son_info_request:
      c.set(other.c.get<intersys_son_info_request_c>());
      break;
    case types::intersys_son_info_reply:
      c.set(other.c.get<intersys_son_info_reply_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "intersys_son_info_ext_ies_o::value_c");
  }

  return *this;
}
intersys_son_info_request_c& intersys_son_info_ext_ies_o::value_c::intersys_son_info_request()
{
  assert_choice_type(types::intersys_son_info_request, type_, "Value");
  return c.get<intersys_son_info_request_c>();
}
intersys_son_info_reply_c& intersys_son_info_ext_ies_o::value_c::intersys_son_info_reply()
{
  assert_choice_type(types::intersys_son_info_reply, type_, "Value");
  return c.get<intersys_son_info_reply_c>();
}
const intersys_son_info_request_c& intersys_son_info_ext_ies_o::value_c::intersys_son_info_request() const
{
  assert_choice_type(types::intersys_son_info_request, type_, "Value");
  return c.get<intersys_son_info_request_c>();
}
const intersys_son_info_reply_c& intersys_son_info_ext_ies_o::value_c::intersys_son_info_reply() const
{
  assert_choice_type(types::intersys_son_info_reply, type_, "Value");
  return c.get<intersys_son_info_reply_c>();
}
void intersys_son_info_ext_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::intersys_son_info_request:
      j.write_fieldname("IntersystemSONInformationRequest");
      c.get<intersys_son_info_request_c>().to_json(j);
      break;
    case types::intersys_son_info_reply:
      j.write_fieldname("IntersystemSONInformationReply");
      c.get<intersys_son_info_reply_c>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "intersys_son_info_ext_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE intersys_son_info_ext_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::intersys_son_info_request:
      HANDLE_CODE(c.get<intersys_son_info_request_c>().pack(bref));
      break;
    case types::intersys_son_info_reply:
      HANDLE_CODE(c.get<intersys_son_info_reply_c>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "intersys_son_info_ext_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE intersys_son_info_ext_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::intersys_son_info_request:
      HANDLE_CODE(c.get<intersys_son_info_request_c>().unpack(bref));
      break;
    case types::intersys_son_info_reply:
      HANDLE_CODE(c.get<intersys_son_info_reply_c>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "intersys_son_info_ext_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* intersys_son_info_ext_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"IntersystemSONInformationRequest", "IntersystemSONInformationReply"};
  return convert_enum_idx(names, 2, value, "intersys_son_info_ext_ies_o::value_c::types");
}

template struct asn1::protocol_ie_single_container_s<intersys_son_info_report_ext_ies_o>;

// IntersystemSONInformationReport ::= CHOICE
void intersys_son_info_report_c::destroy_()
{
  switch (type_) {
    case types::ho_report_info:
      c.destroy<inter_sys_ho_report_s>();
      break;
    case types::fail_ind_info:
      c.destroy<inter_sys_fail_ind_s>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<intersys_son_info_report_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void intersys_son_info_report_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::ho_report_info:
      c.init<inter_sys_ho_report_s>();
      break;
    case types::fail_ind_info:
      c.init<inter_sys_fail_ind_s>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<intersys_son_info_report_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "intersys_son_info_report_c");
  }
}
intersys_son_info_report_c::intersys_son_info_report_c(const intersys_son_info_report_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::ho_report_info:
      c.init(other.c.get<inter_sys_ho_report_s>());
      break;
    case types::fail_ind_info:
      c.init(other.c.get<inter_sys_fail_ind_s>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<intersys_son_info_report_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "intersys_son_info_report_c");
  }
}
intersys_son_info_report_c& intersys_son_info_report_c::operator=(const intersys_son_info_report_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::ho_report_info:
      c.set(other.c.get<inter_sys_ho_report_s>());
      break;
    case types::fail_ind_info:
      c.set(other.c.get<inter_sys_fail_ind_s>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<intersys_son_info_report_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "intersys_son_info_report_c");
  }

  return *this;
}
inter_sys_ho_report_s& intersys_son_info_report_c::set_ho_report_info()
{
  set(types::ho_report_info);
  return c.get<inter_sys_ho_report_s>();
}
inter_sys_fail_ind_s& intersys_son_info_report_c::set_fail_ind_info()
{
  set(types::fail_ind_info);
  return c.get<inter_sys_fail_ind_s>();
}
protocol_ie_single_container_s<intersys_son_info_report_ext_ies_o>& intersys_son_info_report_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<intersys_son_info_report_ext_ies_o>>();
}
void intersys_son_info_report_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::ho_report_info:
      j.write_fieldname("hOReportInformation");
      c.get<inter_sys_ho_report_s>().to_json(j);
      break;
    case types::fail_ind_info:
      j.write_fieldname("failureIndicationInformation");
      c.get<inter_sys_fail_ind_s>().to_json(j);
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<intersys_son_info_report_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "intersys_son_info_report_c");
  }
  j.end_obj();
}
SRSASN_CODE intersys_son_info_report_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::ho_report_info:
      HANDLE_CODE(c.get<inter_sys_ho_report_s>().pack(bref));
      break;
    case types::fail_ind_info:
      HANDLE_CODE(c.get<inter_sys_fail_ind_s>().pack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<intersys_son_info_report_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "intersys_son_info_report_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE intersys_son_info_report_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::ho_report_info:
      HANDLE_CODE(c.get<inter_sys_ho_report_s>().unpack(bref));
      break;
    case types::fail_ind_info:
      HANDLE_CODE(c.get<inter_sys_fail_ind_s>().unpack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<intersys_son_info_report_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "intersys_son_info_report_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* intersys_son_info_report_c::types_opts::to_string() const
{
  static const char* names[] = {"hOReportInformation", "failureIndicationInformation", "choice-Extensions"};
  return convert_enum_idx(names, 3, value, "intersys_son_info_report_c::types");
}

// SONInformation-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t son_info_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {252};
  return map_enum_number(names, 1, idx, "id");
}
bool son_info_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 252 == id;
}
crit_e son_info_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 252) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
son_info_ext_ies_o::value_c son_info_ext_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  if (id != 252) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e son_info_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 252) {
    return presence_e::mandatory;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Value ::= OPEN TYPE
void son_info_ext_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("SONInformationReport");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE son_info_ext_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE son_info_ext_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* son_info_ext_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"SONInformationReport"};
  return convert_enum_idx(names, 1, value, "son_info_ext_ies_o::value_c::types");
}

// SONInformationReply ::= SEQUENCE
SRSASN_CODE son_info_reply_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(xn_tnl_cfg_info_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (xn_tnl_cfg_info_present) {
    HANDLE_CODE(xn_tnl_cfg_info.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE son_info_reply_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(xn_tnl_cfg_info_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (xn_tnl_cfg_info_present) {
    HANDLE_CODE(xn_tnl_cfg_info.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void son_info_reply_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (xn_tnl_cfg_info_present) {
    j.write_fieldname("xnTNLConfigurationInfo");
    xn_tnl_cfg_info.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SONInformationRequest ::= ENUMERATED
const char* son_info_request_opts::to_string() const
{
  static const char* names[] = {"xn-TNL-configuration-info"};
  return convert_enum_idx(names, 1, value, "son_info_request_e");
}

// TargetRANNodeID-SON-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t target_ran_node_id_son_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {45};
  return map_enum_number(names, 1, idx, "id");
}
bool target_ran_node_id_son_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 45 == id;
}
crit_e target_ran_node_id_son_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 45) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
target_ran_node_id_son_ext_ies_o::ext_c target_ran_node_id_son_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 45) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e target_ran_node_id_son_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 45) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void target_ran_node_id_son_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("NR-CGI");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE target_ran_node_id_son_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE target_ran_node_id_son_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* target_ran_node_id_son_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"NR-CGI"};
  return convert_enum_idx(names, 1, value, "target_ran_node_id_son_ext_ies_o::ext_c::types");
}

template struct asn1::protocol_ie_single_container_s<intersys_son_info_ext_ies_o>;

// IntersystemSONInformation ::= CHOICE
void intersys_son_info_c::destroy_()
{
  switch (type_) {
    case types::intersys_son_info_report:
      c.destroy<intersys_son_info_report_c>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<intersys_son_info_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void intersys_son_info_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::intersys_son_info_report:
      c.init<intersys_son_info_report_c>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<intersys_son_info_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "intersys_son_info_c");
  }
}
intersys_son_info_c::intersys_son_info_c(const intersys_son_info_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::intersys_son_info_report:
      c.init(other.c.get<intersys_son_info_report_c>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<intersys_son_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "intersys_son_info_c");
  }
}
intersys_son_info_c& intersys_son_info_c::operator=(const intersys_son_info_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::intersys_son_info_report:
      c.set(other.c.get<intersys_son_info_report_c>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<intersys_son_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "intersys_son_info_c");
  }

  return *this;
}
intersys_son_info_report_c& intersys_son_info_c::set_intersys_son_info_report()
{
  set(types::intersys_son_info_report);
  return c.get<intersys_son_info_report_c>();
}
protocol_ie_single_container_s<intersys_son_info_ext_ies_o>& intersys_son_info_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<intersys_son_info_ext_ies_o>>();
}
void intersys_son_info_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::intersys_son_info_report:
      j.write_fieldname("intersystemSONInformationReport");
      c.get<intersys_son_info_report_c>().to_json(j);
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<intersys_son_info_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "intersys_son_info_c");
  }
  j.end_obj();
}
SRSASN_CODE intersys_son_info_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::intersys_son_info_report:
      HANDLE_CODE(c.get<intersys_son_info_report_c>().pack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<intersys_son_info_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "intersys_son_info_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE intersys_son_info_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::intersys_son_info_report:
      HANDLE_CODE(c.get<intersys_son_info_report_c>().unpack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<intersys_son_info_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "intersys_son_info_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* intersys_son_info_c::types_opts::to_string() const
{
  static const char* names[] = {"intersystemSONInformationReport", "choice-Extensions"};
  return convert_enum_idx(names, 2, value, "intersys_son_info_c::types");
}

// IntersystemSONTransferType ::= CHOICE
void intersys_son_transfer_type_c::destroy_()
{
  switch (type_) {
    case types::from_eutran_to_ngran:
      c.destroy<from_eutran_to_ngran_s>();
      break;
    case types::from_ngran_to_eutran:
      c.destroy<from_ngran_to_eutran_s>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<intersys_son_transfer_type_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void intersys_son_transfer_type_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::from_eutran_to_ngran:
      c.init<from_eutran_to_ngran_s>();
      break;
    case types::from_ngran_to_eutran:
      c.init<from_ngran_to_eutran_s>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<intersys_son_transfer_type_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "intersys_son_transfer_type_c");
  }
}
intersys_son_transfer_type_c::intersys_son_transfer_type_c(const intersys_son_transfer_type_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::from_eutran_to_ngran:
      c.init(other.c.get<from_eutran_to_ngran_s>());
      break;
    case types::from_ngran_to_eutran:
      c.init(other.c.get<from_ngran_to_eutran_s>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<intersys_son_transfer_type_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "intersys_son_transfer_type_c");
  }
}
intersys_son_transfer_type_c& intersys_son_transfer_type_c::operator=(const intersys_son_transfer_type_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::from_eutran_to_ngran:
      c.set(other.c.get<from_eutran_to_ngran_s>());
      break;
    case types::from_ngran_to_eutran:
      c.set(other.c.get<from_ngran_to_eutran_s>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<intersys_son_transfer_type_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "intersys_son_transfer_type_c");
  }

  return *this;
}
from_eutran_to_ngran_s& intersys_son_transfer_type_c::set_from_eutran_to_ngran()
{
  set(types::from_eutran_to_ngran);
  return c.get<from_eutran_to_ngran_s>();
}
from_ngran_to_eutran_s& intersys_son_transfer_type_c::set_from_ngran_to_eutran()
{
  set(types::from_ngran_to_eutran);
  return c.get<from_ngran_to_eutran_s>();
}
protocol_ie_single_container_s<intersys_son_transfer_type_ext_ies_o>& intersys_son_transfer_type_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<intersys_son_transfer_type_ext_ies_o>>();
}
void intersys_son_transfer_type_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::from_eutran_to_ngran:
      j.write_fieldname("fromEUTRANtoNGRAN");
      c.get<from_eutran_to_ngran_s>().to_json(j);
      break;
    case types::from_ngran_to_eutran:
      j.write_fieldname("fromNGRANtoEUTRAN");
      c.get<from_ngran_to_eutran_s>().to_json(j);
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<intersys_son_transfer_type_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "intersys_son_transfer_type_c");
  }
  j.end_obj();
}
SRSASN_CODE intersys_son_transfer_type_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::from_eutran_to_ngran:
      HANDLE_CODE(c.get<from_eutran_to_ngran_s>().pack(bref));
      break;
    case types::from_ngran_to_eutran:
      HANDLE_CODE(c.get<from_ngran_to_eutran_s>().pack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<intersys_son_transfer_type_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "intersys_son_transfer_type_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE intersys_son_transfer_type_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::from_eutran_to_ngran:
      HANDLE_CODE(c.get<from_eutran_to_ngran_s>().unpack(bref));
      break;
    case types::from_ngran_to_eutran:
      HANDLE_CODE(c.get<from_ngran_to_eutran_s>().unpack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<intersys_son_transfer_type_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "intersys_son_transfer_type_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* intersys_son_transfer_type_c::types_opts::to_string() const
{
  static const char* names[] = {"fromEUTRANtoNGRAN", "fromNGRANtoEUTRAN", "choice-Extensions"};
  return convert_enum_idx(names, 3, value, "intersys_son_transfer_type_c::types");
}

template struct asn1::protocol_ie_single_container_s<son_info_ext_ies_o>;

// SONInformation ::= CHOICE
void son_info_c::destroy_()
{
  switch (type_) {
    case types::son_info_reply:
      c.destroy<son_info_reply_s>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<son_info_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void son_info_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::son_info_request:
      break;
    case types::son_info_reply:
      c.init<son_info_reply_s>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<son_info_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "son_info_c");
  }
}
son_info_c::son_info_c(const son_info_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::son_info_request:
      c.init(other.c.get<son_info_request_e>());
      break;
    case types::son_info_reply:
      c.init(other.c.get<son_info_reply_s>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<son_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "son_info_c");
  }
}
son_info_c& son_info_c::operator=(const son_info_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::son_info_request:
      c.set(other.c.get<son_info_request_e>());
      break;
    case types::son_info_reply:
      c.set(other.c.get<son_info_reply_s>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<son_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "son_info_c");
  }

  return *this;
}
son_info_request_e& son_info_c::set_son_info_request()
{
  set(types::son_info_request);
  return c.get<son_info_request_e>();
}
son_info_reply_s& son_info_c::set_son_info_reply()
{
  set(types::son_info_reply);
  return c.get<son_info_reply_s>();
}
protocol_ie_single_container_s<son_info_ext_ies_o>& son_info_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<son_info_ext_ies_o>>();
}
void son_info_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::son_info_request:
      j.write_str("sONInformationRequest", "xn-TNL-configuration-info");
      break;
    case types::son_info_reply:
      j.write_fieldname("sONInformationReply");
      c.get<son_info_reply_s>().to_json(j);
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<son_info_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "son_info_c");
  }
  j.end_obj();
}
SRSASN_CODE son_info_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::son_info_request:
      HANDLE_CODE(c.get<son_info_request_e>().pack(bref));
      break;
    case types::son_info_reply:
      HANDLE_CODE(c.get<son_info_reply_s>().pack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<son_info_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "son_info_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE son_info_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::son_info_request:
      HANDLE_CODE(c.get<son_info_request_e>().unpack(bref));
      break;
    case types::son_info_reply:
      HANDLE_CODE(c.get<son_info_reply_s>().unpack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<son_info_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "son_info_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* son_info_c::types_opts::to_string() const
{
  static const char* names[] = {"sONInformationRequest", "sONInformationReply", "choice-Extensions"};
  return convert_enum_idx(names, 3, value, "son_info_c::types");
}

// SourceRANNodeID ::= SEQUENCE
SRSASN_CODE source_ran_node_id_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(global_ran_node_id.pack(bref));
  HANDLE_CODE(sel_tai.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE source_ran_node_id_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(global_ran_node_id.unpack(bref));
  HANDLE_CODE(sel_tai.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void source_ran_node_id_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("globalRANNodeID");
  global_ran_node_id.to_json(j);
  j.write_fieldname("selectedTAI");
  sel_tai.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TargetRANNodeID-SON ::= SEQUENCE
SRSASN_CODE target_ran_node_id_son_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(global_ran_node_id.pack(bref));
  HANDLE_CODE(sel_tai.pack(bref));
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE target_ran_node_id_son_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(global_ran_node_id.unpack(bref));
  HANDLE_CODE(sel_tai.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void target_ran_node_id_son_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("globalRANNodeID");
  global_ran_node_id.to_json(j);
  j.write_fieldname("selectedTAI");
  sel_tai.to_json(j);
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// IntersystemSONConfigurationTransfer ::= SEQUENCE
SRSASN_CODE intersys_son_cfg_transfer_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(transfer_type.pack(bref));
  HANDLE_CODE(intersys_son_info.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE intersys_son_cfg_transfer_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(transfer_type.unpack(bref));
  HANDLE_CODE(intersys_son_info.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void intersys_son_cfg_transfer_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("transferType");
  transfer_type.to_json(j);
  j.write_fieldname("intersystemSONInformation");
  intersys_son_info.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SONConfigurationTransfer ::= SEQUENCE
SRSASN_CODE son_cfg_transfer_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(xn_tnl_cfg_info_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(target_ran_node_id_son.pack(bref));
  HANDLE_CODE(source_ran_node_id.pack(bref));
  HANDLE_CODE(son_info.pack(bref));
  if (xn_tnl_cfg_info_present) {
    HANDLE_CODE(xn_tnl_cfg_info.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE son_cfg_transfer_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(xn_tnl_cfg_info_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(target_ran_node_id_son.unpack(bref));
  HANDLE_CODE(source_ran_node_id.unpack(bref));
  HANDLE_CODE(son_info.unpack(bref));
  if (xn_tnl_cfg_info_present) {
    HANDLE_CODE(xn_tnl_cfg_info.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void son_cfg_transfer_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("targetRANNodeID-SON");
  target_ran_node_id_son.to_json(j);
  j.write_fieldname("sourceRANNodeID");
  source_ran_node_id.to_json(j);
  j.write_fieldname("sONInformation");
  son_info.to_json(j);
  if (xn_tnl_cfg_info_present) {
    j.write_fieldname("xnTNLConfigurationInfo");
    xn_tnl_cfg_info.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// DownlinkRANConfigurationTransferIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t dl_ran_cfg_transfer_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {98, 157, 250};
  return map_enum_number(names, 3, idx, "id");
}
bool dl_ran_cfg_transfer_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {98, 157, 250};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e dl_ran_cfg_transfer_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 98:
      return crit_e::ignore;
    case 157:
      return crit_e::ignore;
    case 250:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
dl_ran_cfg_transfer_ies_o::value_c dl_ran_cfg_transfer_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 98:
      ret.set(value_c::types::son_cfg_transfer_dl);
      break;
    case 157:
      ret.set(value_c::types::endc_son_cfg_transfer_dl);
      break;
    case 250:
      ret.set(value_c::types::intersys_son_cfg_transfer_dl);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e dl_ran_cfg_transfer_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 98:
      return presence_e::optional;
    case 157:
      return presence_e::optional;
    case 250:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void dl_ran_cfg_transfer_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::son_cfg_transfer_dl:
      c.destroy<son_cfg_transfer_s>();
      break;
    case types::endc_son_cfg_transfer_dl:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::intersys_son_cfg_transfer_dl:
      c.destroy<intersys_son_cfg_transfer_s>();
      break;
    default:
      break;
  }
}
void dl_ran_cfg_transfer_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::son_cfg_transfer_dl:
      c.init<son_cfg_transfer_s>();
      break;
    case types::endc_son_cfg_transfer_dl:
      c.init<unbounded_octstring<true>>();
      break;
    case types::intersys_son_cfg_transfer_dl:
      c.init<intersys_son_cfg_transfer_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "dl_ran_cfg_transfer_ies_o::value_c");
  }
}
dl_ran_cfg_transfer_ies_o::value_c::value_c(const dl_ran_cfg_transfer_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::son_cfg_transfer_dl:
      c.init(other.c.get<son_cfg_transfer_s>());
      break;
    case types::endc_son_cfg_transfer_dl:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::intersys_son_cfg_transfer_dl:
      c.init(other.c.get<intersys_son_cfg_transfer_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "dl_ran_cfg_transfer_ies_o::value_c");
  }
}
dl_ran_cfg_transfer_ies_o::value_c&
dl_ran_cfg_transfer_ies_o::value_c::operator=(const dl_ran_cfg_transfer_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::son_cfg_transfer_dl:
      c.set(other.c.get<son_cfg_transfer_s>());
      break;
    case types::endc_son_cfg_transfer_dl:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::intersys_son_cfg_transfer_dl:
      c.set(other.c.get<intersys_son_cfg_transfer_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "dl_ran_cfg_transfer_ies_o::value_c");
  }

  return *this;
}
son_cfg_transfer_s& dl_ran_cfg_transfer_ies_o::value_c::son_cfg_transfer_dl()
{
  assert_choice_type(types::son_cfg_transfer_dl, type_, "Value");
  return c.get<son_cfg_transfer_s>();
}
unbounded_octstring<true>& dl_ran_cfg_transfer_ies_o::value_c::endc_son_cfg_transfer_dl()
{
  assert_choice_type(types::endc_son_cfg_transfer_dl, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
intersys_son_cfg_transfer_s& dl_ran_cfg_transfer_ies_o::value_c::intersys_son_cfg_transfer_dl()
{
  assert_choice_type(types::intersys_son_cfg_transfer_dl, type_, "Value");
  return c.get<intersys_son_cfg_transfer_s>();
}
const son_cfg_transfer_s& dl_ran_cfg_transfer_ies_o::value_c::son_cfg_transfer_dl() const
{
  assert_choice_type(types::son_cfg_transfer_dl, type_, "Value");
  return c.get<son_cfg_transfer_s>();
}
const unbounded_octstring<true>& dl_ran_cfg_transfer_ies_o::value_c::endc_son_cfg_transfer_dl() const
{
  assert_choice_type(types::endc_son_cfg_transfer_dl, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const intersys_son_cfg_transfer_s& dl_ran_cfg_transfer_ies_o::value_c::intersys_son_cfg_transfer_dl() const
{
  assert_choice_type(types::intersys_son_cfg_transfer_dl, type_, "Value");
  return c.get<intersys_son_cfg_transfer_s>();
}
void dl_ran_cfg_transfer_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::son_cfg_transfer_dl:
      j.write_fieldname("SONConfigurationTransfer");
      c.get<son_cfg_transfer_s>().to_json(j);
      break;
    case types::endc_son_cfg_transfer_dl:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::intersys_son_cfg_transfer_dl:
      j.write_fieldname("IntersystemSONConfigurationTransfer");
      c.get<intersys_son_cfg_transfer_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "dl_ran_cfg_transfer_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE dl_ran_cfg_transfer_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::son_cfg_transfer_dl:
      HANDLE_CODE(c.get<son_cfg_transfer_s>().pack(bref));
      break;
    case types::endc_son_cfg_transfer_dl:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::intersys_son_cfg_transfer_dl:
      HANDLE_CODE(c.get<intersys_son_cfg_transfer_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "dl_ran_cfg_transfer_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE dl_ran_cfg_transfer_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::son_cfg_transfer_dl:
      HANDLE_CODE(c.get<son_cfg_transfer_s>().unpack(bref));
      break;
    case types::endc_son_cfg_transfer_dl:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::intersys_son_cfg_transfer_dl:
      HANDLE_CODE(c.get<intersys_son_cfg_transfer_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "dl_ran_cfg_transfer_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* dl_ran_cfg_transfer_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"SONConfigurationTransfer", "OCTET STRING", "IntersystemSONConfigurationTransfer"};
  return convert_enum_idx(names, 3, value, "dl_ran_cfg_transfer_ies_o::value_c::types");
}

template struct asn1::protocol_ie_field_s<dl_ran_cfg_transfer_ies_o>;

dl_ran_cfg_transfer_ies_container::dl_ran_cfg_transfer_ies_container() :
  son_cfg_transfer_dl(98, crit_e::ignore),
  endc_son_cfg_transfer_dl(157, crit_e::ignore),
  intersys_son_cfg_transfer_dl(250, crit_e::ignore)
{
}
SRSASN_CODE dl_ran_cfg_transfer_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += son_cfg_transfer_dl_present ? 1 : 0;
  nof_ies += endc_son_cfg_transfer_dl_present ? 1 : 0;
  nof_ies += intersys_son_cfg_transfer_dl_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  if (son_cfg_transfer_dl_present) {
    HANDLE_CODE(son_cfg_transfer_dl.pack(bref));
  }
  if (endc_son_cfg_transfer_dl_present) {
    HANDLE_CODE(endc_son_cfg_transfer_dl.pack(bref));
  }
  if (intersys_son_cfg_transfer_dl_present) {
    HANDLE_CODE(intersys_son_cfg_transfer_dl.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE dl_ran_cfg_transfer_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 98: {
        son_cfg_transfer_dl_present = true;
        son_cfg_transfer_dl.id      = id;
        HANDLE_CODE(son_cfg_transfer_dl.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(son_cfg_transfer_dl.value.unpack(bref));
        break;
      }
      case 157: {
        endc_son_cfg_transfer_dl_present = true;
        endc_son_cfg_transfer_dl.id      = id;
        HANDLE_CODE(endc_son_cfg_transfer_dl.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(endc_son_cfg_transfer_dl.value.unpack(bref));
        break;
      }
      case 250: {
        intersys_son_cfg_transfer_dl_present = true;
        intersys_son_cfg_transfer_dl.id      = id;
        HANDLE_CODE(intersys_son_cfg_transfer_dl.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(intersys_son_cfg_transfer_dl.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void dl_ran_cfg_transfer_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (son_cfg_transfer_dl_present) {
    j.write_fieldname("");
    son_cfg_transfer_dl.to_json(j);
  }
  if (endc_son_cfg_transfer_dl_present) {
    j.write_fieldname("");
    endc_son_cfg_transfer_dl.to_json(j);
  }
  if (intersys_son_cfg_transfer_dl_present) {
    j.write_fieldname("");
    intersys_son_cfg_transfer_dl.to_json(j);
  }
  j.end_obj();
}

// FirstDLCount ::= SEQUENCE
SRSASN_CODE first_dl_count_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, drbs_subject_to_early_status_transfer, 1, 32, true));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE first_dl_count_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(drbs_subject_to_early_status_transfer, bref, 1, 32, true));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void first_dl_count_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("dRBsSubjectToEarlyStatusTransfer");
  for (const auto& e1 : drbs_subject_to_early_status_transfer) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// ProcedureStageChoice ::= CHOICE
void proc_stage_choice_c::destroy_()
{
  switch (type_) {
    case types::first_dl_count:
      c.destroy<first_dl_count_s>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<proc_stage_choice_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void proc_stage_choice_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::first_dl_count:
      c.init<first_dl_count_s>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<proc_stage_choice_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "proc_stage_choice_c");
  }
}
proc_stage_choice_c::proc_stage_choice_c(const proc_stage_choice_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::first_dl_count:
      c.init(other.c.get<first_dl_count_s>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<proc_stage_choice_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "proc_stage_choice_c");
  }
}
proc_stage_choice_c& proc_stage_choice_c::operator=(const proc_stage_choice_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::first_dl_count:
      c.set(other.c.get<first_dl_count_s>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<proc_stage_choice_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "proc_stage_choice_c");
  }

  return *this;
}
first_dl_count_s& proc_stage_choice_c::set_first_dl_count()
{
  set(types::first_dl_count);
  return c.get<first_dl_count_s>();
}
protocol_ie_single_container_s<proc_stage_choice_ext_ies_o>& proc_stage_choice_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<proc_stage_choice_ext_ies_o>>();
}
void proc_stage_choice_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::first_dl_count:
      j.write_fieldname("first-dl-count");
      c.get<first_dl_count_s>().to_json(j);
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<proc_stage_choice_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "proc_stage_choice_c");
  }
  j.end_obj();
}
SRSASN_CODE proc_stage_choice_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::first_dl_count:
      HANDLE_CODE(c.get<first_dl_count_s>().pack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<proc_stage_choice_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "proc_stage_choice_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE proc_stage_choice_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::first_dl_count:
      HANDLE_CODE(c.get<first_dl_count_s>().unpack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<proc_stage_choice_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "proc_stage_choice_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* proc_stage_choice_c::types_opts::to_string() const
{
  static const char* names[] = {"first-dl-count", "choice-Extensions"};
  return convert_enum_idx(names, 2, value, "proc_stage_choice_c::types");
}

// EarlyStatusTransfer-TransparentContainer ::= SEQUENCE
SRSASN_CODE early_status_transfer_transparent_container_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(proc_stage.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE early_status_transfer_transparent_container_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(proc_stage.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void early_status_transfer_transparent_container_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("procedureStage");
  proc_stage.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// DownlinkRANEarlyStatusTransferIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t dl_ran_early_status_transfer_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 268};
  return map_enum_number(names, 3, idx, "id");
}
bool dl_ran_early_status_transfer_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 268};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e dl_ran_early_status_transfer_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 268:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
dl_ran_early_status_transfer_ies_o::value_c dl_ran_early_status_transfer_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 268:
      ret.set(value_c::types::early_status_transfer_transparent_container);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e dl_ran_early_status_transfer_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 268:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void dl_ran_early_status_transfer_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::early_status_transfer_transparent_container:
      c.destroy<early_status_transfer_transparent_container_s>();
      break;
    default:
      break;
  }
}
void dl_ran_early_status_transfer_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::early_status_transfer_transparent_container:
      c.init<early_status_transfer_transparent_container_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "dl_ran_early_status_transfer_ies_o::value_c");
  }
}
dl_ran_early_status_transfer_ies_o::value_c::value_c(const dl_ran_early_status_transfer_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::early_status_transfer_transparent_container:
      c.init(other.c.get<early_status_transfer_transparent_container_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "dl_ran_early_status_transfer_ies_o::value_c");
  }
}
dl_ran_early_status_transfer_ies_o::value_c&
dl_ran_early_status_transfer_ies_o::value_c::operator=(const dl_ran_early_status_transfer_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::early_status_transfer_transparent_container:
      c.set(other.c.get<early_status_transfer_transparent_container_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "dl_ran_early_status_transfer_ies_o::value_c");
  }

  return *this;
}
uint64_t& dl_ran_early_status_transfer_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& dl_ran_early_status_transfer_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
early_status_transfer_transparent_container_s&
dl_ran_early_status_transfer_ies_o::value_c::early_status_transfer_transparent_container()
{
  assert_choice_type(types::early_status_transfer_transparent_container, type_, "Value");
  return c.get<early_status_transfer_transparent_container_s>();
}
const uint64_t& dl_ran_early_status_transfer_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& dl_ran_early_status_transfer_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const early_status_transfer_transparent_container_s&
dl_ran_early_status_transfer_ies_o::value_c::early_status_transfer_transparent_container() const
{
  assert_choice_type(types::early_status_transfer_transparent_container, type_, "Value");
  return c.get<early_status_transfer_transparent_container_s>();
}
void dl_ran_early_status_transfer_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::early_status_transfer_transparent_container:
      j.write_fieldname("EarlyStatusTransfer-TransparentContainer");
      c.get<early_status_transfer_transparent_container_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "dl_ran_early_status_transfer_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE dl_ran_early_status_transfer_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::early_status_transfer_transparent_container:
      HANDLE_CODE(c.get<early_status_transfer_transparent_container_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "dl_ran_early_status_transfer_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE dl_ran_early_status_transfer_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::early_status_transfer_transparent_container:
      HANDLE_CODE(c.get<early_status_transfer_transparent_container_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "dl_ran_early_status_transfer_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* dl_ran_early_status_transfer_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {
      "INTEGER (0..1099511627775)", "INTEGER (0..4294967295)", "EarlyStatusTransfer-TransparentContainer"};
  return convert_enum_idx(names, 3, value, "dl_ran_early_status_transfer_ies_o::value_c::types");
}

template struct asn1::protocol_ie_field_s<dl_ran_early_status_transfer_ies_o>;

dl_ran_early_status_transfer_ies_container::dl_ran_early_status_transfer_ies_container() :
  amf_ue_ngap_id(10, crit_e::reject),
  ran_ue_ngap_id(85, crit_e::reject),
  early_status_transfer_transparent_container(268, crit_e::reject)
{
}
SRSASN_CODE dl_ran_early_status_transfer_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  HANDLE_CODE(early_status_transfer_transparent_container.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE dl_ran_early_status_transfer_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 268: {
        nof_mandatory_ies--;
        early_status_transfer_transparent_container.id = id;
        HANDLE_CODE(early_status_transfer_transparent_container.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(early_status_transfer_transparent_container.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void dl_ran_early_status_transfer_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  early_status_transfer_transparent_container.to_json(j);
  j.end_obj();
}

// RANStatusTransfer-TransparentContainer ::= SEQUENCE
SRSASN_CODE ran_status_transfer_transparent_container_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, drbs_subject_to_status_transfer_list, 1, 32, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ran_status_transfer_transparent_container_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(drbs_subject_to_status_transfer_list, bref, 1, 32, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ran_status_transfer_transparent_container_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("dRBsSubjectToStatusTransferList");
  for (const auto& e1 : drbs_subject_to_status_transfer_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// DownlinkRANStatusTransferIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t dl_ran_status_transfer_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 84};
  return map_enum_number(names, 3, idx, "id");
}
bool dl_ran_status_transfer_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 84};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e dl_ran_status_transfer_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 84:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
dl_ran_status_transfer_ies_o::value_c dl_ran_status_transfer_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 84:
      ret.set(value_c::types::ran_status_transfer_transparent_container);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e dl_ran_status_transfer_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 84:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void dl_ran_status_transfer_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::ran_status_transfer_transparent_container:
      c.destroy<ran_status_transfer_transparent_container_s>();
      break;
    default:
      break;
  }
}
void dl_ran_status_transfer_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::ran_status_transfer_transparent_container:
      c.init<ran_status_transfer_transparent_container_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "dl_ran_status_transfer_ies_o::value_c");
  }
}
dl_ran_status_transfer_ies_o::value_c::value_c(const dl_ran_status_transfer_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_status_transfer_transparent_container:
      c.init(other.c.get<ran_status_transfer_transparent_container_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "dl_ran_status_transfer_ies_o::value_c");
  }
}
dl_ran_status_transfer_ies_o::value_c&
dl_ran_status_transfer_ies_o::value_c::operator=(const dl_ran_status_transfer_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_status_transfer_transparent_container:
      c.set(other.c.get<ran_status_transfer_transparent_container_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "dl_ran_status_transfer_ies_o::value_c");
  }

  return *this;
}
uint64_t& dl_ran_status_transfer_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& dl_ran_status_transfer_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
ran_status_transfer_transparent_container_s&
dl_ran_status_transfer_ies_o::value_c::ran_status_transfer_transparent_container()
{
  assert_choice_type(types::ran_status_transfer_transparent_container, type_, "Value");
  return c.get<ran_status_transfer_transparent_container_s>();
}
const uint64_t& dl_ran_status_transfer_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& dl_ran_status_transfer_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const ran_status_transfer_transparent_container_s&
dl_ran_status_transfer_ies_o::value_c::ran_status_transfer_transparent_container() const
{
  assert_choice_type(types::ran_status_transfer_transparent_container, type_, "Value");
  return c.get<ran_status_transfer_transparent_container_s>();
}
void dl_ran_status_transfer_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::ran_status_transfer_transparent_container:
      j.write_fieldname("RANStatusTransfer-TransparentContainer");
      c.get<ran_status_transfer_transparent_container_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "dl_ran_status_transfer_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE dl_ran_status_transfer_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ran_status_transfer_transparent_container:
      HANDLE_CODE(c.get<ran_status_transfer_transparent_container_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "dl_ran_status_transfer_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE dl_ran_status_transfer_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ran_status_transfer_transparent_container:
      HANDLE_CODE(c.get<ran_status_transfer_transparent_container_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "dl_ran_status_transfer_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* dl_ran_status_transfer_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {
      "INTEGER (0..1099511627775)", "INTEGER (0..4294967295)", "RANStatusTransfer-TransparentContainer"};
  return convert_enum_idx(names, 3, value, "dl_ran_status_transfer_ies_o::value_c::types");
}

template struct asn1::protocol_ie_field_s<dl_ran_status_transfer_ies_o>;

dl_ran_status_transfer_ies_container::dl_ran_status_transfer_ies_container() :
  amf_ue_ngap_id(10, crit_e::reject),
  ran_ue_ngap_id(85, crit_e::reject),
  ran_status_transfer_transparent_container(84, crit_e::reject)
{
}
SRSASN_CODE dl_ran_status_transfer_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_status_transfer_transparent_container.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE dl_ran_status_transfer_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 84: {
        nof_mandatory_ies--;
        ran_status_transfer_transparent_container.id = id;
        HANDLE_CODE(ran_status_transfer_transparent_container.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_status_transfer_transparent_container.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void dl_ran_status_transfer_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_status_transfer_transparent_container.to_json(j);
  j.end_obj();
}

// RIMInformation ::= SEQUENCE
SRSASN_CODE rim_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(target_gnb_set_id.pack(bref));
  HANDLE_CODE(rim_rs_detection.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE rim_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(target_gnb_set_id.unpack(bref));
  HANDLE_CODE(rim_rs_detection.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void rim_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("targetgNBSetID", target_gnb_set_id.to_string());
  j.write_str("rIM-RSDetection", rim_rs_detection.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* rim_info_s::rim_rs_detection_opts::to_string() const
{
  static const char* names[] = {"rs-detected", "rs-disappeared"};
  return convert_enum_idx(names, 2, value, "rim_info_s::rim_rs_detection_e_");
}

// TargetRANNodeID-RIM ::= SEQUENCE
SRSASN_CODE target_ran_node_id_rim_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(global_ran_node_id.pack(bref));
  HANDLE_CODE(sel_tai.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE target_ran_node_id_rim_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(global_ran_node_id.unpack(bref));
  HANDLE_CODE(sel_tai.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void target_ran_node_id_rim_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("globalRANNodeID");
  global_ran_node_id.to_json(j);
  j.write_fieldname("selectedTAI");
  sel_tai.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// RIMInformationTransfer ::= SEQUENCE
SRSASN_CODE rim_info_transfer_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(target_ran_node_id_rim.pack(bref));
  HANDLE_CODE(source_ran_node_id.pack(bref));
  HANDLE_CODE(rim_info.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE rim_info_transfer_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(target_ran_node_id_rim.unpack(bref));
  HANDLE_CODE(source_ran_node_id.unpack(bref));
  HANDLE_CODE(rim_info.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void rim_info_transfer_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("targetRANNodeID-RIM");
  target_ran_node_id_rim.to_json(j);
  j.write_fieldname("sourceRANNodeID");
  source_ran_node_id.to_json(j);
  j.write_fieldname("rIMInformation");
  rim_info.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// DownlinkRIMInformationTransferIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t dl_rim_info_transfer_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {175};
  return map_enum_number(names, 1, idx, "id");
}
bool dl_rim_info_transfer_ies_o::is_id_valid(const uint32_t& id)
{
  return 175 == id;
}
crit_e dl_rim_info_transfer_ies_o::get_crit(const uint32_t& id)
{
  if (id == 175) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
dl_rim_info_transfer_ies_o::value_c dl_rim_info_transfer_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  if (id != 175) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e dl_rim_info_transfer_ies_o::get_presence(const uint32_t& id)
{
  if (id == 175) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Value ::= OPEN TYPE
void dl_rim_info_transfer_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("RIMInformationTransfer");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE dl_rim_info_transfer_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE dl_rim_info_transfer_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* dl_rim_info_transfer_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"RIMInformationTransfer"};
  return convert_enum_idx(names, 1, value, "dl_rim_info_transfer_ies_o::value_c::types");
}

// DownlinkUEAssociatedNRPPaTransportIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t dl_ue_associated_nrppa_transport_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 89, 46};
  return map_enum_number(names, 4, idx, "id");
}
bool dl_ue_associated_nrppa_transport_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 89, 46};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e dl_ue_associated_nrppa_transport_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 89:
      return crit_e::reject;
    case 46:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
dl_ue_associated_nrppa_transport_ies_o::value_c dl_ue_associated_nrppa_transport_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 89:
      ret.set(value_c::types::routing_id);
      break;
    case 46:
      ret.set(value_c::types::nrppa_pdu);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e dl_ue_associated_nrppa_transport_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 89:
      return presence_e::mandatory;
    case 46:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void dl_ue_associated_nrppa_transport_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::routing_id:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::nrppa_pdu:
      c.destroy<unbounded_octstring<true>>();
      break;
    default:
      break;
  }
}
void dl_ue_associated_nrppa_transport_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::routing_id:
      c.init<unbounded_octstring<true>>();
      break;
    case types::nrppa_pdu:
      c.init<unbounded_octstring<true>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "dl_ue_associated_nrppa_transport_ies_o::value_c");
  }
}
dl_ue_associated_nrppa_transport_ies_o::value_c::value_c(const dl_ue_associated_nrppa_transport_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::routing_id:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nrppa_pdu:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "dl_ue_associated_nrppa_transport_ies_o::value_c");
  }
}
dl_ue_associated_nrppa_transport_ies_o::value_c&
dl_ue_associated_nrppa_transport_ies_o::value_c::operator=(const dl_ue_associated_nrppa_transport_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::routing_id:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nrppa_pdu:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "dl_ue_associated_nrppa_transport_ies_o::value_c");
  }

  return *this;
}
uint64_t& dl_ue_associated_nrppa_transport_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& dl_ue_associated_nrppa_transport_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
unbounded_octstring<true>& dl_ue_associated_nrppa_transport_ies_o::value_c::routing_id()
{
  assert_choice_type(types::routing_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
unbounded_octstring<true>& dl_ue_associated_nrppa_transport_ies_o::value_c::nrppa_pdu()
{
  assert_choice_type(types::nrppa_pdu, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const uint64_t& dl_ue_associated_nrppa_transport_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& dl_ue_associated_nrppa_transport_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const unbounded_octstring<true>& dl_ue_associated_nrppa_transport_ies_o::value_c::routing_id() const
{
  assert_choice_type(types::routing_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const unbounded_octstring<true>& dl_ue_associated_nrppa_transport_ies_o::value_c::nrppa_pdu() const
{
  assert_choice_type(types::nrppa_pdu, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
void dl_ue_associated_nrppa_transport_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::routing_id:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::nrppa_pdu:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "dl_ue_associated_nrppa_transport_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE dl_ue_associated_nrppa_transport_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::routing_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::nrppa_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "dl_ue_associated_nrppa_transport_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE dl_ue_associated_nrppa_transport_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::routing_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::nrppa_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "dl_ue_associated_nrppa_transport_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* dl_ue_associated_nrppa_transport_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {
      "INTEGER (0..1099511627775)", "INTEGER (0..4294967295)", "OCTET STRING", "OCTET STRING"};
  return convert_enum_idx(names, 4, value, "dl_ue_associated_nrppa_transport_ies_o::value_c::types");
}

template struct asn1::protocol_ie_field_s<dl_ue_associated_nrppa_transport_ies_o>;

dl_ue_associated_nrppa_transport_ies_container::dl_ue_associated_nrppa_transport_ies_container() :
  amf_ue_ngap_id(10, crit_e::reject),
  ran_ue_ngap_id(85, crit_e::reject),
  routing_id(89, crit_e::reject),
  nrppa_pdu(46, crit_e::reject)
{
}
SRSASN_CODE dl_ue_associated_nrppa_transport_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 4;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  HANDLE_CODE(routing_id.pack(bref));
  HANDLE_CODE(nrppa_pdu.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE dl_ue_associated_nrppa_transport_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 4;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 89: {
        nof_mandatory_ies--;
        routing_id.id = id;
        HANDLE_CODE(routing_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(routing_id.value.unpack(bref));
        break;
      }
      case 46: {
        nof_mandatory_ies--;
        nrppa_pdu.id = id;
        HANDLE_CODE(nrppa_pdu.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nrppa_pdu.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void dl_ue_associated_nrppa_transport_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  routing_id.to_json(j);
  j.write_fieldname("");
  nrppa_pdu.to_json(j);
  j.end_obj();
}

// DelayCritical ::= ENUMERATED
const char* delay_crit_opts::to_string() const
{
  static const char* names[] = {"delay-critical", "non-delay-critical"};
  return convert_enum_idx(names, 2, value, "delay_crit_e");
}

// Dynamic5QIDescriptor-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t dyn_5qi_descriptor_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {189, 187, 188};
  return map_enum_number(names, 3, idx, "id");
}
bool dyn_5qi_descriptor_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {189, 187, 188};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e dyn_5qi_descriptor_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 189:
      return crit_e::ignore;
    case 187:
      return crit_e::ignore;
    case 188:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
dyn_5qi_descriptor_ext_ies_o::ext_c dyn_5qi_descriptor_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 189:
      ret.set(ext_c::types::extended_packet_delay_budget);
      break;
    case 187:
      ret.set(ext_c::types::cn_packet_delay_budget_dl);
      break;
    case 188:
      ret.set(ext_c::types::cn_packet_delay_budget_ul);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e dyn_5qi_descriptor_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 189:
      return presence_e::optional;
    case 187:
      return presence_e::optional;
    case 188:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void dyn_5qi_descriptor_ext_ies_o::ext_c::destroy_() {}
void dyn_5qi_descriptor_ext_ies_o::ext_c::set(types::options e)
{
  destroy_();
  type_ = e;
}
dyn_5qi_descriptor_ext_ies_o::ext_c::ext_c(const dyn_5qi_descriptor_ext_ies_o::ext_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::extended_packet_delay_budget:
      c.init(other.c.get<uint32_t>());
      break;
    case types::cn_packet_delay_budget_dl:
      c.init(other.c.get<uint32_t>());
      break;
    case types::cn_packet_delay_budget_ul:
      c.init(other.c.get<uint32_t>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "dyn_5qi_descriptor_ext_ies_o::ext_c");
  }
}
dyn_5qi_descriptor_ext_ies_o::ext_c&
dyn_5qi_descriptor_ext_ies_o::ext_c::operator=(const dyn_5qi_descriptor_ext_ies_o::ext_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::extended_packet_delay_budget:
      c.set(other.c.get<uint32_t>());
      break;
    case types::cn_packet_delay_budget_dl:
      c.set(other.c.get<uint32_t>());
      break;
    case types::cn_packet_delay_budget_ul:
      c.set(other.c.get<uint32_t>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "dyn_5qi_descriptor_ext_ies_o::ext_c");
  }

  return *this;
}
uint32_t& dyn_5qi_descriptor_ext_ies_o::ext_c::extended_packet_delay_budget()
{
  assert_choice_type(types::extended_packet_delay_budget, type_, "Extension");
  return c.get<uint32_t>();
}
uint32_t& dyn_5qi_descriptor_ext_ies_o::ext_c::cn_packet_delay_budget_dl()
{
  assert_choice_type(types::cn_packet_delay_budget_dl, type_, "Extension");
  return c.get<uint32_t>();
}
uint32_t& dyn_5qi_descriptor_ext_ies_o::ext_c::cn_packet_delay_budget_ul()
{
  assert_choice_type(types::cn_packet_delay_budget_ul, type_, "Extension");
  return c.get<uint32_t>();
}
const uint32_t& dyn_5qi_descriptor_ext_ies_o::ext_c::extended_packet_delay_budget() const
{
  assert_choice_type(types::extended_packet_delay_budget, type_, "Extension");
  return c.get<uint32_t>();
}
const uint32_t& dyn_5qi_descriptor_ext_ies_o::ext_c::cn_packet_delay_budget_dl() const
{
  assert_choice_type(types::cn_packet_delay_budget_dl, type_, "Extension");
  return c.get<uint32_t>();
}
const uint32_t& dyn_5qi_descriptor_ext_ies_o::ext_c::cn_packet_delay_budget_ul() const
{
  assert_choice_type(types::cn_packet_delay_budget_ul, type_, "Extension");
  return c.get<uint32_t>();
}
void dyn_5qi_descriptor_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::extended_packet_delay_budget:
      j.write_int("INTEGER (1..65535,...)", c.get<uint32_t>());
      break;
    case types::cn_packet_delay_budget_dl:
      j.write_int("INTEGER (1..65535,...)", c.get<uint32_t>());
      break;
    case types::cn_packet_delay_budget_ul:
      j.write_int("INTEGER (1..65535,...)", c.get<uint32_t>());
      break;
    default:
      log_invalid_choice_id(type_, "dyn_5qi_descriptor_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE dyn_5qi_descriptor_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::extended_packet_delay_budget:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)1u, (uint32_t)65535u, true, true));
      break;
    case types::cn_packet_delay_budget_dl:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)1u, (uint32_t)65535u, true, true));
      break;
    case types::cn_packet_delay_budget_ul:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)1u, (uint32_t)65535u, true, true));
      break;
    default:
      log_invalid_choice_id(type_, "dyn_5qi_descriptor_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE dyn_5qi_descriptor_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::extended_packet_delay_budget:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)1u, (uint32_t)65535u, true, true));
      break;
    case types::cn_packet_delay_budget_dl:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)1u, (uint32_t)65535u, true, true));
      break;
    case types::cn_packet_delay_budget_ul:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)1u, (uint32_t)65535u, true, true));
      break;
    default:
      log_invalid_choice_id(type_, "dyn_5qi_descriptor_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* dyn_5qi_descriptor_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (1..65535,...)", "INTEGER (1..65535,...)", "INTEGER (1..65535,...)"};
  return convert_enum_idx(names, 3, value, "dyn_5qi_descriptor_ext_ies_o::ext_c::types");
}

template struct asn1::protocol_ext_field_s<dyn_5qi_descriptor_ext_ies_o>;

dyn_5qi_descriptor_ext_ies_container::dyn_5qi_descriptor_ext_ies_container() :
  extended_packet_delay_budget(189, crit_e::ignore),
  cn_packet_delay_budget_dl(187, crit_e::ignore),
  cn_packet_delay_budget_ul(188, crit_e::ignore)
{
}
SRSASN_CODE dyn_5qi_descriptor_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += extended_packet_delay_budget_present ? 1 : 0;
  nof_ies += cn_packet_delay_budget_dl_present ? 1 : 0;
  nof_ies += cn_packet_delay_budget_ul_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (extended_packet_delay_budget_present) {
    HANDLE_CODE(extended_packet_delay_budget.pack(bref));
  }
  if (cn_packet_delay_budget_dl_present) {
    HANDLE_CODE(cn_packet_delay_budget_dl.pack(bref));
  }
  if (cn_packet_delay_budget_ul_present) {
    HANDLE_CODE(cn_packet_delay_budget_ul.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE dyn_5qi_descriptor_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 189: {
        extended_packet_delay_budget_present = true;
        extended_packet_delay_budget.id      = id;
        HANDLE_CODE(extended_packet_delay_budget.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(extended_packet_delay_budget.ext.unpack(bref));
        break;
      }
      case 187: {
        cn_packet_delay_budget_dl_present = true;
        cn_packet_delay_budget_dl.id      = id;
        HANDLE_CODE(cn_packet_delay_budget_dl.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cn_packet_delay_budget_dl.ext.unpack(bref));
        break;
      }
      case 188: {
        cn_packet_delay_budget_ul_present = true;
        cn_packet_delay_budget_ul.id      = id;
        HANDLE_CODE(cn_packet_delay_budget_ul.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cn_packet_delay_budget_ul.ext.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void dyn_5qi_descriptor_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (extended_packet_delay_budget_present) {
    j.write_fieldname("");
    extended_packet_delay_budget.to_json(j);
  }
  if (cn_packet_delay_budget_dl_present) {
    j.write_fieldname("");
    cn_packet_delay_budget_dl.to_json(j);
  }
  if (cn_packet_delay_budget_ul_present) {
    j.write_fieldname("");
    cn_packet_delay_budget_ul.to_json(j);
  }
  j.end_obj();
}

// Dynamic5QIDescriptor ::= SEQUENCE
SRSASN_CODE dyn_5qi_descriptor_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(five_qi_present, 1));
  HANDLE_CODE(bref.pack(delay_crit_present, 1));
  HANDLE_CODE(bref.pack(averaging_win_present, 1));
  HANDLE_CODE(bref.pack(max_data_burst_volume_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, prio_level_qos, (uint8_t)1u, (uint8_t)127u, true, true));
  HANDLE_CODE(pack_integer(bref, packet_delay_budget, (uint16_t)0u, (uint16_t)1023u, true, true));
  HANDLE_CODE(packet_error_rate.pack(bref));
  if (five_qi_present) {
    HANDLE_CODE(pack_integer(bref, five_qi, (uint16_t)0u, (uint16_t)255u, true, true));
  }
  if (delay_crit_present) {
    HANDLE_CODE(delay_crit.pack(bref));
  }
  if (averaging_win_present) {
    HANDLE_CODE(pack_integer(bref, averaging_win, (uint16_t)0u, (uint16_t)4095u, true, true));
  }
  if (max_data_burst_volume_present) {
    HANDLE_CODE(pack_integer(bref, max_data_burst_volume, (uint16_t)0u, (uint16_t)4095u, true, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE dyn_5qi_descriptor_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(five_qi_present, 1));
  HANDLE_CODE(bref.unpack(delay_crit_present, 1));
  HANDLE_CODE(bref.unpack(averaging_win_present, 1));
  HANDLE_CODE(bref.unpack(max_data_burst_volume_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(prio_level_qos, bref, (uint8_t)1u, (uint8_t)127u, true, true));
  HANDLE_CODE(unpack_integer(packet_delay_budget, bref, (uint16_t)0u, (uint16_t)1023u, true, true));
  HANDLE_CODE(packet_error_rate.unpack(bref));
  if (five_qi_present) {
    HANDLE_CODE(unpack_integer(five_qi, bref, (uint16_t)0u, (uint16_t)255u, true, true));
  }
  if (delay_crit_present) {
    HANDLE_CODE(delay_crit.unpack(bref));
  }
  if (averaging_win_present) {
    HANDLE_CODE(unpack_integer(averaging_win, bref, (uint16_t)0u, (uint16_t)4095u, true, true));
  }
  if (max_data_burst_volume_present) {
    HANDLE_CODE(unpack_integer(max_data_burst_volume, bref, (uint16_t)0u, (uint16_t)4095u, true, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void dyn_5qi_descriptor_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("priorityLevelQos", prio_level_qos);
  j.write_int("packetDelayBudget", packet_delay_budget);
  j.write_fieldname("packetErrorRate");
  packet_error_rate.to_json(j);
  if (five_qi_present) {
    j.write_int("fiveQI", five_qi);
  }
  if (delay_crit_present) {
    j.write_str("delayCritical", delay_crit.to_string());
  }
  if (averaging_win_present) {
    j.write_int("averagingWindow", averaging_win);
  }
  if (max_data_burst_volume_present) {
    j.write_int("maximumDataBurstVolume", max_data_burst_volume);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// DLForwarding ::= ENUMERATED
const char* dl_forwarding_opts::to_string() const
{
  static const char* names[] = {"dl-forwarding-proposed"};
  return convert_enum_idx(names, 1, value, "dl_forwarding_e");
}

// E-RABInformationItem-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t erab_info_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {284, 354};
  return map_enum_number(names, 2, idx, "id");
}
bool erab_info_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {284, 354};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e erab_info_item_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 284:
      return crit_e::ignore;
    case 354:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
erab_info_item_ext_ies_o::ext_c erab_info_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 284:
      ret.set(ext_c::types::source_tnla_ddr_info);
      break;
    case 354:
      ret.set(ext_c::types::source_node_tnla_ddr_info);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e erab_info_item_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 284:
      return presence_e::optional;
    case 354:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void erab_info_item_ext_ies_o::ext_c::destroy_()
{
  switch (type_) {
    case types::source_tnla_ddr_info:
      c.destroy<bounded_bitstring<1, 160, true, true>>();
      break;
    case types::source_node_tnla_ddr_info:
      c.destroy<bounded_bitstring<1, 160, true, true>>();
      break;
    default:
      break;
  }
}
void erab_info_item_ext_ies_o::ext_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::source_tnla_ddr_info:
      c.init<bounded_bitstring<1, 160, true, true>>();
      break;
    case types::source_node_tnla_ddr_info:
      c.init<bounded_bitstring<1, 160, true, true>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "erab_info_item_ext_ies_o::ext_c");
  }
}
erab_info_item_ext_ies_o::ext_c::ext_c(const erab_info_item_ext_ies_o::ext_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::source_tnla_ddr_info:
      c.init(other.c.get<bounded_bitstring<1, 160, true, true>>());
      break;
    case types::source_node_tnla_ddr_info:
      c.init(other.c.get<bounded_bitstring<1, 160, true, true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "erab_info_item_ext_ies_o::ext_c");
  }
}
erab_info_item_ext_ies_o::ext_c&
erab_info_item_ext_ies_o::ext_c::operator=(const erab_info_item_ext_ies_o::ext_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::source_tnla_ddr_info:
      c.set(other.c.get<bounded_bitstring<1, 160, true, true>>());
      break;
    case types::source_node_tnla_ddr_info:
      c.set(other.c.get<bounded_bitstring<1, 160, true, true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "erab_info_item_ext_ies_o::ext_c");
  }

  return *this;
}
bounded_bitstring<1, 160, true, true>& erab_info_item_ext_ies_o::ext_c::source_tnla_ddr_info()
{
  assert_choice_type(types::source_tnla_ddr_info, type_, "Extension");
  return c.get<bounded_bitstring<1, 160, true, true>>();
}
bounded_bitstring<1, 160, true, true>& erab_info_item_ext_ies_o::ext_c::source_node_tnla_ddr_info()
{
  assert_choice_type(types::source_node_tnla_ddr_info, type_, "Extension");
  return c.get<bounded_bitstring<1, 160, true, true>>();
}
const bounded_bitstring<1, 160, true, true>& erab_info_item_ext_ies_o::ext_c::source_tnla_ddr_info() const
{
  assert_choice_type(types::source_tnla_ddr_info, type_, "Extension");
  return c.get<bounded_bitstring<1, 160, true, true>>();
}
const bounded_bitstring<1, 160, true, true>& erab_info_item_ext_ies_o::ext_c::source_node_tnla_ddr_info() const
{
  assert_choice_type(types::source_node_tnla_ddr_info, type_, "Extension");
  return c.get<bounded_bitstring<1, 160, true, true>>();
}
void erab_info_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::source_tnla_ddr_info:
      j.write_str("BIT STRING", c.get<bounded_bitstring<1, 160, true, true>>().to_string());
      break;
    case types::source_node_tnla_ddr_info:
      j.write_str("BIT STRING", c.get<bounded_bitstring<1, 160, true, true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "erab_info_item_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE erab_info_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::source_tnla_ddr_info:
      HANDLE_CODE((c.get<bounded_bitstring<1, 160, true, true>>().pack(bref)));
      break;
    case types::source_node_tnla_ddr_info:
      HANDLE_CODE((c.get<bounded_bitstring<1, 160, true, true>>().pack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "erab_info_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE erab_info_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::source_tnla_ddr_info:
      HANDLE_CODE((c.get<bounded_bitstring<1, 160, true, true>>().unpack(bref)));
      break;
    case types::source_node_tnla_ddr_info:
      HANDLE_CODE((c.get<bounded_bitstring<1, 160, true, true>>().unpack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "erab_info_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* erab_info_item_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"BIT STRING", "BIT STRING"};
  return convert_enum_idx(names, 2, value, "erab_info_item_ext_ies_o::ext_c::types");
}

template struct asn1::protocol_ext_field_s<erab_info_item_ext_ies_o>;

erab_info_item_ext_ies_container::erab_info_item_ext_ies_container() :
  source_tnla_ddr_info(284, crit_e::ignore), source_node_tnla_ddr_info(354, crit_e::ignore)
{
}
SRSASN_CODE erab_info_item_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += source_tnla_ddr_info_present ? 1 : 0;
  nof_ies += source_node_tnla_ddr_info_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (source_tnla_ddr_info_present) {
    HANDLE_CODE(source_tnla_ddr_info.pack(bref));
  }
  if (source_node_tnla_ddr_info_present) {
    HANDLE_CODE(source_node_tnla_ddr_info.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE erab_info_item_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 284: {
        source_tnla_ddr_info_present = true;
        source_tnla_ddr_info.id      = id;
        HANDLE_CODE(source_tnla_ddr_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(source_tnla_ddr_info.ext.unpack(bref));
        break;
      }
      case 354: {
        source_node_tnla_ddr_info_present = true;
        source_node_tnla_ddr_info.id      = id;
        HANDLE_CODE(source_node_tnla_ddr_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(source_node_tnla_ddr_info.ext.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void erab_info_item_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (source_tnla_ddr_info_present) {
    j.write_fieldname("");
    source_tnla_ddr_info.to_json(j);
  }
  if (source_node_tnla_ddr_info_present) {
    j.write_fieldname("");
    source_node_tnla_ddr_info.to_json(j);
  }
  j.end_obj();
}

// E-RABInformationItem ::= SEQUENCE
SRSASN_CODE erab_info_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(dl_forwarding_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, erab_id, (uint8_t)0u, (uint8_t)15u, true, true));
  if (dl_forwarding_present) {
    HANDLE_CODE(dl_forwarding.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE erab_info_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(dl_forwarding_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(erab_id, bref, (uint8_t)0u, (uint8_t)15u, true, true));
  if (dl_forwarding_present) {
    HANDLE_CODE(dl_forwarding.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void erab_info_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("e-RAB-ID", erab_id);
  if (dl_forwarding_present) {
    j.write_str("dLForwarding", "dl-forwarding-proposed");
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// EmergencyFallbackRequestIndicator ::= ENUMERATED
const char* emergency_fallback_request_ind_opts::to_string() const
{
  static const char* names[] = {"emergency-fallback-requested"};
  return convert_enum_idx(names, 1, value, "emergency_fallback_request_ind_e");
}

// EmergencyServiceTargetCN ::= ENUMERATED
const char* emergency_service_target_cn_opts::to_string() const
{
  static const char* names[] = {"fiveGC", "epc"};
  return convert_enum_idx(names, 2, value, "emergency_service_target_cn_e");
}
uint8_t emergency_service_target_cn_opts::to_number() const
{
  static const uint8_t numbers[] = {5};
  return map_enum_number(numbers, 1, value, "emergency_service_target_cn_e");
}

// EmergencyFallbackIndicator ::= SEQUENCE
SRSASN_CODE emergency_fallback_ind_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(emergency_service_target_cn_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(emergency_fallback_request_ind.pack(bref));
  if (emergency_service_target_cn_present) {
    HANDLE_CODE(emergency_service_target_cn.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE emergency_fallback_ind_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(emergency_service_target_cn_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(emergency_fallback_request_ind.unpack(bref));
  if (emergency_service_target_cn_present) {
    HANDLE_CODE(emergency_service_target_cn.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void emergency_fallback_ind_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("emergencyFallbackRequestIndicator", "emergency-fallback-requested");
  if (emergency_service_target_cn_present) {
    j.write_str("emergencyServiceTargetCN", emergency_service_target_cn.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// FiveG-S-TMSI ::= SEQUENCE
SRSASN_CODE five_g_s_tmsi_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(amf_set_id.pack(bref));
  HANDLE_CODE(amf_pointer.pack(bref));
  HANDLE_CODE(five_g_tmsi.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE five_g_s_tmsi_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(amf_set_id.unpack(bref));
  HANDLE_CODE(amf_pointer.unpack(bref));
  HANDLE_CODE(five_g_tmsi.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void five_g_s_tmsi_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("aMFSetID", amf_set_id.to_string());
  j.write_str("aMFPointer", amf_pointer.to_string());
  j.write_str("fiveG-TMSI", five_g_tmsi.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// ErrorIndicationIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t error_ind_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 15, 19, 26};
  return map_enum_number(names, 5, idx, "id");
}
bool error_ind_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 15, 19, 26};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e error_ind_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::ignore;
    case 85:
      return crit_e::ignore;
    case 15:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    case 26:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
error_ind_ies_o::value_c error_ind_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 15:
      ret.set(value_c::types::cause);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    case 26:
      ret.set(value_c::types::five_g_s_tmsi);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e error_ind_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::optional;
    case 85:
      return presence_e::optional;
    case 15:
      return presence_e::optional;
    case 19:
      return presence_e::optional;
    case 26:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void error_ind_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::cause:
      c.destroy<cause_c>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    case types::five_g_s_tmsi:
      c.destroy<five_g_s_tmsi_s>();
      break;
    default:
      break;
  }
}
void error_ind_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::cause:
      c.init<cause_c>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::five_g_s_tmsi:
      c.init<five_g_s_tmsi_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "error_ind_ies_o::value_c");
  }
}
error_ind_ies_o::value_c::value_c(const error_ind_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::five_g_s_tmsi:
      c.init(other.c.get<five_g_s_tmsi_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "error_ind_ies_o::value_c");
  }
}
error_ind_ies_o::value_c& error_ind_ies_o::value_c::operator=(const error_ind_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::five_g_s_tmsi:
      c.set(other.c.get<five_g_s_tmsi_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "error_ind_ies_o::value_c");
  }

  return *this;
}
uint64_t& error_ind_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& error_ind_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
cause_c& error_ind_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
crit_diagnostics_s& error_ind_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
five_g_s_tmsi_s& error_ind_ies_o::value_c::five_g_s_tmsi()
{
  assert_choice_type(types::five_g_s_tmsi, type_, "Value");
  return c.get<five_g_s_tmsi_s>();
}
const uint64_t& error_ind_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& error_ind_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const cause_c& error_ind_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const crit_diagnostics_s& error_ind_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const five_g_s_tmsi_s& error_ind_ies_o::value_c::five_g_s_tmsi() const
{
  assert_choice_type(types::five_g_s_tmsi, type_, "Value");
  return c.get<five_g_s_tmsi_s>();
}
void error_ind_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    case types::five_g_s_tmsi:
      j.write_fieldname("FiveG-S-TMSI");
      c.get<five_g_s_tmsi_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "error_ind_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE error_ind_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    case types::five_g_s_tmsi:
      HANDLE_CODE(c.get<five_g_s_tmsi_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "error_ind_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE error_ind_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    case types::five_g_s_tmsi:
      HANDLE_CODE(c.get<five_g_s_tmsi_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "error_ind_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* error_ind_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {
      "INTEGER (0..1099511627775)", "INTEGER (0..4294967295)", "Cause", "CriticalityDiagnostics", "FiveG-S-TMSI"};
  return convert_enum_idx(names, 5, value, "error_ind_ies_o::value_c::types");
}

template struct asn1::protocol_ie_field_s<error_ind_ies_o>;

error_ind_ies_container::error_ind_ies_container() :
  amf_ue_ngap_id(10, crit_e::ignore),
  ran_ue_ngap_id(85, crit_e::ignore),
  cause(15, crit_e::ignore),
  crit_diagnostics(19, crit_e::ignore),
  five_g_s_tmsi(26, crit_e::ignore)
{
}
SRSASN_CODE error_ind_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += amf_ue_ngap_id_present ? 1 : 0;
  nof_ies += ran_ue_ngap_id_present ? 1 : 0;
  nof_ies += cause_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  nof_ies += five_g_s_tmsi_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  if (amf_ue_ngap_id_present) {
    HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  }
  if (ran_ue_ngap_id_present) {
    HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  }
  if (cause_present) {
    HANDLE_CODE(cause.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }
  if (five_g_s_tmsi_present) {
    HANDLE_CODE(five_g_s_tmsi.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE error_ind_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        amf_ue_ngap_id_present = true;
        amf_ue_ngap_id.id      = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        ran_ue_ngap_id_present = true;
        ran_ue_ngap_id.id      = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 15: {
        cause_present = true;
        cause.id      = id;
        HANDLE_CODE(cause.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.value.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        crit_diagnostics.id      = id;
        HANDLE_CODE(crit_diagnostics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.value.unpack(bref));
        break;
      }
      case 26: {
        five_g_s_tmsi_present = true;
        five_g_s_tmsi.id      = id;
        HANDLE_CODE(five_g_s_tmsi.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(five_g_s_tmsi.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void error_ind_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (amf_ue_ngap_id_present) {
    j.write_fieldname("");
    amf_ue_ngap_id.to_json(j);
  }
  if (ran_ue_ngap_id_present) {
    j.write_fieldname("");
    ran_ue_ngap_id.to_json(j);
  }
  if (cause_present) {
    j.write_fieldname("");
    cause.to_json(j);
  }
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  if (five_g_s_tmsi_present) {
    j.write_fieldname("");
    five_g_s_tmsi.to_json(j);
  }
  j.end_obj();
}

// MeasurementThresholdL1LoggedMDT ::= CHOICE
void meas_thres_l1_logged_mdt_c::destroy_()
{
  switch (type_) {
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<meas_thres_l1_logged_mdt_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void meas_thres_l1_logged_mdt_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::thres_rsrp:
      break;
    case types::thres_rsrq:
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<meas_thres_l1_logged_mdt_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "meas_thres_l1_logged_mdt_c");
  }
}
meas_thres_l1_logged_mdt_c::meas_thres_l1_logged_mdt_c(const meas_thres_l1_logged_mdt_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::thres_rsrp:
      c.init(other.c.get<uint8_t>());
      break;
    case types::thres_rsrq:
      c.init(other.c.get<uint8_t>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<meas_thres_l1_logged_mdt_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "meas_thres_l1_logged_mdt_c");
  }
}
meas_thres_l1_logged_mdt_c& meas_thres_l1_logged_mdt_c::operator=(const meas_thres_l1_logged_mdt_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::thres_rsrp:
      c.set(other.c.get<uint8_t>());
      break;
    case types::thres_rsrq:
      c.set(other.c.get<uint8_t>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<meas_thres_l1_logged_mdt_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "meas_thres_l1_logged_mdt_c");
  }

  return *this;
}
uint8_t& meas_thres_l1_logged_mdt_c::set_thres_rsrp()
{
  set(types::thres_rsrp);
  return c.get<uint8_t>();
}
uint8_t& meas_thres_l1_logged_mdt_c::set_thres_rsrq()
{
  set(types::thres_rsrq);
  return c.get<uint8_t>();
}
protocol_ie_single_container_s<meas_thres_l1_logged_mdt_ext_ies_o>& meas_thres_l1_logged_mdt_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<meas_thres_l1_logged_mdt_ext_ies_o>>();
}
void meas_thres_l1_logged_mdt_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::thres_rsrp:
      j.write_int("threshold-RSRP", c.get<uint8_t>());
      break;
    case types::thres_rsrq:
      j.write_int("threshold-RSRQ", c.get<uint8_t>());
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<meas_thres_l1_logged_mdt_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "meas_thres_l1_logged_mdt_c");
  }
  j.end_obj();
}
SRSASN_CODE meas_thres_l1_logged_mdt_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::thres_rsrp:
      HANDLE_CODE(pack_integer(bref, c.get<uint8_t>(), (uint8_t)0u, (uint8_t)127u, false, true));
      break;
    case types::thres_rsrq:
      HANDLE_CODE(pack_integer(bref, c.get<uint8_t>(), (uint8_t)0u, (uint8_t)127u, false, true));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<meas_thres_l1_logged_mdt_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "meas_thres_l1_logged_mdt_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE meas_thres_l1_logged_mdt_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::thres_rsrp:
      HANDLE_CODE(unpack_integer(c.get<uint8_t>(), bref, (uint8_t)0u, (uint8_t)127u, false, true));
      break;
    case types::thres_rsrq:
      HANDLE_CODE(unpack_integer(c.get<uint8_t>(), bref, (uint8_t)0u, (uint8_t)127u, false, true));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<meas_thres_l1_logged_mdt_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "meas_thres_l1_logged_mdt_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* meas_thres_l1_logged_mdt_c::types_opts::to_string() const
{
  static const char* names[] = {"threshold-RSRP", "threshold-RSRQ", "choice-Extensions"};
  return convert_enum_idx(names, 3, value, "meas_thres_l1_logged_mdt_c::types");
}

// TimeToTrigger ::= ENUMERATED
const char* time_to_trigger_opts::to_string() const
{
  static const char* names[] = {"ms0",
                                "ms40",
                                "ms64",
                                "ms80",
                                "ms100",
                                "ms128",
                                "ms160",
                                "ms256",
                                "ms320",
                                "ms480",
                                "ms512",
                                "ms640",
                                "ms1024",
                                "ms1280",
                                "ms2560",
                                "ms5120"};
  return convert_enum_idx(names, 16, value, "time_to_trigger_e");
}
uint16_t time_to_trigger_opts::to_number() const
{
  static const uint16_t numbers[] = {0, 40, 64, 80, 100, 128, 160, 256, 320, 480, 512, 640, 1024, 1280, 2560, 5120};
  return map_enum_number(numbers, 16, value, "time_to_trigger_e");
}

// EventL1LoggedMDTConfig ::= SEQUENCE
SRSASN_CODE event_l1_logged_mdt_cfg_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(l1_thres.pack(bref));
  HANDLE_CODE(pack_integer(bref, hysteresis, (uint8_t)0u, (uint8_t)30u, false, true));
  HANDLE_CODE(time_to_trigger.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE event_l1_logged_mdt_cfg_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(l1_thres.unpack(bref));
  HANDLE_CODE(unpack_integer(hysteresis, bref, (uint8_t)0u, (uint8_t)30u, false, true));
  HANDLE_CODE(time_to_trigger.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void event_l1_logged_mdt_cfg_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("l1Threshold");
  l1_thres.to_json(j);
  j.write_int("hysteresis", hysteresis);
  j.write_str("timeToTrigger", time_to_trigger.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// EventTrigger ::= CHOICE
void event_trigger_c::destroy_()
{
  switch (type_) {
    case types::event_l1_logged_mdt_cfg:
      c.destroy<event_l1_logged_mdt_cfg_s>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<event_trigger_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void event_trigger_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::out_of_coverage:
      break;
    case types::event_l1_logged_mdt_cfg:
      c.init<event_l1_logged_mdt_cfg_s>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<event_trigger_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "event_trigger_c");
  }
}
event_trigger_c::event_trigger_c(const event_trigger_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::out_of_coverage:
      c.init(other.c.get<out_of_coverage_e_>());
      break;
    case types::event_l1_logged_mdt_cfg:
      c.init(other.c.get<event_l1_logged_mdt_cfg_s>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<event_trigger_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "event_trigger_c");
  }
}
event_trigger_c& event_trigger_c::operator=(const event_trigger_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::out_of_coverage:
      c.set(other.c.get<out_of_coverage_e_>());
      break;
    case types::event_l1_logged_mdt_cfg:
      c.set(other.c.get<event_l1_logged_mdt_cfg_s>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<event_trigger_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "event_trigger_c");
  }

  return *this;
}
event_trigger_c::out_of_coverage_e_& event_trigger_c::set_out_of_coverage()
{
  set(types::out_of_coverage);
  return c.get<out_of_coverage_e_>();
}
event_l1_logged_mdt_cfg_s& event_trigger_c::set_event_l1_logged_mdt_cfg()
{
  set(types::event_l1_logged_mdt_cfg);
  return c.get<event_l1_logged_mdt_cfg_s>();
}
protocol_ie_single_container_s<event_trigger_ext_ies_o>& event_trigger_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<event_trigger_ext_ies_o>>();
}
void event_trigger_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::out_of_coverage:
      j.write_str("outOfCoverage", "true");
      break;
    case types::event_l1_logged_mdt_cfg:
      j.write_fieldname("eventL1LoggedMDTConfig");
      c.get<event_l1_logged_mdt_cfg_s>().to_json(j);
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<event_trigger_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "event_trigger_c");
  }
  j.end_obj();
}
SRSASN_CODE event_trigger_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::out_of_coverage:
      HANDLE_CODE(c.get<out_of_coverage_e_>().pack(bref));
      break;
    case types::event_l1_logged_mdt_cfg:
      HANDLE_CODE(c.get<event_l1_logged_mdt_cfg_s>().pack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<event_trigger_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "event_trigger_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE event_trigger_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::out_of_coverage:
      HANDLE_CODE(c.get<out_of_coverage_e_>().unpack(bref));
      break;
    case types::event_l1_logged_mdt_cfg:
      HANDLE_CODE(c.get<event_l1_logged_mdt_cfg_s>().unpack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<event_trigger_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "event_trigger_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* event_trigger_c::out_of_coverage_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "event_trigger_c::out_of_coverage_e_");
}

const char* event_trigger_c::types_opts::to_string() const
{
  static const char* names[] = {"outOfCoverage", "eventL1LoggedMDTConfig", "choice-Extensions"};
  return convert_enum_idx(names, 3, value, "event_trigger_c::types");
}
uint8_t event_trigger_c::types_opts::to_number() const
{
  if (value == event_l1_logged_mdt_cfg) {
    return 1;
  }
  invalid_enum_number(value, "event_trigger_c::types");
  return 0;
}

// ExcessPacketDelayThresholdValue ::= ENUMERATED
const char* excess_packet_delay_thres_value_opts::to_string() const
{
  static const char* names[] = {"ms0dot25",
                                "ms0dot5",
                                "ms1",
                                "ms2",
                                "ms4",
                                "ms5",
                                "ms10",
                                "ms20",
                                "ms30",
                                "ms40",
                                "ms50",
                                "ms60",
                                "ms70",
                                "ms80",
                                "ms90",
                                "ms100",
                                "ms150",
                                "ms300",
                                "ms500"};
  return convert_enum_idx(names, 19, value, "excess_packet_delay_thres_value_e");
}
float excess_packet_delay_thres_value_opts::to_number() const
{
  static const float numbers[] = {
      0.25, 0.5, 1.0, 2.0, 4.0, 5.0, 10.0, 20.0, 30.0, 40.0, 50.0, 60.0, 70.0, 80.0, 90.0, 100.0, 150.0, 300.0, 500.0};
  return map_enum_number(numbers, 19, value, "excess_packet_delay_thres_value_e");
}
const char* excess_packet_delay_thres_value_opts::to_number_string() const
{
  static const char* number_strs[] = {"0.25",
                                      "0.5",
                                      "1",
                                      "2",
                                      "4",
                                      "5",
                                      "10",
                                      "20",
                                      "30",
                                      "40",
                                      "50",
                                      "60",
                                      "70",
                                      "80",
                                      "90",
                                      "100",
                                      "150",
                                      "300",
                                      "500"};
  return convert_enum_idx(number_strs, 19, value, "excess_packet_delay_thres_value_e");
}

// ExcessPacketDelayThresholdItem ::= SEQUENCE
SRSASN_CODE excess_packet_delay_thres_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, five_qi, (uint16_t)0u, (uint16_t)255u, true, true));
  HANDLE_CODE(excess_packet_delay_thres_value.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE excess_packet_delay_thres_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(five_qi, bref, (uint16_t)0u, (uint16_t)255u, true, true));
  HANDLE_CODE(excess_packet_delay_thres_value.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void excess_packet_delay_thres_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("fiveQi", five_qi);
  j.write_str("excessPacketDelayThresholdValue", excess_packet_delay_thres_value.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// Extended-RANNodeName ::= SEQUENCE
SRSASN_CODE extended_ran_node_name_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ran_node_name_visible_string_present, 1));
  HANDLE_CODE(bref.pack(ran_node_name_utf8_string_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (ran_node_name_visible_string_present) {
    HANDLE_CODE(ran_node_name_visible_string.pack(bref));
  }
  if (ran_node_name_utf8_string_present) {
    HANDLE_CODE(ran_node_name_utf8_string.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE extended_ran_node_name_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ran_node_name_visible_string_present, 1));
  HANDLE_CODE(bref.unpack(ran_node_name_utf8_string_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (ran_node_name_visible_string_present) {
    HANDLE_CODE(ran_node_name_visible_string.unpack(bref));
  }
  if (ran_node_name_utf8_string_present) {
    HANDLE_CODE(ran_node_name_utf8_string.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void extended_ran_node_name_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (ran_node_name_visible_string_present) {
    j.write_str("rANNodeNameVisibleString", ran_node_name_visible_string.to_string());
  }
  if (ran_node_name_utf8_string_present) {
    j.write_str("rANNodeNameUTF8String", ran_node_name_utf8_string.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// FiveGProSeDirectCommunication ::= ENUMERATED
const char* five_g_pro_se_direct_communication_opts::to_string() const
{
  static const char* names[] = {"authorized", "not-authorized"};
  return convert_enum_idx(names, 2, value, "five_g_pro_se_direct_communication_e");
}

// FiveGProSeDirectDiscovery ::= ENUMERATED
const char* five_g_pro_se_direct_discovery_opts::to_string() const
{
  static const char* names[] = {"authorized", "not-authorized"};
  return convert_enum_idx(names, 2, value, "five_g_pro_se_direct_discovery_e");
}

// FiveGProSeLayer2RemoteUE ::= ENUMERATED
const char* five_g_pro_se_layer2_remote_ue_opts::to_string() const
{
  static const char* names[] = {"authorized", "not-authorized"};
  return convert_enum_idx(names, 2, value, "five_g_pro_se_layer2_remote_ue_e");
}

// FiveGProSeLayer2UEtoNetworkRelay ::= ENUMERATED
const char* five_g_pro_se_layer2_ue_to_network_relay_opts::to_string() const
{
  static const char* names[] = {"authorized", "not-authorized"};
  return convert_enum_idx(names, 2, value, "five_g_pro_se_layer2_ue_to_network_relay_e");
}

// FiveGProSeLayer3UEtoNetworkRelay ::= ENUMERATED
const char* five_g_pro_se_layer3_ue_to_network_relay_opts::to_string() const
{
  static const char* names[] = {"authorized", "not-authorized"};
  return convert_enum_idx(names, 2, value, "five_g_pro_se_layer3_ue_to_network_relay_e");
}

// FiveG-ProSeAuthorized ::= SEQUENCE
SRSASN_CODE five_g_pro_se_authorized_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(five_g_pro_se_direct_discovery_present, 1));
  HANDLE_CODE(bref.pack(five_g_pro_se_direct_communication_present, 1));
  HANDLE_CODE(bref.pack(five_g_pro_se_layer2_ue_to_network_relay_present, 1));
  HANDLE_CODE(bref.pack(five_g_pro_se_layer3_ue_to_network_relay_present, 1));
  HANDLE_CODE(bref.pack(five_g_pro_se_layer2_remote_ue_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (five_g_pro_se_direct_discovery_present) {
    HANDLE_CODE(five_g_pro_se_direct_discovery.pack(bref));
  }
  if (five_g_pro_se_direct_communication_present) {
    HANDLE_CODE(five_g_pro_se_direct_communication.pack(bref));
  }
  if (five_g_pro_se_layer2_ue_to_network_relay_present) {
    HANDLE_CODE(five_g_pro_se_layer2_ue_to_network_relay.pack(bref));
  }
  if (five_g_pro_se_layer3_ue_to_network_relay_present) {
    HANDLE_CODE(five_g_pro_se_layer3_ue_to_network_relay.pack(bref));
  }
  if (five_g_pro_se_layer2_remote_ue_present) {
    HANDLE_CODE(five_g_pro_se_layer2_remote_ue.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE five_g_pro_se_authorized_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(five_g_pro_se_direct_discovery_present, 1));
  HANDLE_CODE(bref.unpack(five_g_pro_se_direct_communication_present, 1));
  HANDLE_CODE(bref.unpack(five_g_pro_se_layer2_ue_to_network_relay_present, 1));
  HANDLE_CODE(bref.unpack(five_g_pro_se_layer3_ue_to_network_relay_present, 1));
  HANDLE_CODE(bref.unpack(five_g_pro_se_layer2_remote_ue_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (five_g_pro_se_direct_discovery_present) {
    HANDLE_CODE(five_g_pro_se_direct_discovery.unpack(bref));
  }
  if (five_g_pro_se_direct_communication_present) {
    HANDLE_CODE(five_g_pro_se_direct_communication.unpack(bref));
  }
  if (five_g_pro_se_layer2_ue_to_network_relay_present) {
    HANDLE_CODE(five_g_pro_se_layer2_ue_to_network_relay.unpack(bref));
  }
  if (five_g_pro_se_layer3_ue_to_network_relay_present) {
    HANDLE_CODE(five_g_pro_se_layer3_ue_to_network_relay.unpack(bref));
  }
  if (five_g_pro_se_layer2_remote_ue_present) {
    HANDLE_CODE(five_g_pro_se_layer2_remote_ue.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void five_g_pro_se_authorized_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (five_g_pro_se_direct_discovery_present) {
    j.write_str("fiveGProSeDirectDiscovery", five_g_pro_se_direct_discovery.to_string());
  }
  if (five_g_pro_se_direct_communication_present) {
    j.write_str("fiveGProSeDirectCommunication", five_g_pro_se_direct_communication.to_string());
  }
  if (five_g_pro_se_layer2_ue_to_network_relay_present) {
    j.write_str("fiveGProSeLayer2UEtoNetworkRelay", five_g_pro_se_layer2_ue_to_network_relay.to_string());
  }
  if (five_g_pro_se_layer3_ue_to_network_relay_present) {
    j.write_str("fiveGProSeLayer3UEtoNetworkRelay", five_g_pro_se_layer3_ue_to_network_relay.to_string());
  }
  if (five_g_pro_se_layer2_remote_ue_present) {
    j.write_str("fiveGProSeLayer2RemoteUE", five_g_pro_se_layer2_remote_ue.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// FiveGProSePC5FlowBitRates ::= SEQUENCE
SRSASN_CODE five_g_pro_se_pc5_flow_bit_rates_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(
      pack_integer(bref, five_gpro_seguaranteed_flow_bit_rate, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  HANDLE_CODE(pack_integer(bref, five_gpro_semax_flow_bit_rate, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE five_g_pro_se_pc5_flow_bit_rates_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(
      unpack_integer(five_gpro_seguaranteed_flow_bit_rate, bref, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  HANDLE_CODE(unpack_integer(five_gpro_semax_flow_bit_rate, bref, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void five_g_pro_se_pc5_flow_bit_rates_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("fiveGproSeguaranteedFlowBitRate", five_gpro_seguaranteed_flow_bit_rate);
  j.write_int("fiveGproSemaximumFlowBitRate", five_gpro_semax_flow_bit_rate);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// Range ::= ENUMERATED
const char* range_opts::to_string() const
{
  static const char* names[] = {"m50", "m80", "m180", "m200", "m350", "m400", "m500", "m700", "m1000"};
  return convert_enum_idx(names, 9, value, "range_e");
}
uint16_t range_opts::to_number() const
{
  static const uint16_t numbers[] = {50, 80, 180, 200, 350, 400, 500, 700, 1000};
  return map_enum_number(numbers, 9, value, "range_e");
}

// FiveGProSePC5QoSFlowItem ::= SEQUENCE
SRSASN_CODE five_g_pro_se_pc5_qos_flow_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(five_gpro_sepc5_flow_bit_rates_present, 1));
  HANDLE_CODE(bref.pack(five_gpro_serange_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, five_gpro_sep_qi, (uint16_t)0u, (uint16_t)255u, true, true));
  if (five_gpro_sepc5_flow_bit_rates_present) {
    HANDLE_CODE(five_gpro_sepc5_flow_bit_rates.pack(bref));
  }
  if (five_gpro_serange_present) {
    HANDLE_CODE(five_gpro_serange.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE five_g_pro_se_pc5_qos_flow_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(five_gpro_sepc5_flow_bit_rates_present, 1));
  HANDLE_CODE(bref.unpack(five_gpro_serange_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(five_gpro_sep_qi, bref, (uint16_t)0u, (uint16_t)255u, true, true));
  if (five_gpro_sepc5_flow_bit_rates_present) {
    HANDLE_CODE(five_gpro_sepc5_flow_bit_rates.unpack(bref));
  }
  if (five_gpro_serange_present) {
    HANDLE_CODE(five_gpro_serange.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void five_g_pro_se_pc5_qos_flow_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("fiveGproSepQI", five_gpro_sep_qi);
  if (five_gpro_sepc5_flow_bit_rates_present) {
    j.write_fieldname("fiveGproSepc5FlowBitRates");
    five_gpro_sepc5_flow_bit_rates.to_json(j);
  }
  if (five_gpro_serange_present) {
    j.write_str("fiveGproSerange", five_gpro_serange.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// FiveG-ProSePC5QoSParameters ::= SEQUENCE
SRSASN_CODE five_g_pro_se_pc5_qos_params_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(five_g_pro_sepc5_link_aggr_bit_rates_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, five_g_pro_sepc5_qos_flow_list, 1, 2048, true));
  if (five_g_pro_sepc5_link_aggr_bit_rates_present) {
    HANDLE_CODE(
        pack_integer(bref, five_g_pro_sepc5_link_aggr_bit_rates, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE five_g_pro_se_pc5_qos_params_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(five_g_pro_sepc5_link_aggr_bit_rates_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(five_g_pro_sepc5_qos_flow_list, bref, 1, 2048, true));
  if (five_g_pro_sepc5_link_aggr_bit_rates_present) {
    HANDLE_CODE(
        unpack_integer(five_g_pro_sepc5_link_aggr_bit_rates, bref, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void five_g_pro_se_pc5_qos_params_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("fiveGProSepc5QoSFlowList");
  for (const auto& e1 : five_g_pro_sepc5_qos_flow_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (five_g_pro_sepc5_link_aggr_bit_rates_present) {
    j.write_int("fiveGProSepc5LinkAggregateBitRates", five_g_pro_sepc5_link_aggr_bit_rates);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// GBR-QosInformation-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t gbr_qos_info_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {220};
  return map_enum_number(names, 1, idx, "id");
}
bool gbr_qos_info_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 220 == id;
}
crit_e gbr_qos_info_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 220) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
gbr_qos_info_ext_ies_o::ext_c gbr_qos_info_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 220) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e gbr_qos_info_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 220) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void gbr_qos_info_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("AlternativeQoSParaSetList");
  for (const auto& e1 : c) {
    e1.to_json(j);
  }
  j.end_array();
  j.end_obj();
}
SRSASN_CODE gbr_qos_info_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(pack_dyn_seq_of(bref, c, 1, 8, true));
  return SRSASN_SUCCESS;
}
SRSASN_CODE gbr_qos_info_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(unpack_dyn_seq_of(c, bref, 1, 8, true));
  return SRSASN_SUCCESS;
}

const char* gbr_qos_info_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"AlternativeQoSParaSetList"};
  return convert_enum_idx(names, 1, value, "gbr_qos_info_ext_ies_o::ext_c::types");
}

// NotificationControl ::= ENUMERATED
const char* notif_ctrl_opts::to_string() const
{
  static const char* names[] = {"notification-requested"};
  return convert_enum_idx(names, 1, value, "notif_ctrl_e");
}

// GBR-QosInformation ::= SEQUENCE
SRSASN_CODE gbr_qos_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(notif_ctrl_present, 1));
  HANDLE_CODE(bref.pack(max_packet_loss_rate_dl_present, 1));
  HANDLE_CODE(bref.pack(max_packet_loss_rate_ul_present, 1));
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(pack_integer(bref, max_flow_bit_rate_dl, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  HANDLE_CODE(pack_integer(bref, max_flow_bit_rate_ul, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  HANDLE_CODE(pack_integer(bref, guaranteed_flow_bit_rate_dl, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  HANDLE_CODE(pack_integer(bref, guaranteed_flow_bit_rate_ul, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  if (notif_ctrl_present) {
    HANDLE_CODE(notif_ctrl.pack(bref));
  }
  if (max_packet_loss_rate_dl_present) {
    HANDLE_CODE(pack_integer(bref, max_packet_loss_rate_dl, (uint16_t)0u, (uint16_t)1000u, true, true));
  }
  if (max_packet_loss_rate_ul_present) {
    HANDLE_CODE(pack_integer(bref, max_packet_loss_rate_ul, (uint16_t)0u, (uint16_t)1000u, true, true));
  }
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE gbr_qos_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(notif_ctrl_present, 1));
  HANDLE_CODE(bref.unpack(max_packet_loss_rate_dl_present, 1));
  HANDLE_CODE(bref.unpack(max_packet_loss_rate_ul_present, 1));
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(max_flow_bit_rate_dl, bref, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  HANDLE_CODE(unpack_integer(max_flow_bit_rate_ul, bref, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  HANDLE_CODE(unpack_integer(guaranteed_flow_bit_rate_dl, bref, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  HANDLE_CODE(unpack_integer(guaranteed_flow_bit_rate_ul, bref, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  if (notif_ctrl_present) {
    HANDLE_CODE(notif_ctrl.unpack(bref));
  }
  if (max_packet_loss_rate_dl_present) {
    HANDLE_CODE(unpack_integer(max_packet_loss_rate_dl, bref, (uint16_t)0u, (uint16_t)1000u, true, true));
  }
  if (max_packet_loss_rate_ul_present) {
    HANDLE_CODE(unpack_integer(max_packet_loss_rate_ul, bref, (uint16_t)0u, (uint16_t)1000u, true, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void gbr_qos_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("maximumFlowBitRateDL", max_flow_bit_rate_dl);
  j.write_int("maximumFlowBitRateUL", max_flow_bit_rate_ul);
  j.write_int("guaranteedFlowBitRateDL", guaranteed_flow_bit_rate_dl);
  j.write_int("guaranteedFlowBitRateUL", guaranteed_flow_bit_rate_ul);
  if (notif_ctrl_present) {
    j.write_str("notificationControl", "notification-requested");
  }
  if (max_packet_loss_rate_dl_present) {
    j.write_int("maximumPacketLossRateDL", max_packet_loss_rate_dl);
  }
  if (max_packet_loss_rate_ul_present) {
    j.write_int("maximumPacketLossRateUL", max_packet_loss_rate_ul);
  }
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// GlobalCable-ID-new ::= SEQUENCE
SRSASN_CODE global_cable_id_new_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(global_cable_id.pack(bref));
  HANDLE_CODE(tai.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE global_cable_id_new_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(global_cable_id.unpack(bref));
  HANDLE_CODE(tai.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void global_cable_id_new_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("globalCable-ID", global_cable_id.to_string());
  j.write_fieldname("tAI");
  tai.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// GlobalLine-ID-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t global_line_id_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {213};
  return map_enum_number(names, 1, idx, "id");
}
bool global_line_id_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 213 == id;
}
crit_e global_line_id_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 213) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
global_line_id_ext_ies_o::ext_c global_line_id_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 213) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e global_line_id_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 213) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void global_line_id_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("TAI");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE global_line_id_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE global_line_id_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* global_line_id_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"TAI"};
  return convert_enum_idx(names, 1, value, "global_line_id_ext_ies_o::ext_c::types");
}

// LineType ::= ENUMERATED
const char* line_type_opts::to_string() const
{
  static const char* names[] = {"dsl", "pon"};
  return convert_enum_idx(names, 2, value, "line_type_e");
}

// GlobalLine-ID ::= SEQUENCE
SRSASN_CODE global_line_id_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(line_type_present, 1));
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(global_line_id.pack(bref));
  if (line_type_present) {
    HANDLE_CODE(line_type.pack(bref));
  }
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE global_line_id_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(line_type_present, 1));
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(global_line_id.unpack(bref));
  if (line_type_present) {
    HANDLE_CODE(line_type.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void global_line_id_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("globalLineIdentity", global_line_id.to_string());
  if (line_type_present) {
    j.write_str("lineType", line_type.to_string());
  }
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// HFCNode-ID-new ::= SEQUENCE
SRSASN_CODE hfc_node_id_new_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(hfc_node_id.pack(bref));
  HANDLE_CODE(tai.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE hfc_node_id_new_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(hfc_node_id.unpack(bref));
  HANDLE_CODE(tai.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void hfc_node_id_new_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("hFCNode-ID", hfc_node_id.to_string());
  j.write_fieldname("tAI");
  tai.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// HandoverCancelIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ho_cancel_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 15};
  return map_enum_number(names, 3, idx, "id");
}
bool ho_cancel_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 15};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ho_cancel_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 15:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ho_cancel_ies_o::value_c ho_cancel_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 15:
      ret.set(value_c::types::cause);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ho_cancel_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 15:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ho_cancel_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::cause:
      c.destroy<cause_c>();
      break;
    default:
      break;
  }
}
void ho_cancel_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::cause:
      c.init<cause_c>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_cancel_ies_o::value_c");
  }
}
ho_cancel_ies_o::value_c::value_c(const ho_cancel_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_cancel_ies_o::value_c");
  }
}
ho_cancel_ies_o::value_c& ho_cancel_ies_o::value_c::operator=(const ho_cancel_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_cancel_ies_o::value_c");
  }

  return *this;
}
uint64_t& ho_cancel_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ho_cancel_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
cause_c& ho_cancel_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const uint64_t& ho_cancel_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ho_cancel_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const cause_c& ho_cancel_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
void ho_cancel_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ho_cancel_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ho_cancel_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_cancel_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_cancel_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_cancel_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ho_cancel_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..1099511627775)", "INTEGER (0..4294967295)", "Cause"};
  return convert_enum_idx(names, 3, value, "ho_cancel_ies_o::value_c::types");
}

template struct asn1::protocol_ie_field_s<ho_cancel_ies_o>;

ho_cancel_ies_container::ho_cancel_ies_container() :
  amf_ue_ngap_id(10, crit_e::reject), ran_ue_ngap_id(85, crit_e::reject), cause(15, crit_e::ignore)
{
}
SRSASN_CODE ho_cancel_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  HANDLE_CODE(cause.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_cancel_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 15: {
        nof_mandatory_ies--;
        cause.id = id;
        HANDLE_CODE(cause.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ho_cancel_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  cause.to_json(j);
  j.end_obj();
}

// HandoverCancelAcknowledgeIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ho_cancel_ack_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 19};
  return map_enum_number(names, 3, idx, "id");
}
bool ho_cancel_ack_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ho_cancel_ack_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::ignore;
    case 85:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ho_cancel_ack_ies_o::value_c ho_cancel_ack_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ho_cancel_ack_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ho_cancel_ack_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void ho_cancel_ack_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_cancel_ack_ies_o::value_c");
  }
}
ho_cancel_ack_ies_o::value_c::value_c(const ho_cancel_ack_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_cancel_ack_ies_o::value_c");
  }
}
ho_cancel_ack_ies_o::value_c& ho_cancel_ack_ies_o::value_c::operator=(const ho_cancel_ack_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_cancel_ack_ies_o::value_c");
  }

  return *this;
}
uint64_t& ho_cancel_ack_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ho_cancel_ack_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
crit_diagnostics_s& ho_cancel_ack_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const uint64_t& ho_cancel_ack_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ho_cancel_ack_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const crit_diagnostics_s& ho_cancel_ack_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void ho_cancel_ack_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ho_cancel_ack_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ho_cancel_ack_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_cancel_ack_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_cancel_ack_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_cancel_ack_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ho_cancel_ack_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..1099511627775)", "INTEGER (0..4294967295)", "CriticalityDiagnostics"};
  return convert_enum_idx(names, 3, value, "ho_cancel_ack_ies_o::value_c::types");
}

template struct asn1::protocol_ie_field_s<ho_cancel_ack_ies_o>;

ho_cancel_ack_ies_container::ho_cancel_ack_ies_container() :
  amf_ue_ngap_id(10, crit_e::ignore), ran_ue_ngap_id(85, crit_e::ignore), crit_diagnostics(19, crit_e::ignore)
{
}
SRSASN_CODE ho_cancel_ack_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_cancel_ack_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        crit_diagnostics.id      = id;
        HANDLE_CODE(crit_diagnostics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ho_cancel_ack_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceHandoverItem ::= SEQUENCE
SRSASN_CODE pdu_session_res_ho_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pdu_session_id, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(ho_cmd_transfer.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_ho_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pdu_session_id, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(ho_cmd_transfer.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_ho_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pDUSessionID", pdu_session_id);
  j.write_str("handoverCommandTransfer", ho_cmd_transfer.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceToReleaseItemHOCmd ::= SEQUENCE
SRSASN_CODE pdu_session_res_to_release_item_ho_cmd_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pdu_session_id, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(ho_prep_unsuccessful_transfer.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_to_release_item_ho_cmd_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pdu_session_id, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(ho_prep_unsuccessful_transfer.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_to_release_item_ho_cmd_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pDUSessionID", pdu_session_id);
  j.write_str("handoverPreparationUnsuccessfulTransfer", ho_prep_unsuccessful_transfer.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// HandoverType ::= ENUMERATED
const char* handov_type_opts::to_string() const
{
  static const char* names[] = {"intra5gs", "fivegs-to-eps", "eps-to-5gs", "fivegs-to-utran"};
  return convert_enum_idx(names, 4, value, "handov_type_e");
}

// HandoverCommandIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ho_cmd_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 29, 39, 59, 78, 106, 19};
  return map_enum_number(names, 8, idx, "id");
}
bool ho_cmd_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 29, 39, 59, 78, 106, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ho_cmd_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 29:
      return crit_e::reject;
    case 39:
      return crit_e::reject;
    case 59:
      return crit_e::ignore;
    case 78:
      return crit_e::ignore;
    case 106:
      return crit_e::reject;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ho_cmd_ies_o::value_c ho_cmd_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 29:
      ret.set(value_c::types::handov_type);
      break;
    case 39:
      ret.set(value_c::types::nas_security_params_from_ngran);
      break;
    case 59:
      ret.set(value_c::types::pdu_session_res_ho_list);
      break;
    case 78:
      ret.set(value_c::types::pdu_session_res_to_release_list_ho_cmd);
      break;
    case 106:
      ret.set(value_c::types::target_to_source_transparent_container);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ho_cmd_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 29:
      return presence_e::mandatory;
    case 39:
      return presence_e::conditional;
    case 59:
      return presence_e::optional;
    case 78:
      return presence_e::optional;
    case 106:
      return presence_e::mandatory;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ho_cmd_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::nas_security_params_from_ngran:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::pdu_session_res_ho_list:
      c.destroy<pdu_session_res_ho_list_l>();
      break;
    case types::pdu_session_res_to_release_list_ho_cmd:
      c.destroy<pdu_session_res_to_release_list_ho_cmd_l>();
      break;
    case types::target_to_source_transparent_container:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void ho_cmd_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::handov_type:
      break;
    case types::nas_security_params_from_ngran:
      c.init<unbounded_octstring<true>>();
      break;
    case types::pdu_session_res_ho_list:
      c.init<pdu_session_res_ho_list_l>();
      break;
    case types::pdu_session_res_to_release_list_ho_cmd:
      c.init<pdu_session_res_to_release_list_ho_cmd_l>();
      break;
    case types::target_to_source_transparent_container:
      c.init<unbounded_octstring<true>>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_cmd_ies_o::value_c");
  }
}
ho_cmd_ies_o::value_c::value_c(const ho_cmd_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::handov_type:
      c.init(other.c.get<handov_type_e>());
      break;
    case types::nas_security_params_from_ngran:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::pdu_session_res_ho_list:
      c.init(other.c.get<pdu_session_res_ho_list_l>());
      break;
    case types::pdu_session_res_to_release_list_ho_cmd:
      c.init(other.c.get<pdu_session_res_to_release_list_ho_cmd_l>());
      break;
    case types::target_to_source_transparent_container:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_cmd_ies_o::value_c");
  }
}
ho_cmd_ies_o::value_c& ho_cmd_ies_o::value_c::operator=(const ho_cmd_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::handov_type:
      c.set(other.c.get<handov_type_e>());
      break;
    case types::nas_security_params_from_ngran:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::pdu_session_res_ho_list:
      c.set(other.c.get<pdu_session_res_ho_list_l>());
      break;
    case types::pdu_session_res_to_release_list_ho_cmd:
      c.set(other.c.get<pdu_session_res_to_release_list_ho_cmd_l>());
      break;
    case types::target_to_source_transparent_container:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_cmd_ies_o::value_c");
  }

  return *this;
}
uint64_t& ho_cmd_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ho_cmd_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
handov_type_e& ho_cmd_ies_o::value_c::handov_type()
{
  assert_choice_type(types::handov_type, type_, "Value");
  return c.get<handov_type_e>();
}
unbounded_octstring<true>& ho_cmd_ies_o::value_c::nas_security_params_from_ngran()
{
  assert_choice_type(types::nas_security_params_from_ngran, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
pdu_session_res_ho_list_l& ho_cmd_ies_o::value_c::pdu_session_res_ho_list()
{
  assert_choice_type(types::pdu_session_res_ho_list, type_, "Value");
  return c.get<pdu_session_res_ho_list_l>();
}
pdu_session_res_to_release_list_ho_cmd_l& ho_cmd_ies_o::value_c::pdu_session_res_to_release_list_ho_cmd()
{
  assert_choice_type(types::pdu_session_res_to_release_list_ho_cmd, type_, "Value");
  return c.get<pdu_session_res_to_release_list_ho_cmd_l>();
}
unbounded_octstring<true>& ho_cmd_ies_o::value_c::target_to_source_transparent_container()
{
  assert_choice_type(types::target_to_source_transparent_container, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
crit_diagnostics_s& ho_cmd_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const uint64_t& ho_cmd_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ho_cmd_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const handov_type_e& ho_cmd_ies_o::value_c::handov_type() const
{
  assert_choice_type(types::handov_type, type_, "Value");
  return c.get<handov_type_e>();
}
const unbounded_octstring<true>& ho_cmd_ies_o::value_c::nas_security_params_from_ngran() const
{
  assert_choice_type(types::nas_security_params_from_ngran, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const pdu_session_res_ho_list_l& ho_cmd_ies_o::value_c::pdu_session_res_ho_list() const
{
  assert_choice_type(types::pdu_session_res_ho_list, type_, "Value");
  return c.get<pdu_session_res_ho_list_l>();
}
const pdu_session_res_to_release_list_ho_cmd_l& ho_cmd_ies_o::value_c::pdu_session_res_to_release_list_ho_cmd() const
{
  assert_choice_type(types::pdu_session_res_to_release_list_ho_cmd, type_, "Value");
  return c.get<pdu_session_res_to_release_list_ho_cmd_l>();
}
const unbounded_octstring<true>& ho_cmd_ies_o::value_c::target_to_source_transparent_container() const
{
  assert_choice_type(types::target_to_source_transparent_container, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const crit_diagnostics_s& ho_cmd_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void ho_cmd_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::handov_type:
      j.write_str("HandoverType", c.get<handov_type_e>().to_string());
      break;
    case types::nas_security_params_from_ngran:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::pdu_session_res_ho_list:
      j.start_array("PDUSessionResourceHandoverList");
      for (const auto& e1 : c.get<pdu_session_res_ho_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::pdu_session_res_to_release_list_ho_cmd:
      j.start_array("PDUSessionResourceToReleaseListHOCmd");
      for (const auto& e1 : c.get<pdu_session_res_to_release_list_ho_cmd_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::target_to_source_transparent_container:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ho_cmd_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ho_cmd_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::handov_type:
      HANDLE_CODE(c.get<handov_type_e>().pack(bref));
      break;
    case types::nas_security_params_from_ngran:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::pdu_session_res_ho_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_ho_list_l>(), 1, 256, true));
      break;
    case types::pdu_session_res_to_release_list_ho_cmd:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_to_release_list_ho_cmd_l>(), 1, 256, true));
      break;
    case types::target_to_source_transparent_container:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_cmd_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_cmd_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::handov_type:
      HANDLE_CODE(c.get<handov_type_e>().unpack(bref));
      break;
    case types::nas_security_params_from_ngran:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::pdu_session_res_ho_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_ho_list_l>(), bref, 1, 256, true));
      break;
    case types::pdu_session_res_to_release_list_ho_cmd:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_to_release_list_ho_cmd_l>(), bref, 1, 256, true));
      break;
    case types::target_to_source_transparent_container:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_cmd_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ho_cmd_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..1099511627775)",
                                "INTEGER (0..4294967295)",
                                "HandoverType",
                                "OCTET STRING",
                                "PDUSessionResourceHandoverList",
                                "PDUSessionResourceToReleaseListHOCmd",
                                "OCTET STRING",
                                "CriticalityDiagnostics"};
  return convert_enum_idx(names, 8, value, "ho_cmd_ies_o::value_c::types");
}

template struct asn1::protocol_ie_field_s<ho_cmd_ies_o>;

ho_cmd_ies_container::ho_cmd_ies_container() :
  amf_ue_ngap_id(10, crit_e::reject),
  ran_ue_ngap_id(85, crit_e::reject),
  handov_type(29, crit_e::reject),
  nas_security_params_from_ngran(39, crit_e::reject),
  pdu_session_res_ho_list(59, crit_e::ignore),
  pdu_session_res_to_release_list_ho_cmd(78, crit_e::ignore),
  target_to_source_transparent_container(106, crit_e::reject),
  crit_diagnostics(19, crit_e::ignore)
{
}
SRSASN_CODE ho_cmd_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 4;
  nof_ies += nas_security_params_from_ngran_present ? 1 : 0;
  nof_ies += pdu_session_res_ho_list_present ? 1 : 0;
  nof_ies += pdu_session_res_to_release_list_ho_cmd_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  HANDLE_CODE(handov_type.pack(bref));
  if (nas_security_params_from_ngran_present) {
    HANDLE_CODE(nas_security_params_from_ngran.pack(bref));
  }
  if (pdu_session_res_ho_list_present) {
    HANDLE_CODE(pdu_session_res_ho_list.pack(bref));
  }
  if (pdu_session_res_to_release_list_ho_cmd_present) {
    HANDLE_CODE(pdu_session_res_to_release_list_ho_cmd.pack(bref));
  }
  HANDLE_CODE(target_to_source_transparent_container.pack(bref));
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_cmd_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 4;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 29: {
        nof_mandatory_ies--;
        handov_type.id = id;
        HANDLE_CODE(handov_type.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(handov_type.value.unpack(bref));
        break;
      }
      case 39: {
        nas_security_params_from_ngran_present = true;
        nas_security_params_from_ngran.id      = id;
        HANDLE_CODE(nas_security_params_from_ngran.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nas_security_params_from_ngran.value.unpack(bref));
        break;
      }
      case 59: {
        pdu_session_res_ho_list_present = true;
        pdu_session_res_ho_list.id      = id;
        HANDLE_CODE(pdu_session_res_ho_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pdu_session_res_ho_list.value.unpack(bref));
        break;
      }
      case 78: {
        pdu_session_res_to_release_list_ho_cmd_present = true;
        pdu_session_res_to_release_list_ho_cmd.id      = id;
        HANDLE_CODE(pdu_session_res_to_release_list_ho_cmd.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pdu_session_res_to_release_list_ho_cmd.value.unpack(bref));
        break;
      }
      case 106: {
        nof_mandatory_ies--;
        target_to_source_transparent_container.id = id;
        HANDLE_CODE(target_to_source_transparent_container.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(target_to_source_transparent_container.value.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        crit_diagnostics.id      = id;
        HANDLE_CODE(crit_diagnostics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ho_cmd_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  handov_type.to_json(j);
  if (nas_security_params_from_ngran_present) {
    j.write_fieldname("");
    nas_security_params_from_ngran.to_json(j);
  }
  if (pdu_session_res_ho_list_present) {
    j.write_fieldname("");
    pdu_session_res_ho_list.to_json(j);
  }
  if (pdu_session_res_to_release_list_ho_cmd_present) {
    j.write_fieldname("");
    pdu_session_res_to_release_list_ho_cmd.to_json(j);
  }
  j.write_fieldname("");
  target_to_source_transparent_container.to_json(j);
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

// QosFlowPerTNLInformation ::= SEQUENCE
SRSASN_CODE qos_flow_per_tnl_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(up_transport_layer_info.pack(bref));
  HANDLE_CODE(pack_dyn_seq_of(bref, associated_qos_flow_list, 1, 64, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_flow_per_tnl_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(up_transport_layer_info.unpack(bref));
  HANDLE_CODE(unpack_dyn_seq_of(associated_qos_flow_list, bref, 1, 64, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void qos_flow_per_tnl_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("uPTransportLayerInformation");
  up_transport_layer_info.to_json(j);
  j.start_array("associatedQosFlowList");
  for (const auto& e1 : associated_qos_flow_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// UPTransportLayerInformationItem-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t up_transport_layer_info_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {166};
  return map_enum_number(names, 1, idx, "id");
}
bool up_transport_layer_info_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 166 == id;
}
crit_e up_transport_layer_info_item_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 166) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
up_transport_layer_info_item_ext_ies_o::ext_c up_transport_layer_info_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 166) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e up_transport_layer_info_item_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 166) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void up_transport_layer_info_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("OCTET STRING", c.to_string());
  j.end_obj();
}
SRSASN_CODE up_transport_layer_info_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE up_transport_layer_info_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* up_transport_layer_info_item_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"OCTET STRING"};
  return convert_enum_idx(names, 1, value, "up_transport_layer_info_item_ext_ies_o::ext_c::types");
}

// QosFlowPerTNLInformationItem ::= SEQUENCE
SRSASN_CODE qos_flow_per_tnl_info_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(qos_flow_per_tnl_info.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_flow_per_tnl_info_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(qos_flow_per_tnl_info.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void qos_flow_per_tnl_info_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("qosFlowPerTNLInformation");
  qos_flow_per_tnl_info.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// QosFlowWithCauseItem ::= SEQUENCE
SRSASN_CODE qos_flow_with_cause_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, qos_flow_id, (uint8_t)0u, (uint8_t)63u, true, true));
  HANDLE_CODE(cause.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_flow_with_cause_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(qos_flow_id, bref, (uint8_t)0u, (uint8_t)63u, true, true));
  HANDLE_CODE(cause.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void qos_flow_with_cause_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("qosFlowIdentifier", qos_flow_id);
  j.write_fieldname("cause");
  cause.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// UPTransportLayerInformationItem ::= SEQUENCE
SRSASN_CODE up_transport_layer_info_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(ngu_up_tnl_info.pack(bref));
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE up_transport_layer_info_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(ngu_up_tnl_info.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void up_transport_layer_info_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("nGU-UP-TNLInformation");
  ngu_up_tnl_info.to_json(j);
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// QosFlowToBeForwardedItem ::= SEQUENCE
SRSASN_CODE qos_flow_to_be_forwarded_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, qos_flow_id, (uint8_t)0u, (uint8_t)63u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_flow_to_be_forwarded_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(qos_flow_id, bref, (uint8_t)0u, (uint8_t)63u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void qos_flow_to_be_forwarded_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("qosFlowIdentifier", qos_flow_id);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// HandoverCommandTransfer-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t ho_cmd_transfer_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {152, 164, 172, 249, 283};
  return map_enum_number(names, 5, idx, "id");
}
bool ho_cmd_transfer_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {152, 164, 172, 249, 283};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ho_cmd_transfer_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 152:
      return crit_e::ignore;
    case 164:
      return crit_e::reject;
    case 172:
      return crit_e::reject;
    case 249:
      return crit_e::ignore;
    case 283:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ho_cmd_transfer_ext_ies_o::ext_c ho_cmd_transfer_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 152:
      ret.set(ext_c::types::add_dl_forwarding_up_tnl_info);
      break;
    case 164:
      ret.set(ext_c::types::ul_forwarding_up_tnl_info);
      break;
    case 172:
      ret.set(ext_c::types::add_ul_forwarding_up_tnl_info);
      break;
    case 249:
      ret.set(ext_c::types::data_forwarding_resp_erab_list);
      break;
    case 283:
      ret.set(ext_c::types::qos_flow_failed_to_setup_list);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ho_cmd_transfer_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 152:
      return presence_e::optional;
    case 164:
      return presence_e::optional;
    case 172:
      return presence_e::optional;
    case 249:
      return presence_e::optional;
    case 283:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void ho_cmd_transfer_ext_ies_o::ext_c::destroy_()
{
  switch (type_) {
    case types::add_dl_forwarding_up_tnl_info:
      c.destroy<qos_flow_per_tnl_info_list_l>();
      break;
    case types::ul_forwarding_up_tnl_info:
      c.destroy<up_transport_layer_info_c>();
      break;
    case types::add_ul_forwarding_up_tnl_info:
      c.destroy<up_transport_layer_info_list_l>();
      break;
    case types::data_forwarding_resp_erab_list:
      c.destroy<data_forwarding_resp_erab_list_l>();
      break;
    case types::qos_flow_failed_to_setup_list:
      c.destroy<qos_flow_list_with_cause_l>();
      break;
    default:
      break;
  }
}
void ho_cmd_transfer_ext_ies_o::ext_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::add_dl_forwarding_up_tnl_info:
      c.init<qos_flow_per_tnl_info_list_l>();
      break;
    case types::ul_forwarding_up_tnl_info:
      c.init<up_transport_layer_info_c>();
      break;
    case types::add_ul_forwarding_up_tnl_info:
      c.init<up_transport_layer_info_list_l>();
      break;
    case types::data_forwarding_resp_erab_list:
      c.init<data_forwarding_resp_erab_list_l>();
      break;
    case types::qos_flow_failed_to_setup_list:
      c.init<qos_flow_list_with_cause_l>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_cmd_transfer_ext_ies_o::ext_c");
  }
}
ho_cmd_transfer_ext_ies_o::ext_c::ext_c(const ho_cmd_transfer_ext_ies_o::ext_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::add_dl_forwarding_up_tnl_info:
      c.init(other.c.get<qos_flow_per_tnl_info_list_l>());
      break;
    case types::ul_forwarding_up_tnl_info:
      c.init(other.c.get<up_transport_layer_info_c>());
      break;
    case types::add_ul_forwarding_up_tnl_info:
      c.init(other.c.get<up_transport_layer_info_list_l>());
      break;
    case types::data_forwarding_resp_erab_list:
      c.init(other.c.get<data_forwarding_resp_erab_list_l>());
      break;
    case types::qos_flow_failed_to_setup_list:
      c.init(other.c.get<qos_flow_list_with_cause_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_cmd_transfer_ext_ies_o::ext_c");
  }
}
ho_cmd_transfer_ext_ies_o::ext_c&
ho_cmd_transfer_ext_ies_o::ext_c::operator=(const ho_cmd_transfer_ext_ies_o::ext_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::add_dl_forwarding_up_tnl_info:
      c.set(other.c.get<qos_flow_per_tnl_info_list_l>());
      break;
    case types::ul_forwarding_up_tnl_info:
      c.set(other.c.get<up_transport_layer_info_c>());
      break;
    case types::add_ul_forwarding_up_tnl_info:
      c.set(other.c.get<up_transport_layer_info_list_l>());
      break;
    case types::data_forwarding_resp_erab_list:
      c.set(other.c.get<data_forwarding_resp_erab_list_l>());
      break;
    case types::qos_flow_failed_to_setup_list:
      c.set(other.c.get<qos_flow_list_with_cause_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_cmd_transfer_ext_ies_o::ext_c");
  }

  return *this;
}
qos_flow_per_tnl_info_list_l& ho_cmd_transfer_ext_ies_o::ext_c::add_dl_forwarding_up_tnl_info()
{
  assert_choice_type(types::add_dl_forwarding_up_tnl_info, type_, "Extension");
  return c.get<qos_flow_per_tnl_info_list_l>();
}
up_transport_layer_info_c& ho_cmd_transfer_ext_ies_o::ext_c::ul_forwarding_up_tnl_info()
{
  assert_choice_type(types::ul_forwarding_up_tnl_info, type_, "Extension");
  return c.get<up_transport_layer_info_c>();
}
up_transport_layer_info_list_l& ho_cmd_transfer_ext_ies_o::ext_c::add_ul_forwarding_up_tnl_info()
{
  assert_choice_type(types::add_ul_forwarding_up_tnl_info, type_, "Extension");
  return c.get<up_transport_layer_info_list_l>();
}
data_forwarding_resp_erab_list_l& ho_cmd_transfer_ext_ies_o::ext_c::data_forwarding_resp_erab_list()
{
  assert_choice_type(types::data_forwarding_resp_erab_list, type_, "Extension");
  return c.get<data_forwarding_resp_erab_list_l>();
}
qos_flow_list_with_cause_l& ho_cmd_transfer_ext_ies_o::ext_c::qos_flow_failed_to_setup_list()
{
  assert_choice_type(types::qos_flow_failed_to_setup_list, type_, "Extension");
  return c.get<qos_flow_list_with_cause_l>();
}
const qos_flow_per_tnl_info_list_l& ho_cmd_transfer_ext_ies_o::ext_c::add_dl_forwarding_up_tnl_info() const
{
  assert_choice_type(types::add_dl_forwarding_up_tnl_info, type_, "Extension");
  return c.get<qos_flow_per_tnl_info_list_l>();
}
const up_transport_layer_info_c& ho_cmd_transfer_ext_ies_o::ext_c::ul_forwarding_up_tnl_info() const
{
  assert_choice_type(types::ul_forwarding_up_tnl_info, type_, "Extension");
  return c.get<up_transport_layer_info_c>();
}
const up_transport_layer_info_list_l& ho_cmd_transfer_ext_ies_o::ext_c::add_ul_forwarding_up_tnl_info() const
{
  assert_choice_type(types::add_ul_forwarding_up_tnl_info, type_, "Extension");
  return c.get<up_transport_layer_info_list_l>();
}
const data_forwarding_resp_erab_list_l& ho_cmd_transfer_ext_ies_o::ext_c::data_forwarding_resp_erab_list() const
{
  assert_choice_type(types::data_forwarding_resp_erab_list, type_, "Extension");
  return c.get<data_forwarding_resp_erab_list_l>();
}
const qos_flow_list_with_cause_l& ho_cmd_transfer_ext_ies_o::ext_c::qos_flow_failed_to_setup_list() const
{
  assert_choice_type(types::qos_flow_failed_to_setup_list, type_, "Extension");
  return c.get<qos_flow_list_with_cause_l>();
}
void ho_cmd_transfer_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::add_dl_forwarding_up_tnl_info:
      j.start_array("QosFlowPerTNLInformationList");
      for (const auto& e1 : c.get<qos_flow_per_tnl_info_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::ul_forwarding_up_tnl_info:
      j.write_fieldname("UPTransportLayerInformation");
      c.get<up_transport_layer_info_c>().to_json(j);
      break;
    case types::add_ul_forwarding_up_tnl_info:
      j.start_array("UPTransportLayerInformationList");
      for (const auto& e1 : c.get<up_transport_layer_info_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::data_forwarding_resp_erab_list:
      j.start_array("DataForwardingResponseERABList");
      for (const auto& e1 : c.get<data_forwarding_resp_erab_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::qos_flow_failed_to_setup_list:
      j.start_array("QosFlowListWithCause");
      for (const auto& e1 : c.get<qos_flow_list_with_cause_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    default:
      log_invalid_choice_id(type_, "ho_cmd_transfer_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE ho_cmd_transfer_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::add_dl_forwarding_up_tnl_info:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<qos_flow_per_tnl_info_list_l>(), 1, 3, true));
      break;
    case types::ul_forwarding_up_tnl_info:
      HANDLE_CODE(c.get<up_transport_layer_info_c>().pack(bref));
      break;
    case types::add_ul_forwarding_up_tnl_info:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<up_transport_layer_info_list_l>(), 1, 3, true));
      break;
    case types::data_forwarding_resp_erab_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<data_forwarding_resp_erab_list_l>(), 1, 256, true));
      break;
    case types::qos_flow_failed_to_setup_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<qos_flow_list_with_cause_l>(), 1, 64, true));
      break;
    default:
      log_invalid_choice_id(type_, "ho_cmd_transfer_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_cmd_transfer_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::add_dl_forwarding_up_tnl_info:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<qos_flow_per_tnl_info_list_l>(), bref, 1, 3, true));
      break;
    case types::ul_forwarding_up_tnl_info:
      HANDLE_CODE(c.get<up_transport_layer_info_c>().unpack(bref));
      break;
    case types::add_ul_forwarding_up_tnl_info:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<up_transport_layer_info_list_l>(), bref, 1, 3, true));
      break;
    case types::data_forwarding_resp_erab_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<data_forwarding_resp_erab_list_l>(), bref, 1, 256, true));
      break;
    case types::qos_flow_failed_to_setup_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<qos_flow_list_with_cause_l>(), bref, 1, 64, true));
      break;
    default:
      log_invalid_choice_id(type_, "ho_cmd_transfer_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ho_cmd_transfer_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"QosFlowPerTNLInformationList",
                                "UPTransportLayerInformation",
                                "UPTransportLayerInformationList",
                                "DataForwardingResponseERABList",
                                "QosFlowListWithCause"};
  return convert_enum_idx(names, 5, value, "ho_cmd_transfer_ext_ies_o::ext_c::types");
}

template struct asn1::protocol_ext_field_s<ho_cmd_transfer_ext_ies_o>;

ho_cmd_transfer_ext_ies_container::ho_cmd_transfer_ext_ies_container() :
  add_dl_forwarding_up_tnl_info(152, crit_e::ignore),
  ul_forwarding_up_tnl_info(164, crit_e::reject),
  add_ul_forwarding_up_tnl_info(172, crit_e::reject),
  data_forwarding_resp_erab_list(249, crit_e::ignore),
  qos_flow_failed_to_setup_list(283, crit_e::ignore)
{
}
SRSASN_CODE ho_cmd_transfer_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += add_dl_forwarding_up_tnl_info_present ? 1 : 0;
  nof_ies += ul_forwarding_up_tnl_info_present ? 1 : 0;
  nof_ies += add_ul_forwarding_up_tnl_info_present ? 1 : 0;
  nof_ies += data_forwarding_resp_erab_list_present ? 1 : 0;
  nof_ies += qos_flow_failed_to_setup_list_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (add_dl_forwarding_up_tnl_info_present) {
    HANDLE_CODE(add_dl_forwarding_up_tnl_info.pack(bref));
  }
  if (ul_forwarding_up_tnl_info_present) {
    HANDLE_CODE(ul_forwarding_up_tnl_info.pack(bref));
  }
  if (add_ul_forwarding_up_tnl_info_present) {
    HANDLE_CODE(add_ul_forwarding_up_tnl_info.pack(bref));
  }
  if (data_forwarding_resp_erab_list_present) {
    HANDLE_CODE(data_forwarding_resp_erab_list.pack(bref));
  }
  if (qos_flow_failed_to_setup_list_present) {
    HANDLE_CODE(qos_flow_failed_to_setup_list.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_cmd_transfer_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 152: {
        add_dl_forwarding_up_tnl_info_present = true;
        add_dl_forwarding_up_tnl_info.id      = id;
        HANDLE_CODE(add_dl_forwarding_up_tnl_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(add_dl_forwarding_up_tnl_info.ext.unpack(bref));
        break;
      }
      case 164: {
        ul_forwarding_up_tnl_info_present = true;
        ul_forwarding_up_tnl_info.id      = id;
        HANDLE_CODE(ul_forwarding_up_tnl_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ul_forwarding_up_tnl_info.ext.unpack(bref));
        break;
      }
      case 172: {
        add_ul_forwarding_up_tnl_info_present = true;
        add_ul_forwarding_up_tnl_info.id      = id;
        HANDLE_CODE(add_ul_forwarding_up_tnl_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(add_ul_forwarding_up_tnl_info.ext.unpack(bref));
        break;
      }
      case 249: {
        data_forwarding_resp_erab_list_present = true;
        data_forwarding_resp_erab_list.id      = id;
        HANDLE_CODE(data_forwarding_resp_erab_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(data_forwarding_resp_erab_list.ext.unpack(bref));
        break;
      }
      case 283: {
        qos_flow_failed_to_setup_list_present = true;
        qos_flow_failed_to_setup_list.id      = id;
        HANDLE_CODE(qos_flow_failed_to_setup_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(qos_flow_failed_to_setup_list.ext.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void ho_cmd_transfer_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (add_dl_forwarding_up_tnl_info_present) {
    j.write_fieldname("");
    add_dl_forwarding_up_tnl_info.to_json(j);
  }
  if (ul_forwarding_up_tnl_info_present) {
    j.write_fieldname("");
    ul_forwarding_up_tnl_info.to_json(j);
  }
  if (add_ul_forwarding_up_tnl_info_present) {
    j.write_fieldname("");
    add_ul_forwarding_up_tnl_info.to_json(j);
  }
  if (data_forwarding_resp_erab_list_present) {
    j.write_fieldname("");
    data_forwarding_resp_erab_list.to_json(j);
  }
  if (qos_flow_failed_to_setup_list_present) {
    j.write_fieldname("");
    qos_flow_failed_to_setup_list.to_json(j);
  }
  j.end_obj();
}

// HandoverCommandTransfer ::= SEQUENCE
SRSASN_CODE ho_cmd_transfer_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(dl_forwarding_up_tnl_info_present, 1));
  HANDLE_CODE(bref.pack(qos_flow_to_be_forwarded_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(data_forwarding_resp_drb_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (dl_forwarding_up_tnl_info_present) {
    HANDLE_CODE(dl_forwarding_up_tnl_info.pack(bref));
  }
  if (qos_flow_to_be_forwarded_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, qos_flow_to_be_forwarded_list, 1, 64, true));
  }
  if (data_forwarding_resp_drb_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, data_forwarding_resp_drb_list, 1, 32, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_cmd_transfer_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(dl_forwarding_up_tnl_info_present, 1));
  bool qos_flow_to_be_forwarded_list_present;
  HANDLE_CODE(bref.unpack(qos_flow_to_be_forwarded_list_present, 1));
  bool data_forwarding_resp_drb_list_present;
  HANDLE_CODE(bref.unpack(data_forwarding_resp_drb_list_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (dl_forwarding_up_tnl_info_present) {
    HANDLE_CODE(dl_forwarding_up_tnl_info.unpack(bref));
  }
  if (qos_flow_to_be_forwarded_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(qos_flow_to_be_forwarded_list, bref, 1, 64, true));
  }
  if (data_forwarding_resp_drb_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(data_forwarding_resp_drb_list, bref, 1, 32, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ho_cmd_transfer_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (dl_forwarding_up_tnl_info_present) {
    j.write_fieldname("dLForwardingUP-TNLInformation");
    dl_forwarding_up_tnl_info.to_json(j);
  }
  if (qos_flow_to_be_forwarded_list.size() > 0) {
    j.start_array("qosFlowToBeForwardedList");
    for (const auto& e1 : qos_flow_to_be_forwarded_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (data_forwarding_resp_drb_list.size() > 0) {
    j.start_array("dataForwardingResponseDRBList");
    for (const auto& e1 : data_forwarding_resp_drb_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// HandoverFailureIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ho_fail_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 15, 19, 262};
  return map_enum_number(names, 4, idx, "id");
}
bool ho_fail_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 15, 19, 262};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ho_fail_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::ignore;
    case 15:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    case 262:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ho_fail_ies_o::value_c ho_fail_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 15:
      ret.set(value_c::types::cause);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    case 262:
      ret.set(value_c::types::targetto_source_fail_transparent_container);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ho_fail_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 15:
      return presence_e::mandatory;
    case 19:
      return presence_e::optional;
    case 262:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ho_fail_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::cause:
      c.destroy<cause_c>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    case types::targetto_source_fail_transparent_container:
      c.destroy<unbounded_octstring<true>>();
      break;
    default:
      break;
  }
}
void ho_fail_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::cause:
      c.init<cause_c>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::targetto_source_fail_transparent_container:
      c.init<unbounded_octstring<true>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_fail_ies_o::value_c");
  }
}
ho_fail_ies_o::value_c::value_c(const ho_fail_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::targetto_source_fail_transparent_container:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_fail_ies_o::value_c");
  }
}
ho_fail_ies_o::value_c& ho_fail_ies_o::value_c::operator=(const ho_fail_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::targetto_source_fail_transparent_container:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_fail_ies_o::value_c");
  }

  return *this;
}
uint64_t& ho_fail_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
cause_c& ho_fail_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
crit_diagnostics_s& ho_fail_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
unbounded_octstring<true>& ho_fail_ies_o::value_c::targetto_source_fail_transparent_container()
{
  assert_choice_type(types::targetto_source_fail_transparent_container, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const uint64_t& ho_fail_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const cause_c& ho_fail_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const crit_diagnostics_s& ho_fail_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const unbounded_octstring<true>& ho_fail_ies_o::value_c::targetto_source_fail_transparent_container() const
{
  assert_choice_type(types::targetto_source_fail_transparent_container, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
void ho_fail_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    case types::targetto_source_fail_transparent_container:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "ho_fail_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ho_fail_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    case types::targetto_source_fail_transparent_container:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_fail_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_fail_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    case types::targetto_source_fail_transparent_container:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_fail_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ho_fail_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..1099511627775)", "Cause", "CriticalityDiagnostics", "OCTET STRING"};
  return convert_enum_idx(names, 4, value, "ho_fail_ies_o::value_c::types");
}
uint8_t ho_fail_ies_o::value_c::types_opts::to_number() const
{
  static const uint8_t numbers[] = {0};
  return map_enum_number(numbers, 1, value, "ho_fail_ies_o::value_c::types");
}

template struct asn1::protocol_ie_field_s<ho_fail_ies_o>;

ho_fail_ies_container::ho_fail_ies_container() :
  amf_ue_ngap_id(10, crit_e::ignore),
  cause(15, crit_e::ignore),
  crit_diagnostics(19, crit_e::ignore),
  targetto_source_fail_transparent_container(262, crit_e::ignore)
{
}
SRSASN_CODE ho_fail_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  nof_ies += targetto_source_fail_transparent_container_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(cause.pack(bref));
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }
  if (targetto_source_fail_transparent_container_present) {
    HANDLE_CODE(targetto_source_fail_transparent_container.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_fail_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 15: {
        nof_mandatory_ies--;
        cause.id = id;
        HANDLE_CODE(cause.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.value.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        crit_diagnostics.id      = id;
        HANDLE_CODE(crit_diagnostics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.value.unpack(bref));
        break;
      }
      case 262: {
        targetto_source_fail_transparent_container_present = true;
        targetto_source_fail_transparent_container.id      = id;
        HANDLE_CODE(targetto_source_fail_transparent_container.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(targetto_source_fail_transparent_container.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ho_fail_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  cause.to_json(j);
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  if (targetto_source_fail_transparent_container_present) {
    j.write_fieldname("");
    targetto_source_fail_transparent_container.to_json(j);
  }
  j.end_obj();
}

// NRNTNTAIInformation ::= SEQUENCE
SRSASN_CODE nr_ntn_tai_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ue_location_derived_tac_in_nr_ntn_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(serving_plmn.pack(bref));
  HANDLE_CODE(pack_dyn_seq_of(bref, tac_list_in_nr_ntn, 1, 12, true));
  if (ue_location_derived_tac_in_nr_ntn_present) {
    HANDLE_CODE(ue_location_derived_tac_in_nr_ntn.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE nr_ntn_tai_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ue_location_derived_tac_in_nr_ntn_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(serving_plmn.unpack(bref));
  HANDLE_CODE(unpack_dyn_seq_of(tac_list_in_nr_ntn, bref, 1, 12, true));
  if (ue_location_derived_tac_in_nr_ntn_present) {
    HANDLE_CODE(ue_location_derived_tac_in_nr_ntn.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void nr_ntn_tai_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("servingPLMN", serving_plmn.to_string());
  j.start_array("tACListInNRNTN");
  for (const auto& e1 : tac_list_in_nr_ntn) {
    j.write_str(e1.to_string());
  }
  j.end_array();
  if (ue_location_derived_tac_in_nr_ntn_present) {
    j.write_str("uELocationDerivedTACInNRNTN", ue_location_derived_tac_in_nr_ntn.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// UserLocationInformationTNGF-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t user_location_info_tngf_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {213};
  return map_enum_number(names, 1, idx, "id");
}
bool user_location_info_tngf_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 213 == id;
}
crit_e user_location_info_tngf_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 213) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
user_location_info_tngf_ext_ies_o::ext_c user_location_info_tngf_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 213) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e user_location_info_tngf_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 213) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void user_location_info_tngf_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("TAI");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE user_location_info_tngf_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE user_location_info_tngf_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* user_location_info_tngf_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"TAI"};
  return convert_enum_idx(names, 1, value, "user_location_info_tngf_ext_ies_o::ext_c::types");
}

// UserLocationInformationTWIF-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t user_location_info_twif_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {213};
  return map_enum_number(names, 1, idx, "id");
}
bool user_location_info_twif_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 213 == id;
}
crit_e user_location_info_twif_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 213) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
user_location_info_twif_ext_ies_o::ext_c user_location_info_twif_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 213) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e user_location_info_twif_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 213) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void user_location_info_twif_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("TAI");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE user_location_info_twif_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE user_location_info_twif_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* user_location_info_twif_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"TAI"};
  return convert_enum_idx(names, 1, value, "user_location_info_twif_ext_ies_o::ext_c::types");
}

// UserLocationInformationW-AGF-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t user_location_info_w_agf_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {275, 362, 363};
  return map_enum_number(names, 3, idx, "id");
}
bool user_location_info_w_agf_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {275, 362, 363};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e user_location_info_w_agf_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 275:
      return crit_e::ignore;
    case 362:
      return crit_e::ignore;
    case 363:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
user_location_info_w_agf_ext_ies_o::value_c user_location_info_w_agf_ext_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 275:
      ret.set(value_c::types::global_cable_id);
      break;
    case 362:
      ret.set(value_c::types::hfc_node_id_new);
      break;
    case 363:
      ret.set(value_c::types::global_cable_id_new);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e user_location_info_w_agf_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 275:
      return presence_e::mandatory;
    case 362:
      return presence_e::mandatory;
    case 363:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void user_location_info_w_agf_ext_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::global_cable_id:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::hfc_node_id_new:
      c.destroy<hfc_node_id_new_s>();
      break;
    case types::global_cable_id_new:
      c.destroy<global_cable_id_new_s>();
      break;
    default:
      break;
  }
}
void user_location_info_w_agf_ext_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::global_cable_id:
      c.init<unbounded_octstring<true>>();
      break;
    case types::hfc_node_id_new:
      c.init<hfc_node_id_new_s>();
      break;
    case types::global_cable_id_new:
      c.init<global_cable_id_new_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "user_location_info_w_agf_ext_ies_o::value_c");
  }
}
user_location_info_w_agf_ext_ies_o::value_c::value_c(const user_location_info_w_agf_ext_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::global_cable_id:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::hfc_node_id_new:
      c.init(other.c.get<hfc_node_id_new_s>());
      break;
    case types::global_cable_id_new:
      c.init(other.c.get<global_cable_id_new_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "user_location_info_w_agf_ext_ies_o::value_c");
  }
}
user_location_info_w_agf_ext_ies_o::value_c&
user_location_info_w_agf_ext_ies_o::value_c::operator=(const user_location_info_w_agf_ext_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::global_cable_id:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::hfc_node_id_new:
      c.set(other.c.get<hfc_node_id_new_s>());
      break;
    case types::global_cable_id_new:
      c.set(other.c.get<global_cable_id_new_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "user_location_info_w_agf_ext_ies_o::value_c");
  }

  return *this;
}
unbounded_octstring<true>& user_location_info_w_agf_ext_ies_o::value_c::global_cable_id()
{
  assert_choice_type(types::global_cable_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
hfc_node_id_new_s& user_location_info_w_agf_ext_ies_o::value_c::hfc_node_id_new()
{
  assert_choice_type(types::hfc_node_id_new, type_, "Value");
  return c.get<hfc_node_id_new_s>();
}
global_cable_id_new_s& user_location_info_w_agf_ext_ies_o::value_c::global_cable_id_new()
{
  assert_choice_type(types::global_cable_id_new, type_, "Value");
  return c.get<global_cable_id_new_s>();
}
const unbounded_octstring<true>& user_location_info_w_agf_ext_ies_o::value_c::global_cable_id() const
{
  assert_choice_type(types::global_cable_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const hfc_node_id_new_s& user_location_info_w_agf_ext_ies_o::value_c::hfc_node_id_new() const
{
  assert_choice_type(types::hfc_node_id_new, type_, "Value");
  return c.get<hfc_node_id_new_s>();
}
const global_cable_id_new_s& user_location_info_w_agf_ext_ies_o::value_c::global_cable_id_new() const
{
  assert_choice_type(types::global_cable_id_new, type_, "Value");
  return c.get<global_cable_id_new_s>();
}
void user_location_info_w_agf_ext_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::global_cable_id:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::hfc_node_id_new:
      j.write_fieldname("HFCNode-ID-new");
      c.get<hfc_node_id_new_s>().to_json(j);
      break;
    case types::global_cable_id_new:
      j.write_fieldname("GlobalCable-ID-new");
      c.get<global_cable_id_new_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "user_location_info_w_agf_ext_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE user_location_info_w_agf_ext_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::global_cable_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::hfc_node_id_new:
      HANDLE_CODE(c.get<hfc_node_id_new_s>().pack(bref));
      break;
    case types::global_cable_id_new:
      HANDLE_CODE(c.get<global_cable_id_new_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "user_location_info_w_agf_ext_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE user_location_info_w_agf_ext_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::global_cable_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::hfc_node_id_new:
      HANDLE_CODE(c.get<hfc_node_id_new_s>().unpack(bref));
      break;
    case types::global_cable_id_new:
      HANDLE_CODE(c.get<global_cable_id_new_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "user_location_info_w_agf_ext_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* user_location_info_w_agf_ext_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"OCTET STRING", "HFCNode-ID-new", "GlobalCable-ID-new"};
  return convert_enum_idx(names, 3, value, "user_location_info_w_agf_ext_ies_o::value_c::types");
}

// UserLocationInformationEUTRA-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t user_location_info_eutra_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {149};
  return map_enum_number(names, 1, idx, "id");
}
bool user_location_info_eutra_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 149 == id;
}
crit_e user_location_info_eutra_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 149) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
user_location_info_eutra_ext_ies_o::ext_c user_location_info_eutra_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 149) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e user_location_info_eutra_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 149) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void user_location_info_eutra_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("NGRAN-CGI");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE user_location_info_eutra_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE user_location_info_eutra_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* user_location_info_eutra_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"NGRAN-CGI"};
  return convert_enum_idx(names, 1, value, "user_location_info_eutra_ext_ies_o::ext_c::types");
}

// UserLocationInformationN3IWF-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t user_location_info_n3_iwf_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {213};
  return map_enum_number(names, 1, idx, "id");
}
bool user_location_info_n3_iwf_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 213 == id;
}
crit_e user_location_info_n3_iwf_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 213) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
user_location_info_n3_iwf_ext_ies_o::ext_c user_location_info_n3_iwf_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 213) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e user_location_info_n3_iwf_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 213) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void user_location_info_n3_iwf_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("TAI");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE user_location_info_n3_iwf_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE user_location_info_n3_iwf_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* user_location_info_n3_iwf_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"TAI"};
  return convert_enum_idx(names, 1, value, "user_location_info_n3_iwf_ext_ies_o::ext_c::types");
}

// UserLocationInformationNR-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t user_location_info_nr_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {149, 263, 287};
  return map_enum_number(names, 3, idx, "id");
}
bool user_location_info_nr_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {149, 263, 287};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e user_location_info_nr_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 149:
      return crit_e::ignore;
    case 263:
      return crit_e::reject;
    case 287:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
user_location_info_nr_ext_ies_o::ext_c user_location_info_nr_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 149:
      ret.set(ext_c::types::pscell_info);
      break;
    case 263:
      ret.set(ext_c::types::n_id);
      break;
    case 287:
      ret.set(ext_c::types::nr_ntn_tai_info);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e user_location_info_nr_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 149:
      return presence_e::optional;
    case 263:
      return presence_e::optional;
    case 287:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void user_location_info_nr_ext_ies_o::ext_c::destroy_()
{
  switch (type_) {
    case types::pscell_info:
      c.destroy<ngran_cgi_c>();
      break;
    case types::n_id:
      c.destroy<fixed_bitstring<44, false, true>>();
      break;
    case types::nr_ntn_tai_info:
      c.destroy<nr_ntn_tai_info_s>();
      break;
    default:
      break;
  }
}
void user_location_info_nr_ext_ies_o::ext_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::pscell_info:
      c.init<ngran_cgi_c>();
      break;
    case types::n_id:
      c.init<fixed_bitstring<44, false, true>>();
      break;
    case types::nr_ntn_tai_info:
      c.init<nr_ntn_tai_info_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "user_location_info_nr_ext_ies_o::ext_c");
  }
}
user_location_info_nr_ext_ies_o::ext_c::ext_c(const user_location_info_nr_ext_ies_o::ext_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::pscell_info:
      c.init(other.c.get<ngran_cgi_c>());
      break;
    case types::n_id:
      c.init(other.c.get<fixed_bitstring<44, false, true>>());
      break;
    case types::nr_ntn_tai_info:
      c.init(other.c.get<nr_ntn_tai_info_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "user_location_info_nr_ext_ies_o::ext_c");
  }
}
user_location_info_nr_ext_ies_o::ext_c&
user_location_info_nr_ext_ies_o::ext_c::operator=(const user_location_info_nr_ext_ies_o::ext_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::pscell_info:
      c.set(other.c.get<ngran_cgi_c>());
      break;
    case types::n_id:
      c.set(other.c.get<fixed_bitstring<44, false, true>>());
      break;
    case types::nr_ntn_tai_info:
      c.set(other.c.get<nr_ntn_tai_info_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "user_location_info_nr_ext_ies_o::ext_c");
  }

  return *this;
}
ngran_cgi_c& user_location_info_nr_ext_ies_o::ext_c::pscell_info()
{
  assert_choice_type(types::pscell_info, type_, "Extension");
  return c.get<ngran_cgi_c>();
}
fixed_bitstring<44, false, true>& user_location_info_nr_ext_ies_o::ext_c::n_id()
{
  assert_choice_type(types::n_id, type_, "Extension");
  return c.get<fixed_bitstring<44, false, true>>();
}
nr_ntn_tai_info_s& user_location_info_nr_ext_ies_o::ext_c::nr_ntn_tai_info()
{
  assert_choice_type(types::nr_ntn_tai_info, type_, "Extension");
  return c.get<nr_ntn_tai_info_s>();
}
const ngran_cgi_c& user_location_info_nr_ext_ies_o::ext_c::pscell_info() const
{
  assert_choice_type(types::pscell_info, type_, "Extension");
  return c.get<ngran_cgi_c>();
}
const fixed_bitstring<44, false, true>& user_location_info_nr_ext_ies_o::ext_c::n_id() const
{
  assert_choice_type(types::n_id, type_, "Extension");
  return c.get<fixed_bitstring<44, false, true>>();
}
const nr_ntn_tai_info_s& user_location_info_nr_ext_ies_o::ext_c::nr_ntn_tai_info() const
{
  assert_choice_type(types::nr_ntn_tai_info, type_, "Extension");
  return c.get<nr_ntn_tai_info_s>();
}
void user_location_info_nr_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::pscell_info:
      j.write_fieldname("NGRAN-CGI");
      c.get<ngran_cgi_c>().to_json(j);
      break;
    case types::n_id:
      j.write_str("BIT STRING", c.get<fixed_bitstring<44, false, true>>().to_string());
      break;
    case types::nr_ntn_tai_info:
      j.write_fieldname("NRNTNTAIInformation");
      c.get<nr_ntn_tai_info_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "user_location_info_nr_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE user_location_info_nr_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::pscell_info:
      HANDLE_CODE(c.get<ngran_cgi_c>().pack(bref));
      break;
    case types::n_id:
      HANDLE_CODE((c.get<fixed_bitstring<44, false, true>>().pack(bref)));
      break;
    case types::nr_ntn_tai_info:
      HANDLE_CODE(c.get<nr_ntn_tai_info_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "user_location_info_nr_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE user_location_info_nr_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::pscell_info:
      HANDLE_CODE(c.get<ngran_cgi_c>().unpack(bref));
      break;
    case types::n_id:
      HANDLE_CODE((c.get<fixed_bitstring<44, false, true>>().unpack(bref)));
      break;
    case types::nr_ntn_tai_info:
      HANDLE_CODE(c.get<nr_ntn_tai_info_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "user_location_info_nr_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* user_location_info_nr_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"NGRAN-CGI", "BIT STRING", "NRNTNTAIInformation"};
  return convert_enum_idx(names, 3, value, "user_location_info_nr_ext_ies_o::ext_c::types");
}

// UserLocationInformationTNGF ::= SEQUENCE
SRSASN_CODE user_location_info_tngf_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(port_num_present, 1));
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(tnap_id.pack(bref));
  HANDLE_CODE(ip_address.pack(bref));
  if (port_num_present) {
    HANDLE_CODE(port_num.pack(bref));
  }
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE user_location_info_tngf_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(port_num_present, 1));
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(tnap_id.unpack(bref));
  HANDLE_CODE(ip_address.unpack(bref));
  if (port_num_present) {
    HANDLE_CODE(port_num.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void user_location_info_tngf_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("tNAP-ID", tnap_id.to_string());
  j.write_str("iPAddress", ip_address.to_string());
  if (port_num_present) {
    j.write_str("portNumber", port_num.to_string());
  }
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// UserLocationInformationTWIF ::= SEQUENCE
SRSASN_CODE user_location_info_twif_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(port_num_present, 1));
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(twap_id.pack(bref));
  HANDLE_CODE(ip_address.pack(bref));
  if (port_num_present) {
    HANDLE_CODE(port_num.pack(bref));
  }
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE user_location_info_twif_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(port_num_present, 1));
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(twap_id.unpack(bref));
  HANDLE_CODE(ip_address.unpack(bref));
  if (port_num_present) {
    HANDLE_CODE(port_num.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void user_location_info_twif_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("tWAP-ID", twap_id.to_string());
  j.write_str("iPAddress", ip_address.to_string());
  if (port_num_present) {
    j.write_str("portNumber", port_num.to_string());
  }
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

template struct asn1::protocol_ie_single_container_s<user_location_info_w_agf_ext_ies_o>;

// UserLocationInformationW-AGF ::= CHOICE
void user_location_info_w_agf_c::destroy_()
{
  switch (type_) {
    case types::global_line_id:
      c.destroy<global_line_id_s>();
      break;
    case types::hfc_node_id:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<user_location_info_w_agf_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void user_location_info_w_agf_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::global_line_id:
      c.init<global_line_id_s>();
      break;
    case types::hfc_node_id:
      c.init<unbounded_octstring<true>>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<user_location_info_w_agf_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "user_location_info_w_agf_c");
  }
}
user_location_info_w_agf_c::user_location_info_w_agf_c(const user_location_info_w_agf_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::global_line_id:
      c.init(other.c.get<global_line_id_s>());
      break;
    case types::hfc_node_id:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<user_location_info_w_agf_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "user_location_info_w_agf_c");
  }
}
user_location_info_w_agf_c& user_location_info_w_agf_c::operator=(const user_location_info_w_agf_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::global_line_id:
      c.set(other.c.get<global_line_id_s>());
      break;
    case types::hfc_node_id:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<user_location_info_w_agf_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "user_location_info_w_agf_c");
  }

  return *this;
}
global_line_id_s& user_location_info_w_agf_c::set_global_line_id()
{
  set(types::global_line_id);
  return c.get<global_line_id_s>();
}
unbounded_octstring<true>& user_location_info_w_agf_c::set_hfc_node_id()
{
  set(types::hfc_node_id);
  return c.get<unbounded_octstring<true>>();
}
protocol_ie_single_container_s<user_location_info_w_agf_ext_ies_o>& user_location_info_w_agf_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<user_location_info_w_agf_ext_ies_o>>();
}
void user_location_info_w_agf_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::global_line_id:
      j.write_fieldname("globalLine-ID");
      c.get<global_line_id_s>().to_json(j);
      break;
    case types::hfc_node_id:
      j.write_str("hFCNode-ID", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<user_location_info_w_agf_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "user_location_info_w_agf_c");
  }
  j.end_obj();
}
SRSASN_CODE user_location_info_w_agf_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::global_line_id:
      HANDLE_CODE(c.get<global_line_id_s>().pack(bref));
      break;
    case types::hfc_node_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<user_location_info_w_agf_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "user_location_info_w_agf_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE user_location_info_w_agf_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::global_line_id:
      HANDLE_CODE(c.get<global_line_id_s>().unpack(bref));
      break;
    case types::hfc_node_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<user_location_info_w_agf_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "user_location_info_w_agf_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* user_location_info_w_agf_c::types_opts::to_string() const
{
  static const char* names[] = {"globalLine-ID", "hFCNode-ID", "choice-Extensions"};
  return convert_enum_idx(names, 3, value, "user_location_info_w_agf_c::types");
}

// UserLocationInformation-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t user_location_info_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {244, 248, 243};
  return map_enum_number(names, 3, idx, "id");
}
bool user_location_info_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {244, 248, 243};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e user_location_info_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 244:
      return crit_e::ignore;
    case 248:
      return crit_e::ignore;
    case 243:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
user_location_info_ext_ies_o::value_c user_location_info_ext_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 244:
      ret.set(value_c::types::user_location_info_tngf);
      break;
    case 248:
      ret.set(value_c::types::user_location_info_twif);
      break;
    case 243:
      ret.set(value_c::types::user_location_info_w_agf);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e user_location_info_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 244:
      return presence_e::mandatory;
    case 248:
      return presence_e::mandatory;
    case 243:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void user_location_info_ext_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::user_location_info_tngf:
      c.destroy<user_location_info_tngf_s>();
      break;
    case types::user_location_info_twif:
      c.destroy<user_location_info_twif_s>();
      break;
    case types::user_location_info_w_agf:
      c.destroy<user_location_info_w_agf_c>();
      break;
    default:
      break;
  }
}
void user_location_info_ext_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::user_location_info_tngf:
      c.init<user_location_info_tngf_s>();
      break;
    case types::user_location_info_twif:
      c.init<user_location_info_twif_s>();
      break;
    case types::user_location_info_w_agf:
      c.init<user_location_info_w_agf_c>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "user_location_info_ext_ies_o::value_c");
  }
}
user_location_info_ext_ies_o::value_c::value_c(const user_location_info_ext_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::user_location_info_tngf:
      c.init(other.c.get<user_location_info_tngf_s>());
      break;
    case types::user_location_info_twif:
      c.init(other.c.get<user_location_info_twif_s>());
      break;
    case types::user_location_info_w_agf:
      c.init(other.c.get<user_location_info_w_agf_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "user_location_info_ext_ies_o::value_c");
  }
}
user_location_info_ext_ies_o::value_c&
user_location_info_ext_ies_o::value_c::operator=(const user_location_info_ext_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::user_location_info_tngf:
      c.set(other.c.get<user_location_info_tngf_s>());
      break;
    case types::user_location_info_twif:
      c.set(other.c.get<user_location_info_twif_s>());
      break;
    case types::user_location_info_w_agf:
      c.set(other.c.get<user_location_info_w_agf_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "user_location_info_ext_ies_o::value_c");
  }

  return *this;
}
user_location_info_tngf_s& user_location_info_ext_ies_o::value_c::user_location_info_tngf()
{
  assert_choice_type(types::user_location_info_tngf, type_, "Value");
  return c.get<user_location_info_tngf_s>();
}
user_location_info_twif_s& user_location_info_ext_ies_o::value_c::user_location_info_twif()
{
  assert_choice_type(types::user_location_info_twif, type_, "Value");
  return c.get<user_location_info_twif_s>();
}
user_location_info_w_agf_c& user_location_info_ext_ies_o::value_c::user_location_info_w_agf()
{
  assert_choice_type(types::user_location_info_w_agf, type_, "Value");
  return c.get<user_location_info_w_agf_c>();
}
const user_location_info_tngf_s& user_location_info_ext_ies_o::value_c::user_location_info_tngf() const
{
  assert_choice_type(types::user_location_info_tngf, type_, "Value");
  return c.get<user_location_info_tngf_s>();
}
const user_location_info_twif_s& user_location_info_ext_ies_o::value_c::user_location_info_twif() const
{
  assert_choice_type(types::user_location_info_twif, type_, "Value");
  return c.get<user_location_info_twif_s>();
}
const user_location_info_w_agf_c& user_location_info_ext_ies_o::value_c::user_location_info_w_agf() const
{
  assert_choice_type(types::user_location_info_w_agf, type_, "Value");
  return c.get<user_location_info_w_agf_c>();
}
void user_location_info_ext_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::user_location_info_tngf:
      j.write_fieldname("UserLocationInformationTNGF");
      c.get<user_location_info_tngf_s>().to_json(j);
      break;
    case types::user_location_info_twif:
      j.write_fieldname("UserLocationInformationTWIF");
      c.get<user_location_info_twif_s>().to_json(j);
      break;
    case types::user_location_info_w_agf:
      j.write_fieldname("UserLocationInformationW-AGF");
      c.get<user_location_info_w_agf_c>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "user_location_info_ext_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE user_location_info_ext_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::user_location_info_tngf:
      HANDLE_CODE(c.get<user_location_info_tngf_s>().pack(bref));
      break;
    case types::user_location_info_twif:
      HANDLE_CODE(c.get<user_location_info_twif_s>().pack(bref));
      break;
    case types::user_location_info_w_agf:
      HANDLE_CODE(c.get<user_location_info_w_agf_c>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "user_location_info_ext_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE user_location_info_ext_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::user_location_info_tngf:
      HANDLE_CODE(c.get<user_location_info_tngf_s>().unpack(bref));
      break;
    case types::user_location_info_twif:
      HANDLE_CODE(c.get<user_location_info_twif_s>().unpack(bref));
      break;
    case types::user_location_info_w_agf:
      HANDLE_CODE(c.get<user_location_info_w_agf_c>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "user_location_info_ext_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* user_location_info_ext_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {
      "UserLocationInformationTNGF", "UserLocationInformationTWIF", "UserLocationInformationW-AGF"};
  return convert_enum_idx(names, 3, value, "user_location_info_ext_ies_o::value_c::types");
}

// UserLocationInformationEUTRA ::= SEQUENCE
SRSASN_CODE user_location_info_eutra_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(time_stamp_present, 1));
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(eutra_cgi.pack(bref));
  HANDLE_CODE(tai.pack(bref));
  if (time_stamp_present) {
    HANDLE_CODE(time_stamp.pack(bref));
  }
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE user_location_info_eutra_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(time_stamp_present, 1));
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(eutra_cgi.unpack(bref));
  HANDLE_CODE(tai.unpack(bref));
  if (time_stamp_present) {
    HANDLE_CODE(time_stamp.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void user_location_info_eutra_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("eUTRA-CGI");
  eutra_cgi.to_json(j);
  j.write_fieldname("tAI");
  tai.to_json(j);
  if (time_stamp_present) {
    j.write_str("timeStamp", time_stamp.to_string());
  }
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// UserLocationInformationN3IWF ::= SEQUENCE
SRSASN_CODE user_location_info_n3_iwf_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(ip_address.pack(bref));
  HANDLE_CODE(port_num.pack(bref));
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE user_location_info_n3_iwf_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(ip_address.unpack(bref));
  HANDLE_CODE(port_num.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void user_location_info_n3_iwf_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("iPAddress", ip_address.to_string());
  j.write_str("portNumber", port_num.to_string());
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

template struct asn1::protocol_ext_field_s<user_location_info_nr_ext_ies_o>;

user_location_info_nr_ext_ies_container::user_location_info_nr_ext_ies_container() :
  pscell_info(149, crit_e::ignore), n_id(263, crit_e::reject), nr_ntn_tai_info(287, crit_e::ignore)
{
}
SRSASN_CODE user_location_info_nr_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += pscell_info_present ? 1 : 0;
  nof_ies += n_id_present ? 1 : 0;
  nof_ies += nr_ntn_tai_info_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (pscell_info_present) {
    HANDLE_CODE(pscell_info.pack(bref));
  }
  if (n_id_present) {
    HANDLE_CODE(n_id.pack(bref));
  }
  if (nr_ntn_tai_info_present) {
    HANDLE_CODE(nr_ntn_tai_info.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE user_location_info_nr_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 149: {
        pscell_info_present = true;
        pscell_info.id      = id;
        HANDLE_CODE(pscell_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pscell_info.ext.unpack(bref));
        break;
      }
      case 263: {
        n_id_present = true;
        n_id.id      = id;
        HANDLE_CODE(n_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(n_id.ext.unpack(bref));
        break;
      }
      case 287: {
        nr_ntn_tai_info_present = true;
        nr_ntn_tai_info.id      = id;
        HANDLE_CODE(nr_ntn_tai_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nr_ntn_tai_info.ext.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void user_location_info_nr_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (pscell_info_present) {
    j.write_fieldname("");
    pscell_info.to_json(j);
  }
  if (n_id_present) {
    j.write_fieldname("");
    n_id.to_json(j);
  }
  if (nr_ntn_tai_info_present) {
    j.write_fieldname("");
    nr_ntn_tai_info.to_json(j);
  }
  j.end_obj();
}

// UserLocationInformationNR ::= SEQUENCE
SRSASN_CODE user_location_info_nr_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(time_stamp_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(nr_cgi.pack(bref));
  HANDLE_CODE(tai.pack(bref));
  if (time_stamp_present) {
    HANDLE_CODE(time_stamp.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE user_location_info_nr_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(time_stamp_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(nr_cgi.unpack(bref));
  HANDLE_CODE(tai.unpack(bref));
  if (time_stamp_present) {
    HANDLE_CODE(time_stamp.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void user_location_info_nr_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("nR-CGI");
  nr_cgi.to_json(j);
  j.write_fieldname("tAI");
  tai.to_json(j);
  if (time_stamp_present) {
    j.write_str("timeStamp", time_stamp.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// NotifySourceNGRANNode ::= ENUMERATED
const char* notify_source_ngran_node_opts::to_string() const
{
  static const char* names[] = {"notifySource"};
  return convert_enum_idx(names, 1, value, "notify_source_ngran_node_e");
}

template struct asn1::protocol_ie_single_container_s<user_location_info_ext_ies_o>;

// UserLocationInformation ::= CHOICE
void user_location_info_c::destroy_()
{
  switch (type_) {
    case types::user_location_info_eutra:
      c.destroy<user_location_info_eutra_s>();
      break;
    case types::user_location_info_nr:
      c.destroy<user_location_info_nr_s>();
      break;
    case types::user_location_info_n3_iwf:
      c.destroy<user_location_info_n3_iwf_s>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<user_location_info_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void user_location_info_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::user_location_info_eutra:
      c.init<user_location_info_eutra_s>();
      break;
    case types::user_location_info_nr:
      c.init<user_location_info_nr_s>();
      break;
    case types::user_location_info_n3_iwf:
      c.init<user_location_info_n3_iwf_s>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<user_location_info_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "user_location_info_c");
  }
}
user_location_info_c::user_location_info_c(const user_location_info_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::user_location_info_eutra:
      c.init(other.c.get<user_location_info_eutra_s>());
      break;
    case types::user_location_info_nr:
      c.init(other.c.get<user_location_info_nr_s>());
      break;
    case types::user_location_info_n3_iwf:
      c.init(other.c.get<user_location_info_n3_iwf_s>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<user_location_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "user_location_info_c");
  }
}
user_location_info_c& user_location_info_c::operator=(const user_location_info_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::user_location_info_eutra:
      c.set(other.c.get<user_location_info_eutra_s>());
      break;
    case types::user_location_info_nr:
      c.set(other.c.get<user_location_info_nr_s>());
      break;
    case types::user_location_info_n3_iwf:
      c.set(other.c.get<user_location_info_n3_iwf_s>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<user_location_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "user_location_info_c");
  }

  return *this;
}
user_location_info_eutra_s& user_location_info_c::set_user_location_info_eutra()
{
  set(types::user_location_info_eutra);
  return c.get<user_location_info_eutra_s>();
}
user_location_info_nr_s& user_location_info_c::set_user_location_info_nr()
{
  set(types::user_location_info_nr);
  return c.get<user_location_info_nr_s>();
}
user_location_info_n3_iwf_s& user_location_info_c::set_user_location_info_n3_iwf()
{
  set(types::user_location_info_n3_iwf);
  return c.get<user_location_info_n3_iwf_s>();
}
protocol_ie_single_container_s<user_location_info_ext_ies_o>& user_location_info_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<user_location_info_ext_ies_o>>();
}
void user_location_info_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::user_location_info_eutra:
      j.write_fieldname("userLocationInformationEUTRA");
      c.get<user_location_info_eutra_s>().to_json(j);
      break;
    case types::user_location_info_nr:
      j.write_fieldname("userLocationInformationNR");
      c.get<user_location_info_nr_s>().to_json(j);
      break;
    case types::user_location_info_n3_iwf:
      j.write_fieldname("userLocationInformationN3IWF");
      c.get<user_location_info_n3_iwf_s>().to_json(j);
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<user_location_info_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "user_location_info_c");
  }
  j.end_obj();
}
SRSASN_CODE user_location_info_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::user_location_info_eutra:
      HANDLE_CODE(c.get<user_location_info_eutra_s>().pack(bref));
      break;
    case types::user_location_info_nr:
      HANDLE_CODE(c.get<user_location_info_nr_s>().pack(bref));
      break;
    case types::user_location_info_n3_iwf:
      HANDLE_CODE(c.get<user_location_info_n3_iwf_s>().pack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<user_location_info_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "user_location_info_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE user_location_info_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::user_location_info_eutra:
      HANDLE_CODE(c.get<user_location_info_eutra_s>().unpack(bref));
      break;
    case types::user_location_info_nr:
      HANDLE_CODE(c.get<user_location_info_nr_s>().unpack(bref));
      break;
    case types::user_location_info_n3_iwf:
      HANDLE_CODE(c.get<user_location_info_n3_iwf_s>().unpack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<user_location_info_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "user_location_info_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* user_location_info_c::types_opts::to_string() const
{
  static const char* names[] = {
      "userLocationInformationEUTRA", "userLocationInformationNR", "userLocationInformationN3IWF", "choice-Extensions"};
  return convert_enum_idx(names, 4, value, "user_location_info_c::types");
}
uint8_t user_location_info_c::types_opts::to_number() const
{
  if (value == user_location_info_n3_iwf) {
    return 3;
  }
  invalid_enum_number(value, "user_location_info_c::types");
  return 0;
}

// HandoverNotifyIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ho_notify_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 121, 269};
  return map_enum_number(names, 4, idx, "id");
}
bool ho_notify_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 121, 269};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ho_notify_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 121:
      return crit_e::ignore;
    case 269:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ho_notify_ies_o::value_c ho_notify_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 121:
      ret.set(value_c::types::user_location_info);
      break;
    case 269:
      ret.set(value_c::types::notify_source_ngran_node);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ho_notify_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 121:
      return presence_e::mandatory;
    case 269:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ho_notify_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::user_location_info:
      c.destroy<user_location_info_c>();
      break;
    default:
      break;
  }
}
void ho_notify_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::user_location_info:
      c.init<user_location_info_c>();
      break;
    case types::notify_source_ngran_node:
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_notify_ies_o::value_c");
  }
}
ho_notify_ies_o::value_c::value_c(const ho_notify_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::user_location_info:
      c.init(other.c.get<user_location_info_c>());
      break;
    case types::notify_source_ngran_node:
      c.init(other.c.get<notify_source_ngran_node_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_notify_ies_o::value_c");
  }
}
ho_notify_ies_o::value_c& ho_notify_ies_o::value_c::operator=(const ho_notify_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::user_location_info:
      c.set(other.c.get<user_location_info_c>());
      break;
    case types::notify_source_ngran_node:
      c.set(other.c.get<notify_source_ngran_node_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_notify_ies_o::value_c");
  }

  return *this;
}
uint64_t& ho_notify_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ho_notify_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
user_location_info_c& ho_notify_ies_o::value_c::user_location_info()
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
notify_source_ngran_node_e& ho_notify_ies_o::value_c::notify_source_ngran_node()
{
  assert_choice_type(types::notify_source_ngran_node, type_, "Value");
  return c.get<notify_source_ngran_node_e>();
}
const uint64_t& ho_notify_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ho_notify_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const user_location_info_c& ho_notify_ies_o::value_c::user_location_info() const
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
const notify_source_ngran_node_e& ho_notify_ies_o::value_c::notify_source_ngran_node() const
{
  assert_choice_type(types::notify_source_ngran_node, type_, "Value");
  return c.get<notify_source_ngran_node_e>();
}
void ho_notify_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::user_location_info:
      j.write_fieldname("UserLocationInformation");
      c.get<user_location_info_c>().to_json(j);
      break;
    case types::notify_source_ngran_node:
      j.write_str("NotifySourceNGRANNode", "notifySource");
      break;
    default:
      log_invalid_choice_id(type_, "ho_notify_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ho_notify_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().pack(bref));
      break;
    case types::notify_source_ngran_node:
      HANDLE_CODE(c.get<notify_source_ngran_node_e>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_notify_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_notify_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().unpack(bref));
      break;
    case types::notify_source_ngran_node:
      HANDLE_CODE(c.get<notify_source_ngran_node_e>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_notify_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ho_notify_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {
      "INTEGER (0..1099511627775)", "INTEGER (0..4294967295)", "UserLocationInformation", "NotifySourceNGRANNode"};
  return convert_enum_idx(names, 4, value, "ho_notify_ies_o::value_c::types");
}

template struct asn1::protocol_ie_field_s<ho_notify_ies_o>;

ho_notify_ies_container::ho_notify_ies_container() :
  amf_ue_ngap_id(10, crit_e::reject),
  ran_ue_ngap_id(85, crit_e::reject),
  user_location_info(121, crit_e::ignore),
  notify_source_ngran_node(269, crit_e::ignore)
{
}
SRSASN_CODE ho_notify_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += notify_source_ngran_node_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  HANDLE_CODE(user_location_info.pack(bref));
  if (notify_source_ngran_node_present) {
    HANDLE_CODE(notify_source_ngran_node.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_notify_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 121: {
        nof_mandatory_ies--;
        user_location_info.id = id;
        HANDLE_CODE(user_location_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(user_location_info.value.unpack(bref));
        break;
      }
      case 269: {
        notify_source_ngran_node_present = true;
        notify_source_ngran_node.id      = id;
        HANDLE_CODE(notify_source_ngran_node.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(notify_source_ngran_node.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ho_notify_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  user_location_info.to_json(j);
  if (notify_source_ngran_node_present) {
    j.write_fieldname("");
    notify_source_ngran_node.to_json(j);
  }
  j.end_obj();
}

// HandoverPreparationFailureIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ho_prep_fail_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 15, 19, 262};
  return map_enum_number(names, 5, idx, "id");
}
bool ho_prep_fail_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 15, 19, 262};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ho_prep_fail_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::ignore;
    case 85:
      return crit_e::ignore;
    case 15:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    case 262:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ho_prep_fail_ies_o::value_c ho_prep_fail_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 15:
      ret.set(value_c::types::cause);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    case 262:
      ret.set(value_c::types::targetto_source_fail_transparent_container);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ho_prep_fail_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 15:
      return presence_e::mandatory;
    case 19:
      return presence_e::optional;
    case 262:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ho_prep_fail_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::cause:
      c.destroy<cause_c>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    case types::targetto_source_fail_transparent_container:
      c.destroy<unbounded_octstring<true>>();
      break;
    default:
      break;
  }
}
void ho_prep_fail_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::cause:
      c.init<cause_c>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::targetto_source_fail_transparent_container:
      c.init<unbounded_octstring<true>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_prep_fail_ies_o::value_c");
  }
}
ho_prep_fail_ies_o::value_c::value_c(const ho_prep_fail_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::targetto_source_fail_transparent_container:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_prep_fail_ies_o::value_c");
  }
}
ho_prep_fail_ies_o::value_c& ho_prep_fail_ies_o::value_c::operator=(const ho_prep_fail_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::targetto_source_fail_transparent_container:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_prep_fail_ies_o::value_c");
  }

  return *this;
}
uint64_t& ho_prep_fail_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ho_prep_fail_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
cause_c& ho_prep_fail_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
crit_diagnostics_s& ho_prep_fail_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
unbounded_octstring<true>& ho_prep_fail_ies_o::value_c::targetto_source_fail_transparent_container()
{
  assert_choice_type(types::targetto_source_fail_transparent_container, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const uint64_t& ho_prep_fail_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ho_prep_fail_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const cause_c& ho_prep_fail_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const crit_diagnostics_s& ho_prep_fail_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const unbounded_octstring<true>& ho_prep_fail_ies_o::value_c::targetto_source_fail_transparent_container() const
{
  assert_choice_type(types::targetto_source_fail_transparent_container, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
void ho_prep_fail_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    case types::targetto_source_fail_transparent_container:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "ho_prep_fail_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ho_prep_fail_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    case types::targetto_source_fail_transparent_container:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_prep_fail_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_prep_fail_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    case types::targetto_source_fail_transparent_container:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_prep_fail_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ho_prep_fail_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {
      "INTEGER (0..1099511627775)", "INTEGER (0..4294967295)", "Cause", "CriticalityDiagnostics", "OCTET STRING"};
  return convert_enum_idx(names, 5, value, "ho_prep_fail_ies_o::value_c::types");
}

template struct asn1::protocol_ie_field_s<ho_prep_fail_ies_o>;

ho_prep_fail_ies_container::ho_prep_fail_ies_container() :
  amf_ue_ngap_id(10, crit_e::ignore),
  ran_ue_ngap_id(85, crit_e::ignore),
  cause(15, crit_e::ignore),
  crit_diagnostics(19, crit_e::ignore),
  targetto_source_fail_transparent_container(262, crit_e::ignore)
{
}
SRSASN_CODE ho_prep_fail_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  nof_ies += targetto_source_fail_transparent_container_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  HANDLE_CODE(cause.pack(bref));
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }
  if (targetto_source_fail_transparent_container_present) {
    HANDLE_CODE(targetto_source_fail_transparent_container.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_prep_fail_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 15: {
        nof_mandatory_ies--;
        cause.id = id;
        HANDLE_CODE(cause.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.value.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        crit_diagnostics.id      = id;
        HANDLE_CODE(crit_diagnostics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.value.unpack(bref));
        break;
      }
      case 262: {
        targetto_source_fail_transparent_container_present = true;
        targetto_source_fail_transparent_container.id      = id;
        HANDLE_CODE(targetto_source_fail_transparent_container.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(targetto_source_fail_transparent_container.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ho_prep_fail_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  cause.to_json(j);
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  if (targetto_source_fail_transparent_container_present) {
    j.write_fieldname("");
    targetto_source_fail_transparent_container.to_json(j);
  }
  j.end_obj();
}

// HandoverPreparationUnsuccessfulTransfer ::= SEQUENCE
SRSASN_CODE ho_prep_unsuccessful_transfer_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(cause.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_prep_unsuccessful_transfer_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(cause.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ho_prep_unsuccessful_transfer_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("cause");
  cause.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// ExtendedReportIntervalMDT ::= ENUMERATED
const char* extended_report_interv_mdt_opts::to_string() const
{
  static const char* names[] = {"ms20480", "ms40960"};
  return convert_enum_idx(names, 2, value, "extended_report_interv_mdt_e");
}
uint16_t extended_report_interv_mdt_opts::to_number() const
{
  static const uint16_t numbers[] = {20480, 40960};
  return map_enum_number(numbers, 2, value, "extended_report_interv_mdt_e");
}

// SensorNameConfig ::= CHOICE
void sensor_name_cfg_c::destroy_()
{
  switch (type_) {
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<sensor_name_cfg_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void sensor_name_cfg_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::uncompensated_barometric_cfg:
      break;
    case types::ue_speed_cfg:
      break;
    case types::ue_orientation_cfg:
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<sensor_name_cfg_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "sensor_name_cfg_c");
  }
}
sensor_name_cfg_c::sensor_name_cfg_c(const sensor_name_cfg_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::uncompensated_barometric_cfg:
      c.init(other.c.get<uncompensated_barometric_cfg_e_>());
      break;
    case types::ue_speed_cfg:
      c.init(other.c.get<ue_speed_cfg_e_>());
      break;
    case types::ue_orientation_cfg:
      c.init(other.c.get<ue_orientation_cfg_e_>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<sensor_name_cfg_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "sensor_name_cfg_c");
  }
}
sensor_name_cfg_c& sensor_name_cfg_c::operator=(const sensor_name_cfg_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::uncompensated_barometric_cfg:
      c.set(other.c.get<uncompensated_barometric_cfg_e_>());
      break;
    case types::ue_speed_cfg:
      c.set(other.c.get<ue_speed_cfg_e_>());
      break;
    case types::ue_orientation_cfg:
      c.set(other.c.get<ue_orientation_cfg_e_>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<sensor_name_cfg_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "sensor_name_cfg_c");
  }

  return *this;
}
sensor_name_cfg_c::uncompensated_barometric_cfg_e_& sensor_name_cfg_c::set_uncompensated_barometric_cfg()
{
  set(types::uncompensated_barometric_cfg);
  return c.get<uncompensated_barometric_cfg_e_>();
}
sensor_name_cfg_c::ue_speed_cfg_e_& sensor_name_cfg_c::set_ue_speed_cfg()
{
  set(types::ue_speed_cfg);
  return c.get<ue_speed_cfg_e_>();
}
sensor_name_cfg_c::ue_orientation_cfg_e_& sensor_name_cfg_c::set_ue_orientation_cfg()
{
  set(types::ue_orientation_cfg);
  return c.get<ue_orientation_cfg_e_>();
}
protocol_ie_single_container_s<sensor_name_cfg_ext_ies_o>& sensor_name_cfg_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<sensor_name_cfg_ext_ies_o>>();
}
void sensor_name_cfg_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::uncompensated_barometric_cfg:
      j.write_str("uncompensatedBarometricConfig", "true");
      break;
    case types::ue_speed_cfg:
      j.write_str("ueSpeedConfig", "true");
      break;
    case types::ue_orientation_cfg:
      j.write_str("ueOrientationConfig", "true");
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<sensor_name_cfg_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "sensor_name_cfg_c");
  }
  j.end_obj();
}
SRSASN_CODE sensor_name_cfg_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::uncompensated_barometric_cfg:
      HANDLE_CODE(c.get<uncompensated_barometric_cfg_e_>().pack(bref));
      break;
    case types::ue_speed_cfg:
      HANDLE_CODE(c.get<ue_speed_cfg_e_>().pack(bref));
      break;
    case types::ue_orientation_cfg:
      HANDLE_CODE(c.get<ue_orientation_cfg_e_>().pack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<sensor_name_cfg_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "sensor_name_cfg_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE sensor_name_cfg_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::uncompensated_barometric_cfg:
      HANDLE_CODE(c.get<uncompensated_barometric_cfg_e_>().unpack(bref));
      break;
    case types::ue_speed_cfg:
      HANDLE_CODE(c.get<ue_speed_cfg_e_>().unpack(bref));
      break;
    case types::ue_orientation_cfg:
      HANDLE_CODE(c.get<ue_orientation_cfg_e_>().unpack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<sensor_name_cfg_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "sensor_name_cfg_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* sensor_name_cfg_c::uncompensated_barometric_cfg_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "sensor_name_cfg_c::uncompensated_barometric_cfg_e_");
}

const char* sensor_name_cfg_c::ue_speed_cfg_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "sensor_name_cfg_c::ue_speed_cfg_e_");
}

const char* sensor_name_cfg_c::ue_orientation_cfg_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "sensor_name_cfg_c::ue_orientation_cfg_e_");
}

const char* sensor_name_cfg_c::types_opts::to_string() const
{
  static const char* names[] = {
      "uncompensatedBarometricConfig", "ueSpeedConfig", "ueOrientationConfig", "choice-Extensions"};
  return convert_enum_idx(names, 4, value, "sensor_name_cfg_c::types");
}

// IncludeBeamMeasurementsIndication ::= ENUMERATED
const char* include_beam_meass_ind_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "include_beam_meass_ind_e");
}

// M1PeriodicReporting-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t m1_periodic_report_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {285};
  return map_enum_number(names, 1, idx, "id");
}
bool m1_periodic_report_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 285 == id;
}
crit_e m1_periodic_report_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 285) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
m1_periodic_report_ext_ies_o::ext_c m1_periodic_report_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 285) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e m1_periodic_report_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 285) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void m1_periodic_report_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("ExtendedReportIntervalMDT", c.to_string());
  j.end_obj();
}
SRSASN_CODE m1_periodic_report_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE m1_periodic_report_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* m1_periodic_report_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"ExtendedReportIntervalMDT"};
  return convert_enum_idx(names, 1, value, "m1_periodic_report_ext_ies_o::ext_c::types");
}

// M1ThresholdType ::= CHOICE
void m1_thres_type_c::destroy_()
{
  switch (type_) {
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<m1_thres_type_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void m1_thres_type_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::thres_rsrp:
      break;
    case types::thres_rsrq:
      break;
    case types::thres_sinr:
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<m1_thres_type_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "m1_thres_type_c");
  }
}
m1_thres_type_c::m1_thres_type_c(const m1_thres_type_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::thres_rsrp:
      c.init(other.c.get<uint8_t>());
      break;
    case types::thres_rsrq:
      c.init(other.c.get<uint8_t>());
      break;
    case types::thres_sinr:
      c.init(other.c.get<uint8_t>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<m1_thres_type_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "m1_thres_type_c");
  }
}
m1_thres_type_c& m1_thres_type_c::operator=(const m1_thres_type_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::thres_rsrp:
      c.set(other.c.get<uint8_t>());
      break;
    case types::thres_rsrq:
      c.set(other.c.get<uint8_t>());
      break;
    case types::thres_sinr:
      c.set(other.c.get<uint8_t>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<m1_thres_type_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "m1_thres_type_c");
  }

  return *this;
}
uint8_t& m1_thres_type_c::set_thres_rsrp()
{
  set(types::thres_rsrp);
  return c.get<uint8_t>();
}
uint8_t& m1_thres_type_c::set_thres_rsrq()
{
  set(types::thres_rsrq);
  return c.get<uint8_t>();
}
uint8_t& m1_thres_type_c::set_thres_sinr()
{
  set(types::thres_sinr);
  return c.get<uint8_t>();
}
protocol_ie_single_container_s<m1_thres_type_ext_ies_o>& m1_thres_type_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<m1_thres_type_ext_ies_o>>();
}
void m1_thres_type_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::thres_rsrp:
      j.write_int("threshold-RSRP", c.get<uint8_t>());
      break;
    case types::thres_rsrq:
      j.write_int("threshold-RSRQ", c.get<uint8_t>());
      break;
    case types::thres_sinr:
      j.write_int("threshold-SINR", c.get<uint8_t>());
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<m1_thres_type_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "m1_thres_type_c");
  }
  j.end_obj();
}
SRSASN_CODE m1_thres_type_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::thres_rsrp:
      HANDLE_CODE(pack_integer(bref, c.get<uint8_t>(), (uint8_t)0u, (uint8_t)127u, false, true));
      break;
    case types::thres_rsrq:
      HANDLE_CODE(pack_integer(bref, c.get<uint8_t>(), (uint8_t)0u, (uint8_t)127u, false, true));
      break;
    case types::thres_sinr:
      HANDLE_CODE(pack_integer(bref, c.get<uint8_t>(), (uint8_t)0u, (uint8_t)127u, false, true));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<m1_thres_type_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "m1_thres_type_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE m1_thres_type_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::thres_rsrp:
      HANDLE_CODE(unpack_integer(c.get<uint8_t>(), bref, (uint8_t)0u, (uint8_t)127u, false, true));
      break;
    case types::thres_rsrq:
      HANDLE_CODE(unpack_integer(c.get<uint8_t>(), bref, (uint8_t)0u, (uint8_t)127u, false, true));
      break;
    case types::thres_sinr:
      HANDLE_CODE(unpack_integer(c.get<uint8_t>(), bref, (uint8_t)0u, (uint8_t)127u, false, true));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<m1_thres_type_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "m1_thres_type_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* m1_thres_type_c::types_opts::to_string() const
{
  static const char* names[] = {"threshold-RSRP", "threshold-RSRQ", "threshold-SINR", "choice-Extensions"};
  return convert_enum_idx(names, 4, value, "m1_thres_type_c::types");
}

// M4ReportAmountMDT ::= ENUMERATED
const char* m4_report_amount_mdt_opts::to_string() const
{
  static const char* names[] = {"r1", "r2", "r4", "r8", "r16", "r32", "r64", "infinity"};
  return convert_enum_idx(names, 8, value, "m4_report_amount_mdt_e");
}
int8_t m4_report_amount_mdt_opts::to_number() const
{
  static const int8_t numbers[] = {1, 2, 4, 8, 16, 32, 64, -1};
  return map_enum_number(numbers, 8, value, "m4_report_amount_mdt_e");
}

// M5ReportAmountMDT ::= ENUMERATED
const char* m5_report_amount_mdt_opts::to_string() const
{
  static const char* names[] = {"r1", "r2", "r4", "r8", "r16", "r32", "r64", "infinity"};
  return convert_enum_idx(names, 8, value, "m5_report_amount_mdt_e");
}
int8_t m5_report_amount_mdt_opts::to_number() const
{
  static const int8_t numbers[] = {1, 2, 4, 8, 16, 32, 64, -1};
  return map_enum_number(numbers, 8, value, "m5_report_amount_mdt_e");
}

// M6ReportAmountMDT ::= ENUMERATED
const char* m6_report_amount_mdt_opts::to_string() const
{
  static const char* names[] = {"r1", "r2", "r4", "r8", "r16", "r32", "r64", "infinity"};
  return convert_enum_idx(names, 8, value, "m6_report_amount_mdt_e");
}
int8_t m6_report_amount_mdt_opts::to_number() const
{
  static const int8_t numbers[] = {1, 2, 4, 8, 16, 32, 64, -1};
  return map_enum_number(numbers, 8, value, "m6_report_amount_mdt_e");
}

// M7ReportAmountMDT ::= ENUMERATED
const char* m7_report_amount_mdt_opts::to_string() const
{
  static const char* names[] = {"r1", "r2", "r4", "r8", "r16", "r32", "r64", "infinity"};
  return convert_enum_idx(names, 8, value, "m7_report_amount_mdt_e");
}
int8_t m7_report_amount_mdt_opts::to_number() const
{
  static const int8_t numbers[] = {1, 2, 4, 8, 16, 32, 64, -1};
  return map_enum_number(numbers, 8, value, "m7_report_amount_mdt_e");
}

// ReportAmountMDT ::= ENUMERATED
const char* report_amount_mdt_opts::to_string() const
{
  static const char* names[] = {"r1", "r2", "r4", "r8", "r16", "r32", "r64", "rinfinity"};
  return convert_enum_idx(names, 8, value, "report_amount_mdt_e");
}
int8_t report_amount_mdt_opts::to_number() const
{
  static const int8_t numbers[] = {1, 2, 4, 8, 16, 32, 64, -1};
  return map_enum_number(numbers, 8, value, "report_amount_mdt_e");
}

// ReportIntervalMDT ::= ENUMERATED
const char* report_interv_mdt_opts::to_string() const
{
  static const char* names[] = {"ms120",
                                "ms240",
                                "ms480",
                                "ms640",
                                "ms1024",
                                "ms2048",
                                "ms5120",
                                "ms10240",
                                "min1",
                                "min6",
                                "min12",
                                "min30",
                                "min60"};
  return convert_enum_idx(names, 13, value, "report_interv_mdt_e");
}
uint16_t report_interv_mdt_opts::to_number() const
{
  static const uint16_t numbers[] = {120, 240, 480, 640, 1024, 2048, 5120, 10240, 1, 6, 12, 30, 60};
  return map_enum_number(numbers, 13, value, "report_interv_mdt_e");
}

// SensorMeasConfigNameItem ::= SEQUENCE
SRSASN_CODE sensor_meas_cfg_name_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(sensor_name_cfg.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE sensor_meas_cfg_name_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(sensor_name_cfg.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void sensor_meas_cfg_name_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("sensorNameConfig");
  sensor_name_cfg.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// WLANMeasConfigNameItem ::= SEQUENCE
SRSASN_CODE wlan_meas_cfg_name_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(wlan_name.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE wlan_meas_cfg_name_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(wlan_name.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void wlan_meas_cfg_name_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("wLANName", wlan_name.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// EarlyMeasurement ::= ENUMERATED
const char* early_meas_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "early_meas_e");
}

// Links-to-log ::= ENUMERATED
const char* links_to_log_opts::to_string() const
{
  static const char* names[] = {"uplink", "downlink", "both-uplink-and-downlink"};
  return convert_enum_idx(names, 3, value, "links_to_log_e");
}

// M1Configuration-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t m1_cfg_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {340, 361};
  return map_enum_number(names, 2, idx, "id");
}
bool m1_cfg_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {340, 361};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e m1_cfg_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 340:
      return crit_e::ignore;
    case 361:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
m1_cfg_ext_ies_o::ext_c m1_cfg_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 340:
      ret.set(ext_c::types::include_beam_meass_ind);
      break;
    case 361:
      ret.set(ext_c::types::beam_meass_report_cfg);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e m1_cfg_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 340:
      return presence_e::optional;
    case 361:
      return presence_e::conditional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void m1_cfg_ext_ies_o::ext_c::destroy_()
{
  switch (type_) {
    case types::beam_meass_report_cfg:
      c.destroy<beam_meass_report_cfg_s>();
      break;
    default:
      break;
  }
}
void m1_cfg_ext_ies_o::ext_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::include_beam_meass_ind:
      break;
    case types::beam_meass_report_cfg:
      c.init<beam_meass_report_cfg_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "m1_cfg_ext_ies_o::ext_c");
  }
}
m1_cfg_ext_ies_o::ext_c::ext_c(const m1_cfg_ext_ies_o::ext_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::include_beam_meass_ind:
      c.init(other.c.get<include_beam_meass_ind_e>());
      break;
    case types::beam_meass_report_cfg:
      c.init(other.c.get<beam_meass_report_cfg_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "m1_cfg_ext_ies_o::ext_c");
  }
}
m1_cfg_ext_ies_o::ext_c& m1_cfg_ext_ies_o::ext_c::operator=(const m1_cfg_ext_ies_o::ext_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::include_beam_meass_ind:
      c.set(other.c.get<include_beam_meass_ind_e>());
      break;
    case types::beam_meass_report_cfg:
      c.set(other.c.get<beam_meass_report_cfg_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "m1_cfg_ext_ies_o::ext_c");
  }

  return *this;
}
include_beam_meass_ind_e& m1_cfg_ext_ies_o::ext_c::include_beam_meass_ind()
{
  assert_choice_type(types::include_beam_meass_ind, type_, "Extension");
  return c.get<include_beam_meass_ind_e>();
}
beam_meass_report_cfg_s& m1_cfg_ext_ies_o::ext_c::beam_meass_report_cfg()
{
  assert_choice_type(types::beam_meass_report_cfg, type_, "Extension");
  return c.get<beam_meass_report_cfg_s>();
}
const include_beam_meass_ind_e& m1_cfg_ext_ies_o::ext_c::include_beam_meass_ind() const
{
  assert_choice_type(types::include_beam_meass_ind, type_, "Extension");
  return c.get<include_beam_meass_ind_e>();
}
const beam_meass_report_cfg_s& m1_cfg_ext_ies_o::ext_c::beam_meass_report_cfg() const
{
  assert_choice_type(types::beam_meass_report_cfg, type_, "Extension");
  return c.get<beam_meass_report_cfg_s>();
}
void m1_cfg_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::include_beam_meass_ind:
      j.write_str("IncludeBeamMeasurementsIndication", "true");
      break;
    case types::beam_meass_report_cfg:
      j.write_fieldname("BeamMeasurementsReportConfiguration");
      c.get<beam_meass_report_cfg_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "m1_cfg_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE m1_cfg_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::include_beam_meass_ind:
      HANDLE_CODE(c.get<include_beam_meass_ind_e>().pack(bref));
      break;
    case types::beam_meass_report_cfg:
      HANDLE_CODE(c.get<beam_meass_report_cfg_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "m1_cfg_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE m1_cfg_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::include_beam_meass_ind:
      HANDLE_CODE(c.get<include_beam_meass_ind_e>().unpack(bref));
      break;
    case types::beam_meass_report_cfg:
      HANDLE_CODE(c.get<beam_meass_report_cfg_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "m1_cfg_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* m1_cfg_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"IncludeBeamMeasurementsIndication", "BeamMeasurementsReportConfiguration"};
  return convert_enum_idx(names, 2, value, "m1_cfg_ext_ies_o::ext_c::types");
}

// M1PeriodicReporting ::= SEQUENCE
SRSASN_CODE m1_periodic_report_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(report_interv.pack(bref));
  HANDLE_CODE(report_amount.pack(bref));
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE m1_periodic_report_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(report_interv.unpack(bref));
  HANDLE_CODE(report_amount.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void m1_periodic_report_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("reportInterval", report_interv.to_string());
  j.write_str("reportAmount", report_amount.to_string());
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// M1ReportingTrigger ::= ENUMERATED
const char* m1_report_trigger_opts::to_string() const
{
  static const char* names[] = {"periodic", "a2eventtriggered", "a2eventtriggered-periodic"};
  return convert_enum_idx(names, 3, value, "m1_report_trigger_e");
}

// M1ThresholdEventA2 ::= SEQUENCE
SRSASN_CODE m1_thres_event_a2_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(m1_thres_type.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE m1_thres_event_a2_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(m1_thres_type.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void m1_thres_event_a2_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("m1ThresholdType");
  m1_thres_type.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// M4Configuration-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t m4_cfg_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {336};
  return map_enum_number(names, 1, idx, "id");
}
bool m4_cfg_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 336 == id;
}
crit_e m4_cfg_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 336) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
m4_cfg_ext_ies_o::ext_c m4_cfg_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 336) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e m4_cfg_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 336) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void m4_cfg_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("M4ReportAmountMDT", c.to_string());
  j.end_obj();
}
SRSASN_CODE m4_cfg_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE m4_cfg_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* m4_cfg_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"M4ReportAmountMDT"};
  return convert_enum_idx(names, 1, value, "m4_cfg_ext_ies_o::ext_c::types");
}
uint8_t m4_cfg_ext_ies_o::ext_c::types_opts::to_number() const
{
  static const uint8_t numbers[] = {4};
  return map_enum_number(numbers, 1, value, "m4_cfg_ext_ies_o::ext_c::types");
}

// M4period ::= ENUMERATED
const char* m4period_opts::to_string() const
{
  static const char* names[] = {"ms1024", "ms2048", "ms5120", "ms10240", "min1"};
  return convert_enum_idx(names, 5, value, "m4period_e");
}
uint16_t m4period_opts::to_number() const
{
  static const uint16_t numbers[] = {1024, 2048, 5120, 10240, 1};
  return map_enum_number(numbers, 5, value, "m4period_e");
}

// M5Configuration-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t m5_cfg_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {337};
  return map_enum_number(names, 1, idx, "id");
}
bool m5_cfg_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 337 == id;
}
crit_e m5_cfg_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 337) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
m5_cfg_ext_ies_o::ext_c m5_cfg_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 337) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e m5_cfg_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 337) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void m5_cfg_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("M5ReportAmountMDT", c.to_string());
  j.end_obj();
}
SRSASN_CODE m5_cfg_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE m5_cfg_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* m5_cfg_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"M5ReportAmountMDT"};
  return convert_enum_idx(names, 1, value, "m5_cfg_ext_ies_o::ext_c::types");
}
uint8_t m5_cfg_ext_ies_o::ext_c::types_opts::to_number() const
{
  static const uint8_t numbers[] = {5};
  return map_enum_number(numbers, 1, value, "m5_cfg_ext_ies_o::ext_c::types");
}

// M5period ::= ENUMERATED
const char* m5period_opts::to_string() const
{
  static const char* names[] = {"ms1024", "ms2048", "ms5120", "ms10240", "min1"};
  return convert_enum_idx(names, 5, value, "m5period_e");
}
uint16_t m5period_opts::to_number() const
{
  static const uint16_t numbers[] = {1024, 2048, 5120, 10240, 1};
  return map_enum_number(numbers, 5, value, "m5period_e");
}

// M6Configuration-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t m6_cfg_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {338, 341};
  return map_enum_number(names, 2, idx, "id");
}
bool m6_cfg_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {338, 341};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e m6_cfg_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 338:
      return crit_e::ignore;
    case 341:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
m6_cfg_ext_ies_o::ext_c m6_cfg_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 338:
      ret.set(ext_c::types::m6_report_amount);
      break;
    case 341:
      ret.set(ext_c::types::excess_packet_delay_thres_cfg);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e m6_cfg_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 338:
      return presence_e::optional;
    case 341:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void m6_cfg_ext_ies_o::ext_c::destroy_()
{
  switch (type_) {
    case types::excess_packet_delay_thres_cfg:
      c.destroy<excess_packet_delay_thres_cfg_l>();
      break;
    default:
      break;
  }
}
void m6_cfg_ext_ies_o::ext_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::m6_report_amount:
      break;
    case types::excess_packet_delay_thres_cfg:
      c.init<excess_packet_delay_thres_cfg_l>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "m6_cfg_ext_ies_o::ext_c");
  }
}
m6_cfg_ext_ies_o::ext_c::ext_c(const m6_cfg_ext_ies_o::ext_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::m6_report_amount:
      c.init(other.c.get<m6_report_amount_mdt_e>());
      break;
    case types::excess_packet_delay_thres_cfg:
      c.init(other.c.get<excess_packet_delay_thres_cfg_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "m6_cfg_ext_ies_o::ext_c");
  }
}
m6_cfg_ext_ies_o::ext_c& m6_cfg_ext_ies_o::ext_c::operator=(const m6_cfg_ext_ies_o::ext_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::m6_report_amount:
      c.set(other.c.get<m6_report_amount_mdt_e>());
      break;
    case types::excess_packet_delay_thres_cfg:
      c.set(other.c.get<excess_packet_delay_thres_cfg_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "m6_cfg_ext_ies_o::ext_c");
  }

  return *this;
}
m6_report_amount_mdt_e& m6_cfg_ext_ies_o::ext_c::m6_report_amount()
{
  assert_choice_type(types::m6_report_amount, type_, "Extension");
  return c.get<m6_report_amount_mdt_e>();
}
excess_packet_delay_thres_cfg_l& m6_cfg_ext_ies_o::ext_c::excess_packet_delay_thres_cfg()
{
  assert_choice_type(types::excess_packet_delay_thres_cfg, type_, "Extension");
  return c.get<excess_packet_delay_thres_cfg_l>();
}
const m6_report_amount_mdt_e& m6_cfg_ext_ies_o::ext_c::m6_report_amount() const
{
  assert_choice_type(types::m6_report_amount, type_, "Extension");
  return c.get<m6_report_amount_mdt_e>();
}
const excess_packet_delay_thres_cfg_l& m6_cfg_ext_ies_o::ext_c::excess_packet_delay_thres_cfg() const
{
  assert_choice_type(types::excess_packet_delay_thres_cfg, type_, "Extension");
  return c.get<excess_packet_delay_thres_cfg_l>();
}
void m6_cfg_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::m6_report_amount:
      j.write_str("M6ReportAmountMDT", c.get<m6_report_amount_mdt_e>().to_string());
      break;
    case types::excess_packet_delay_thres_cfg:
      j.start_array("ExcessPacketDelayThresholdConfiguration");
      for (const auto& e1 : c.get<excess_packet_delay_thres_cfg_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    default:
      log_invalid_choice_id(type_, "m6_cfg_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE m6_cfg_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::m6_report_amount:
      HANDLE_CODE(c.get<m6_report_amount_mdt_e>().pack(bref));
      break;
    case types::excess_packet_delay_thres_cfg:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<excess_packet_delay_thres_cfg_l>(), 1, 255, true));
      break;
    default:
      log_invalid_choice_id(type_, "m6_cfg_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE m6_cfg_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::m6_report_amount:
      HANDLE_CODE(c.get<m6_report_amount_mdt_e>().unpack(bref));
      break;
    case types::excess_packet_delay_thres_cfg:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<excess_packet_delay_thres_cfg_l>(), bref, 1, 255, true));
      break;
    default:
      log_invalid_choice_id(type_, "m6_cfg_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* m6_cfg_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"M6ReportAmountMDT", "ExcessPacketDelayThresholdConfiguration"};
  return convert_enum_idx(names, 2, value, "m6_cfg_ext_ies_o::ext_c::types");
}
uint8_t m6_cfg_ext_ies_o::ext_c::types_opts::to_number() const
{
  static const uint8_t numbers[] = {6};
  return map_enum_number(numbers, 1, value, "m6_cfg_ext_ies_o::ext_c::types");
}

// M6report-Interval ::= ENUMERATED
const char* m6report_interv_opts::to_string() const
{
  static const char* names[] = {"ms120",
                                "ms240",
                                "ms480",
                                "ms640",
                                "ms1024",
                                "ms2048",
                                "ms5120",
                                "ms10240",
                                "ms20480",
                                "ms40960",
                                "min1",
                                "min6",
                                "min12",
                                "min30"};
  return convert_enum_idx(names, 14, value, "m6report_interv_e");
}
uint16_t m6report_interv_opts::to_number() const
{
  static const uint16_t numbers[] = {120, 240, 480, 640, 1024, 2048, 5120, 10240, 20480, 40960, 1, 6, 12, 30};
  return map_enum_number(numbers, 14, value, "m6report_interv_e");
}

// M7Configuration-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t m7_cfg_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {339};
  return map_enum_number(names, 1, idx, "id");
}
bool m7_cfg_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 339 == id;
}
crit_e m7_cfg_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 339) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
m7_cfg_ext_ies_o::ext_c m7_cfg_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 339) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e m7_cfg_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 339) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void m7_cfg_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("M7ReportAmountMDT", c.to_string());
  j.end_obj();
}
SRSASN_CODE m7_cfg_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE m7_cfg_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* m7_cfg_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"M7ReportAmountMDT"};
  return convert_enum_idx(names, 1, value, "m7_cfg_ext_ies_o::ext_c::types");
}
uint8_t m7_cfg_ext_ies_o::ext_c::types_opts::to_number() const
{
  static const uint8_t numbers[] = {7};
  return map_enum_number(numbers, 1, value, "m7_cfg_ext_ies_o::ext_c::types");
}

// SensorMeasConfig ::= ENUMERATED
const char* sensor_meas_cfg_opts::to_string() const
{
  static const char* names[] = {"setup"};
  return convert_enum_idx(names, 1, value, "sensor_meas_cfg_e");
}

// WLANMeasConfig ::= ENUMERATED
const char* wlan_meas_cfg_opts::to_string() const
{
  static const char* names[] = {"setup"};
  return convert_enum_idx(names, 1, value, "wlan_meas_cfg_e");
}

// LoggedMDTNr-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t logged_mdt_nr_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {360};
  return map_enum_number(names, 1, idx, "id");
}
bool logged_mdt_nr_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 360 == id;
}
crit_e logged_mdt_nr_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 360) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
logged_mdt_nr_ext_ies_o::ext_c logged_mdt_nr_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 360) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e logged_mdt_nr_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 360) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void logged_mdt_nr_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("EarlyMeasurement", "true");
  j.end_obj();
}
SRSASN_CODE logged_mdt_nr_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE logged_mdt_nr_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* logged_mdt_nr_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"EarlyMeasurement"};
  return convert_enum_idx(names, 1, value, "logged_mdt_nr_ext_ies_o::ext_c::types");
}

// LoggedMDTTrigger ::= CHOICE
void logged_mdt_trigger_c::destroy_()
{
  switch (type_) {
    case types::event_trigger:
      c.destroy<event_trigger_c>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<logged_mdt_trigger_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void logged_mdt_trigger_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::periodical:
      break;
    case types::event_trigger:
      c.init<event_trigger_c>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<logged_mdt_trigger_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "logged_mdt_trigger_c");
  }
}
logged_mdt_trigger_c::logged_mdt_trigger_c(const logged_mdt_trigger_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::periodical:
      break;
    case types::event_trigger:
      c.init(other.c.get<event_trigger_c>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<logged_mdt_trigger_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "logged_mdt_trigger_c");
  }
}
logged_mdt_trigger_c& logged_mdt_trigger_c::operator=(const logged_mdt_trigger_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::periodical:
      break;
    case types::event_trigger:
      c.set(other.c.get<event_trigger_c>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<logged_mdt_trigger_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "logged_mdt_trigger_c");
  }

  return *this;
}
void logged_mdt_trigger_c::set_periodical()
{
  set(types::periodical);
}
event_trigger_c& logged_mdt_trigger_c::set_event_trigger()
{
  set(types::event_trigger);
  return c.get<event_trigger_c>();
}
protocol_ie_single_container_s<logged_mdt_trigger_ext_ies_o>& logged_mdt_trigger_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<logged_mdt_trigger_ext_ies_o>>();
}
void logged_mdt_trigger_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::periodical:
      break;
    case types::event_trigger:
      j.write_fieldname("eventTrigger");
      c.get<event_trigger_c>().to_json(j);
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<logged_mdt_trigger_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "logged_mdt_trigger_c");
  }
  j.end_obj();
}
SRSASN_CODE logged_mdt_trigger_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::periodical:
      break;
    case types::event_trigger:
      HANDLE_CODE(c.get<event_trigger_c>().pack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<logged_mdt_trigger_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "logged_mdt_trigger_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE logged_mdt_trigger_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::periodical:
      break;
    case types::event_trigger:
      HANDLE_CODE(c.get<event_trigger_c>().unpack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<logged_mdt_trigger_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "logged_mdt_trigger_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* logged_mdt_trigger_c::types_opts::to_string() const
{
  static const char* names[] = {"periodical", "eventTrigger", "choice-Extensions"};
  return convert_enum_idx(names, 3, value, "logged_mdt_trigger_c::types");
}

// LoggingDuration ::= ENUMERATED
const char* logging_dur_opts::to_string() const
{
  static const char* names[] = {"m10", "m20", "m40", "m60", "m90", "m120"};
  return convert_enum_idx(names, 6, value, "logging_dur_e");
}
uint8_t logging_dur_opts::to_number() const
{
  static const uint8_t numbers[] = {10, 20, 40, 60, 90, 120};
  return map_enum_number(numbers, 6, value, "logging_dur_e");
}

// LoggingInterval ::= ENUMERATED
const char* logging_interv_opts::to_string() const
{
  static const char* names[] = {"ms320",
                                "ms640",
                                "ms1280",
                                "ms2560",
                                "ms5120",
                                "ms10240",
                                "ms20480",
                                "ms30720",
                                "ms40960",
                                "ms61440",
                                "infinity"};
  return convert_enum_idx(names, 11, value, "logging_interv_e");
}
int32_t logging_interv_opts::to_number() const
{
  static const int32_t numbers[] = {320, 640, 1280, 2560, 5120, 10240, 20480, 30720, 40960, 61440, -1};
  return map_enum_number(numbers, 11, value, "logging_interv_e");
}

template struct asn1::protocol_ext_field_s<m1_cfg_ext_ies_o>;

m1_cfg_ext_ies_container::m1_cfg_ext_ies_container() :
  include_beam_meass_ind(340, crit_e::ignore), beam_meass_report_cfg(361, crit_e::ignore)
{
}
SRSASN_CODE m1_cfg_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += include_beam_meass_ind_present ? 1 : 0;
  nof_ies += beam_meass_report_cfg_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (include_beam_meass_ind_present) {
    HANDLE_CODE(include_beam_meass_ind.pack(bref));
  }
  if (beam_meass_report_cfg_present) {
    HANDLE_CODE(beam_meass_report_cfg.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE m1_cfg_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 340: {
        include_beam_meass_ind_present = true;
        include_beam_meass_ind.id      = id;
        HANDLE_CODE(include_beam_meass_ind.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(include_beam_meass_ind.ext.unpack(bref));
        break;
      }
      case 361: {
        beam_meass_report_cfg_present = true;
        beam_meass_report_cfg.id      = id;
        HANDLE_CODE(beam_meass_report_cfg.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(beam_meass_report_cfg.ext.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void m1_cfg_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (include_beam_meass_ind_present) {
    j.write_fieldname("");
    include_beam_meass_ind.to_json(j);
  }
  if (beam_meass_report_cfg_present) {
    j.write_fieldname("");
    beam_meass_report_cfg.to_json(j);
  }
  j.end_obj();
}

// M1Configuration ::= SEQUENCE
SRSASN_CODE m1_cfg_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(m1thres_event_a2_present, 1));
  HANDLE_CODE(bref.pack(m1periodic_report_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(m1report_trigger.pack(bref));
  if (m1thres_event_a2_present) {
    HANDLE_CODE(m1thres_event_a2.pack(bref));
  }
  if (m1periodic_report_present) {
    HANDLE_CODE(m1periodic_report.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE m1_cfg_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(m1thres_event_a2_present, 1));
  HANDLE_CODE(bref.unpack(m1periodic_report_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(m1report_trigger.unpack(bref));
  if (m1thres_event_a2_present) {
    HANDLE_CODE(m1thres_event_a2.unpack(bref));
  }
  if (m1periodic_report_present) {
    HANDLE_CODE(m1periodic_report.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void m1_cfg_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("m1reportingTrigger", m1report_trigger.to_string());
  if (m1thres_event_a2_present) {
    j.write_fieldname("m1thresholdEventA2");
    m1thres_event_a2.to_json(j);
  }
  if (m1periodic_report_present) {
    j.write_fieldname("m1periodicReporting");
    m1periodic_report.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// M4Configuration ::= SEQUENCE
SRSASN_CODE m4_cfg_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(m4period.pack(bref));
  HANDLE_CODE(m4_links_to_log.pack(bref));
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE m4_cfg_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(m4period.unpack(bref));
  HANDLE_CODE(m4_links_to_log.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void m4_cfg_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("m4period", m4period.to_string());
  j.write_str("m4-links-to-log", m4_links_to_log.to_string());
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// M5Configuration ::= SEQUENCE
SRSASN_CODE m5_cfg_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(m5period.pack(bref));
  HANDLE_CODE(m5_links_to_log.pack(bref));
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE m5_cfg_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(m5period.unpack(bref));
  HANDLE_CODE(m5_links_to_log.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void m5_cfg_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("m5period", m5period.to_string());
  j.write_str("m5-links-to-log", m5_links_to_log.to_string());
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

template struct asn1::protocol_ext_field_s<m6_cfg_ext_ies_o>;

m6_cfg_ext_ies_container::m6_cfg_ext_ies_container() :
  m6_report_amount(338, crit_e::ignore), excess_packet_delay_thres_cfg(341, crit_e::ignore)
{
}
SRSASN_CODE m6_cfg_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += m6_report_amount_present ? 1 : 0;
  nof_ies += excess_packet_delay_thres_cfg_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (m6_report_amount_present) {
    HANDLE_CODE(m6_report_amount.pack(bref));
  }
  if (excess_packet_delay_thres_cfg_present) {
    HANDLE_CODE(excess_packet_delay_thres_cfg.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE m6_cfg_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 338: {
        m6_report_amount_present = true;
        m6_report_amount.id      = id;
        HANDLE_CODE(m6_report_amount.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(m6_report_amount.ext.unpack(bref));
        break;
      }
      case 341: {
        excess_packet_delay_thres_cfg_present = true;
        excess_packet_delay_thres_cfg.id      = id;
        HANDLE_CODE(excess_packet_delay_thres_cfg.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(excess_packet_delay_thres_cfg.ext.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void m6_cfg_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (m6_report_amount_present) {
    j.write_fieldname("");
    m6_report_amount.to_json(j);
  }
  if (excess_packet_delay_thres_cfg_present) {
    j.write_fieldname("");
    excess_packet_delay_thres_cfg.to_json(j);
  }
  j.end_obj();
}

// M6Configuration ::= SEQUENCE
SRSASN_CODE m6_cfg_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(m6report_interv.pack(bref));
  HANDLE_CODE(m6_links_to_log.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE m6_cfg_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(m6report_interv.unpack(bref));
  HANDLE_CODE(m6_links_to_log.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void m6_cfg_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("m6report-Interval", m6report_interv.to_string());
  j.write_str("m6-links-to-log", m6_links_to_log.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// M7Configuration ::= SEQUENCE
SRSASN_CODE m7_cfg_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(pack_integer(bref, m7period, (uint8_t)1u, (uint8_t)60u, true, true));
  HANDLE_CODE(m7_links_to_log.pack(bref));
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE m7_cfg_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(m7period, bref, (uint8_t)1u, (uint8_t)60u, true, true));
  HANDLE_CODE(m7_links_to_log.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void m7_cfg_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("m7period", m7period);
  j.write_str("m7-links-to-log", m7_links_to_log.to_string());
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// MDT-Location-Info ::= SEQUENCE
SRSASN_CODE mdt_location_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(mdt_location_info.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mdt_location_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(mdt_location_info.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void mdt_location_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("mDT-Location-Information", mdt_location_info.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SensorMeasurementConfiguration ::= SEQUENCE
SRSASN_CODE sensor_meas_cfg_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(sensor_meas_cfg_name_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(sensor_meas_cfg.pack(bref));
  if (sensor_meas_cfg_name_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, sensor_meas_cfg_name_list, 1, 3, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE sensor_meas_cfg_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool sensor_meas_cfg_name_list_present;
  HANDLE_CODE(bref.unpack(sensor_meas_cfg_name_list_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(sensor_meas_cfg.unpack(bref));
  if (sensor_meas_cfg_name_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(sensor_meas_cfg_name_list, bref, 1, 3, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void sensor_meas_cfg_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("sensorMeasConfig", "setup");
  if (sensor_meas_cfg_name_list.size() > 0) {
    j.start_array("sensorMeasConfigNameList");
    for (const auto& e1 : sensor_meas_cfg_name_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// WLANMeasurementConfiguration ::= SEQUENCE
SRSASN_CODE wlan_meas_cfg_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(wlan_meas_cfg_name_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(wlan_rssi_present, 1));
  HANDLE_CODE(bref.pack(wlan_rtt_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(wlan_meas_cfg.pack(bref));
  if (wlan_meas_cfg_name_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, wlan_meas_cfg_name_list, 1, 4, true));
  }
  if (wlan_rssi_present) {
    HANDLE_CODE(wlan_rssi.pack(bref));
  }
  if (wlan_rtt_present) {
    HANDLE_CODE(wlan_rtt.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE wlan_meas_cfg_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool wlan_meas_cfg_name_list_present;
  HANDLE_CODE(bref.unpack(wlan_meas_cfg_name_list_present, 1));
  HANDLE_CODE(bref.unpack(wlan_rssi_present, 1));
  HANDLE_CODE(bref.unpack(wlan_rtt_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(wlan_meas_cfg.unpack(bref));
  if (wlan_meas_cfg_name_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(wlan_meas_cfg_name_list, bref, 1, 4, true));
  }
  if (wlan_rssi_present) {
    HANDLE_CODE(wlan_rssi.unpack(bref));
  }
  if (wlan_rtt_present) {
    HANDLE_CODE(wlan_rtt.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void wlan_meas_cfg_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("wlanMeasConfig", "setup");
  if (wlan_meas_cfg_name_list.size() > 0) {
    j.start_array("wlanMeasConfigNameList");
    for (const auto& e1 : wlan_meas_cfg_name_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (wlan_rssi_present) {
    j.write_str("wlan-rssi", "true");
  }
  if (wlan_rtt_present) {
    j.write_str("wlan-rtt", "true");
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* wlan_meas_cfg_s::wlan_rssi_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "wlan_meas_cfg_s::wlan_rssi_e_");
}

const char* wlan_meas_cfg_s::wlan_rtt_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "wlan_meas_cfg_s::wlan_rtt_e_");
}

// ImmediateMDTNr ::= SEQUENCE
SRSASN_CODE immediate_mdt_nr_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(m1_cfg_present, 1));
  HANDLE_CODE(bref.pack(m4_cfg_present, 1));
  HANDLE_CODE(bref.pack(m5_cfg_present, 1));
  HANDLE_CODE(bref.pack(m6_cfg_present, 1));
  HANDLE_CODE(bref.pack(m7_cfg_present, 1));
  HANDLE_CODE(bref.pack(bluetooth_meas_cfg_present, 1));
  HANDLE_CODE(bref.pack(wlan_meas_cfg_present, 1));
  HANDLE_CODE(bref.pack(mdt_location_info_present, 1));
  HANDLE_CODE(bref.pack(sensor_meas_cfg_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(meass_to_activ.pack(bref));
  if (m1_cfg_present) {
    HANDLE_CODE(m1_cfg.pack(bref));
  }
  if (m4_cfg_present) {
    HANDLE_CODE(m4_cfg.pack(bref));
  }
  if (m5_cfg_present) {
    HANDLE_CODE(m5_cfg.pack(bref));
  }
  if (m6_cfg_present) {
    HANDLE_CODE(m6_cfg.pack(bref));
  }
  if (m7_cfg_present) {
    HANDLE_CODE(m7_cfg.pack(bref));
  }
  if (bluetooth_meas_cfg_present) {
    HANDLE_CODE(bluetooth_meas_cfg.pack(bref));
  }
  if (wlan_meas_cfg_present) {
    HANDLE_CODE(wlan_meas_cfg.pack(bref));
  }
  if (mdt_location_info_present) {
    HANDLE_CODE(mdt_location_info.pack(bref));
  }
  if (sensor_meas_cfg_present) {
    HANDLE_CODE(sensor_meas_cfg.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE immediate_mdt_nr_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(m1_cfg_present, 1));
  HANDLE_CODE(bref.unpack(m4_cfg_present, 1));
  HANDLE_CODE(bref.unpack(m5_cfg_present, 1));
  HANDLE_CODE(bref.unpack(m6_cfg_present, 1));
  HANDLE_CODE(bref.unpack(m7_cfg_present, 1));
  HANDLE_CODE(bref.unpack(bluetooth_meas_cfg_present, 1));
  HANDLE_CODE(bref.unpack(wlan_meas_cfg_present, 1));
  HANDLE_CODE(bref.unpack(mdt_location_info_present, 1));
  HANDLE_CODE(bref.unpack(sensor_meas_cfg_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(meass_to_activ.unpack(bref));
  if (m1_cfg_present) {
    HANDLE_CODE(m1_cfg.unpack(bref));
  }
  if (m4_cfg_present) {
    HANDLE_CODE(m4_cfg.unpack(bref));
  }
  if (m5_cfg_present) {
    HANDLE_CODE(m5_cfg.unpack(bref));
  }
  if (m6_cfg_present) {
    HANDLE_CODE(m6_cfg.unpack(bref));
  }
  if (m7_cfg_present) {
    HANDLE_CODE(m7_cfg.unpack(bref));
  }
  if (bluetooth_meas_cfg_present) {
    HANDLE_CODE(bluetooth_meas_cfg.unpack(bref));
  }
  if (wlan_meas_cfg_present) {
    HANDLE_CODE(wlan_meas_cfg.unpack(bref));
  }
  if (mdt_location_info_present) {
    HANDLE_CODE(mdt_location_info.unpack(bref));
  }
  if (sensor_meas_cfg_present) {
    HANDLE_CODE(sensor_meas_cfg.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void immediate_mdt_nr_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("measurementsToActivate", meass_to_activ.to_string());
  if (m1_cfg_present) {
    j.write_fieldname("m1Configuration");
    m1_cfg.to_json(j);
  }
  if (m4_cfg_present) {
    j.write_fieldname("m4Configuration");
    m4_cfg.to_json(j);
  }
  if (m5_cfg_present) {
    j.write_fieldname("m5Configuration");
    m5_cfg.to_json(j);
  }
  if (m6_cfg_present) {
    j.write_fieldname("m6Configuration");
    m6_cfg.to_json(j);
  }
  if (m7_cfg_present) {
    j.write_fieldname("m7Configuration");
    m7_cfg.to_json(j);
  }
  if (bluetooth_meas_cfg_present) {
    j.write_fieldname("bluetoothMeasurementConfiguration");
    bluetooth_meas_cfg.to_json(j);
  }
  if (wlan_meas_cfg_present) {
    j.write_fieldname("wLANMeasurementConfiguration");
    wlan_meas_cfg.to_json(j);
  }
  if (mdt_location_info_present) {
    j.write_fieldname("mDT-Location-Info");
    mdt_location_info.to_json(j);
  }
  if (sensor_meas_cfg_present) {
    j.write_fieldname("sensorMeasurementConfiguration");
    sensor_meas_cfg.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// LoggedMDTNr ::= SEQUENCE
SRSASN_CODE logged_mdt_nr_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(bluetooth_meas_cfg_present, 1));
  HANDLE_CODE(bref.pack(wlan_meas_cfg_present, 1));
  HANDLE_CODE(bref.pack(sensor_meas_cfg_present, 1));
  HANDLE_CODE(bref.pack(area_scope_of_neigh_cells_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(logging_interv.pack(bref));
  HANDLE_CODE(logging_dur.pack(bref));
  HANDLE_CODE(logged_mdt_trigger.pack(bref));
  if (bluetooth_meas_cfg_present) {
    HANDLE_CODE(bluetooth_meas_cfg.pack(bref));
  }
  if (wlan_meas_cfg_present) {
    HANDLE_CODE(wlan_meas_cfg.pack(bref));
  }
  if (sensor_meas_cfg_present) {
    HANDLE_CODE(sensor_meas_cfg.pack(bref));
  }
  if (area_scope_of_neigh_cells_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, area_scope_of_neigh_cells_list, 1, 8, true));
  }
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE logged_mdt_nr_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(bluetooth_meas_cfg_present, 1));
  HANDLE_CODE(bref.unpack(wlan_meas_cfg_present, 1));
  HANDLE_CODE(bref.unpack(sensor_meas_cfg_present, 1));
  bool area_scope_of_neigh_cells_list_present;
  HANDLE_CODE(bref.unpack(area_scope_of_neigh_cells_list_present, 1));
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(logging_interv.unpack(bref));
  HANDLE_CODE(logging_dur.unpack(bref));
  HANDLE_CODE(logged_mdt_trigger.unpack(bref));
  if (bluetooth_meas_cfg_present) {
    HANDLE_CODE(bluetooth_meas_cfg.unpack(bref));
  }
  if (wlan_meas_cfg_present) {
    HANDLE_CODE(wlan_meas_cfg.unpack(bref));
  }
  if (sensor_meas_cfg_present) {
    HANDLE_CODE(sensor_meas_cfg.unpack(bref));
  }
  if (area_scope_of_neigh_cells_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(area_scope_of_neigh_cells_list, bref, 1, 8, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void logged_mdt_nr_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("loggingInterval", logging_interv.to_string());
  j.write_str("loggingDuration", logging_dur.to_string());
  j.write_fieldname("loggedMDTTrigger");
  logged_mdt_trigger.to_json(j);
  if (bluetooth_meas_cfg_present) {
    j.write_fieldname("bluetoothMeasurementConfiguration");
    bluetooth_meas_cfg.to_json(j);
  }
  if (wlan_meas_cfg_present) {
    j.write_fieldname("wLANMeasurementConfiguration");
    wlan_meas_cfg.to_json(j);
  }
  if (sensor_meas_cfg_present) {
    j.write_fieldname("sensorMeasurementConfiguration");
    sensor_meas_cfg.to_json(j);
  }
  if (area_scope_of_neigh_cells_list.size() > 0) {
    j.start_array("areaScopeOfNeighCellsList");
    for (const auto& e1 : area_scope_of_neigh_cells_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// MDT-Activation ::= ENUMERATED
const char* mdt_activation_opts::to_string() const
{
  static const char* names[] = {"immediate-MDT-only", "logged-MDT-only", "immediate-MDT-and-Trace"};
  return convert_enum_idx(names, 3, value, "mdt_activation_e");
}

// MDTModeNr ::= CHOICE
void mdt_mode_nr_c::destroy_()
{
  switch (type_) {
    case types::immediate_mdt_nr:
      c.destroy<immediate_mdt_nr_s>();
      break;
    case types::logged_mdt_nr:
      c.destroy<logged_mdt_nr_s>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<mdt_mode_nr_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void mdt_mode_nr_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::immediate_mdt_nr:
      c.init<immediate_mdt_nr_s>();
      break;
    case types::logged_mdt_nr:
      c.init<logged_mdt_nr_s>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<mdt_mode_nr_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "mdt_mode_nr_c");
  }
}
mdt_mode_nr_c::mdt_mode_nr_c(const mdt_mode_nr_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::immediate_mdt_nr:
      c.init(other.c.get<immediate_mdt_nr_s>());
      break;
    case types::logged_mdt_nr:
      c.init(other.c.get<logged_mdt_nr_s>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<mdt_mode_nr_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "mdt_mode_nr_c");
  }
}
mdt_mode_nr_c& mdt_mode_nr_c::operator=(const mdt_mode_nr_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::immediate_mdt_nr:
      c.set(other.c.get<immediate_mdt_nr_s>());
      break;
    case types::logged_mdt_nr:
      c.set(other.c.get<logged_mdt_nr_s>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<mdt_mode_nr_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "mdt_mode_nr_c");
  }

  return *this;
}
immediate_mdt_nr_s& mdt_mode_nr_c::set_immediate_mdt_nr()
{
  set(types::immediate_mdt_nr);
  return c.get<immediate_mdt_nr_s>();
}
logged_mdt_nr_s& mdt_mode_nr_c::set_logged_mdt_nr()
{
  set(types::logged_mdt_nr);
  return c.get<logged_mdt_nr_s>();
}
protocol_ie_single_container_s<mdt_mode_nr_ext_ies_o>& mdt_mode_nr_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<mdt_mode_nr_ext_ies_o>>();
}
void mdt_mode_nr_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::immediate_mdt_nr:
      j.write_fieldname("immediateMDTNr");
      c.get<immediate_mdt_nr_s>().to_json(j);
      break;
    case types::logged_mdt_nr:
      j.write_fieldname("loggedMDTNr");
      c.get<logged_mdt_nr_s>().to_json(j);
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<mdt_mode_nr_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "mdt_mode_nr_c");
  }
  j.end_obj();
}
SRSASN_CODE mdt_mode_nr_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::immediate_mdt_nr:
      HANDLE_CODE(c.get<immediate_mdt_nr_s>().pack(bref));
      break;
    case types::logged_mdt_nr:
      HANDLE_CODE(c.get<logged_mdt_nr_s>().pack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<mdt_mode_nr_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "mdt_mode_nr_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE mdt_mode_nr_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::immediate_mdt_nr:
      HANDLE_CODE(c.get<immediate_mdt_nr_s>().unpack(bref));
      break;
    case types::logged_mdt_nr:
      HANDLE_CODE(c.get<logged_mdt_nr_s>().unpack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<mdt_mode_nr_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "mdt_mode_nr_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* mdt_mode_nr_c::types_opts::to_string() const
{
  static const char* names[] = {"immediateMDTNr", "loggedMDTNr", "choice-Extensions"};
  return convert_enum_idx(names, 3, value, "mdt_mode_nr_c::types");
}

// MDT-Configuration-EUTRA ::= SEQUENCE
SRSASN_CODE mdt_cfg_eutra_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(sig_based_mdt_plmn_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(mdt_activation.pack(bref));
  HANDLE_CODE(area_scope_of_mdt.pack(bref));
  HANDLE_CODE(mdt_mode.pack(bref));
  if (sig_based_mdt_plmn_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, sig_based_mdt_plmn_list, 1, 16, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mdt_cfg_eutra_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool sig_based_mdt_plmn_list_present;
  HANDLE_CODE(bref.unpack(sig_based_mdt_plmn_list_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(mdt_activation.unpack(bref));
  HANDLE_CODE(area_scope_of_mdt.unpack(bref));
  HANDLE_CODE(mdt_mode.unpack(bref));
  if (sig_based_mdt_plmn_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(sig_based_mdt_plmn_list, bref, 1, 16, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void mdt_cfg_eutra_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("mdt-Activation", mdt_activation.to_string());
  j.write_fieldname("areaScopeOfMDT");
  area_scope_of_mdt.to_json(j);
  j.write_str("mDTMode", mdt_mode.to_string());
  if (sig_based_mdt_plmn_list.size() > 0) {
    j.start_array("signallingBasedMDTPLMNList");
    for (const auto& e1 : sig_based_mdt_plmn_list) {
      j.write_str(e1.to_string());
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MDT-Configuration-NR ::= SEQUENCE
SRSASN_CODE mdt_cfg_nr_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(sig_based_mdt_plmn_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(mdt_activation.pack(bref));
  HANDLE_CODE(area_scope_of_mdt.pack(bref));
  HANDLE_CODE(mdt_mode_nr.pack(bref));
  if (sig_based_mdt_plmn_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, sig_based_mdt_plmn_list, 1, 16, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mdt_cfg_nr_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool sig_based_mdt_plmn_list_present;
  HANDLE_CODE(bref.unpack(sig_based_mdt_plmn_list_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(mdt_activation.unpack(bref));
  HANDLE_CODE(area_scope_of_mdt.unpack(bref));
  HANDLE_CODE(mdt_mode_nr.unpack(bref));
  if (sig_based_mdt_plmn_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(sig_based_mdt_plmn_list, bref, 1, 16, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void mdt_cfg_nr_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("mdt-Activation", mdt_activation.to_string());
  j.write_fieldname("areaScopeOfMDT");
  area_scope_of_mdt.to_json(j);
  j.write_fieldname("mDTModeNr");
  mdt_mode_nr.to_json(j);
  if (sig_based_mdt_plmn_list.size() > 0) {
    j.start_array("signallingBasedMDTPLMNList");
    for (const auto& e1 : sig_based_mdt_plmn_list) {
      j.write_str(e1.to_string());
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PC5FlowBitRates ::= SEQUENCE
SRSASN_CODE pc5_flow_bit_rates_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, guaranteed_flow_bit_rate, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  HANDLE_CODE(pack_integer(bref, max_flow_bit_rate, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pc5_flow_bit_rates_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(guaranteed_flow_bit_rate, bref, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  HANDLE_CODE(unpack_integer(max_flow_bit_rate, bref, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pc5_flow_bit_rates_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("guaranteedFlowBitRate", guaranteed_flow_bit_rate);
  j.write_int("maximumFlowBitRate", max_flow_bit_rate);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// LocationReportingAdditionalInfo ::= ENUMERATED
const char* location_report_add_info_opts::to_string() const
{
  static const char* names[] = {"includePSCell"};
  return convert_enum_idx(names, 1, value, "location_report_add_info_e");
}

// MDT-Configuration ::= SEQUENCE
SRSASN_CODE mdt_cfg_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(mdt_cfg_nr_present, 1));
  HANDLE_CODE(bref.pack(mdt_cfg_eutra_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (mdt_cfg_nr_present) {
    HANDLE_CODE(mdt_cfg_nr.pack(bref));
  }
  if (mdt_cfg_eutra_present) {
    HANDLE_CODE(mdt_cfg_eutra.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mdt_cfg_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(mdt_cfg_nr_present, 1));
  HANDLE_CODE(bref.unpack(mdt_cfg_eutra_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (mdt_cfg_nr_present) {
    HANDLE_CODE(mdt_cfg_nr.unpack(bref));
  }
  if (mdt_cfg_eutra_present) {
    HANDLE_CODE(mdt_cfg_eutra.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void mdt_cfg_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (mdt_cfg_nr_present) {
    j.write_fieldname("mdt-Config-NR");
    mdt_cfg_nr.to_json(j);
  }
  if (mdt_cfg_eutra_present) {
    j.write_fieldname("mdt-Config-EUTRA");
    mdt_cfg_eutra.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PC5QoSFlowItem ::= SEQUENCE
SRSASN_CODE pc5_qos_flow_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(pc5_flow_bit_rates_present, 1));
  HANDLE_CODE(bref.pack(range_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pqi, (uint16_t)0u, (uint16_t)255u, true, true));
  if (pc5_flow_bit_rates_present) {
    HANDLE_CODE(pc5_flow_bit_rates.pack(bref));
  }
  if (range_present) {
    HANDLE_CODE(range.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pc5_qos_flow_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(pc5_flow_bit_rates_present, 1));
  HANDLE_CODE(bref.unpack(range_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pqi, bref, (uint16_t)0u, (uint16_t)255u, true, true));
  if (pc5_flow_bit_rates_present) {
    HANDLE_CODE(pc5_flow_bit_rates.unpack(bref));
  }
  if (range_present) {
    HANDLE_CODE(range.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pc5_qos_flow_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pQI", pqi);
  if (pc5_flow_bit_rates_present) {
    j.write_fieldname("pc5FlowBitRates");
    pc5_flow_bit_rates.to_json(j);
  }
  if (range_present) {
    j.write_str("range", range.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceSetupItemHOReq-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t pdu_session_res_setup_item_ho_req_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {281};
  return map_enum_number(names, 1, idx, "id");
}
bool pdu_session_res_setup_item_ho_req_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 281 == id;
}
crit_e pdu_session_res_setup_item_ho_req_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 281) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
pdu_session_res_setup_item_ho_req_ext_ies_o::ext_c
pdu_session_res_setup_item_ho_req_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 281) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pdu_session_res_setup_item_ho_req_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 281) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void pdu_session_res_setup_item_ho_req_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("ExpectedUEActivityBehaviour");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE pdu_session_res_setup_item_ho_req_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_setup_item_ho_req_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* pdu_session_res_setup_item_ho_req_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"ExpectedUEActivityBehaviour"};
  return convert_enum_idx(names, 1, value, "pdu_session_res_setup_item_ho_req_ext_ies_o::ext_c::types");
}

// EventType ::= ENUMERATED
const char* event_type_opts::to_string() const
{
  static const char* names[] = {"direct",
                                "change-of-serve-cell",
                                "ue-presence-in-area-of-interest",
                                "stop-change-of-serve-cell",
                                "stop-ue-presence-in-area-of-interest",
                                "cancel-location-reporting-for-the-ue"};
  return convert_enum_idx(names, 6, value, "event_type_e");
}

// LocationReportingRequestType-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t location_report_request_type_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {170};
  return map_enum_number(names, 1, idx, "id");
}
bool location_report_request_type_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 170 == id;
}
crit_e location_report_request_type_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 170) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
location_report_request_type_ext_ies_o::ext_c location_report_request_type_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 170) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e location_report_request_type_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 170) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void location_report_request_type_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("LocationReportingAdditionalInfo", "includePSCell");
  j.end_obj();
}
SRSASN_CODE location_report_request_type_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE location_report_request_type_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* location_report_request_type_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"LocationReportingAdditionalInfo"};
  return convert_enum_idx(names, 1, value, "location_report_request_type_ext_ies_o::ext_c::types");
}

// PDUSessionResourceSetupItemHOReq ::= SEQUENCE
SRSASN_CODE pdu_session_res_setup_item_ho_req_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(pack_integer(bref, pdu_session_id, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(s_nssai.pack(bref));
  HANDLE_CODE(ho_request_transfer.pack(bref));
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_setup_item_ho_req_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pdu_session_id, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(s_nssai.unpack(bref));
  HANDLE_CODE(ho_request_transfer.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_setup_item_ho_req_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pDUSessionID", pdu_session_id);
  j.write_fieldname("s-NSSAI");
  s_nssai.to_json(j);
  j.write_str("handoverRequestTransfer", ho_request_transfer.to_string());
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// PedestrianUE ::= ENUMERATED
const char* pedestrian_ue_opts::to_string() const
{
  static const char* names[] = {"authorized", "not-authorized"};
  return convert_enum_idx(names, 2, value, "pedestrian_ue_e");
}

// ReportArea ::= ENUMERATED
const char* report_area_opts::to_string() const
{
  static const char* names[] = {"cell"};
  return convert_enum_idx(names, 1, value, "report_area_e");
}

// TraceActivation-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t trace_activation_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {255, 257};
  return map_enum_number(names, 2, idx, "id");
}
bool trace_activation_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {255, 257};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e trace_activation_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 255:
      return crit_e::ignore;
    case 257:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
trace_activation_ext_ies_o::ext_c trace_activation_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 255:
      ret.set(ext_c::types::mdt_cfg);
      break;
    case 257:
      ret.set(ext_c::types::trace_collection_entity_uri);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e trace_activation_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 255:
      return presence_e::optional;
    case 257:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void trace_activation_ext_ies_o::ext_c::destroy_()
{
  switch (type_) {
    case types::mdt_cfg:
      c.destroy<mdt_cfg_s>();
      break;
    case types::trace_collection_entity_uri:
      c.destroy<visible_string<0, MAX_ASN_STRING_LENGTH, false, true>>();
      break;
    default:
      break;
  }
}
void trace_activation_ext_ies_o::ext_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mdt_cfg:
      c.init<mdt_cfg_s>();
      break;
    case types::trace_collection_entity_uri:
      c.init<visible_string<0, MAX_ASN_STRING_LENGTH, false, true>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "trace_activation_ext_ies_o::ext_c");
  }
}
trace_activation_ext_ies_o::ext_c::ext_c(const trace_activation_ext_ies_o::ext_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mdt_cfg:
      c.init(other.c.get<mdt_cfg_s>());
      break;
    case types::trace_collection_entity_uri:
      c.init(other.c.get<visible_string<0, MAX_ASN_STRING_LENGTH, false, true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "trace_activation_ext_ies_o::ext_c");
  }
}
trace_activation_ext_ies_o::ext_c&
trace_activation_ext_ies_o::ext_c::operator=(const trace_activation_ext_ies_o::ext_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mdt_cfg:
      c.set(other.c.get<mdt_cfg_s>());
      break;
    case types::trace_collection_entity_uri:
      c.set(other.c.get<visible_string<0, MAX_ASN_STRING_LENGTH, false, true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "trace_activation_ext_ies_o::ext_c");
  }

  return *this;
}
mdt_cfg_s& trace_activation_ext_ies_o::ext_c::mdt_cfg()
{
  assert_choice_type(types::mdt_cfg, type_, "Extension");
  return c.get<mdt_cfg_s>();
}
visible_string<0, MAX_ASN_STRING_LENGTH, false, true>& trace_activation_ext_ies_o::ext_c::trace_collection_entity_uri()
{
  assert_choice_type(types::trace_collection_entity_uri, type_, "Extension");
  return c.get<visible_string<0, MAX_ASN_STRING_LENGTH, false, true>>();
}
const mdt_cfg_s& trace_activation_ext_ies_o::ext_c::mdt_cfg() const
{
  assert_choice_type(types::mdt_cfg, type_, "Extension");
  return c.get<mdt_cfg_s>();
}
const visible_string<0, MAX_ASN_STRING_LENGTH, false, true>&
trace_activation_ext_ies_o::ext_c::trace_collection_entity_uri() const
{
  assert_choice_type(types::trace_collection_entity_uri, type_, "Extension");
  return c.get<visible_string<0, MAX_ASN_STRING_LENGTH, false, true>>();
}
void trace_activation_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mdt_cfg:
      j.write_fieldname("MDT-Configuration");
      c.get<mdt_cfg_s>().to_json(j);
      break;
    case types::trace_collection_entity_uri:
      j.write_str("VisibleString", c.get<visible_string<0, MAX_ASN_STRING_LENGTH, false, true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "trace_activation_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE trace_activation_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mdt_cfg:
      HANDLE_CODE(c.get<mdt_cfg_s>().pack(bref));
      break;
    case types::trace_collection_entity_uri:
      HANDLE_CODE((c.get<visible_string<0, MAX_ASN_STRING_LENGTH, false, true>>().pack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "trace_activation_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE trace_activation_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mdt_cfg:
      HANDLE_CODE(c.get<mdt_cfg_s>().unpack(bref));
      break;
    case types::trace_collection_entity_uri:
      HANDLE_CODE((c.get<visible_string<0, MAX_ASN_STRING_LENGTH, false, true>>().unpack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "trace_activation_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* trace_activation_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"MDT-Configuration", "VisibleString"};
  return convert_enum_idx(names, 2, value, "trace_activation_ext_ies_o::ext_c::types");
}

// TraceDepth ::= ENUMERATED
const char* trace_depth_opts::to_string() const
{
  static const char* names[] = {"minimum",
                                "medium",
                                "maximum",
                                "minimumWithoutVendorSpecificExtension",
                                "mediumWithoutVendorSpecificExtension",
                                "maximumWithoutVendorSpecificExtension"};
  return convert_enum_idx(names, 6, value, "trace_depth_e");
}

// UESliceMaximumBitRateItem ::= SEQUENCE
SRSASN_CODE ue_slice_max_bit_rate_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(s_nssai.pack(bref));
  HANDLE_CODE(pack_integer(bref, ue_slice_max_bit_rate_dl, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  HANDLE_CODE(pack_integer(bref, ue_slice_max_bit_rate_ul, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_slice_max_bit_rate_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(s_nssai.unpack(bref));
  HANDLE_CODE(unpack_integer(ue_slice_max_bit_rate_dl, bref, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  HANDLE_CODE(unpack_integer(ue_slice_max_bit_rate_ul, bref, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ue_slice_max_bit_rate_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("s-NSSAI");
  s_nssai.to_json(j);
  j.write_int("uESliceMaximumBitRateDL", ue_slice_max_bit_rate_dl);
  j.write_int("uESliceMaximumBitRateUL", ue_slice_max_bit_rate_ul);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// VehicleUE ::= ENUMERATED
const char* vehicle_ue_opts::to_string() const
{
  static const char* names[] = {"authorized", "not-authorized"};
  return convert_enum_idx(names, 2, value, "vehicle_ue_e");
}

// IAB-Authorized ::= ENUMERATED
const char* iab_authorized_opts::to_string() const
{
  static const char* names[] = {"authorized", "not-authorized"};
  return convert_enum_idx(names, 2, value, "iab_authorized_e");
}

// LTEUESidelinkAggregateMaximumBitrate ::= SEQUENCE
SRSASN_CODE lte_ue_sidelink_aggr_max_bitrate_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, ue_sidelink_aggr_max_bit_rate, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE lte_ue_sidelink_aggr_max_bitrate_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(ue_sidelink_aggr_max_bit_rate, bref, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void lte_ue_sidelink_aggr_max_bitrate_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("uESidelinkAggregateMaximumBitRate", ue_sidelink_aggr_max_bit_rate);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// LTEV2XServicesAuthorized ::= SEQUENCE
SRSASN_CODE ltev2x_services_authorized_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(vehicle_ue_present, 1));
  HANDLE_CODE(bref.pack(pedestrian_ue_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (vehicle_ue_present) {
    HANDLE_CODE(vehicle_ue.pack(bref));
  }
  if (pedestrian_ue_present) {
    HANDLE_CODE(pedestrian_ue.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ltev2x_services_authorized_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(vehicle_ue_present, 1));
  HANDLE_CODE(bref.unpack(pedestrian_ue_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (vehicle_ue_present) {
    HANDLE_CODE(vehicle_ue.unpack(bref));
  }
  if (pedestrian_ue_present) {
    HANDLE_CODE(pedestrian_ue.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ltev2x_services_authorized_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (vehicle_ue_present) {
    j.write_str("vehicleUE", vehicle_ue.to_string());
  }
  if (pedestrian_ue_present) {
    j.write_str("pedestrianUE", pedestrian_ue.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// LocationReportingRequestType ::= SEQUENCE
SRSASN_CODE location_report_request_type_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(area_of_interest_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(location_report_ref_id_to_be_cancelled_present, 1));
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(event_type.pack(bref));
  HANDLE_CODE(report_area.pack(bref));
  if (area_of_interest_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, area_of_interest_list, 1, 64, true));
  }
  if (location_report_ref_id_to_be_cancelled_present) {
    HANDLE_CODE(pack_integer(bref, location_report_ref_id_to_be_cancelled, (uint8_t)1u, (uint8_t)64u, true, true));
  }
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE location_report_request_type_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool area_of_interest_list_present;
  HANDLE_CODE(bref.unpack(area_of_interest_list_present, 1));
  HANDLE_CODE(bref.unpack(location_report_ref_id_to_be_cancelled_present, 1));
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(event_type.unpack(bref));
  HANDLE_CODE(report_area.unpack(bref));
  if (area_of_interest_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(area_of_interest_list, bref, 1, 64, true));
  }
  if (location_report_ref_id_to_be_cancelled_present) {
    HANDLE_CODE(unpack_integer(location_report_ref_id_to_be_cancelled, bref, (uint8_t)1u, (uint8_t)64u, true, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void location_report_request_type_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("eventType", event_type.to_string());
  j.write_str("reportArea", "cell");
  if (area_of_interest_list.size() > 0) {
    j.start_array("areaOfInterestList");
    for (const auto& e1 : area_of_interest_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (location_report_ref_id_to_be_cancelled_present) {
    j.write_int("locationReportingReferenceIDToBeCancelled", location_report_ref_id_to_be_cancelled);
  }
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// NRUESidelinkAggregateMaximumBitrate ::= SEQUENCE
SRSASN_CODE nr_ue_sidelink_aggr_max_bitrate_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, ue_sidelink_aggr_max_bit_rate, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE nr_ue_sidelink_aggr_max_bitrate_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(ue_sidelink_aggr_max_bit_rate, bref, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void nr_ue_sidelink_aggr_max_bitrate_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("uESidelinkAggregateMaximumBitRate", ue_sidelink_aggr_max_bit_rate);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// NRV2XServicesAuthorized ::= SEQUENCE
SRSASN_CODE nr_v2x_services_authorized_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(vehicle_ue_present, 1));
  HANDLE_CODE(bref.pack(pedestrian_ue_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (vehicle_ue_present) {
    HANDLE_CODE(vehicle_ue.pack(bref));
  }
  if (pedestrian_ue_present) {
    HANDLE_CODE(pedestrian_ue.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE nr_v2x_services_authorized_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(vehicle_ue_present, 1));
  HANDLE_CODE(bref.unpack(pedestrian_ue_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (vehicle_ue_present) {
    HANDLE_CODE(vehicle_ue.unpack(bref));
  }
  if (pedestrian_ue_present) {
    HANDLE_CODE(pedestrian_ue.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void nr_v2x_services_authorized_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (vehicle_ue_present) {
    j.write_str("vehicleUE", vehicle_ue.to_string());
  }
  if (pedestrian_ue_present) {
    j.write_str("pedestrianUE", pedestrian_ue.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// NewSecurityContextInd ::= ENUMERATED
const char* new_security_context_ind_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "new_security_context_ind_e");
}

// PC5QoSParameters ::= SEQUENCE
SRSASN_CODE pc5_qos_params_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(pc5_link_aggr_bit_rates_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, pc5_qos_flow_list, 1, 2048, true));
  if (pc5_link_aggr_bit_rates_present) {
    HANDLE_CODE(pack_integer(bref, pc5_link_aggr_bit_rates, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pc5_qos_params_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(pc5_link_aggr_bit_rates_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(pc5_qos_flow_list, bref, 1, 2048, true));
  if (pc5_link_aggr_bit_rates_present) {
    HANDLE_CODE(unpack_integer(pc5_link_aggr_bit_rates, bref, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pc5_qos_params_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("pc5QoSFlowList");
  for (const auto& e1 : pc5_qos_flow_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (pc5_link_aggr_bit_rates_present) {
    j.write_int("pc5LinkAggregateBitRates", pc5_link_aggr_bit_rates);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// RRCInactiveTransitionReportRequest ::= ENUMERATED
const char* rrc_inactive_transition_report_request_opts::to_string() const
{
  static const char* names[] = {
      "subsequent-state-transition-report", "single-rrc-connected-state-report", "cancel-report"};
  return convert_enum_idx(names, 3, value, "rrc_inactive_transition_report_request_e");
}

// RedirectionVoiceFallback ::= ENUMERATED
const char* redirection_voice_fallback_opts::to_string() const
{
  static const char* names[] = {"possible", "not-possible"};
  return convert_enum_idx(names, 2, value, "redirection_voice_fallback_e");
}

// SecurityContext ::= SEQUENCE
SRSASN_CODE security_context_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, next_hop_chaining_count, (uint8_t)0u, (uint8_t)7u, false, true));
  HANDLE_CODE(next_hop_nh.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE security_context_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(next_hop_chaining_count, bref, (uint8_t)0u, (uint8_t)7u, false, true));
  HANDLE_CODE(next_hop_nh.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void security_context_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("nextHopChainingCount", next_hop_chaining_count);
  j.write_str("nextHopNH", next_hop_nh.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TimeSyncAssistanceInfo ::= SEQUENCE
SRSASN_CODE time_sync_assist_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(uu_time_sync_error_budget_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(time_distribution_ind.pack(bref));
  if (uu_time_sync_error_budget_present) {
    HANDLE_CODE(pack_integer(bref, uu_time_sync_error_budget, (uint32_t)1u, (uint32_t)1000000u, true, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE time_sync_assist_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(uu_time_sync_error_budget_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(time_distribution_ind.unpack(bref));
  if (uu_time_sync_error_budget_present) {
    HANDLE_CODE(unpack_integer(uu_time_sync_error_budget, bref, (uint32_t)1u, (uint32_t)1000000u, true, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void time_sync_assist_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("timeDistributionIndication", time_distribution_ind.to_string());
  if (uu_time_sync_error_budget_present) {
    j.write_int("uUTimeSyncErrorBudget", uu_time_sync_error_budget);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* time_sync_assist_info_s::time_distribution_ind_opts::to_string() const
{
  static const char* names[] = {"enabled", "disabled"};
  return convert_enum_idx(names, 2, value, "time_sync_assist_info_s::time_distribution_ind_e_");
}

template struct asn1::protocol_ext_field_s<trace_activation_ext_ies_o>;

trace_activation_ext_ies_container::trace_activation_ext_ies_container() :
  mdt_cfg(255, crit_e::ignore), trace_collection_entity_uri(257, crit_e::ignore)
{
}
SRSASN_CODE trace_activation_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += mdt_cfg_present ? 1 : 0;
  nof_ies += trace_collection_entity_uri_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (mdt_cfg_present) {
    HANDLE_CODE(mdt_cfg.pack(bref));
  }
  if (trace_collection_entity_uri_present) {
    HANDLE_CODE(trace_collection_entity_uri.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE trace_activation_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 255: {
        mdt_cfg_present = true;
        mdt_cfg.id      = id;
        HANDLE_CODE(mdt_cfg.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mdt_cfg.ext.unpack(bref));
        break;
      }
      case 257: {
        trace_collection_entity_uri_present = true;
        trace_collection_entity_uri.id      = id;
        HANDLE_CODE(trace_collection_entity_uri.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(trace_collection_entity_uri.ext.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void trace_activation_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (mdt_cfg_present) {
    j.write_fieldname("");
    mdt_cfg.to_json(j);
  }
  if (trace_collection_entity_uri_present) {
    j.write_fieldname("");
    trace_collection_entity_uri.to_json(j);
  }
  j.end_obj();
}

// TraceActivation ::= SEQUENCE
SRSASN_CODE trace_activation_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(ngran_trace_id.pack(bref));
  HANDLE_CODE(interfaces_to_trace.pack(bref));
  HANDLE_CODE(trace_depth.pack(bref));
  HANDLE_CODE(trace_collection_entity_ip_address.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE trace_activation_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(ngran_trace_id.unpack(bref));
  HANDLE_CODE(interfaces_to_trace.unpack(bref));
  HANDLE_CODE(trace_depth.unpack(bref));
  HANDLE_CODE(trace_collection_entity_ip_address.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void trace_activation_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("nGRANTraceID", ngran_trace_id.to_string());
  j.write_str("interfacesToTrace", interfaces_to_trace.to_string());
  j.write_str("traceDepth", trace_depth.to_string());
  j.write_str("traceCollectionEntityIPAddress", trace_collection_entity_ip_address.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// UE-UP-CIoT-Support ::= ENUMERATED
const char* ue_up_c_iot_support_opts::to_string() const
{
  static const char* names[] = {"supported"};
  return convert_enum_idx(names, 1, value, "ue_up_c_iot_support_e");
}

// UESecurityCapabilities ::= SEQUENCE
SRSASN_CODE ue_security_cap_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(nr_encryption_algorithms.pack(bref));
  HANDLE_CODE(nr_integrity_protection_algorithms.pack(bref));
  HANDLE_CODE(eutr_aencryption_algorithms.pack(bref));
  HANDLE_CODE(eutr_aintegrity_protection_algorithms.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_security_cap_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(nr_encryption_algorithms.unpack(bref));
  HANDLE_CODE(nr_integrity_protection_algorithms.unpack(bref));
  HANDLE_CODE(eutr_aencryption_algorithms.unpack(bref));
  HANDLE_CODE(eutr_aintegrity_protection_algorithms.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ue_security_cap_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("nRencryptionAlgorithms", nr_encryption_algorithms.to_string());
  j.write_str("nRintegrityProtectionAlgorithms", nr_integrity_protection_algorithms.to_string());
  j.write_str("eUTRAencryptionAlgorithms", eutr_aencryption_algorithms.to_string());
  j.write_str("eUTRAintegrityProtectionAlgorithms", eutr_aintegrity_protection_algorithms.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// HandoverRequestIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ho_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10,  29,  15,  110, 18,  119, 93,  41,  37,  73,  0,   108, 34,
                                   101, 36,  33,  91,  28,  146, 165, 177, 199, 205, 209, 216, 215,
                                   218, 217, 219, 222, 234, 254, 264, 206, 326, 335, 345, 346, 347};
  return map_enum_number(names, 39, idx, "id");
}
bool ho_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10,  29,  15,  110, 18,  119, 93,  41,  37,  73,  0,   108, 34,
                                   101, 36,  33,  91,  28,  146, 165, 177, 199, 205, 209, 216, 215,
                                   218, 217, 219, 222, 234, 254, 264, 206, 326, 335, 345, 346, 347};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ho_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 29:
      return crit_e::reject;
    case 15:
      return crit_e::ignore;
    case 110:
      return crit_e::reject;
    case 18:
      return crit_e::ignore;
    case 119:
      return crit_e::reject;
    case 93:
      return crit_e::reject;
    case 41:
      return crit_e::reject;
    case 37:
      return crit_e::reject;
    case 73:
      return crit_e::reject;
    case 0:
      return crit_e::reject;
    case 108:
      return crit_e::ignore;
    case 34:
      return crit_e::ignore;
    case 101:
      return crit_e::reject;
    case 36:
      return crit_e::ignore;
    case 33:
      return crit_e::ignore;
    case 91:
      return crit_e::ignore;
    case 28:
      return crit_e::reject;
    case 146:
      return crit_e::ignore;
    case 165:
      return crit_e::ignore;
    case 177:
      return crit_e::ignore;
    case 199:
      return crit_e::reject;
    case 205:
      return crit_e::ignore;
    case 209:
      return crit_e::ignore;
    case 216:
      return crit_e::ignore;
    case 215:
      return crit_e::ignore;
    case 218:
      return crit_e::ignore;
    case 217:
      return crit_e::ignore;
    case 219:
      return crit_e::ignore;
    case 222:
      return crit_e::ignore;
    case 234:
      return crit_e::ignore;
    case 254:
      return crit_e::ignore;
    case 264:
      return crit_e::reject;
    case 206:
      return crit_e::ignore;
    case 326:
      return crit_e::ignore;
    case 335:
      return crit_e::ignore;
    case 345:
      return crit_e::ignore;
    case 346:
      return crit_e::ignore;
    case 347:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ho_request_ies_o::value_c ho_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 29:
      ret.set(value_c::types::handov_type);
      break;
    case 15:
      ret.set(value_c::types::cause);
      break;
    case 110:
      ret.set(value_c::types::ue_aggr_max_bit_rate);
      break;
    case 18:
      ret.set(value_c::types::core_network_assist_info_for_inactive);
      break;
    case 119:
      ret.set(value_c::types::ue_security_cap);
      break;
    case 93:
      ret.set(value_c::types::security_context);
      break;
    case 41:
      ret.set(value_c::types::new_security_context_ind);
      break;
    case 37:
      ret.set(value_c::types::nasc);
      break;
    case 73:
      ret.set(value_c::types::pdu_session_res_setup_list_ho_req);
      break;
    case 0:
      ret.set(value_c::types::allowed_nssai);
      break;
    case 108:
      ret.set(value_c::types::trace_activation);
      break;
    case 34:
      ret.set(value_c::types::masked_imeisv);
      break;
    case 101:
      ret.set(value_c::types::source_to_target_transparent_container);
      break;
    case 36:
      ret.set(value_c::types::mob_restrict_list);
      break;
    case 33:
      ret.set(value_c::types::location_report_request_type);
      break;
    case 91:
      ret.set(value_c::types::rrc_inactive_transition_report_request);
      break;
    case 28:
      ret.set(value_c::types::guami);
      break;
    case 146:
      ret.set(value_c::types::redirection_voice_fallback);
      break;
    case 165:
      ret.set(value_c::types::cn_assisted_ran_tuning);
      break;
    case 177:
      ret.set(value_c::types::srvcc_operation_possible);
      break;
    case 199:
      ret.set(value_c::types::iab_authorized);
      break;
    case 205:
      ret.set(value_c::types::enhanced_coverage_restrict);
      break;
    case 209:
      ret.set(value_c::types::ue_diff_info);
      break;
    case 216:
      ret.set(value_c::types::nr_v2x_services_authorized);
      break;
    case 215:
      ret.set(value_c::types::ltev2x_services_authorized);
      break;
    case 218:
      ret.set(value_c::types::nr_ue_sidelink_aggr_max_bitrate);
      break;
    case 217:
      ret.set(value_c::types::lte_ue_sidelink_aggr_max_bitrate);
      break;
    case 219:
      ret.set(value_c::types::pc5_qos_params);
      break;
    case 222:
      ret.set(value_c::types::ce_mode_brestricted);
      break;
    case 234:
      ret.set(value_c::types::ue_up_c_iot_support);
      break;
    case 254:
      ret.set(value_c::types::management_based_mdt_plmn_list);
      break;
    case 264:
      ret.set(value_c::types::ue_radio_cap_id);
      break;
    case 206:
      ret.set(value_c::types::extended_connected_time);
      break;
    case 326:
      ret.set(value_c::types::time_sync_assist_info);
      break;
    case 335:
      ret.set(value_c::types::ue_slice_max_bit_rate_list);
      break;
    case 345:
      ret.set(value_c::types::five_g_pro_se_authorized);
      break;
    case 346:
      ret.set(value_c::types::five_g_pro_se_ue_pc5_aggr_max_bit_rate);
      break;
    case 347:
      ret.set(value_c::types::five_g_pro_se_pc5_qos_params);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ho_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 29:
      return presence_e::mandatory;
    case 15:
      return presence_e::mandatory;
    case 110:
      return presence_e::mandatory;
    case 18:
      return presence_e::optional;
    case 119:
      return presence_e::mandatory;
    case 93:
      return presence_e::mandatory;
    case 41:
      return presence_e::optional;
    case 37:
      return presence_e::optional;
    case 73:
      return presence_e::mandatory;
    case 0:
      return presence_e::mandatory;
    case 108:
      return presence_e::optional;
    case 34:
      return presence_e::optional;
    case 101:
      return presence_e::mandatory;
    case 36:
      return presence_e::optional;
    case 33:
      return presence_e::optional;
    case 91:
      return presence_e::optional;
    case 28:
      return presence_e::mandatory;
    case 146:
      return presence_e::optional;
    case 165:
      return presence_e::optional;
    case 177:
      return presence_e::optional;
    case 199:
      return presence_e::optional;
    case 205:
      return presence_e::optional;
    case 209:
      return presence_e::optional;
    case 216:
      return presence_e::optional;
    case 215:
      return presence_e::optional;
    case 218:
      return presence_e::optional;
    case 217:
      return presence_e::optional;
    case 219:
      return presence_e::optional;
    case 222:
      return presence_e::optional;
    case 234:
      return presence_e::optional;
    case 254:
      return presence_e::optional;
    case 264:
      return presence_e::optional;
    case 206:
      return presence_e::optional;
    case 326:
      return presence_e::optional;
    case 335:
      return presence_e::optional;
    case 345:
      return presence_e::optional;
    case 346:
      return presence_e::optional;
    case 347:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ho_request_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::cause:
      c.destroy<cause_c>();
      break;
    case types::ue_aggr_max_bit_rate:
      c.destroy<ue_aggr_max_bit_rate_s>();
      break;
    case types::core_network_assist_info_for_inactive:
      c.destroy<core_network_assist_info_for_inactive_s>();
      break;
    case types::ue_security_cap:
      c.destroy<ue_security_cap_s>();
      break;
    case types::security_context:
      c.destroy<security_context_s>();
      break;
    case types::nasc:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::pdu_session_res_setup_list_ho_req:
      c.destroy<pdu_session_res_setup_list_ho_req_l>();
      break;
    case types::allowed_nssai:
      c.destroy<allowed_nssai_l>();
      break;
    case types::trace_activation:
      c.destroy<trace_activation_s>();
      break;
    case types::masked_imeisv:
      c.destroy<fixed_bitstring<64, false, true>>();
      break;
    case types::source_to_target_transparent_container:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::mob_restrict_list:
      c.destroy<mob_restrict_list_s>();
      break;
    case types::location_report_request_type:
      c.destroy<location_report_request_type_s>();
      break;
    case types::guami:
      c.destroy<guami_s>();
      break;
    case types::cn_assisted_ran_tuning:
      c.destroy<cn_assisted_ran_tuning_s>();
      break;
    case types::ue_diff_info:
      c.destroy<ue_diff_info_s>();
      break;
    case types::nr_v2x_services_authorized:
      c.destroy<nr_v2x_services_authorized_s>();
      break;
    case types::ltev2x_services_authorized:
      c.destroy<ltev2x_services_authorized_s>();
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      c.destroy<nr_ue_sidelink_aggr_max_bitrate_s>();
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      c.destroy<lte_ue_sidelink_aggr_max_bitrate_s>();
      break;
    case types::pc5_qos_params:
      c.destroy<pc5_qos_params_s>();
      break;
    case types::management_based_mdt_plmn_list:
      c.destroy<mdt_plmn_list_l>();
      break;
    case types::ue_radio_cap_id:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::time_sync_assist_info:
      c.destroy<time_sync_assist_info_s>();
      break;
    case types::ue_slice_max_bit_rate_list:
      c.destroy<ue_slice_max_bit_rate_list_l>();
      break;
    case types::five_g_pro_se_authorized:
      c.destroy<five_g_pro_se_authorized_s>();
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      c.destroy<nr_ue_sidelink_aggr_max_bitrate_s>();
      break;
    case types::five_g_pro_se_pc5_qos_params:
      c.destroy<five_g_pro_se_pc5_qos_params_s>();
      break;
    default:
      break;
  }
}
void ho_request_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::handov_type:
      break;
    case types::cause:
      c.init<cause_c>();
      break;
    case types::ue_aggr_max_bit_rate:
      c.init<ue_aggr_max_bit_rate_s>();
      break;
    case types::core_network_assist_info_for_inactive:
      c.init<core_network_assist_info_for_inactive_s>();
      break;
    case types::ue_security_cap:
      c.init<ue_security_cap_s>();
      break;
    case types::security_context:
      c.init<security_context_s>();
      break;
    case types::new_security_context_ind:
      break;
    case types::nasc:
      c.init<unbounded_octstring<true>>();
      break;
    case types::pdu_session_res_setup_list_ho_req:
      c.init<pdu_session_res_setup_list_ho_req_l>();
      break;
    case types::allowed_nssai:
      c.init<allowed_nssai_l>();
      break;
    case types::trace_activation:
      c.init<trace_activation_s>();
      break;
    case types::masked_imeisv:
      c.init<fixed_bitstring<64, false, true>>();
      break;
    case types::source_to_target_transparent_container:
      c.init<unbounded_octstring<true>>();
      break;
    case types::mob_restrict_list:
      c.init<mob_restrict_list_s>();
      break;
    case types::location_report_request_type:
      c.init<location_report_request_type_s>();
      break;
    case types::rrc_inactive_transition_report_request:
      break;
    case types::guami:
      c.init<guami_s>();
      break;
    case types::redirection_voice_fallback:
      break;
    case types::cn_assisted_ran_tuning:
      c.init<cn_assisted_ran_tuning_s>();
      break;
    case types::srvcc_operation_possible:
      break;
    case types::iab_authorized:
      break;
    case types::enhanced_coverage_restrict:
      break;
    case types::ue_diff_info:
      c.init<ue_diff_info_s>();
      break;
    case types::nr_v2x_services_authorized:
      c.init<nr_v2x_services_authorized_s>();
      break;
    case types::ltev2x_services_authorized:
      c.init<ltev2x_services_authorized_s>();
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      c.init<nr_ue_sidelink_aggr_max_bitrate_s>();
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      c.init<lte_ue_sidelink_aggr_max_bitrate_s>();
      break;
    case types::pc5_qos_params:
      c.init<pc5_qos_params_s>();
      break;
    case types::ce_mode_brestricted:
      break;
    case types::ue_up_c_iot_support:
      break;
    case types::management_based_mdt_plmn_list:
      c.init<mdt_plmn_list_l>();
      break;
    case types::ue_radio_cap_id:
      c.init<unbounded_octstring<true>>();
      break;
    case types::extended_connected_time:
      break;
    case types::time_sync_assist_info:
      c.init<time_sync_assist_info_s>();
      break;
    case types::ue_slice_max_bit_rate_list:
      c.init<ue_slice_max_bit_rate_list_l>();
      break;
    case types::five_g_pro_se_authorized:
      c.init<five_g_pro_se_authorized_s>();
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      c.init<nr_ue_sidelink_aggr_max_bitrate_s>();
      break;
    case types::five_g_pro_se_pc5_qos_params:
      c.init<five_g_pro_se_pc5_qos_params_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_request_ies_o::value_c");
  }
}
ho_request_ies_o::value_c::value_c(const ho_request_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::handov_type:
      c.init(other.c.get<handov_type_e>());
      break;
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::ue_aggr_max_bit_rate:
      c.init(other.c.get<ue_aggr_max_bit_rate_s>());
      break;
    case types::core_network_assist_info_for_inactive:
      c.init(other.c.get<core_network_assist_info_for_inactive_s>());
      break;
    case types::ue_security_cap:
      c.init(other.c.get<ue_security_cap_s>());
      break;
    case types::security_context:
      c.init(other.c.get<security_context_s>());
      break;
    case types::new_security_context_ind:
      c.init(other.c.get<new_security_context_ind_e>());
      break;
    case types::nasc:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::pdu_session_res_setup_list_ho_req:
      c.init(other.c.get<pdu_session_res_setup_list_ho_req_l>());
      break;
    case types::allowed_nssai:
      c.init(other.c.get<allowed_nssai_l>());
      break;
    case types::trace_activation:
      c.init(other.c.get<trace_activation_s>());
      break;
    case types::masked_imeisv:
      c.init(other.c.get<fixed_bitstring<64, false, true>>());
      break;
    case types::source_to_target_transparent_container:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::mob_restrict_list:
      c.init(other.c.get<mob_restrict_list_s>());
      break;
    case types::location_report_request_type:
      c.init(other.c.get<location_report_request_type_s>());
      break;
    case types::rrc_inactive_transition_report_request:
      c.init(other.c.get<rrc_inactive_transition_report_request_e>());
      break;
    case types::guami:
      c.init(other.c.get<guami_s>());
      break;
    case types::redirection_voice_fallback:
      c.init(other.c.get<redirection_voice_fallback_e>());
      break;
    case types::cn_assisted_ran_tuning:
      c.init(other.c.get<cn_assisted_ran_tuning_s>());
      break;
    case types::srvcc_operation_possible:
      c.init(other.c.get<srvcc_operation_possible_e>());
      break;
    case types::iab_authorized:
      c.init(other.c.get<iab_authorized_e>());
      break;
    case types::enhanced_coverage_restrict:
      c.init(other.c.get<enhanced_coverage_restrict_e>());
      break;
    case types::ue_diff_info:
      c.init(other.c.get<ue_diff_info_s>());
      break;
    case types::nr_v2x_services_authorized:
      c.init(other.c.get<nr_v2x_services_authorized_s>());
      break;
    case types::ltev2x_services_authorized:
      c.init(other.c.get<ltev2x_services_authorized_s>());
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      c.init(other.c.get<nr_ue_sidelink_aggr_max_bitrate_s>());
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      c.init(other.c.get<lte_ue_sidelink_aggr_max_bitrate_s>());
      break;
    case types::pc5_qos_params:
      c.init(other.c.get<pc5_qos_params_s>());
      break;
    case types::ce_mode_brestricted:
      c.init(other.c.get<ce_mode_brestricted_e>());
      break;
    case types::ue_up_c_iot_support:
      c.init(other.c.get<ue_up_c_iot_support_e>());
      break;
    case types::management_based_mdt_plmn_list:
      c.init(other.c.get<mdt_plmn_list_l>());
      break;
    case types::ue_radio_cap_id:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::extended_connected_time:
      c.init(other.c.get<uint16_t>());
      break;
    case types::time_sync_assist_info:
      c.init(other.c.get<time_sync_assist_info_s>());
      break;
    case types::ue_slice_max_bit_rate_list:
      c.init(other.c.get<ue_slice_max_bit_rate_list_l>());
      break;
    case types::five_g_pro_se_authorized:
      c.init(other.c.get<five_g_pro_se_authorized_s>());
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      c.init(other.c.get<nr_ue_sidelink_aggr_max_bitrate_s>());
      break;
    case types::five_g_pro_se_pc5_qos_params:
      c.init(other.c.get<five_g_pro_se_pc5_qos_params_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_request_ies_o::value_c");
  }
}
ho_request_ies_o::value_c& ho_request_ies_o::value_c::operator=(const ho_request_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::handov_type:
      c.set(other.c.get<handov_type_e>());
      break;
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::ue_aggr_max_bit_rate:
      c.set(other.c.get<ue_aggr_max_bit_rate_s>());
      break;
    case types::core_network_assist_info_for_inactive:
      c.set(other.c.get<core_network_assist_info_for_inactive_s>());
      break;
    case types::ue_security_cap:
      c.set(other.c.get<ue_security_cap_s>());
      break;
    case types::security_context:
      c.set(other.c.get<security_context_s>());
      break;
    case types::new_security_context_ind:
      c.set(other.c.get<new_security_context_ind_e>());
      break;
    case types::nasc:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::pdu_session_res_setup_list_ho_req:
      c.set(other.c.get<pdu_session_res_setup_list_ho_req_l>());
      break;
    case types::allowed_nssai:
      c.set(other.c.get<allowed_nssai_l>());
      break;
    case types::trace_activation:
      c.set(other.c.get<trace_activation_s>());
      break;
    case types::masked_imeisv:
      c.set(other.c.get<fixed_bitstring<64, false, true>>());
      break;
    case types::source_to_target_transparent_container:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::mob_restrict_list:
      c.set(other.c.get<mob_restrict_list_s>());
      break;
    case types::location_report_request_type:
      c.set(other.c.get<location_report_request_type_s>());
      break;
    case types::rrc_inactive_transition_report_request:
      c.set(other.c.get<rrc_inactive_transition_report_request_e>());
      break;
    case types::guami:
      c.set(other.c.get<guami_s>());
      break;
    case types::redirection_voice_fallback:
      c.set(other.c.get<redirection_voice_fallback_e>());
      break;
    case types::cn_assisted_ran_tuning:
      c.set(other.c.get<cn_assisted_ran_tuning_s>());
      break;
    case types::srvcc_operation_possible:
      c.set(other.c.get<srvcc_operation_possible_e>());
      break;
    case types::iab_authorized:
      c.set(other.c.get<iab_authorized_e>());
      break;
    case types::enhanced_coverage_restrict:
      c.set(other.c.get<enhanced_coverage_restrict_e>());
      break;
    case types::ue_diff_info:
      c.set(other.c.get<ue_diff_info_s>());
      break;
    case types::nr_v2x_services_authorized:
      c.set(other.c.get<nr_v2x_services_authorized_s>());
      break;
    case types::ltev2x_services_authorized:
      c.set(other.c.get<ltev2x_services_authorized_s>());
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      c.set(other.c.get<nr_ue_sidelink_aggr_max_bitrate_s>());
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      c.set(other.c.get<lte_ue_sidelink_aggr_max_bitrate_s>());
      break;
    case types::pc5_qos_params:
      c.set(other.c.get<pc5_qos_params_s>());
      break;
    case types::ce_mode_brestricted:
      c.set(other.c.get<ce_mode_brestricted_e>());
      break;
    case types::ue_up_c_iot_support:
      c.set(other.c.get<ue_up_c_iot_support_e>());
      break;
    case types::management_based_mdt_plmn_list:
      c.set(other.c.get<mdt_plmn_list_l>());
      break;
    case types::ue_radio_cap_id:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::extended_connected_time:
      c.set(other.c.get<uint16_t>());
      break;
    case types::time_sync_assist_info:
      c.set(other.c.get<time_sync_assist_info_s>());
      break;
    case types::ue_slice_max_bit_rate_list:
      c.set(other.c.get<ue_slice_max_bit_rate_list_l>());
      break;
    case types::five_g_pro_se_authorized:
      c.set(other.c.get<five_g_pro_se_authorized_s>());
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      c.set(other.c.get<nr_ue_sidelink_aggr_max_bitrate_s>());
      break;
    case types::five_g_pro_se_pc5_qos_params:
      c.set(other.c.get<five_g_pro_se_pc5_qos_params_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_request_ies_o::value_c");
  }

  return *this;
}
uint64_t& ho_request_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
handov_type_e& ho_request_ies_o::value_c::handov_type()
{
  assert_choice_type(types::handov_type, type_, "Value");
  return c.get<handov_type_e>();
}
cause_c& ho_request_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
ue_aggr_max_bit_rate_s& ho_request_ies_o::value_c::ue_aggr_max_bit_rate()
{
  assert_choice_type(types::ue_aggr_max_bit_rate, type_, "Value");
  return c.get<ue_aggr_max_bit_rate_s>();
}
core_network_assist_info_for_inactive_s& ho_request_ies_o::value_c::core_network_assist_info_for_inactive()
{
  assert_choice_type(types::core_network_assist_info_for_inactive, type_, "Value");
  return c.get<core_network_assist_info_for_inactive_s>();
}
ue_security_cap_s& ho_request_ies_o::value_c::ue_security_cap()
{
  assert_choice_type(types::ue_security_cap, type_, "Value");
  return c.get<ue_security_cap_s>();
}
security_context_s& ho_request_ies_o::value_c::security_context()
{
  assert_choice_type(types::security_context, type_, "Value");
  return c.get<security_context_s>();
}
new_security_context_ind_e& ho_request_ies_o::value_c::new_security_context_ind()
{
  assert_choice_type(types::new_security_context_ind, type_, "Value");
  return c.get<new_security_context_ind_e>();
}
unbounded_octstring<true>& ho_request_ies_o::value_c::nasc()
{
  assert_choice_type(types::nasc, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
pdu_session_res_setup_list_ho_req_l& ho_request_ies_o::value_c::pdu_session_res_setup_list_ho_req()
{
  assert_choice_type(types::pdu_session_res_setup_list_ho_req, type_, "Value");
  return c.get<pdu_session_res_setup_list_ho_req_l>();
}
allowed_nssai_l& ho_request_ies_o::value_c::allowed_nssai()
{
  assert_choice_type(types::allowed_nssai, type_, "Value");
  return c.get<allowed_nssai_l>();
}
trace_activation_s& ho_request_ies_o::value_c::trace_activation()
{
  assert_choice_type(types::trace_activation, type_, "Value");
  return c.get<trace_activation_s>();
}
fixed_bitstring<64, false, true>& ho_request_ies_o::value_c::masked_imeisv()
{
  assert_choice_type(types::masked_imeisv, type_, "Value");
  return c.get<fixed_bitstring<64, false, true>>();
}
unbounded_octstring<true>& ho_request_ies_o::value_c::source_to_target_transparent_container()
{
  assert_choice_type(types::source_to_target_transparent_container, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
mob_restrict_list_s& ho_request_ies_o::value_c::mob_restrict_list()
{
  assert_choice_type(types::mob_restrict_list, type_, "Value");
  return c.get<mob_restrict_list_s>();
}
location_report_request_type_s& ho_request_ies_o::value_c::location_report_request_type()
{
  assert_choice_type(types::location_report_request_type, type_, "Value");
  return c.get<location_report_request_type_s>();
}
rrc_inactive_transition_report_request_e& ho_request_ies_o::value_c::rrc_inactive_transition_report_request()
{
  assert_choice_type(types::rrc_inactive_transition_report_request, type_, "Value");
  return c.get<rrc_inactive_transition_report_request_e>();
}
guami_s& ho_request_ies_o::value_c::guami()
{
  assert_choice_type(types::guami, type_, "Value");
  return c.get<guami_s>();
}
redirection_voice_fallback_e& ho_request_ies_o::value_c::redirection_voice_fallback()
{
  assert_choice_type(types::redirection_voice_fallback, type_, "Value");
  return c.get<redirection_voice_fallback_e>();
}
cn_assisted_ran_tuning_s& ho_request_ies_o::value_c::cn_assisted_ran_tuning()
{
  assert_choice_type(types::cn_assisted_ran_tuning, type_, "Value");
  return c.get<cn_assisted_ran_tuning_s>();
}
srvcc_operation_possible_e& ho_request_ies_o::value_c::srvcc_operation_possible()
{
  assert_choice_type(types::srvcc_operation_possible, type_, "Value");
  return c.get<srvcc_operation_possible_e>();
}
iab_authorized_e& ho_request_ies_o::value_c::iab_authorized()
{
  assert_choice_type(types::iab_authorized, type_, "Value");
  return c.get<iab_authorized_e>();
}
enhanced_coverage_restrict_e& ho_request_ies_o::value_c::enhanced_coverage_restrict()
{
  assert_choice_type(types::enhanced_coverage_restrict, type_, "Value");
  return c.get<enhanced_coverage_restrict_e>();
}
ue_diff_info_s& ho_request_ies_o::value_c::ue_diff_info()
{
  assert_choice_type(types::ue_diff_info, type_, "Value");
  return c.get<ue_diff_info_s>();
}
nr_v2x_services_authorized_s& ho_request_ies_o::value_c::nr_v2x_services_authorized()
{
  assert_choice_type(types::nr_v2x_services_authorized, type_, "Value");
  return c.get<nr_v2x_services_authorized_s>();
}
ltev2x_services_authorized_s& ho_request_ies_o::value_c::ltev2x_services_authorized()
{
  assert_choice_type(types::ltev2x_services_authorized, type_, "Value");
  return c.get<ltev2x_services_authorized_s>();
}
nr_ue_sidelink_aggr_max_bitrate_s& ho_request_ies_o::value_c::nr_ue_sidelink_aggr_max_bitrate()
{
  assert_choice_type(types::nr_ue_sidelink_aggr_max_bitrate, type_, "Value");
  return c.get<nr_ue_sidelink_aggr_max_bitrate_s>();
}
lte_ue_sidelink_aggr_max_bitrate_s& ho_request_ies_o::value_c::lte_ue_sidelink_aggr_max_bitrate()
{
  assert_choice_type(types::lte_ue_sidelink_aggr_max_bitrate, type_, "Value");
  return c.get<lte_ue_sidelink_aggr_max_bitrate_s>();
}
pc5_qos_params_s& ho_request_ies_o::value_c::pc5_qos_params()
{
  assert_choice_type(types::pc5_qos_params, type_, "Value");
  return c.get<pc5_qos_params_s>();
}
ce_mode_brestricted_e& ho_request_ies_o::value_c::ce_mode_brestricted()
{
  assert_choice_type(types::ce_mode_brestricted, type_, "Value");
  return c.get<ce_mode_brestricted_e>();
}
ue_up_c_iot_support_e& ho_request_ies_o::value_c::ue_up_c_iot_support()
{
  assert_choice_type(types::ue_up_c_iot_support, type_, "Value");
  return c.get<ue_up_c_iot_support_e>();
}
mdt_plmn_list_l& ho_request_ies_o::value_c::management_based_mdt_plmn_list()
{
  assert_choice_type(types::management_based_mdt_plmn_list, type_, "Value");
  return c.get<mdt_plmn_list_l>();
}
unbounded_octstring<true>& ho_request_ies_o::value_c::ue_radio_cap_id()
{
  assert_choice_type(types::ue_radio_cap_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
uint16_t& ho_request_ies_o::value_c::extended_connected_time()
{
  assert_choice_type(types::extended_connected_time, type_, "Value");
  return c.get<uint16_t>();
}
time_sync_assist_info_s& ho_request_ies_o::value_c::time_sync_assist_info()
{
  assert_choice_type(types::time_sync_assist_info, type_, "Value");
  return c.get<time_sync_assist_info_s>();
}
ue_slice_max_bit_rate_list_l& ho_request_ies_o::value_c::ue_slice_max_bit_rate_list()
{
  assert_choice_type(types::ue_slice_max_bit_rate_list, type_, "Value");
  return c.get<ue_slice_max_bit_rate_list_l>();
}
five_g_pro_se_authorized_s& ho_request_ies_o::value_c::five_g_pro_se_authorized()
{
  assert_choice_type(types::five_g_pro_se_authorized, type_, "Value");
  return c.get<five_g_pro_se_authorized_s>();
}
nr_ue_sidelink_aggr_max_bitrate_s& ho_request_ies_o::value_c::five_g_pro_se_ue_pc5_aggr_max_bit_rate()
{
  assert_choice_type(types::five_g_pro_se_ue_pc5_aggr_max_bit_rate, type_, "Value");
  return c.get<nr_ue_sidelink_aggr_max_bitrate_s>();
}
five_g_pro_se_pc5_qos_params_s& ho_request_ies_o::value_c::five_g_pro_se_pc5_qos_params()
{
  assert_choice_type(types::five_g_pro_se_pc5_qos_params, type_, "Value");
  return c.get<five_g_pro_se_pc5_qos_params_s>();
}
const uint64_t& ho_request_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const handov_type_e& ho_request_ies_o::value_c::handov_type() const
{
  assert_choice_type(types::handov_type, type_, "Value");
  return c.get<handov_type_e>();
}
const cause_c& ho_request_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const ue_aggr_max_bit_rate_s& ho_request_ies_o::value_c::ue_aggr_max_bit_rate() const
{
  assert_choice_type(types::ue_aggr_max_bit_rate, type_, "Value");
  return c.get<ue_aggr_max_bit_rate_s>();
}
const core_network_assist_info_for_inactive_s& ho_request_ies_o::value_c::core_network_assist_info_for_inactive() const
{
  assert_choice_type(types::core_network_assist_info_for_inactive, type_, "Value");
  return c.get<core_network_assist_info_for_inactive_s>();
}
const ue_security_cap_s& ho_request_ies_o::value_c::ue_security_cap() const
{
  assert_choice_type(types::ue_security_cap, type_, "Value");
  return c.get<ue_security_cap_s>();
}
const security_context_s& ho_request_ies_o::value_c::security_context() const
{
  assert_choice_type(types::security_context, type_, "Value");
  return c.get<security_context_s>();
}
const new_security_context_ind_e& ho_request_ies_o::value_c::new_security_context_ind() const
{
  assert_choice_type(types::new_security_context_ind, type_, "Value");
  return c.get<new_security_context_ind_e>();
}
const unbounded_octstring<true>& ho_request_ies_o::value_c::nasc() const
{
  assert_choice_type(types::nasc, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const pdu_session_res_setup_list_ho_req_l& ho_request_ies_o::value_c::pdu_session_res_setup_list_ho_req() const
{
  assert_choice_type(types::pdu_session_res_setup_list_ho_req, type_, "Value");
  return c.get<pdu_session_res_setup_list_ho_req_l>();
}
const allowed_nssai_l& ho_request_ies_o::value_c::allowed_nssai() const
{
  assert_choice_type(types::allowed_nssai, type_, "Value");
  return c.get<allowed_nssai_l>();
}
const trace_activation_s& ho_request_ies_o::value_c::trace_activation() const
{
  assert_choice_type(types::trace_activation, type_, "Value");
  return c.get<trace_activation_s>();
}
const fixed_bitstring<64, false, true>& ho_request_ies_o::value_c::masked_imeisv() const
{
  assert_choice_type(types::masked_imeisv, type_, "Value");
  return c.get<fixed_bitstring<64, false, true>>();
}
const unbounded_octstring<true>& ho_request_ies_o::value_c::source_to_target_transparent_container() const
{
  assert_choice_type(types::source_to_target_transparent_container, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const mob_restrict_list_s& ho_request_ies_o::value_c::mob_restrict_list() const
{
  assert_choice_type(types::mob_restrict_list, type_, "Value");
  return c.get<mob_restrict_list_s>();
}
const location_report_request_type_s& ho_request_ies_o::value_c::location_report_request_type() const
{
  assert_choice_type(types::location_report_request_type, type_, "Value");
  return c.get<location_report_request_type_s>();
}
const rrc_inactive_transition_report_request_e&
ho_request_ies_o::value_c::rrc_inactive_transition_report_request() const
{
  assert_choice_type(types::rrc_inactive_transition_report_request, type_, "Value");
  return c.get<rrc_inactive_transition_report_request_e>();
}
const guami_s& ho_request_ies_o::value_c::guami() const
{
  assert_choice_type(types::guami, type_, "Value");
  return c.get<guami_s>();
}
const redirection_voice_fallback_e& ho_request_ies_o::value_c::redirection_voice_fallback() const
{
  assert_choice_type(types::redirection_voice_fallback, type_, "Value");
  return c.get<redirection_voice_fallback_e>();
}
const cn_assisted_ran_tuning_s& ho_request_ies_o::value_c::cn_assisted_ran_tuning() const
{
  assert_choice_type(types::cn_assisted_ran_tuning, type_, "Value");
  return c.get<cn_assisted_ran_tuning_s>();
}
const srvcc_operation_possible_e& ho_request_ies_o::value_c::srvcc_operation_possible() const
{
  assert_choice_type(types::srvcc_operation_possible, type_, "Value");
  return c.get<srvcc_operation_possible_e>();
}
const iab_authorized_e& ho_request_ies_o::value_c::iab_authorized() const
{
  assert_choice_type(types::iab_authorized, type_, "Value");
  return c.get<iab_authorized_e>();
}
const enhanced_coverage_restrict_e& ho_request_ies_o::value_c::enhanced_coverage_restrict() const
{
  assert_choice_type(types::enhanced_coverage_restrict, type_, "Value");
  return c.get<enhanced_coverage_restrict_e>();
}
const ue_diff_info_s& ho_request_ies_o::value_c::ue_diff_info() const
{
  assert_choice_type(types::ue_diff_info, type_, "Value");
  return c.get<ue_diff_info_s>();
}
const nr_v2x_services_authorized_s& ho_request_ies_o::value_c::nr_v2x_services_authorized() const
{
  assert_choice_type(types::nr_v2x_services_authorized, type_, "Value");
  return c.get<nr_v2x_services_authorized_s>();
}
const ltev2x_services_authorized_s& ho_request_ies_o::value_c::ltev2x_services_authorized() const
{
  assert_choice_type(types::ltev2x_services_authorized, type_, "Value");
  return c.get<ltev2x_services_authorized_s>();
}
const nr_ue_sidelink_aggr_max_bitrate_s& ho_request_ies_o::value_c::nr_ue_sidelink_aggr_max_bitrate() const
{
  assert_choice_type(types::nr_ue_sidelink_aggr_max_bitrate, type_, "Value");
  return c.get<nr_ue_sidelink_aggr_max_bitrate_s>();
}
const lte_ue_sidelink_aggr_max_bitrate_s& ho_request_ies_o::value_c::lte_ue_sidelink_aggr_max_bitrate() const
{
  assert_choice_type(types::lte_ue_sidelink_aggr_max_bitrate, type_, "Value");
  return c.get<lte_ue_sidelink_aggr_max_bitrate_s>();
}
const pc5_qos_params_s& ho_request_ies_o::value_c::pc5_qos_params() const
{
  assert_choice_type(types::pc5_qos_params, type_, "Value");
  return c.get<pc5_qos_params_s>();
}
const ce_mode_brestricted_e& ho_request_ies_o::value_c::ce_mode_brestricted() const
{
  assert_choice_type(types::ce_mode_brestricted, type_, "Value");
  return c.get<ce_mode_brestricted_e>();
}
const ue_up_c_iot_support_e& ho_request_ies_o::value_c::ue_up_c_iot_support() const
{
  assert_choice_type(types::ue_up_c_iot_support, type_, "Value");
  return c.get<ue_up_c_iot_support_e>();
}
const mdt_plmn_list_l& ho_request_ies_o::value_c::management_based_mdt_plmn_list() const
{
  assert_choice_type(types::management_based_mdt_plmn_list, type_, "Value");
  return c.get<mdt_plmn_list_l>();
}
const unbounded_octstring<true>& ho_request_ies_o::value_c::ue_radio_cap_id() const
{
  assert_choice_type(types::ue_radio_cap_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const uint16_t& ho_request_ies_o::value_c::extended_connected_time() const
{
  assert_choice_type(types::extended_connected_time, type_, "Value");
  return c.get<uint16_t>();
}
const time_sync_assist_info_s& ho_request_ies_o::value_c::time_sync_assist_info() const
{
  assert_choice_type(types::time_sync_assist_info, type_, "Value");
  return c.get<time_sync_assist_info_s>();
}
const ue_slice_max_bit_rate_list_l& ho_request_ies_o::value_c::ue_slice_max_bit_rate_list() const
{
  assert_choice_type(types::ue_slice_max_bit_rate_list, type_, "Value");
  return c.get<ue_slice_max_bit_rate_list_l>();
}
const five_g_pro_se_authorized_s& ho_request_ies_o::value_c::five_g_pro_se_authorized() const
{
  assert_choice_type(types::five_g_pro_se_authorized, type_, "Value");
  return c.get<five_g_pro_se_authorized_s>();
}
const nr_ue_sidelink_aggr_max_bitrate_s& ho_request_ies_o::value_c::five_g_pro_se_ue_pc5_aggr_max_bit_rate() const
{
  assert_choice_type(types::five_g_pro_se_ue_pc5_aggr_max_bit_rate, type_, "Value");
  return c.get<nr_ue_sidelink_aggr_max_bitrate_s>();
}
const five_g_pro_se_pc5_qos_params_s& ho_request_ies_o::value_c::five_g_pro_se_pc5_qos_params() const
{
  assert_choice_type(types::five_g_pro_se_pc5_qos_params, type_, "Value");
  return c.get<five_g_pro_se_pc5_qos_params_s>();
}
void ho_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::handov_type:
      j.write_str("HandoverType", c.get<handov_type_e>().to_string());
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    case types::ue_aggr_max_bit_rate:
      j.write_fieldname("UEAggregateMaximumBitRate");
      c.get<ue_aggr_max_bit_rate_s>().to_json(j);
      break;
    case types::core_network_assist_info_for_inactive:
      j.write_fieldname("CoreNetworkAssistanceInformationForInactive");
      c.get<core_network_assist_info_for_inactive_s>().to_json(j);
      break;
    case types::ue_security_cap:
      j.write_fieldname("UESecurityCapabilities");
      c.get<ue_security_cap_s>().to_json(j);
      break;
    case types::security_context:
      j.write_fieldname("SecurityContext");
      c.get<security_context_s>().to_json(j);
      break;
    case types::new_security_context_ind:
      j.write_str("NewSecurityContextInd", "true");
      break;
    case types::nasc:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::pdu_session_res_setup_list_ho_req:
      j.start_array("PDUSessionResourceSetupListHOReq");
      for (const auto& e1 : c.get<pdu_session_res_setup_list_ho_req_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::allowed_nssai:
      j.start_array("AllowedNSSAI");
      for (const auto& e1 : c.get<allowed_nssai_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::trace_activation:
      j.write_fieldname("TraceActivation");
      c.get<trace_activation_s>().to_json(j);
      break;
    case types::masked_imeisv:
      j.write_str("BIT STRING", c.get<fixed_bitstring<64, false, true>>().to_string());
      break;
    case types::source_to_target_transparent_container:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::mob_restrict_list:
      j.write_fieldname("MobilityRestrictionList");
      c.get<mob_restrict_list_s>().to_json(j);
      break;
    case types::location_report_request_type:
      j.write_fieldname("LocationReportingRequestType");
      c.get<location_report_request_type_s>().to_json(j);
      break;
    case types::rrc_inactive_transition_report_request:
      j.write_str("RRCInactiveTransitionReportRequest", c.get<rrc_inactive_transition_report_request_e>().to_string());
      break;
    case types::guami:
      j.write_fieldname("GUAMI");
      c.get<guami_s>().to_json(j);
      break;
    case types::redirection_voice_fallback:
      j.write_str("RedirectionVoiceFallback", c.get<redirection_voice_fallback_e>().to_string());
      break;
    case types::cn_assisted_ran_tuning:
      j.write_fieldname("CNAssistedRANTuning");
      c.get<cn_assisted_ran_tuning_s>().to_json(j);
      break;
    case types::srvcc_operation_possible:
      j.write_str("SRVCCOperationPossible", c.get<srvcc_operation_possible_e>().to_string());
      break;
    case types::iab_authorized:
      j.write_str("IAB-Authorized", c.get<iab_authorized_e>().to_string());
      break;
    case types::enhanced_coverage_restrict:
      j.write_str("Enhanced-CoverageRestriction", "restricted");
      break;
    case types::ue_diff_info:
      j.write_fieldname("UE-DifferentiationInfo");
      c.get<ue_diff_info_s>().to_json(j);
      break;
    case types::nr_v2x_services_authorized:
      j.write_fieldname("NRV2XServicesAuthorized");
      c.get<nr_v2x_services_authorized_s>().to_json(j);
      break;
    case types::ltev2x_services_authorized:
      j.write_fieldname("LTEV2XServicesAuthorized");
      c.get<ltev2x_services_authorized_s>().to_json(j);
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      j.write_fieldname("NRUESidelinkAggregateMaximumBitrate");
      c.get<nr_ue_sidelink_aggr_max_bitrate_s>().to_json(j);
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      j.write_fieldname("LTEUESidelinkAggregateMaximumBitrate");
      c.get<lte_ue_sidelink_aggr_max_bitrate_s>().to_json(j);
      break;
    case types::pc5_qos_params:
      j.write_fieldname("PC5QoSParameters");
      c.get<pc5_qos_params_s>().to_json(j);
      break;
    case types::ce_mode_brestricted:
      j.write_str("CEmodeBrestricted", c.get<ce_mode_brestricted_e>().to_string());
      break;
    case types::ue_up_c_iot_support:
      j.write_str("UE-UP-CIoT-Support", "supported");
      break;
    case types::management_based_mdt_plmn_list:
      j.start_array("MDTPLMNList");
      for (const auto& e1 : c.get<mdt_plmn_list_l>()) {
        j.write_str(e1.to_string());
      }
      j.end_array();
      break;
    case types::ue_radio_cap_id:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::extended_connected_time:
      j.write_int("INTEGER (0..255)", c.get<uint16_t>());
      break;
    case types::time_sync_assist_info:
      j.write_fieldname("TimeSyncAssistanceInfo");
      c.get<time_sync_assist_info_s>().to_json(j);
      break;
    case types::ue_slice_max_bit_rate_list:
      j.start_array("UESliceMaximumBitRateList");
      for (const auto& e1 : c.get<ue_slice_max_bit_rate_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::five_g_pro_se_authorized:
      j.write_fieldname("FiveG-ProSeAuthorized");
      c.get<five_g_pro_se_authorized_s>().to_json(j);
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      j.write_fieldname("NRUESidelinkAggregateMaximumBitrate");
      c.get<nr_ue_sidelink_aggr_max_bitrate_s>().to_json(j);
      break;
    case types::five_g_pro_se_pc5_qos_params:
      j.write_fieldname("FiveG-ProSePC5QoSParameters");
      c.get<five_g_pro_se_pc5_qos_params_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ho_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ho_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::handov_type:
      HANDLE_CODE(c.get<handov_type_e>().pack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    case types::ue_aggr_max_bit_rate:
      HANDLE_CODE(c.get<ue_aggr_max_bit_rate_s>().pack(bref));
      break;
    case types::core_network_assist_info_for_inactive:
      HANDLE_CODE(c.get<core_network_assist_info_for_inactive_s>().pack(bref));
      break;
    case types::ue_security_cap:
      HANDLE_CODE(c.get<ue_security_cap_s>().pack(bref));
      break;
    case types::security_context:
      HANDLE_CODE(c.get<security_context_s>().pack(bref));
      break;
    case types::new_security_context_ind:
      HANDLE_CODE(c.get<new_security_context_ind_e>().pack(bref));
      break;
    case types::nasc:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::pdu_session_res_setup_list_ho_req:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_setup_list_ho_req_l>(), 1, 256, true));
      break;
    case types::allowed_nssai:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<allowed_nssai_l>(), 1, 8, true));
      break;
    case types::trace_activation:
      HANDLE_CODE(c.get<trace_activation_s>().pack(bref));
      break;
    case types::masked_imeisv:
      HANDLE_CODE((c.get<fixed_bitstring<64, false, true>>().pack(bref)));
      break;
    case types::source_to_target_transparent_container:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::mob_restrict_list:
      HANDLE_CODE(c.get<mob_restrict_list_s>().pack(bref));
      break;
    case types::location_report_request_type:
      HANDLE_CODE(c.get<location_report_request_type_s>().pack(bref));
      break;
    case types::rrc_inactive_transition_report_request:
      HANDLE_CODE(c.get<rrc_inactive_transition_report_request_e>().pack(bref));
      break;
    case types::guami:
      HANDLE_CODE(c.get<guami_s>().pack(bref));
      break;
    case types::redirection_voice_fallback:
      HANDLE_CODE(c.get<redirection_voice_fallback_e>().pack(bref));
      break;
    case types::cn_assisted_ran_tuning:
      HANDLE_CODE(c.get<cn_assisted_ran_tuning_s>().pack(bref));
      break;
    case types::srvcc_operation_possible:
      HANDLE_CODE(c.get<srvcc_operation_possible_e>().pack(bref));
      break;
    case types::iab_authorized:
      HANDLE_CODE(c.get<iab_authorized_e>().pack(bref));
      break;
    case types::enhanced_coverage_restrict:
      HANDLE_CODE(c.get<enhanced_coverage_restrict_e>().pack(bref));
      break;
    case types::ue_diff_info:
      HANDLE_CODE(c.get<ue_diff_info_s>().pack(bref));
      break;
    case types::nr_v2x_services_authorized:
      HANDLE_CODE(c.get<nr_v2x_services_authorized_s>().pack(bref));
      break;
    case types::ltev2x_services_authorized:
      HANDLE_CODE(c.get<ltev2x_services_authorized_s>().pack(bref));
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      HANDLE_CODE(c.get<nr_ue_sidelink_aggr_max_bitrate_s>().pack(bref));
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      HANDLE_CODE(c.get<lte_ue_sidelink_aggr_max_bitrate_s>().pack(bref));
      break;
    case types::pc5_qos_params:
      HANDLE_CODE(c.get<pc5_qos_params_s>().pack(bref));
      break;
    case types::ce_mode_brestricted:
      HANDLE_CODE(c.get<ce_mode_brestricted_e>().pack(bref));
      break;
    case types::ue_up_c_iot_support:
      HANDLE_CODE(c.get<ue_up_c_iot_support_e>().pack(bref));
      break;
    case types::management_based_mdt_plmn_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<mdt_plmn_list_l>(), 1, 16, true));
      break;
    case types::ue_radio_cap_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::extended_connected_time:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)0u, (uint16_t)255u, false, true));
      break;
    case types::time_sync_assist_info:
      HANDLE_CODE(c.get<time_sync_assist_info_s>().pack(bref));
      break;
    case types::ue_slice_max_bit_rate_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<ue_slice_max_bit_rate_list_l>(), 1, 8, true));
      break;
    case types::five_g_pro_se_authorized:
      HANDLE_CODE(c.get<five_g_pro_se_authorized_s>().pack(bref));
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      HANDLE_CODE(c.get<nr_ue_sidelink_aggr_max_bitrate_s>().pack(bref));
      break;
    case types::five_g_pro_se_pc5_qos_params:
      HANDLE_CODE(c.get<five_g_pro_se_pc5_qos_params_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::handov_type:
      HANDLE_CODE(c.get<handov_type_e>().unpack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    case types::ue_aggr_max_bit_rate:
      HANDLE_CODE(c.get<ue_aggr_max_bit_rate_s>().unpack(bref));
      break;
    case types::core_network_assist_info_for_inactive:
      HANDLE_CODE(c.get<core_network_assist_info_for_inactive_s>().unpack(bref));
      break;
    case types::ue_security_cap:
      HANDLE_CODE(c.get<ue_security_cap_s>().unpack(bref));
      break;
    case types::security_context:
      HANDLE_CODE(c.get<security_context_s>().unpack(bref));
      break;
    case types::new_security_context_ind:
      HANDLE_CODE(c.get<new_security_context_ind_e>().unpack(bref));
      break;
    case types::nasc:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::pdu_session_res_setup_list_ho_req:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_setup_list_ho_req_l>(), bref, 1, 256, true));
      break;
    case types::allowed_nssai:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<allowed_nssai_l>(), bref, 1, 8, true));
      break;
    case types::trace_activation:
      HANDLE_CODE(c.get<trace_activation_s>().unpack(bref));
      break;
    case types::masked_imeisv:
      HANDLE_CODE((c.get<fixed_bitstring<64, false, true>>().unpack(bref)));
      break;
    case types::source_to_target_transparent_container:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::mob_restrict_list:
      HANDLE_CODE(c.get<mob_restrict_list_s>().unpack(bref));
      break;
    case types::location_report_request_type:
      HANDLE_CODE(c.get<location_report_request_type_s>().unpack(bref));
      break;
    case types::rrc_inactive_transition_report_request:
      HANDLE_CODE(c.get<rrc_inactive_transition_report_request_e>().unpack(bref));
      break;
    case types::guami:
      HANDLE_CODE(c.get<guami_s>().unpack(bref));
      break;
    case types::redirection_voice_fallback:
      HANDLE_CODE(c.get<redirection_voice_fallback_e>().unpack(bref));
      break;
    case types::cn_assisted_ran_tuning:
      HANDLE_CODE(c.get<cn_assisted_ran_tuning_s>().unpack(bref));
      break;
    case types::srvcc_operation_possible:
      HANDLE_CODE(c.get<srvcc_operation_possible_e>().unpack(bref));
      break;
    case types::iab_authorized:
      HANDLE_CODE(c.get<iab_authorized_e>().unpack(bref));
      break;
    case types::enhanced_coverage_restrict:
      HANDLE_CODE(c.get<enhanced_coverage_restrict_e>().unpack(bref));
      break;
    case types::ue_diff_info:
      HANDLE_CODE(c.get<ue_diff_info_s>().unpack(bref));
      break;
    case types::nr_v2x_services_authorized:
      HANDLE_CODE(c.get<nr_v2x_services_authorized_s>().unpack(bref));
      break;
    case types::ltev2x_services_authorized:
      HANDLE_CODE(c.get<ltev2x_services_authorized_s>().unpack(bref));
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      HANDLE_CODE(c.get<nr_ue_sidelink_aggr_max_bitrate_s>().unpack(bref));
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      HANDLE_CODE(c.get<lte_ue_sidelink_aggr_max_bitrate_s>().unpack(bref));
      break;
    case types::pc5_qos_params:
      HANDLE_CODE(c.get<pc5_qos_params_s>().unpack(bref));
      break;
    case types::ce_mode_brestricted:
      HANDLE_CODE(c.get<ce_mode_brestricted_e>().unpack(bref));
      break;
    case types::ue_up_c_iot_support:
      HANDLE_CODE(c.get<ue_up_c_iot_support_e>().unpack(bref));
      break;
    case types::management_based_mdt_plmn_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<mdt_plmn_list_l>(), bref, 1, 16, true));
      break;
    case types::ue_radio_cap_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::extended_connected_time:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)0u, (uint16_t)255u, false, true));
      break;
    case types::time_sync_assist_info:
      HANDLE_CODE(c.get<time_sync_assist_info_s>().unpack(bref));
      break;
    case types::ue_slice_max_bit_rate_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<ue_slice_max_bit_rate_list_l>(), bref, 1, 8, true));
      break;
    case types::five_g_pro_se_authorized:
      HANDLE_CODE(c.get<five_g_pro_se_authorized_s>().unpack(bref));
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      HANDLE_CODE(c.get<nr_ue_sidelink_aggr_max_bitrate_s>().unpack(bref));
      break;
    case types::five_g_pro_se_pc5_qos_params:
      HANDLE_CODE(c.get<five_g_pro_se_pc5_qos_params_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ho_request_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..1099511627775)",
                                "HandoverType",
                                "Cause",
                                "UEAggregateMaximumBitRate",
                                "CoreNetworkAssistanceInformationForInactive",
                                "UESecurityCapabilities",
                                "SecurityContext",
                                "NewSecurityContextInd",
                                "OCTET STRING",
                                "PDUSessionResourceSetupListHOReq",
                                "AllowedNSSAI",
                                "TraceActivation",
                                "BIT STRING",
                                "OCTET STRING",
                                "MobilityRestrictionList",
                                "LocationReportingRequestType",
                                "RRCInactiveTransitionReportRequest",
                                "GUAMI",
                                "RedirectionVoiceFallback",
                                "CNAssistedRANTuning",
                                "SRVCCOperationPossible",
                                "IAB-Authorized",
                                "Enhanced-CoverageRestriction",
                                "UE-DifferentiationInfo",
                                "NRV2XServicesAuthorized",
                                "LTEV2XServicesAuthorized",
                                "NRUESidelinkAggregateMaximumBitrate",
                                "LTEUESidelinkAggregateMaximumBitrate",
                                "PC5QoSParameters",
                                "CEmodeBrestricted",
                                "UE-UP-CIoT-Support",
                                "MDTPLMNList",
                                "OCTET STRING",
                                "INTEGER (0..255)",
                                "TimeSyncAssistanceInfo",
                                "UESliceMaximumBitRateList",
                                "FiveG-ProSeAuthorized",
                                "NRUESidelinkAggregateMaximumBitrate",
                                "FiveG-ProSePC5QoSParameters"};
  return convert_enum_idx(names, 39, value, "ho_request_ies_o::value_c::types");
}

template struct asn1::protocol_ie_field_s<ho_request_ies_o>;

ho_request_ies_container::ho_request_ies_container() :
  amf_ue_ngap_id(10, crit_e::reject),
  handov_type(29, crit_e::reject),
  cause(15, crit_e::ignore),
  ue_aggr_max_bit_rate(110, crit_e::reject),
  core_network_assist_info_for_inactive(18, crit_e::ignore),
  ue_security_cap(119, crit_e::reject),
  security_context(93, crit_e::reject),
  new_security_context_ind(41, crit_e::reject),
  nasc(37, crit_e::reject),
  pdu_session_res_setup_list_ho_req(73, crit_e::reject),
  allowed_nssai(0, crit_e::reject),
  trace_activation(108, crit_e::ignore),
  masked_imeisv(34, crit_e::ignore),
  source_to_target_transparent_container(101, crit_e::reject),
  mob_restrict_list(36, crit_e::ignore),
  location_report_request_type(33, crit_e::ignore),
  rrc_inactive_transition_report_request(91, crit_e::ignore),
  guami(28, crit_e::reject),
  redirection_voice_fallback(146, crit_e::ignore),
  cn_assisted_ran_tuning(165, crit_e::ignore),
  srvcc_operation_possible(177, crit_e::ignore),
  iab_authorized(199, crit_e::reject),
  enhanced_coverage_restrict(205, crit_e::ignore),
  ue_diff_info(209, crit_e::ignore),
  nr_v2x_services_authorized(216, crit_e::ignore),
  ltev2x_services_authorized(215, crit_e::ignore),
  nr_ue_sidelink_aggr_max_bitrate(218, crit_e::ignore),
  lte_ue_sidelink_aggr_max_bitrate(217, crit_e::ignore),
  pc5_qos_params(219, crit_e::ignore),
  ce_mode_brestricted(222, crit_e::ignore),
  ue_up_c_iot_support(234, crit_e::ignore),
  management_based_mdt_plmn_list(254, crit_e::ignore),
  ue_radio_cap_id(264, crit_e::reject),
  extended_connected_time(206, crit_e::ignore),
  time_sync_assist_info(326, crit_e::ignore),
  ue_slice_max_bit_rate_list(335, crit_e::ignore),
  five_g_pro_se_authorized(345, crit_e::ignore),
  five_g_pro_se_ue_pc5_aggr_max_bit_rate(346, crit_e::ignore),
  five_g_pro_se_pc5_qos_params(347, crit_e::ignore)
{
}
SRSASN_CODE ho_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 10;
  nof_ies += core_network_assist_info_for_inactive_present ? 1 : 0;
  nof_ies += new_security_context_ind_present ? 1 : 0;
  nof_ies += nasc_present ? 1 : 0;
  nof_ies += trace_activation_present ? 1 : 0;
  nof_ies += masked_imeisv_present ? 1 : 0;
  nof_ies += mob_restrict_list_present ? 1 : 0;
  nof_ies += location_report_request_type_present ? 1 : 0;
  nof_ies += rrc_inactive_transition_report_request_present ? 1 : 0;
  nof_ies += redirection_voice_fallback_present ? 1 : 0;
  nof_ies += cn_assisted_ran_tuning_present ? 1 : 0;
  nof_ies += srvcc_operation_possible_present ? 1 : 0;
  nof_ies += iab_authorized_present ? 1 : 0;
  nof_ies += enhanced_coverage_restrict_present ? 1 : 0;
  nof_ies += ue_diff_info_present ? 1 : 0;
  nof_ies += nr_v2x_services_authorized_present ? 1 : 0;
  nof_ies += ltev2x_services_authorized_present ? 1 : 0;
  nof_ies += nr_ue_sidelink_aggr_max_bitrate_present ? 1 : 0;
  nof_ies += lte_ue_sidelink_aggr_max_bitrate_present ? 1 : 0;
  nof_ies += pc5_qos_params_present ? 1 : 0;
  nof_ies += ce_mode_brestricted_present ? 1 : 0;
  nof_ies += ue_up_c_iot_support_present ? 1 : 0;
  nof_ies += management_based_mdt_plmn_list_present ? 1 : 0;
  nof_ies += ue_radio_cap_id_present ? 1 : 0;
  nof_ies += extended_connected_time_present ? 1 : 0;
  nof_ies += time_sync_assist_info_present ? 1 : 0;
  nof_ies += ue_slice_max_bit_rate_list_present ? 1 : 0;
  nof_ies += five_g_pro_se_authorized_present ? 1 : 0;
  nof_ies += five_g_pro_se_ue_pc5_aggr_max_bit_rate_present ? 1 : 0;
  nof_ies += five_g_pro_se_pc5_qos_params_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(handov_type.pack(bref));
  HANDLE_CODE(cause.pack(bref));
  HANDLE_CODE(ue_aggr_max_bit_rate.pack(bref));
  if (core_network_assist_info_for_inactive_present) {
    HANDLE_CODE(core_network_assist_info_for_inactive.pack(bref));
  }
  HANDLE_CODE(ue_security_cap.pack(bref));
  HANDLE_CODE(security_context.pack(bref));
  if (new_security_context_ind_present) {
    HANDLE_CODE(new_security_context_ind.pack(bref));
  }
  if (nasc_present) {
    HANDLE_CODE(nasc.pack(bref));
  }
  HANDLE_CODE(pdu_session_res_setup_list_ho_req.pack(bref));
  HANDLE_CODE(allowed_nssai.pack(bref));
  if (trace_activation_present) {
    HANDLE_CODE(trace_activation.pack(bref));
  }
  if (masked_imeisv_present) {
    HANDLE_CODE(masked_imeisv.pack(bref));
  }
  HANDLE_CODE(source_to_target_transparent_container.pack(bref));
  if (mob_restrict_list_present) {
    HANDLE_CODE(mob_restrict_list.pack(bref));
  }
  if (location_report_request_type_present) {
    HANDLE_CODE(location_report_request_type.pack(bref));
  }
  if (rrc_inactive_transition_report_request_present) {
    HANDLE_CODE(rrc_inactive_transition_report_request.pack(bref));
  }
  HANDLE_CODE(guami.pack(bref));
  if (redirection_voice_fallback_present) {
    HANDLE_CODE(redirection_voice_fallback.pack(bref));
  }
  if (cn_assisted_ran_tuning_present) {
    HANDLE_CODE(cn_assisted_ran_tuning.pack(bref));
  }
  if (srvcc_operation_possible_present) {
    HANDLE_CODE(srvcc_operation_possible.pack(bref));
  }
  if (iab_authorized_present) {
    HANDLE_CODE(iab_authorized.pack(bref));
  }
  if (enhanced_coverage_restrict_present) {
    HANDLE_CODE(enhanced_coverage_restrict.pack(bref));
  }
  if (ue_diff_info_present) {
    HANDLE_CODE(ue_diff_info.pack(bref));
  }
  if (nr_v2x_services_authorized_present) {
    HANDLE_CODE(nr_v2x_services_authorized.pack(bref));
  }
  if (ltev2x_services_authorized_present) {
    HANDLE_CODE(ltev2x_services_authorized.pack(bref));
  }
  if (nr_ue_sidelink_aggr_max_bitrate_present) {
    HANDLE_CODE(nr_ue_sidelink_aggr_max_bitrate.pack(bref));
  }
  if (lte_ue_sidelink_aggr_max_bitrate_present) {
    HANDLE_CODE(lte_ue_sidelink_aggr_max_bitrate.pack(bref));
  }
  if (pc5_qos_params_present) {
    HANDLE_CODE(pc5_qos_params.pack(bref));
  }
  if (ce_mode_brestricted_present) {
    HANDLE_CODE(ce_mode_brestricted.pack(bref));
  }
  if (ue_up_c_iot_support_present) {
    HANDLE_CODE(ue_up_c_iot_support.pack(bref));
  }
  if (management_based_mdt_plmn_list_present) {
    HANDLE_CODE(management_based_mdt_plmn_list.pack(bref));
  }
  if (ue_radio_cap_id_present) {
    HANDLE_CODE(ue_radio_cap_id.pack(bref));
  }
  if (extended_connected_time_present) {
    HANDLE_CODE(extended_connected_time.pack(bref));
  }
  if (time_sync_assist_info_present) {
    HANDLE_CODE(time_sync_assist_info.pack(bref));
  }
  if (ue_slice_max_bit_rate_list_present) {
    HANDLE_CODE(ue_slice_max_bit_rate_list.pack(bref));
  }
  if (five_g_pro_se_authorized_present) {
    HANDLE_CODE(five_g_pro_se_authorized.pack(bref));
  }
  if (five_g_pro_se_ue_pc5_aggr_max_bit_rate_present) {
    HANDLE_CODE(five_g_pro_se_ue_pc5_aggr_max_bit_rate.pack(bref));
  }
  if (five_g_pro_se_pc5_qos_params_present) {
    HANDLE_CODE(five_g_pro_se_pc5_qos_params.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 10;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 29: {
        nof_mandatory_ies--;
        handov_type.id = id;
        HANDLE_CODE(handov_type.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(handov_type.value.unpack(bref));
        break;
      }
      case 15: {
        nof_mandatory_ies--;
        cause.id = id;
        HANDLE_CODE(cause.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.value.unpack(bref));
        break;
      }
      case 110: {
        nof_mandatory_ies--;
        ue_aggr_max_bit_rate.id = id;
        HANDLE_CODE(ue_aggr_max_bit_rate.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_aggr_max_bit_rate.value.unpack(bref));
        break;
      }
      case 18: {
        core_network_assist_info_for_inactive_present = true;
        core_network_assist_info_for_inactive.id      = id;
        HANDLE_CODE(core_network_assist_info_for_inactive.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(core_network_assist_info_for_inactive.value.unpack(bref));
        break;
      }
      case 119: {
        nof_mandatory_ies--;
        ue_security_cap.id = id;
        HANDLE_CODE(ue_security_cap.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_security_cap.value.unpack(bref));
        break;
      }
      case 93: {
        nof_mandatory_ies--;
        security_context.id = id;
        HANDLE_CODE(security_context.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(security_context.value.unpack(bref));
        break;
      }
      case 41: {
        new_security_context_ind_present = true;
        new_security_context_ind.id      = id;
        HANDLE_CODE(new_security_context_ind.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(new_security_context_ind.value.unpack(bref));
        break;
      }
      case 37: {
        nasc_present = true;
        nasc.id      = id;
        HANDLE_CODE(nasc.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nasc.value.unpack(bref));
        break;
      }
      case 73: {
        nof_mandatory_ies--;
        pdu_session_res_setup_list_ho_req.id = id;
        HANDLE_CODE(pdu_session_res_setup_list_ho_req.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pdu_session_res_setup_list_ho_req.value.unpack(bref));
        break;
      }
      case 0: {
        nof_mandatory_ies--;
        allowed_nssai.id = id;
        HANDLE_CODE(allowed_nssai.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(allowed_nssai.value.unpack(bref));
        break;
      }
      case 108: {
        trace_activation_present = true;
        trace_activation.id      = id;
        HANDLE_CODE(trace_activation.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(trace_activation.value.unpack(bref));
        break;
      }
      case 34: {
        masked_imeisv_present = true;
        masked_imeisv.id      = id;
        HANDLE_CODE(masked_imeisv.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(masked_imeisv.value.unpack(bref));
        break;
      }
      case 101: {
        nof_mandatory_ies--;
        source_to_target_transparent_container.id = id;
        HANDLE_CODE(source_to_target_transparent_container.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(source_to_target_transparent_container.value.unpack(bref));
        break;
      }
      case 36: {
        mob_restrict_list_present = true;
        mob_restrict_list.id      = id;
        HANDLE_CODE(mob_restrict_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mob_restrict_list.value.unpack(bref));
        break;
      }
      case 33: {
        location_report_request_type_present = true;
        location_report_request_type.id      = id;
        HANDLE_CODE(location_report_request_type.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(location_report_request_type.value.unpack(bref));
        break;
      }
      case 91: {
        rrc_inactive_transition_report_request_present = true;
        rrc_inactive_transition_report_request.id      = id;
        HANDLE_CODE(rrc_inactive_transition_report_request.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(rrc_inactive_transition_report_request.value.unpack(bref));
        break;
      }
      case 28: {
        nof_mandatory_ies--;
        guami.id = id;
        HANDLE_CODE(guami.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(guami.value.unpack(bref));
        break;
      }
      case 146: {
        redirection_voice_fallback_present = true;
        redirection_voice_fallback.id      = id;
        HANDLE_CODE(redirection_voice_fallback.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(redirection_voice_fallback.value.unpack(bref));
        break;
      }
      case 165: {
        cn_assisted_ran_tuning_present = true;
        cn_assisted_ran_tuning.id      = id;
        HANDLE_CODE(cn_assisted_ran_tuning.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cn_assisted_ran_tuning.value.unpack(bref));
        break;
      }
      case 177: {
        srvcc_operation_possible_present = true;
        srvcc_operation_possible.id      = id;
        HANDLE_CODE(srvcc_operation_possible.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(srvcc_operation_possible.value.unpack(bref));
        break;
      }
      case 199: {
        iab_authorized_present = true;
        iab_authorized.id      = id;
        HANDLE_CODE(iab_authorized.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(iab_authorized.value.unpack(bref));
        break;
      }
      case 205: {
        enhanced_coverage_restrict_present = true;
        enhanced_coverage_restrict.id      = id;
        HANDLE_CODE(enhanced_coverage_restrict.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(enhanced_coverage_restrict.value.unpack(bref));
        break;
      }
      case 209: {
        ue_diff_info_present = true;
        ue_diff_info.id      = id;
        HANDLE_CODE(ue_diff_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_diff_info.value.unpack(bref));
        break;
      }
      case 216: {
        nr_v2x_services_authorized_present = true;
        nr_v2x_services_authorized.id      = id;
        HANDLE_CODE(nr_v2x_services_authorized.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nr_v2x_services_authorized.value.unpack(bref));
        break;
      }
      case 215: {
        ltev2x_services_authorized_present = true;
        ltev2x_services_authorized.id      = id;
        HANDLE_CODE(ltev2x_services_authorized.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ltev2x_services_authorized.value.unpack(bref));
        break;
      }
      case 218: {
        nr_ue_sidelink_aggr_max_bitrate_present = true;
        nr_ue_sidelink_aggr_max_bitrate.id      = id;
        HANDLE_CODE(nr_ue_sidelink_aggr_max_bitrate.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nr_ue_sidelink_aggr_max_bitrate.value.unpack(bref));
        break;
      }
      case 217: {
        lte_ue_sidelink_aggr_max_bitrate_present = true;
        lte_ue_sidelink_aggr_max_bitrate.id      = id;
        HANDLE_CODE(lte_ue_sidelink_aggr_max_bitrate.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(lte_ue_sidelink_aggr_max_bitrate.value.unpack(bref));
        break;
      }
      case 219: {
        pc5_qos_params_present = true;
        pc5_qos_params.id      = id;
        HANDLE_CODE(pc5_qos_params.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pc5_qos_params.value.unpack(bref));
        break;
      }
      case 222: {
        ce_mode_brestricted_present = true;
        ce_mode_brestricted.id      = id;
        HANDLE_CODE(ce_mode_brestricted.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ce_mode_brestricted.value.unpack(bref));
        break;
      }
      case 234: {
        ue_up_c_iot_support_present = true;
        ue_up_c_iot_support.id      = id;
        HANDLE_CODE(ue_up_c_iot_support.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_up_c_iot_support.value.unpack(bref));
        break;
      }
      case 254: {
        management_based_mdt_plmn_list_present = true;
        management_based_mdt_plmn_list.id      = id;
        HANDLE_CODE(management_based_mdt_plmn_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(management_based_mdt_plmn_list.value.unpack(bref));
        break;
      }
      case 264: {
        ue_radio_cap_id_present = true;
        ue_radio_cap_id.id      = id;
        HANDLE_CODE(ue_radio_cap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_radio_cap_id.value.unpack(bref));
        break;
      }
      case 206: {
        extended_connected_time_present = true;
        extended_connected_time.id      = id;
        HANDLE_CODE(extended_connected_time.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(extended_connected_time.value.unpack(bref));
        break;
      }
      case 326: {
        time_sync_assist_info_present = true;
        time_sync_assist_info.id      = id;
        HANDLE_CODE(time_sync_assist_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(time_sync_assist_info.value.unpack(bref));
        break;
      }
      case 335: {
        ue_slice_max_bit_rate_list_present = true;
        ue_slice_max_bit_rate_list.id      = id;
        HANDLE_CODE(ue_slice_max_bit_rate_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_slice_max_bit_rate_list.value.unpack(bref));
        break;
      }
      case 345: {
        five_g_pro_se_authorized_present = true;
        five_g_pro_se_authorized.id      = id;
        HANDLE_CODE(five_g_pro_se_authorized.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(five_g_pro_se_authorized.value.unpack(bref));
        break;
      }
      case 346: {
        five_g_pro_se_ue_pc5_aggr_max_bit_rate_present = true;
        five_g_pro_se_ue_pc5_aggr_max_bit_rate.id      = id;
        HANDLE_CODE(five_g_pro_se_ue_pc5_aggr_max_bit_rate.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(five_g_pro_se_ue_pc5_aggr_max_bit_rate.value.unpack(bref));
        break;
      }
      case 347: {
        five_g_pro_se_pc5_qos_params_present = true;
        five_g_pro_se_pc5_qos_params.id      = id;
        HANDLE_CODE(five_g_pro_se_pc5_qos_params.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(five_g_pro_se_pc5_qos_params.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ho_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  handov_type.to_json(j);
  j.write_fieldname("");
  cause.to_json(j);
  j.write_fieldname("");
  ue_aggr_max_bit_rate.to_json(j);
  if (core_network_assist_info_for_inactive_present) {
    j.write_fieldname("");
    core_network_assist_info_for_inactive.to_json(j);
  }
  j.write_fieldname("");
  ue_security_cap.to_json(j);
  j.write_fieldname("");
  security_context.to_json(j);
  if (new_security_context_ind_present) {
    j.write_fieldname("");
    new_security_context_ind.to_json(j);
  }
  if (nasc_present) {
    j.write_fieldname("");
    nasc.to_json(j);
  }
  j.write_fieldname("");
  pdu_session_res_setup_list_ho_req.to_json(j);
  j.write_fieldname("");
  allowed_nssai.to_json(j);
  if (trace_activation_present) {
    j.write_fieldname("");
    trace_activation.to_json(j);
  }
  if (masked_imeisv_present) {
    j.write_fieldname("");
    masked_imeisv.to_json(j);
  }
  j.write_fieldname("");
  source_to_target_transparent_container.to_json(j);
  if (mob_restrict_list_present) {
    j.write_fieldname("");
    mob_restrict_list.to_json(j);
  }
  if (location_report_request_type_present) {
    j.write_fieldname("");
    location_report_request_type.to_json(j);
  }
  if (rrc_inactive_transition_report_request_present) {
    j.write_fieldname("");
    rrc_inactive_transition_report_request.to_json(j);
  }
  j.write_fieldname("");
  guami.to_json(j);
  if (redirection_voice_fallback_present) {
    j.write_fieldname("");
    redirection_voice_fallback.to_json(j);
  }
  if (cn_assisted_ran_tuning_present) {
    j.write_fieldname("");
    cn_assisted_ran_tuning.to_json(j);
  }
  if (srvcc_operation_possible_present) {
    j.write_fieldname("");
    srvcc_operation_possible.to_json(j);
  }
  if (iab_authorized_present) {
    j.write_fieldname("");
    iab_authorized.to_json(j);
  }
  if (enhanced_coverage_restrict_present) {
    j.write_fieldname("");
    enhanced_coverage_restrict.to_json(j);
  }
  if (ue_diff_info_present) {
    j.write_fieldname("");
    ue_diff_info.to_json(j);
  }
  if (nr_v2x_services_authorized_present) {
    j.write_fieldname("");
    nr_v2x_services_authorized.to_json(j);
  }
  if (ltev2x_services_authorized_present) {
    j.write_fieldname("");
    ltev2x_services_authorized.to_json(j);
  }
  if (nr_ue_sidelink_aggr_max_bitrate_present) {
    j.write_fieldname("");
    nr_ue_sidelink_aggr_max_bitrate.to_json(j);
  }
  if (lte_ue_sidelink_aggr_max_bitrate_present) {
    j.write_fieldname("");
    lte_ue_sidelink_aggr_max_bitrate.to_json(j);
  }
  if (pc5_qos_params_present) {
    j.write_fieldname("");
    pc5_qos_params.to_json(j);
  }
  if (ce_mode_brestricted_present) {
    j.write_fieldname("");
    ce_mode_brestricted.to_json(j);
  }
  if (ue_up_c_iot_support_present) {
    j.write_fieldname("");
    ue_up_c_iot_support.to_json(j);
  }
  if (management_based_mdt_plmn_list_present) {
    j.write_fieldname("");
    management_based_mdt_plmn_list.to_json(j);
  }
  if (ue_radio_cap_id_present) {
    j.write_fieldname("");
    ue_radio_cap_id.to_json(j);
  }
  if (extended_connected_time_present) {
    j.write_fieldname("");
    extended_connected_time.to_json(j);
  }
  if (time_sync_assist_info_present) {
    j.write_fieldname("");
    time_sync_assist_info.to_json(j);
  }
  if (ue_slice_max_bit_rate_list_present) {
    j.write_fieldname("");
    ue_slice_max_bit_rate_list.to_json(j);
  }
  if (five_g_pro_se_authorized_present) {
    j.write_fieldname("");
    five_g_pro_se_authorized.to_json(j);
  }
  if (five_g_pro_se_ue_pc5_aggr_max_bit_rate_present) {
    j.write_fieldname("");
    five_g_pro_se_ue_pc5_aggr_max_bit_rate.to_json(j);
  }
  if (five_g_pro_se_pc5_qos_params_present) {
    j.write_fieldname("");
    five_g_pro_se_pc5_qos_params.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceAdmittedItem ::= SEQUENCE
SRSASN_CODE pdu_session_res_admitted_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pdu_session_id, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(ho_request_ack_transfer.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_admitted_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pdu_session_id, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(ho_request_ack_transfer.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_admitted_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pDUSessionID", pdu_session_id);
  j.write_str("handoverRequestAcknowledgeTransfer", ho_request_ack_transfer.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceFailedToSetupItemHOAck ::= SEQUENCE
SRSASN_CODE pdu_session_res_failed_to_setup_item_ho_ack_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pdu_session_id, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(ho_res_alloc_unsuccessful_transfer.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_failed_to_setup_item_ho_ack_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pdu_session_id, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(ho_res_alloc_unsuccessful_transfer.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_failed_to_setup_item_ho_ack_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pDUSessionID", pdu_session_id);
  j.write_str("handoverResourceAllocationUnsuccessfulTransfer", ho_res_alloc_unsuccessful_transfer.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// NPN-AccessInformation ::= CHOICE
void npn_access_info_c::destroy_()
{
  switch (type_) {
    case types::pni_npn_access_info:
      c.destroy<cell_cag_list_l>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<npn_access_info_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void npn_access_info_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::pni_npn_access_info:
      c.init<cell_cag_list_l>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<npn_access_info_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "npn_access_info_c");
  }
}
npn_access_info_c::npn_access_info_c(const npn_access_info_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::pni_npn_access_info:
      c.init(other.c.get<cell_cag_list_l>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<npn_access_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "npn_access_info_c");
  }
}
npn_access_info_c& npn_access_info_c::operator=(const npn_access_info_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::pni_npn_access_info:
      c.set(other.c.get<cell_cag_list_l>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<npn_access_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "npn_access_info_c");
  }

  return *this;
}
cell_cag_list_l& npn_access_info_c::set_pni_npn_access_info()
{
  set(types::pni_npn_access_info);
  return c.get<cell_cag_list_l>();
}
protocol_ie_single_container_s<npn_access_info_ext_ies_o>& npn_access_info_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<npn_access_info_ext_ies_o>>();
}
void npn_access_info_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::pni_npn_access_info:
      j.start_array("pNI-NPN-Access-Information");
      for (const auto& e1 : c.get<cell_cag_list_l>()) {
        j.write_str(e1.to_string());
      }
      j.end_array();
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<npn_access_info_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "npn_access_info_c");
  }
  j.end_obj();
}
SRSASN_CODE npn_access_info_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::pni_npn_access_info:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<cell_cag_list_l>(), 1, 64, true));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<npn_access_info_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "npn_access_info_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE npn_access_info_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::pni_npn_access_info:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<cell_cag_list_l>(), bref, 1, 64, true));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<npn_access_info_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "npn_access_info_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* npn_access_info_c::types_opts::to_string() const
{
  static const char* names[] = {"pNI-NPN-Access-Information", "choice-Extensions"};
  return convert_enum_idx(names, 2, value, "npn_access_info_c::types");
}

// RedCapIndication ::= ENUMERATED
const char* red_cap_ind_opts::to_string() const
{
  static const char* names[] = {"redcap"};
  return convert_enum_idx(names, 1, value, "red_cap_ind_e");
}

// HandoverRequestAcknowledgeIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ho_request_ack_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 53, 56, 106, 19, 259, 333};
  return map_enum_number(names, 8, idx, "id");
}
bool ho_request_ack_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 53, 56, 106, 19, 259, 333};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ho_request_ack_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::ignore;
    case 85:
      return crit_e::ignore;
    case 53:
      return crit_e::ignore;
    case 56:
      return crit_e::ignore;
    case 106:
      return crit_e::reject;
    case 19:
      return crit_e::ignore;
    case 259:
      return crit_e::reject;
    case 333:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ho_request_ack_ies_o::value_c ho_request_ack_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 53:
      ret.set(value_c::types::pdu_session_res_admitted_list);
      break;
    case 56:
      ret.set(value_c::types::pdu_session_res_failed_to_setup_list_ho_ack);
      break;
    case 106:
      ret.set(value_c::types::target_to_source_transparent_container);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    case 259:
      ret.set(value_c::types::npn_access_info);
      break;
    case 333:
      ret.set(value_c::types::red_cap_ind);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ho_request_ack_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 53:
      return presence_e::mandatory;
    case 56:
      return presence_e::optional;
    case 106:
      return presence_e::mandatory;
    case 19:
      return presence_e::optional;
    case 259:
      return presence_e::optional;
    case 333:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ho_request_ack_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::pdu_session_res_admitted_list:
      c.destroy<pdu_session_res_admitted_list_l>();
      break;
    case types::pdu_session_res_failed_to_setup_list_ho_ack:
      c.destroy<pdu_session_res_failed_to_setup_list_ho_ack_l>();
      break;
    case types::target_to_source_transparent_container:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    case types::npn_access_info:
      c.destroy<npn_access_info_c>();
      break;
    default:
      break;
  }
}
void ho_request_ack_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::pdu_session_res_admitted_list:
      c.init<pdu_session_res_admitted_list_l>();
      break;
    case types::pdu_session_res_failed_to_setup_list_ho_ack:
      c.init<pdu_session_res_failed_to_setup_list_ho_ack_l>();
      break;
    case types::target_to_source_transparent_container:
      c.init<unbounded_octstring<true>>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::npn_access_info:
      c.init<npn_access_info_c>();
      break;
    case types::red_cap_ind:
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_request_ack_ies_o::value_c");
  }
}
ho_request_ack_ies_o::value_c::value_c(const ho_request_ack_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::pdu_session_res_admitted_list:
      c.init(other.c.get<pdu_session_res_admitted_list_l>());
      break;
    case types::pdu_session_res_failed_to_setup_list_ho_ack:
      c.init(other.c.get<pdu_session_res_failed_to_setup_list_ho_ack_l>());
      break;
    case types::target_to_source_transparent_container:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::npn_access_info:
      c.init(other.c.get<npn_access_info_c>());
      break;
    case types::red_cap_ind:
      c.init(other.c.get<red_cap_ind_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_request_ack_ies_o::value_c");
  }
}
ho_request_ack_ies_o::value_c& ho_request_ack_ies_o::value_c::operator=(const ho_request_ack_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::pdu_session_res_admitted_list:
      c.set(other.c.get<pdu_session_res_admitted_list_l>());
      break;
    case types::pdu_session_res_failed_to_setup_list_ho_ack:
      c.set(other.c.get<pdu_session_res_failed_to_setup_list_ho_ack_l>());
      break;
    case types::target_to_source_transparent_container:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::npn_access_info:
      c.set(other.c.get<npn_access_info_c>());
      break;
    case types::red_cap_ind:
      c.set(other.c.get<red_cap_ind_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_request_ack_ies_o::value_c");
  }

  return *this;
}
uint64_t& ho_request_ack_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ho_request_ack_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
pdu_session_res_admitted_list_l& ho_request_ack_ies_o::value_c::pdu_session_res_admitted_list()
{
  assert_choice_type(types::pdu_session_res_admitted_list, type_, "Value");
  return c.get<pdu_session_res_admitted_list_l>();
}
pdu_session_res_failed_to_setup_list_ho_ack_l&
ho_request_ack_ies_o::value_c::pdu_session_res_failed_to_setup_list_ho_ack()
{
  assert_choice_type(types::pdu_session_res_failed_to_setup_list_ho_ack, type_, "Value");
  return c.get<pdu_session_res_failed_to_setup_list_ho_ack_l>();
}
unbounded_octstring<true>& ho_request_ack_ies_o::value_c::target_to_source_transparent_container()
{
  assert_choice_type(types::target_to_source_transparent_container, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
crit_diagnostics_s& ho_request_ack_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
npn_access_info_c& ho_request_ack_ies_o::value_c::npn_access_info()
{
  assert_choice_type(types::npn_access_info, type_, "Value");
  return c.get<npn_access_info_c>();
}
red_cap_ind_e& ho_request_ack_ies_o::value_c::red_cap_ind()
{
  assert_choice_type(types::red_cap_ind, type_, "Value");
  return c.get<red_cap_ind_e>();
}
const uint64_t& ho_request_ack_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ho_request_ack_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const pdu_session_res_admitted_list_l& ho_request_ack_ies_o::value_c::pdu_session_res_admitted_list() const
{
  assert_choice_type(types::pdu_session_res_admitted_list, type_, "Value");
  return c.get<pdu_session_res_admitted_list_l>();
}
const pdu_session_res_failed_to_setup_list_ho_ack_l&
ho_request_ack_ies_o::value_c::pdu_session_res_failed_to_setup_list_ho_ack() const
{
  assert_choice_type(types::pdu_session_res_failed_to_setup_list_ho_ack, type_, "Value");
  return c.get<pdu_session_res_failed_to_setup_list_ho_ack_l>();
}
const unbounded_octstring<true>& ho_request_ack_ies_o::value_c::target_to_source_transparent_container() const
{
  assert_choice_type(types::target_to_source_transparent_container, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const crit_diagnostics_s& ho_request_ack_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const npn_access_info_c& ho_request_ack_ies_o::value_c::npn_access_info() const
{
  assert_choice_type(types::npn_access_info, type_, "Value");
  return c.get<npn_access_info_c>();
}
const red_cap_ind_e& ho_request_ack_ies_o::value_c::red_cap_ind() const
{
  assert_choice_type(types::red_cap_ind, type_, "Value");
  return c.get<red_cap_ind_e>();
}
void ho_request_ack_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::pdu_session_res_admitted_list:
      j.start_array("PDUSessionResourceAdmittedList");
      for (const auto& e1 : c.get<pdu_session_res_admitted_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::pdu_session_res_failed_to_setup_list_ho_ack:
      j.start_array("PDUSessionResourceFailedToSetupListHOAck");
      for (const auto& e1 : c.get<pdu_session_res_failed_to_setup_list_ho_ack_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::target_to_source_transparent_container:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    case types::npn_access_info:
      j.write_fieldname("NPN-AccessInformation");
      c.get<npn_access_info_c>().to_json(j);
      break;
    case types::red_cap_ind:
      j.write_str("RedCapIndication", "redcap");
      break;
    default:
      log_invalid_choice_id(type_, "ho_request_ack_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ho_request_ack_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_admitted_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_admitted_list_l>(), 1, 256, true));
      break;
    case types::pdu_session_res_failed_to_setup_list_ho_ack:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_failed_to_setup_list_ho_ack_l>(), 1, 256, true));
      break;
    case types::target_to_source_transparent_container:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    case types::npn_access_info:
      HANDLE_CODE(c.get<npn_access_info_c>().pack(bref));
      break;
    case types::red_cap_ind:
      HANDLE_CODE(c.get<red_cap_ind_e>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_request_ack_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_request_ack_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_admitted_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_admitted_list_l>(), bref, 1, 256, true));
      break;
    case types::pdu_session_res_failed_to_setup_list_ho_ack:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_failed_to_setup_list_ho_ack_l>(), bref, 1, 256, true));
      break;
    case types::target_to_source_transparent_container:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    case types::npn_access_info:
      HANDLE_CODE(c.get<npn_access_info_c>().unpack(bref));
      break;
    case types::red_cap_ind:
      HANDLE_CODE(c.get<red_cap_ind_e>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_request_ack_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ho_request_ack_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..1099511627775)",
                                "INTEGER (0..4294967295)",
                                "PDUSessionResourceAdmittedList",
                                "PDUSessionResourceFailedToSetupListHOAck",
                                "OCTET STRING",
                                "CriticalityDiagnostics",
                                "NPN-AccessInformation",
                                "RedCapIndication"};
  return convert_enum_idx(names, 8, value, "ho_request_ack_ies_o::value_c::types");
}

template struct asn1::protocol_ie_field_s<ho_request_ack_ies_o>;

ho_request_ack_ies_container::ho_request_ack_ies_container() :
  amf_ue_ngap_id(10, crit_e::ignore),
  ran_ue_ngap_id(85, crit_e::ignore),
  pdu_session_res_admitted_list(53, crit_e::ignore),
  pdu_session_res_failed_to_setup_list_ho_ack(56, crit_e::ignore),
  target_to_source_transparent_container(106, crit_e::reject),
  crit_diagnostics(19, crit_e::ignore),
  npn_access_info(259, crit_e::reject),
  red_cap_ind(333, crit_e::ignore)
{
}
SRSASN_CODE ho_request_ack_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 4;
  nof_ies += pdu_session_res_failed_to_setup_list_ho_ack_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  nof_ies += npn_access_info_present ? 1 : 0;
  nof_ies += red_cap_ind_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  HANDLE_CODE(pdu_session_res_admitted_list.pack(bref));
  if (pdu_session_res_failed_to_setup_list_ho_ack_present) {
    HANDLE_CODE(pdu_session_res_failed_to_setup_list_ho_ack.pack(bref));
  }
  HANDLE_CODE(target_to_source_transparent_container.pack(bref));
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }
  if (npn_access_info_present) {
    HANDLE_CODE(npn_access_info.pack(bref));
  }
  if (red_cap_ind_present) {
    HANDLE_CODE(red_cap_ind.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_request_ack_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 4;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 53: {
        nof_mandatory_ies--;
        pdu_session_res_admitted_list.id = id;
        HANDLE_CODE(pdu_session_res_admitted_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pdu_session_res_admitted_list.value.unpack(bref));
        break;
      }
      case 56: {
        pdu_session_res_failed_to_setup_list_ho_ack_present = true;
        pdu_session_res_failed_to_setup_list_ho_ack.id      = id;
        HANDLE_CODE(pdu_session_res_failed_to_setup_list_ho_ack.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pdu_session_res_failed_to_setup_list_ho_ack.value.unpack(bref));
        break;
      }
      case 106: {
        nof_mandatory_ies--;
        target_to_source_transparent_container.id = id;
        HANDLE_CODE(target_to_source_transparent_container.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(target_to_source_transparent_container.value.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        crit_diagnostics.id      = id;
        HANDLE_CODE(crit_diagnostics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.value.unpack(bref));
        break;
      }
      case 259: {
        npn_access_info_present = true;
        npn_access_info.id      = id;
        HANDLE_CODE(npn_access_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(npn_access_info.value.unpack(bref));
        break;
      }
      case 333: {
        red_cap_ind_present = true;
        red_cap_ind.id      = id;
        HANDLE_CODE(red_cap_ind.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(red_cap_ind.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ho_request_ack_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  pdu_session_res_admitted_list.to_json(j);
  if (pdu_session_res_failed_to_setup_list_ho_ack_present) {
    j.write_fieldname("");
    pdu_session_res_failed_to_setup_list_ho_ack.to_json(j);
  }
  j.write_fieldname("");
  target_to_source_transparent_container.to_json(j);
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  if (npn_access_info_present) {
    j.write_fieldname("");
    npn_access_info.to_json(j);
  }
  if (red_cap_ind_present) {
    j.write_fieldname("");
    red_cap_ind.to_json(j);
  }
  j.end_obj();
}

// RSN ::= ENUMERATED
const char* r_sn_opts::to_string() const
{
  static const char* names[] = {"v1", "v2"};
  return convert_enum_idx(names, 2, value, "r_sn_e");
}
uint8_t r_sn_opts::to_number() const
{
  static const uint8_t numbers[] = {1, 2};
  return map_enum_number(numbers, 2, value, "r_sn_e");
}

// RedundantPDUSessionInformation-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t redundant_pdu_session_info_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {331};
  return map_enum_number(names, 1, idx, "id");
}
bool redundant_pdu_session_info_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 331 == id;
}
crit_e redundant_pdu_session_info_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 331) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
redundant_pdu_session_info_ext_ies_o::ext_c redundant_pdu_session_info_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 331) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e redundant_pdu_session_info_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 331) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void redundant_pdu_session_info_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("INTEGER (0..255,...)", c);
  j.end_obj();
}
SRSASN_CODE redundant_pdu_session_info_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(pack_integer(bref, c, (uint16_t)0u, (uint16_t)255u, true, true));
  return SRSASN_SUCCESS;
}
SRSASN_CODE redundant_pdu_session_info_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(unpack_integer(c, bref, (uint16_t)0u, (uint16_t)255u, true, true));
  return SRSASN_SUCCESS;
}

const char* redundant_pdu_session_info_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..255,...)"};
  return convert_enum_idx(names, 1, value, "redundant_pdu_session_info_ext_ies_o::ext_c::types");
}
uint8_t redundant_pdu_session_info_ext_ies_o::ext_c::types_opts::to_number() const
{
  static const uint8_t numbers[] = {0};
  return map_enum_number(numbers, 1, value, "redundant_pdu_session_info_ext_ies_o::ext_c::types");
}

// ConfidentialityProtectionResult ::= ENUMERATED
const char* confidentiality_protection_result_opts::to_string() const
{
  static const char* names[] = {"performed", "not-performed"};
  return convert_enum_idx(names, 2, value, "confidentiality_protection_result_e");
}

// IntegrityProtectionResult ::= ENUMERATED
const char* integrity_protection_result_opts::to_string() const
{
  static const char* names[] = {"performed", "not-performed"};
  return convert_enum_idx(names, 2, value, "integrity_protection_result_e");
}

// MBS-SupportIndicator ::= ENUMERATED
const char* mbs_support_ind_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "mbs_support_ind_e");
}

// RedundantPDUSessionInformation ::= SEQUENCE
SRSASN_CODE redundant_pdu_session_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(rsn.pack(bref));
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE redundant_pdu_session_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(rsn.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void redundant_pdu_session_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("rSN", rsn.to_string());
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// HandoverRequestAcknowledgeTransfer-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t ho_request_ack_transfer_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {153, 164, 172, 249, 192, 198, 27, 309};
  return map_enum_number(names, 8, idx, "id");
}
bool ho_request_ack_transfer_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {153, 164, 172, 249, 192, 198, 27, 309};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ho_request_ack_transfer_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 153:
      return crit_e::ignore;
    case 164:
      return crit_e::reject;
    case 172:
      return crit_e::reject;
    case 249:
      return crit_e::ignore;
    case 192:
      return crit_e::ignore;
    case 198:
      return crit_e::ignore;
    case 27:
      return crit_e::ignore;
    case 309:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ho_request_ack_transfer_ext_ies_o::ext_c ho_request_ack_transfer_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 153:
      ret.set(ext_c::types::add_dl_up_tnl_info_for_ho_list);
      break;
    case 164:
      ret.set(ext_c::types::ul_forwarding_up_tnl_info);
      break;
    case 172:
      ret.set(ext_c::types::add_ul_forwarding_up_tnl_info);
      break;
    case 249:
      ret.set(ext_c::types::data_forwarding_resp_erab_list);
      break;
    case 192:
      ret.set(ext_c::types::redundant_dl_ngu_up_tnl_info);
      break;
    case 198:
      ret.set(ext_c::types::used_r_sn_info);
      break;
    case 27:
      ret.set(ext_c::types::global_ran_node_id);
      break;
    case 309:
      ret.set(ext_c::types::mbs_support_ind);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ho_request_ack_transfer_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 153:
      return presence_e::optional;
    case 164:
      return presence_e::optional;
    case 172:
      return presence_e::optional;
    case 249:
      return presence_e::optional;
    case 192:
      return presence_e::optional;
    case 198:
      return presence_e::optional;
    case 27:
      return presence_e::optional;
    case 309:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void ho_request_ack_transfer_ext_ies_o::ext_c::destroy_()
{
  switch (type_) {
    case types::add_dl_up_tnl_info_for_ho_list:
      c.destroy<add_dl_up_tnl_info_for_ho_list_l>();
      break;
    case types::ul_forwarding_up_tnl_info:
      c.destroy<up_transport_layer_info_c>();
      break;
    case types::add_ul_forwarding_up_tnl_info:
      c.destroy<up_transport_layer_info_list_l>();
      break;
    case types::data_forwarding_resp_erab_list:
      c.destroy<data_forwarding_resp_erab_list_l>();
      break;
    case types::redundant_dl_ngu_up_tnl_info:
      c.destroy<up_transport_layer_info_c>();
      break;
    case types::used_r_sn_info:
      c.destroy<redundant_pdu_session_info_s>();
      break;
    case types::global_ran_node_id:
      c.destroy<global_ran_node_id_c>();
      break;
    default:
      break;
  }
}
void ho_request_ack_transfer_ext_ies_o::ext_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::add_dl_up_tnl_info_for_ho_list:
      c.init<add_dl_up_tnl_info_for_ho_list_l>();
      break;
    case types::ul_forwarding_up_tnl_info:
      c.init<up_transport_layer_info_c>();
      break;
    case types::add_ul_forwarding_up_tnl_info:
      c.init<up_transport_layer_info_list_l>();
      break;
    case types::data_forwarding_resp_erab_list:
      c.init<data_forwarding_resp_erab_list_l>();
      break;
    case types::redundant_dl_ngu_up_tnl_info:
      c.init<up_transport_layer_info_c>();
      break;
    case types::used_r_sn_info:
      c.init<redundant_pdu_session_info_s>();
      break;
    case types::global_ran_node_id:
      c.init<global_ran_node_id_c>();
      break;
    case types::mbs_support_ind:
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_request_ack_transfer_ext_ies_o::ext_c");
  }
}
ho_request_ack_transfer_ext_ies_o::ext_c::ext_c(const ho_request_ack_transfer_ext_ies_o::ext_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::add_dl_up_tnl_info_for_ho_list:
      c.init(other.c.get<add_dl_up_tnl_info_for_ho_list_l>());
      break;
    case types::ul_forwarding_up_tnl_info:
      c.init(other.c.get<up_transport_layer_info_c>());
      break;
    case types::add_ul_forwarding_up_tnl_info:
      c.init(other.c.get<up_transport_layer_info_list_l>());
      break;
    case types::data_forwarding_resp_erab_list:
      c.init(other.c.get<data_forwarding_resp_erab_list_l>());
      break;
    case types::redundant_dl_ngu_up_tnl_info:
      c.init(other.c.get<up_transport_layer_info_c>());
      break;
    case types::used_r_sn_info:
      c.init(other.c.get<redundant_pdu_session_info_s>());
      break;
    case types::global_ran_node_id:
      c.init(other.c.get<global_ran_node_id_c>());
      break;
    case types::mbs_support_ind:
      c.init(other.c.get<mbs_support_ind_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_request_ack_transfer_ext_ies_o::ext_c");
  }
}
ho_request_ack_transfer_ext_ies_o::ext_c&
ho_request_ack_transfer_ext_ies_o::ext_c::operator=(const ho_request_ack_transfer_ext_ies_o::ext_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::add_dl_up_tnl_info_for_ho_list:
      c.set(other.c.get<add_dl_up_tnl_info_for_ho_list_l>());
      break;
    case types::ul_forwarding_up_tnl_info:
      c.set(other.c.get<up_transport_layer_info_c>());
      break;
    case types::add_ul_forwarding_up_tnl_info:
      c.set(other.c.get<up_transport_layer_info_list_l>());
      break;
    case types::data_forwarding_resp_erab_list:
      c.set(other.c.get<data_forwarding_resp_erab_list_l>());
      break;
    case types::redundant_dl_ngu_up_tnl_info:
      c.set(other.c.get<up_transport_layer_info_c>());
      break;
    case types::used_r_sn_info:
      c.set(other.c.get<redundant_pdu_session_info_s>());
      break;
    case types::global_ran_node_id:
      c.set(other.c.get<global_ran_node_id_c>());
      break;
    case types::mbs_support_ind:
      c.set(other.c.get<mbs_support_ind_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_request_ack_transfer_ext_ies_o::ext_c");
  }

  return *this;
}
add_dl_up_tnl_info_for_ho_list_l& ho_request_ack_transfer_ext_ies_o::ext_c::add_dl_up_tnl_info_for_ho_list()
{
  assert_choice_type(types::add_dl_up_tnl_info_for_ho_list, type_, "Extension");
  return c.get<add_dl_up_tnl_info_for_ho_list_l>();
}
up_transport_layer_info_c& ho_request_ack_transfer_ext_ies_o::ext_c::ul_forwarding_up_tnl_info()
{
  assert_choice_type(types::ul_forwarding_up_tnl_info, type_, "Extension");
  return c.get<up_transport_layer_info_c>();
}
up_transport_layer_info_list_l& ho_request_ack_transfer_ext_ies_o::ext_c::add_ul_forwarding_up_tnl_info()
{
  assert_choice_type(types::add_ul_forwarding_up_tnl_info, type_, "Extension");
  return c.get<up_transport_layer_info_list_l>();
}
data_forwarding_resp_erab_list_l& ho_request_ack_transfer_ext_ies_o::ext_c::data_forwarding_resp_erab_list()
{
  assert_choice_type(types::data_forwarding_resp_erab_list, type_, "Extension");
  return c.get<data_forwarding_resp_erab_list_l>();
}
up_transport_layer_info_c& ho_request_ack_transfer_ext_ies_o::ext_c::redundant_dl_ngu_up_tnl_info()
{
  assert_choice_type(types::redundant_dl_ngu_up_tnl_info, type_, "Extension");
  return c.get<up_transport_layer_info_c>();
}
redundant_pdu_session_info_s& ho_request_ack_transfer_ext_ies_o::ext_c::used_r_sn_info()
{
  assert_choice_type(types::used_r_sn_info, type_, "Extension");
  return c.get<redundant_pdu_session_info_s>();
}
global_ran_node_id_c& ho_request_ack_transfer_ext_ies_o::ext_c::global_ran_node_id()
{
  assert_choice_type(types::global_ran_node_id, type_, "Extension");
  return c.get<global_ran_node_id_c>();
}
mbs_support_ind_e& ho_request_ack_transfer_ext_ies_o::ext_c::mbs_support_ind()
{
  assert_choice_type(types::mbs_support_ind, type_, "Extension");
  return c.get<mbs_support_ind_e>();
}
const add_dl_up_tnl_info_for_ho_list_l& ho_request_ack_transfer_ext_ies_o::ext_c::add_dl_up_tnl_info_for_ho_list() const
{
  assert_choice_type(types::add_dl_up_tnl_info_for_ho_list, type_, "Extension");
  return c.get<add_dl_up_tnl_info_for_ho_list_l>();
}
const up_transport_layer_info_c& ho_request_ack_transfer_ext_ies_o::ext_c::ul_forwarding_up_tnl_info() const
{
  assert_choice_type(types::ul_forwarding_up_tnl_info, type_, "Extension");
  return c.get<up_transport_layer_info_c>();
}
const up_transport_layer_info_list_l& ho_request_ack_transfer_ext_ies_o::ext_c::add_ul_forwarding_up_tnl_info() const
{
  assert_choice_type(types::add_ul_forwarding_up_tnl_info, type_, "Extension");
  return c.get<up_transport_layer_info_list_l>();
}
const data_forwarding_resp_erab_list_l& ho_request_ack_transfer_ext_ies_o::ext_c::data_forwarding_resp_erab_list() const
{
  assert_choice_type(types::data_forwarding_resp_erab_list, type_, "Extension");
  return c.get<data_forwarding_resp_erab_list_l>();
}
const up_transport_layer_info_c& ho_request_ack_transfer_ext_ies_o::ext_c::redundant_dl_ngu_up_tnl_info() const
{
  assert_choice_type(types::redundant_dl_ngu_up_tnl_info, type_, "Extension");
  return c.get<up_transport_layer_info_c>();
}
const redundant_pdu_session_info_s& ho_request_ack_transfer_ext_ies_o::ext_c::used_r_sn_info() const
{
  assert_choice_type(types::used_r_sn_info, type_, "Extension");
  return c.get<redundant_pdu_session_info_s>();
}
const global_ran_node_id_c& ho_request_ack_transfer_ext_ies_o::ext_c::global_ran_node_id() const
{
  assert_choice_type(types::global_ran_node_id, type_, "Extension");
  return c.get<global_ran_node_id_c>();
}
const mbs_support_ind_e& ho_request_ack_transfer_ext_ies_o::ext_c::mbs_support_ind() const
{
  assert_choice_type(types::mbs_support_ind, type_, "Extension");
  return c.get<mbs_support_ind_e>();
}
void ho_request_ack_transfer_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::add_dl_up_tnl_info_for_ho_list:
      j.start_array("AdditionalDLUPTNLInformationForHOList");
      for (const auto& e1 : c.get<add_dl_up_tnl_info_for_ho_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::ul_forwarding_up_tnl_info:
      j.write_fieldname("UPTransportLayerInformation");
      c.get<up_transport_layer_info_c>().to_json(j);
      break;
    case types::add_ul_forwarding_up_tnl_info:
      j.start_array("UPTransportLayerInformationList");
      for (const auto& e1 : c.get<up_transport_layer_info_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::data_forwarding_resp_erab_list:
      j.start_array("DataForwardingResponseERABList");
      for (const auto& e1 : c.get<data_forwarding_resp_erab_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::redundant_dl_ngu_up_tnl_info:
      j.write_fieldname("UPTransportLayerInformation");
      c.get<up_transport_layer_info_c>().to_json(j);
      break;
    case types::used_r_sn_info:
      j.write_fieldname("RedundantPDUSessionInformation");
      c.get<redundant_pdu_session_info_s>().to_json(j);
      break;
    case types::global_ran_node_id:
      j.write_fieldname("GlobalRANNodeID");
      c.get<global_ran_node_id_c>().to_json(j);
      break;
    case types::mbs_support_ind:
      j.write_str("MBS-SupportIndicator", "true");
      break;
    default:
      log_invalid_choice_id(type_, "ho_request_ack_transfer_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE ho_request_ack_transfer_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::add_dl_up_tnl_info_for_ho_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<add_dl_up_tnl_info_for_ho_list_l>(), 1, 3, true));
      break;
    case types::ul_forwarding_up_tnl_info:
      HANDLE_CODE(c.get<up_transport_layer_info_c>().pack(bref));
      break;
    case types::add_ul_forwarding_up_tnl_info:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<up_transport_layer_info_list_l>(), 1, 3, true));
      break;
    case types::data_forwarding_resp_erab_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<data_forwarding_resp_erab_list_l>(), 1, 256, true));
      break;
    case types::redundant_dl_ngu_up_tnl_info:
      HANDLE_CODE(c.get<up_transport_layer_info_c>().pack(bref));
      break;
    case types::used_r_sn_info:
      HANDLE_CODE(c.get<redundant_pdu_session_info_s>().pack(bref));
      break;
    case types::global_ran_node_id:
      HANDLE_CODE(c.get<global_ran_node_id_c>().pack(bref));
      break;
    case types::mbs_support_ind:
      HANDLE_CODE(c.get<mbs_support_ind_e>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_request_ack_transfer_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_request_ack_transfer_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::add_dl_up_tnl_info_for_ho_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<add_dl_up_tnl_info_for_ho_list_l>(), bref, 1, 3, true));
      break;
    case types::ul_forwarding_up_tnl_info:
      HANDLE_CODE(c.get<up_transport_layer_info_c>().unpack(bref));
      break;
    case types::add_ul_forwarding_up_tnl_info:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<up_transport_layer_info_list_l>(), bref, 1, 3, true));
      break;
    case types::data_forwarding_resp_erab_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<data_forwarding_resp_erab_list_l>(), bref, 1, 256, true));
      break;
    case types::redundant_dl_ngu_up_tnl_info:
      HANDLE_CODE(c.get<up_transport_layer_info_c>().unpack(bref));
      break;
    case types::used_r_sn_info:
      HANDLE_CODE(c.get<redundant_pdu_session_info_s>().unpack(bref));
      break;
    case types::global_ran_node_id:
      HANDLE_CODE(c.get<global_ran_node_id_c>().unpack(bref));
      break;
    case types::mbs_support_ind:
      HANDLE_CODE(c.get<mbs_support_ind_e>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_request_ack_transfer_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ho_request_ack_transfer_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"AdditionalDLUPTNLInformationForHOList",
                                "UPTransportLayerInformation",
                                "UPTransportLayerInformationList",
                                "DataForwardingResponseERABList",
                                "UPTransportLayerInformation",
                                "RedundantPDUSessionInformation",
                                "GlobalRANNodeID",
                                "MBS-SupportIndicator"};
  return convert_enum_idx(names, 8, value, "ho_request_ack_transfer_ext_ies_o::ext_c::types");
}

// SecurityResult ::= SEQUENCE
SRSASN_CODE security_result_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(integrity_protection_result.pack(bref));
  HANDLE_CODE(confidentiality_protection_result.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE security_result_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(integrity_protection_result.unpack(bref));
  HANDLE_CODE(confidentiality_protection_result.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void security_result_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("integrityProtectionResult", integrity_protection_result.to_string());
  j.write_str("confidentialityProtectionResult", confidentiality_protection_result.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ext_field_s<ho_request_ack_transfer_ext_ies_o>;

ho_request_ack_transfer_ext_ies_container::ho_request_ack_transfer_ext_ies_container() :
  add_dl_up_tnl_info_for_ho_list(153, crit_e::ignore),
  ul_forwarding_up_tnl_info(164, crit_e::reject),
  add_ul_forwarding_up_tnl_info(172, crit_e::reject),
  data_forwarding_resp_erab_list(249, crit_e::ignore),
  redundant_dl_ngu_up_tnl_info(192, crit_e::ignore),
  used_r_sn_info(198, crit_e::ignore),
  global_ran_node_id(27, crit_e::ignore),
  mbs_support_ind(309, crit_e::ignore)
{
}
SRSASN_CODE ho_request_ack_transfer_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += add_dl_up_tnl_info_for_ho_list_present ? 1 : 0;
  nof_ies += ul_forwarding_up_tnl_info_present ? 1 : 0;
  nof_ies += add_ul_forwarding_up_tnl_info_present ? 1 : 0;
  nof_ies += data_forwarding_resp_erab_list_present ? 1 : 0;
  nof_ies += redundant_dl_ngu_up_tnl_info_present ? 1 : 0;
  nof_ies += used_r_sn_info_present ? 1 : 0;
  nof_ies += global_ran_node_id_present ? 1 : 0;
  nof_ies += mbs_support_ind_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (add_dl_up_tnl_info_for_ho_list_present) {
    HANDLE_CODE(add_dl_up_tnl_info_for_ho_list.pack(bref));
  }
  if (ul_forwarding_up_tnl_info_present) {
    HANDLE_CODE(ul_forwarding_up_tnl_info.pack(bref));
  }
  if (add_ul_forwarding_up_tnl_info_present) {
    HANDLE_CODE(add_ul_forwarding_up_tnl_info.pack(bref));
  }
  if (data_forwarding_resp_erab_list_present) {
    HANDLE_CODE(data_forwarding_resp_erab_list.pack(bref));
  }
  if (redundant_dl_ngu_up_tnl_info_present) {
    HANDLE_CODE(redundant_dl_ngu_up_tnl_info.pack(bref));
  }
  if (used_r_sn_info_present) {
    HANDLE_CODE(used_r_sn_info.pack(bref));
  }
  if (global_ran_node_id_present) {
    HANDLE_CODE(global_ran_node_id.pack(bref));
  }
  if (mbs_support_ind_present) {
    HANDLE_CODE(mbs_support_ind.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_request_ack_transfer_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 153: {
        add_dl_up_tnl_info_for_ho_list_present = true;
        add_dl_up_tnl_info_for_ho_list.id      = id;
        HANDLE_CODE(add_dl_up_tnl_info_for_ho_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(add_dl_up_tnl_info_for_ho_list.ext.unpack(bref));
        break;
      }
      case 164: {
        ul_forwarding_up_tnl_info_present = true;
        ul_forwarding_up_tnl_info.id      = id;
        HANDLE_CODE(ul_forwarding_up_tnl_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ul_forwarding_up_tnl_info.ext.unpack(bref));
        break;
      }
      case 172: {
        add_ul_forwarding_up_tnl_info_present = true;
        add_ul_forwarding_up_tnl_info.id      = id;
        HANDLE_CODE(add_ul_forwarding_up_tnl_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(add_ul_forwarding_up_tnl_info.ext.unpack(bref));
        break;
      }
      case 249: {
        data_forwarding_resp_erab_list_present = true;
        data_forwarding_resp_erab_list.id      = id;
        HANDLE_CODE(data_forwarding_resp_erab_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(data_forwarding_resp_erab_list.ext.unpack(bref));
        break;
      }
      case 192: {
        redundant_dl_ngu_up_tnl_info_present = true;
        redundant_dl_ngu_up_tnl_info.id      = id;
        HANDLE_CODE(redundant_dl_ngu_up_tnl_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(redundant_dl_ngu_up_tnl_info.ext.unpack(bref));
        break;
      }
      case 198: {
        used_r_sn_info_present = true;
        used_r_sn_info.id      = id;
        HANDLE_CODE(used_r_sn_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(used_r_sn_info.ext.unpack(bref));
        break;
      }
      case 27: {
        global_ran_node_id_present = true;
        global_ran_node_id.id      = id;
        HANDLE_CODE(global_ran_node_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(global_ran_node_id.ext.unpack(bref));
        break;
      }
      case 309: {
        mbs_support_ind_present = true;
        mbs_support_ind.id      = id;
        HANDLE_CODE(mbs_support_ind.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_support_ind.ext.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void ho_request_ack_transfer_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (add_dl_up_tnl_info_for_ho_list_present) {
    j.write_fieldname("");
    add_dl_up_tnl_info_for_ho_list.to_json(j);
  }
  if (ul_forwarding_up_tnl_info_present) {
    j.write_fieldname("");
    ul_forwarding_up_tnl_info.to_json(j);
  }
  if (add_ul_forwarding_up_tnl_info_present) {
    j.write_fieldname("");
    add_ul_forwarding_up_tnl_info.to_json(j);
  }
  if (data_forwarding_resp_erab_list_present) {
    j.write_fieldname("");
    data_forwarding_resp_erab_list.to_json(j);
  }
  if (redundant_dl_ngu_up_tnl_info_present) {
    j.write_fieldname("");
    redundant_dl_ngu_up_tnl_info.to_json(j);
  }
  if (used_r_sn_info_present) {
    j.write_fieldname("");
    used_r_sn_info.to_json(j);
  }
  if (global_ran_node_id_present) {
    j.write_fieldname("");
    global_ran_node_id.to_json(j);
  }
  if (mbs_support_ind_present) {
    j.write_fieldname("");
    mbs_support_ind.to_json(j);
  }
  j.end_obj();
}

// HandoverRequestAcknowledgeTransfer ::= SEQUENCE
SRSASN_CODE ho_request_ack_transfer_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(dl_forwarding_up_tnl_info_present, 1));
  HANDLE_CODE(bref.pack(security_result_present, 1));
  HANDLE_CODE(bref.pack(qos_flow_failed_to_setup_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(data_forwarding_resp_drb_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(dl_ngu_up_tnl_info.pack(bref));
  if (dl_forwarding_up_tnl_info_present) {
    HANDLE_CODE(dl_forwarding_up_tnl_info.pack(bref));
  }
  if (security_result_present) {
    HANDLE_CODE(security_result.pack(bref));
  }
  HANDLE_CODE(pack_dyn_seq_of(bref, qos_flow_setup_resp_list, 1, 64, true));
  if (qos_flow_failed_to_setup_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, qos_flow_failed_to_setup_list, 1, 64, true));
  }
  if (data_forwarding_resp_drb_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, data_forwarding_resp_drb_list, 1, 32, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_request_ack_transfer_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(dl_forwarding_up_tnl_info_present, 1));
  HANDLE_CODE(bref.unpack(security_result_present, 1));
  bool qos_flow_failed_to_setup_list_present;
  HANDLE_CODE(bref.unpack(qos_flow_failed_to_setup_list_present, 1));
  bool data_forwarding_resp_drb_list_present;
  HANDLE_CODE(bref.unpack(data_forwarding_resp_drb_list_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(dl_ngu_up_tnl_info.unpack(bref));
  if (dl_forwarding_up_tnl_info_present) {
    HANDLE_CODE(dl_forwarding_up_tnl_info.unpack(bref));
  }
  if (security_result_present) {
    HANDLE_CODE(security_result.unpack(bref));
  }
  HANDLE_CODE(unpack_dyn_seq_of(qos_flow_setup_resp_list, bref, 1, 64, true));
  if (qos_flow_failed_to_setup_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(qos_flow_failed_to_setup_list, bref, 1, 64, true));
  }
  if (data_forwarding_resp_drb_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(data_forwarding_resp_drb_list, bref, 1, 32, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ho_request_ack_transfer_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("dL-NGU-UP-TNLInformation");
  dl_ngu_up_tnl_info.to_json(j);
  if (dl_forwarding_up_tnl_info_present) {
    j.write_fieldname("dLForwardingUP-TNLInformation");
    dl_forwarding_up_tnl_info.to_json(j);
  }
  if (security_result_present) {
    j.write_fieldname("securityResult");
    security_result.to_json(j);
  }
  j.start_array("qosFlowSetupResponseList");
  for (const auto& e1 : qos_flow_setup_resp_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (qos_flow_failed_to_setup_list.size() > 0) {
    j.start_array("qosFlowFailedToSetupList");
    for (const auto& e1 : qos_flow_failed_to_setup_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (data_forwarding_resp_drb_list.size() > 0) {
    j.start_array("dataForwardingResponseDRBList");
    for (const auto& e1 : data_forwarding_resp_drb_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// LAI ::= SEQUENCE
SRSASN_CODE lai_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.pack(bref));
  HANDLE_CODE(lac.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE lai_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.unpack(bref));
  HANDLE_CODE(lac.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void lai_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("pLMNidentity", plmn_id.to_string());
  j.write_str("lAC", lac.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TargetHomeENB-ID ::= SEQUENCE
SRSASN_CODE target_home_enb_id_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.pack(bref));
  HANDLE_CODE(home_enb_id.pack(bref));
  HANDLE_CODE(sel_eps_tai.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE target_home_enb_id_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.unpack(bref));
  HANDLE_CODE(home_enb_id.unpack(bref));
  HANDLE_CODE(sel_eps_tai.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void target_home_enb_id_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("pLMNidentity", plmn_id.to_string());
  j.write_str("homeENB-ID", home_enb_id.to_string());
  j.write_fieldname("selected-EPS-TAI");
  sel_eps_tai.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TargetRNC-ID ::= SEQUENCE
SRSASN_CODE target_rnc_id_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(extended_rnc_id_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(lai.pack(bref));
  HANDLE_CODE(pack_integer(bref, rnc_id, (uint16_t)0u, (uint16_t)4095u, false, true));
  if (extended_rnc_id_present) {
    HANDLE_CODE(pack_integer(bref, extended_rnc_id, (uint32_t)4096u, (uint32_t)65535u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE target_rnc_id_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(extended_rnc_id_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(lai.unpack(bref));
  HANDLE_CODE(unpack_integer(rnc_id, bref, (uint16_t)0u, (uint16_t)4095u, false, true));
  if (extended_rnc_id_present) {
    HANDLE_CODE(unpack_integer(extended_rnc_id, bref, (uint32_t)4096u, (uint32_t)65535u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void target_rnc_id_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("lAI");
  lai.to_json(j);
  j.write_int("rNC-ID", rnc_id);
  if (extended_rnc_id_present) {
    j.write_int("extendedRNC-ID", extended_rnc_id);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceItemHORqd ::= SEQUENCE
SRSASN_CODE pdu_session_res_item_ho_rqd_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pdu_session_id, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(ho_required_transfer.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_item_ho_rqd_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pdu_session_id, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(ho_required_transfer.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_item_ho_rqd_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pDUSessionID", pdu_session_id);
  j.write_str("handoverRequiredTransfer", ho_required_transfer.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TargetID-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t target_id_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {178, 364};
  return map_enum_number(names, 2, idx, "id");
}
bool target_id_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {178, 364};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e target_id_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 178:
      return crit_e::reject;
    case 364:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
target_id_ext_ies_o::value_c target_id_ext_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 178:
      ret.set(value_c::types::target_rnc_id);
      break;
    case 364:
      ret.set(value_c::types::target_home_enb_id);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e target_id_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 178:
      return presence_e::mandatory;
    case 364:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void target_id_ext_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::target_rnc_id:
      c.destroy<target_rnc_id_s>();
      break;
    case types::target_home_enb_id:
      c.destroy<target_home_enb_id_s>();
      break;
    default:
      break;
  }
}
void target_id_ext_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::target_rnc_id:
      c.init<target_rnc_id_s>();
      break;
    case types::target_home_enb_id:
      c.init<target_home_enb_id_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "target_id_ext_ies_o::value_c");
  }
}
target_id_ext_ies_o::value_c::value_c(const target_id_ext_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::target_rnc_id:
      c.init(other.c.get<target_rnc_id_s>());
      break;
    case types::target_home_enb_id:
      c.init(other.c.get<target_home_enb_id_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "target_id_ext_ies_o::value_c");
  }
}
target_id_ext_ies_o::value_c& target_id_ext_ies_o::value_c::operator=(const target_id_ext_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::target_rnc_id:
      c.set(other.c.get<target_rnc_id_s>());
      break;
    case types::target_home_enb_id:
      c.set(other.c.get<target_home_enb_id_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "target_id_ext_ies_o::value_c");
  }

  return *this;
}
target_rnc_id_s& target_id_ext_ies_o::value_c::target_rnc_id()
{
  assert_choice_type(types::target_rnc_id, type_, "Value");
  return c.get<target_rnc_id_s>();
}
target_home_enb_id_s& target_id_ext_ies_o::value_c::target_home_enb_id()
{
  assert_choice_type(types::target_home_enb_id, type_, "Value");
  return c.get<target_home_enb_id_s>();
}
const target_rnc_id_s& target_id_ext_ies_o::value_c::target_rnc_id() const
{
  assert_choice_type(types::target_rnc_id, type_, "Value");
  return c.get<target_rnc_id_s>();
}
const target_home_enb_id_s& target_id_ext_ies_o::value_c::target_home_enb_id() const
{
  assert_choice_type(types::target_home_enb_id, type_, "Value");
  return c.get<target_home_enb_id_s>();
}
void target_id_ext_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::target_rnc_id:
      j.write_fieldname("TargetRNC-ID");
      c.get<target_rnc_id_s>().to_json(j);
      break;
    case types::target_home_enb_id:
      j.write_fieldname("TargetHomeENB-ID");
      c.get<target_home_enb_id_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "target_id_ext_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE target_id_ext_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::target_rnc_id:
      HANDLE_CODE(c.get<target_rnc_id_s>().pack(bref));
      break;
    case types::target_home_enb_id:
      HANDLE_CODE(c.get<target_home_enb_id_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "target_id_ext_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE target_id_ext_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::target_rnc_id:
      HANDLE_CODE(c.get<target_rnc_id_s>().unpack(bref));
      break;
    case types::target_home_enb_id:
      HANDLE_CODE(c.get<target_home_enb_id_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "target_id_ext_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* target_id_ext_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"TargetRNC-ID", "TargetHomeENB-ID"};
  return convert_enum_idx(names, 2, value, "target_id_ext_ies_o::value_c::types");
}

// TargetRANNodeID ::= SEQUENCE
SRSASN_CODE target_ran_node_id_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(global_ran_node_id.pack(bref));
  HANDLE_CODE(sel_tai.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE target_ran_node_id_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(global_ran_node_id.unpack(bref));
  HANDLE_CODE(sel_tai.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void target_ran_node_id_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("globalRANNodeID");
  global_ran_node_id.to_json(j);
  j.write_fieldname("selectedTAI");
  sel_tai.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TargeteNB-ID ::= SEQUENCE
SRSASN_CODE target_enb_id_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(global_enb_id.pack(bref));
  HANDLE_CODE(sel_eps_tai.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE target_enb_id_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(global_enb_id.unpack(bref));
  HANDLE_CODE(sel_eps_tai.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void target_enb_id_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("globalENB-ID");
  global_enb_id.to_json(j);
  j.write_fieldname("selected-EPS-TAI");
  sel_eps_tai.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// DirectForwardingPathAvailability ::= ENUMERATED
const char* direct_forwarding_path_availability_opts::to_string() const
{
  static const char* names[] = {"direct-path-available"};
  return convert_enum_idx(names, 1, value, "direct_forwarding_path_availability_e");
}

template struct asn1::protocol_ie_single_container_s<target_id_ext_ies_o>;

// TargetID ::= CHOICE
void target_id_c::destroy_()
{
  switch (type_) {
    case types::target_ran_node_id:
      c.destroy<target_ran_node_id_s>();
      break;
    case types::target_enb_id:
      c.destroy<target_enb_id_s>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<target_id_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void target_id_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::target_ran_node_id:
      c.init<target_ran_node_id_s>();
      break;
    case types::target_enb_id:
      c.init<target_enb_id_s>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<target_id_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "target_id_c");
  }
}
target_id_c::target_id_c(const target_id_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::target_ran_node_id:
      c.init(other.c.get<target_ran_node_id_s>());
      break;
    case types::target_enb_id:
      c.init(other.c.get<target_enb_id_s>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<target_id_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "target_id_c");
  }
}
target_id_c& target_id_c::operator=(const target_id_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::target_ran_node_id:
      c.set(other.c.get<target_ran_node_id_s>());
      break;
    case types::target_enb_id:
      c.set(other.c.get<target_enb_id_s>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<target_id_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "target_id_c");
  }

  return *this;
}
target_ran_node_id_s& target_id_c::set_target_ran_node_id()
{
  set(types::target_ran_node_id);
  return c.get<target_ran_node_id_s>();
}
target_enb_id_s& target_id_c::set_target_enb_id()
{
  set(types::target_enb_id);
  return c.get<target_enb_id_s>();
}
protocol_ie_single_container_s<target_id_ext_ies_o>& target_id_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<target_id_ext_ies_o>>();
}
void target_id_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::target_ran_node_id:
      j.write_fieldname("targetRANNodeID");
      c.get<target_ran_node_id_s>().to_json(j);
      break;
    case types::target_enb_id:
      j.write_fieldname("targeteNB-ID");
      c.get<target_enb_id_s>().to_json(j);
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<target_id_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "target_id_c");
  }
  j.end_obj();
}
SRSASN_CODE target_id_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::target_ran_node_id:
      HANDLE_CODE(c.get<target_ran_node_id_s>().pack(bref));
      break;
    case types::target_enb_id:
      HANDLE_CODE(c.get<target_enb_id_s>().pack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<target_id_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "target_id_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE target_id_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::target_ran_node_id:
      HANDLE_CODE(c.get<target_ran_node_id_s>().unpack(bref));
      break;
    case types::target_enb_id:
      HANDLE_CODE(c.get<target_enb_id_s>().unpack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<target_id_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "target_id_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* target_id_c::types_opts::to_string() const
{
  static const char* names[] = {"targetRANNodeID", "targeteNB-ID", "choice-Extensions"};
  return convert_enum_idx(names, 3, value, "target_id_c::types");
}

// HandoverRequiredIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ho_required_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 29, 15, 105, 22, 61, 101};
  return map_enum_number(names, 8, idx, "id");
}
bool ho_required_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 29, 15, 105, 22, 61, 101};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ho_required_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 29:
      return crit_e::reject;
    case 15:
      return crit_e::ignore;
    case 105:
      return crit_e::reject;
    case 22:
      return crit_e::ignore;
    case 61:
      return crit_e::reject;
    case 101:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ho_required_ies_o::value_c ho_required_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 29:
      ret.set(value_c::types::handov_type);
      break;
    case 15:
      ret.set(value_c::types::cause);
      break;
    case 105:
      ret.set(value_c::types::target_id);
      break;
    case 22:
      ret.set(value_c::types::direct_forwarding_path_availability);
      break;
    case 61:
      ret.set(value_c::types::pdu_session_res_list_ho_rqd);
      break;
    case 101:
      ret.set(value_c::types::source_to_target_transparent_container);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ho_required_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 29:
      return presence_e::mandatory;
    case 15:
      return presence_e::mandatory;
    case 105:
      return presence_e::mandatory;
    case 22:
      return presence_e::optional;
    case 61:
      return presence_e::mandatory;
    case 101:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ho_required_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::cause:
      c.destroy<cause_c>();
      break;
    case types::target_id:
      c.destroy<target_id_c>();
      break;
    case types::pdu_session_res_list_ho_rqd:
      c.destroy<pdu_session_res_list_ho_rqd_l>();
      break;
    case types::source_to_target_transparent_container:
      c.destroy<unbounded_octstring<true>>();
      break;
    default:
      break;
  }
}
void ho_required_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::handov_type:
      break;
    case types::cause:
      c.init<cause_c>();
      break;
    case types::target_id:
      c.init<target_id_c>();
      break;
    case types::direct_forwarding_path_availability:
      break;
    case types::pdu_session_res_list_ho_rqd:
      c.init<pdu_session_res_list_ho_rqd_l>();
      break;
    case types::source_to_target_transparent_container:
      c.init<unbounded_octstring<true>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_required_ies_o::value_c");
  }
}
ho_required_ies_o::value_c::value_c(const ho_required_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::handov_type:
      c.init(other.c.get<handov_type_e>());
      break;
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::target_id:
      c.init(other.c.get<target_id_c>());
      break;
    case types::direct_forwarding_path_availability:
      c.init(other.c.get<direct_forwarding_path_availability_e>());
      break;
    case types::pdu_session_res_list_ho_rqd:
      c.init(other.c.get<pdu_session_res_list_ho_rqd_l>());
      break;
    case types::source_to_target_transparent_container:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_required_ies_o::value_c");
  }
}
ho_required_ies_o::value_c& ho_required_ies_o::value_c::operator=(const ho_required_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::handov_type:
      c.set(other.c.get<handov_type_e>());
      break;
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::target_id:
      c.set(other.c.get<target_id_c>());
      break;
    case types::direct_forwarding_path_availability:
      c.set(other.c.get<direct_forwarding_path_availability_e>());
      break;
    case types::pdu_session_res_list_ho_rqd:
      c.set(other.c.get<pdu_session_res_list_ho_rqd_l>());
      break;
    case types::source_to_target_transparent_container:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_required_ies_o::value_c");
  }

  return *this;
}
uint64_t& ho_required_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ho_required_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
handov_type_e& ho_required_ies_o::value_c::handov_type()
{
  assert_choice_type(types::handov_type, type_, "Value");
  return c.get<handov_type_e>();
}
cause_c& ho_required_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
target_id_c& ho_required_ies_o::value_c::target_id()
{
  assert_choice_type(types::target_id, type_, "Value");
  return c.get<target_id_c>();
}
direct_forwarding_path_availability_e& ho_required_ies_o::value_c::direct_forwarding_path_availability()
{
  assert_choice_type(types::direct_forwarding_path_availability, type_, "Value");
  return c.get<direct_forwarding_path_availability_e>();
}
pdu_session_res_list_ho_rqd_l& ho_required_ies_o::value_c::pdu_session_res_list_ho_rqd()
{
  assert_choice_type(types::pdu_session_res_list_ho_rqd, type_, "Value");
  return c.get<pdu_session_res_list_ho_rqd_l>();
}
unbounded_octstring<true>& ho_required_ies_o::value_c::source_to_target_transparent_container()
{
  assert_choice_type(types::source_to_target_transparent_container, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const uint64_t& ho_required_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ho_required_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const handov_type_e& ho_required_ies_o::value_c::handov_type() const
{
  assert_choice_type(types::handov_type, type_, "Value");
  return c.get<handov_type_e>();
}
const cause_c& ho_required_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const target_id_c& ho_required_ies_o::value_c::target_id() const
{
  assert_choice_type(types::target_id, type_, "Value");
  return c.get<target_id_c>();
}
const direct_forwarding_path_availability_e& ho_required_ies_o::value_c::direct_forwarding_path_availability() const
{
  assert_choice_type(types::direct_forwarding_path_availability, type_, "Value");
  return c.get<direct_forwarding_path_availability_e>();
}
const pdu_session_res_list_ho_rqd_l& ho_required_ies_o::value_c::pdu_session_res_list_ho_rqd() const
{
  assert_choice_type(types::pdu_session_res_list_ho_rqd, type_, "Value");
  return c.get<pdu_session_res_list_ho_rqd_l>();
}
const unbounded_octstring<true>& ho_required_ies_o::value_c::source_to_target_transparent_container() const
{
  assert_choice_type(types::source_to_target_transparent_container, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
void ho_required_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::handov_type:
      j.write_str("HandoverType", c.get<handov_type_e>().to_string());
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    case types::target_id:
      j.write_fieldname("TargetID");
      c.get<target_id_c>().to_json(j);
      break;
    case types::direct_forwarding_path_availability:
      j.write_str("DirectForwardingPathAvailability", "direct-path-available");
      break;
    case types::pdu_session_res_list_ho_rqd:
      j.start_array("PDUSessionResourceListHORqd");
      for (const auto& e1 : c.get<pdu_session_res_list_ho_rqd_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::source_to_target_transparent_container:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "ho_required_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ho_required_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::handov_type:
      HANDLE_CODE(c.get<handov_type_e>().pack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    case types::target_id:
      HANDLE_CODE(c.get<target_id_c>().pack(bref));
      break;
    case types::direct_forwarding_path_availability:
      HANDLE_CODE(c.get<direct_forwarding_path_availability_e>().pack(bref));
      break;
    case types::pdu_session_res_list_ho_rqd:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_list_ho_rqd_l>(), 1, 256, true));
      break;
    case types::source_to_target_transparent_container:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_required_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_required_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::handov_type:
      HANDLE_CODE(c.get<handov_type_e>().unpack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    case types::target_id:
      HANDLE_CODE(c.get<target_id_c>().unpack(bref));
      break;
    case types::direct_forwarding_path_availability:
      HANDLE_CODE(c.get<direct_forwarding_path_availability_e>().unpack(bref));
      break;
    case types::pdu_session_res_list_ho_rqd:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_list_ho_rqd_l>(), bref, 1, 256, true));
      break;
    case types::source_to_target_transparent_container:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_required_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ho_required_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..1099511627775)",
                                "INTEGER (0..4294967295)",
                                "HandoverType",
                                "Cause",
                                "TargetID",
                                "DirectForwardingPathAvailability",
                                "PDUSessionResourceListHORqd",
                                "OCTET STRING"};
  return convert_enum_idx(names, 8, value, "ho_required_ies_o::value_c::types");
}

template struct asn1::protocol_ie_field_s<ho_required_ies_o>;

ho_required_ies_container::ho_required_ies_container() :
  amf_ue_ngap_id(10, crit_e::reject),
  ran_ue_ngap_id(85, crit_e::reject),
  handov_type(29, crit_e::reject),
  cause(15, crit_e::ignore),
  target_id(105, crit_e::reject),
  direct_forwarding_path_availability(22, crit_e::ignore),
  pdu_session_res_list_ho_rqd(61, crit_e::reject),
  source_to_target_transparent_container(101, crit_e::reject)
{
}
SRSASN_CODE ho_required_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 7;
  nof_ies += direct_forwarding_path_availability_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  HANDLE_CODE(handov_type.pack(bref));
  HANDLE_CODE(cause.pack(bref));
  HANDLE_CODE(target_id.pack(bref));
  if (direct_forwarding_path_availability_present) {
    HANDLE_CODE(direct_forwarding_path_availability.pack(bref));
  }
  HANDLE_CODE(pdu_session_res_list_ho_rqd.pack(bref));
  HANDLE_CODE(source_to_target_transparent_container.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_required_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 7;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 29: {
        nof_mandatory_ies--;
        handov_type.id = id;
        HANDLE_CODE(handov_type.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(handov_type.value.unpack(bref));
        break;
      }
      case 15: {
        nof_mandatory_ies--;
        cause.id = id;
        HANDLE_CODE(cause.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.value.unpack(bref));
        break;
      }
      case 105: {
        nof_mandatory_ies--;
        target_id.id = id;
        HANDLE_CODE(target_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(target_id.value.unpack(bref));
        break;
      }
      case 22: {
        direct_forwarding_path_availability_present = true;
        direct_forwarding_path_availability.id      = id;
        HANDLE_CODE(direct_forwarding_path_availability.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(direct_forwarding_path_availability.value.unpack(bref));
        break;
      }
      case 61: {
        nof_mandatory_ies--;
        pdu_session_res_list_ho_rqd.id = id;
        HANDLE_CODE(pdu_session_res_list_ho_rqd.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pdu_session_res_list_ho_rqd.value.unpack(bref));
        break;
      }
      case 101: {
        nof_mandatory_ies--;
        source_to_target_transparent_container.id = id;
        HANDLE_CODE(source_to_target_transparent_container.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(source_to_target_transparent_container.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ho_required_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  handov_type.to_json(j);
  j.write_fieldname("");
  cause.to_json(j);
  j.write_fieldname("");
  target_id.to_json(j);
  if (direct_forwarding_path_availability_present) {
    j.write_fieldname("");
    direct_forwarding_path_availability.to_json(j);
  }
  j.write_fieldname("");
  pdu_session_res_list_ho_rqd.to_json(j);
  j.write_fieldname("");
  source_to_target_transparent_container.to_json(j);
  j.end_obj();
}

// HandoverRequiredTransfer ::= SEQUENCE
SRSASN_CODE ho_required_transfer_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(direct_forwarding_path_availability_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (direct_forwarding_path_availability_present) {
    HANDLE_CODE(direct_forwarding_path_availability.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_required_transfer_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(direct_forwarding_path_availability_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (direct_forwarding_path_availability_present) {
    HANDLE_CODE(direct_forwarding_path_availability.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ho_required_transfer_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (direct_forwarding_path_availability_present) {
    j.write_str("directForwardingPathAvailability", "direct-path-available");
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// HandoverResourceAllocationUnsuccessfulTransfer ::= SEQUENCE
SRSASN_CODE ho_res_alloc_unsuccessful_transfer_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(crit_diagnostics_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(cause.pack(bref));
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_res_alloc_unsuccessful_transfer_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(crit_diagnostics_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(cause.unpack(bref));
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ho_res_alloc_unsuccessful_transfer_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("cause");
  cause.to_json(j);
  if (crit_diagnostics_present) {
    j.write_fieldname("criticalityDiagnostics");
    crit_diagnostics.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// HandoverSuccessIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ho_success_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85};
  return map_enum_number(names, 2, idx, "id");
}
bool ho_success_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ho_success_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ho_success_ies_o::value_c ho_success_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ho_success_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ho_success_ies_o::value_c::destroy_() {}
void ho_success_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
}
ho_success_ies_o::value_c::value_c(const ho_success_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_success_ies_o::value_c");
  }
}
ho_success_ies_o::value_c& ho_success_ies_o::value_c::operator=(const ho_success_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_success_ies_o::value_c");
  }

  return *this;
}
uint64_t& ho_success_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ho_success_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ho_success_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ho_success_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
void ho_success_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    default:
      log_invalid_choice_id(type_, "ho_success_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ho_success_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    default:
      log_invalid_choice_id(type_, "ho_success_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_success_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    default:
      log_invalid_choice_id(type_, "ho_success_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ho_success_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..1099511627775)", "INTEGER (0..4294967295)"};
  return convert_enum_idx(names, 2, value, "ho_success_ies_o::value_c::types");
}

template struct asn1::protocol_ie_field_s<ho_success_ies_o>;

ho_success_ies_container::ho_success_ies_container() :
  amf_ue_ngap_id(10, crit_e::reject), ran_ue_ngap_id(85, crit_e::reject)
{
}
SRSASN_CODE ho_success_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_success_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ho_success_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  j.end_obj();
}

// RecommendedRANNodeItem ::= SEQUENCE
SRSASN_CODE recommended_ran_node_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(amf_paging_target.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE recommended_ran_node_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(amf_paging_target.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void recommended_ran_node_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("aMFPagingTarget");
  amf_paging_target.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// RecommendedRANNodesForPaging ::= SEQUENCE
SRSASN_CODE recommended_ran_nodes_for_paging_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, recommended_ran_node_list, 1, 16, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE recommended_ran_nodes_for_paging_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(recommended_ran_node_list, bref, 1, 16, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void recommended_ran_nodes_for_paging_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("recommendedRANNodeList");
  for (const auto& e1 : recommended_ran_node_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// InfoOnRecommendedCellsAndRANNodesForPaging ::= SEQUENCE
SRSASN_CODE info_on_recommended_cells_and_ran_nodes_for_paging_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(recommended_cells_for_paging.pack(bref));
  HANDLE_CODE(recommend_ran_nodes_for_paging.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE info_on_recommended_cells_and_ran_nodes_for_paging_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(recommended_cells_for_paging.unpack(bref));
  HANDLE_CODE(recommend_ran_nodes_for_paging.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void info_on_recommended_cells_and_ran_nodes_for_paging_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("recommendedCellsForPaging");
  recommended_cells_for_paging.to_json(j);
  j.write_fieldname("recommendRANNodesForPaging");
  recommend_ran_nodes_for_paging.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceFailedToSetupItemCxtFail ::= SEQUENCE
SRSASN_CODE pdu_session_res_failed_to_setup_item_cxt_fail_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pdu_session_id, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(pdu_session_res_setup_unsuccessful_transfer.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_failed_to_setup_item_cxt_fail_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pdu_session_id, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(pdu_session_res_setup_unsuccessful_transfer.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_failed_to_setup_item_cxt_fail_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pDUSessionID", pdu_session_id);
  j.write_str("pDUSessionResourceSetupUnsuccessfulTransfer", pdu_session_res_setup_unsuccessful_transfer.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// InitialContextSetupFailureIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t init_context_setup_fail_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 132, 15, 19};
  return map_enum_number(names, 5, idx, "id");
}
bool init_context_setup_fail_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 132, 15, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e init_context_setup_fail_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::ignore;
    case 85:
      return crit_e::ignore;
    case 132:
      return crit_e::ignore;
    case 15:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
init_context_setup_fail_ies_o::value_c init_context_setup_fail_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 132:
      ret.set(value_c::types::pdu_session_res_failed_to_setup_list_cxt_fail);
      break;
    case 15:
      ret.set(value_c::types::cause);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e init_context_setup_fail_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 132:
      return presence_e::optional;
    case 15:
      return presence_e::mandatory;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void init_context_setup_fail_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::pdu_session_res_failed_to_setup_list_cxt_fail:
      c.destroy<pdu_session_res_failed_to_setup_list_cxt_fail_l>();
      break;
    case types::cause:
      c.destroy<cause_c>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void init_context_setup_fail_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::pdu_session_res_failed_to_setup_list_cxt_fail:
      c.init<pdu_session_res_failed_to_setup_list_cxt_fail_l>();
      break;
    case types::cause:
      c.init<cause_c>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "init_context_setup_fail_ies_o::value_c");
  }
}
init_context_setup_fail_ies_o::value_c::value_c(const init_context_setup_fail_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::pdu_session_res_failed_to_setup_list_cxt_fail:
      c.init(other.c.get<pdu_session_res_failed_to_setup_list_cxt_fail_l>());
      break;
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "init_context_setup_fail_ies_o::value_c");
  }
}
init_context_setup_fail_ies_o::value_c&
init_context_setup_fail_ies_o::value_c::operator=(const init_context_setup_fail_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::pdu_session_res_failed_to_setup_list_cxt_fail:
      c.set(other.c.get<pdu_session_res_failed_to_setup_list_cxt_fail_l>());
      break;
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "init_context_setup_fail_ies_o::value_c");
  }

  return *this;
}
uint64_t& init_context_setup_fail_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& init_context_setup_fail_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
pdu_session_res_failed_to_setup_list_cxt_fail_l&
init_context_setup_fail_ies_o::value_c::pdu_session_res_failed_to_setup_list_cxt_fail()
{
  assert_choice_type(types::pdu_session_res_failed_to_setup_list_cxt_fail, type_, "Value");
  return c.get<pdu_session_res_failed_to_setup_list_cxt_fail_l>();
}
cause_c& init_context_setup_fail_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
crit_diagnostics_s& init_context_setup_fail_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const uint64_t& init_context_setup_fail_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& init_context_setup_fail_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const pdu_session_res_failed_to_setup_list_cxt_fail_l&
init_context_setup_fail_ies_o::value_c::pdu_session_res_failed_to_setup_list_cxt_fail() const
{
  assert_choice_type(types::pdu_session_res_failed_to_setup_list_cxt_fail, type_, "Value");
  return c.get<pdu_session_res_failed_to_setup_list_cxt_fail_l>();
}
const cause_c& init_context_setup_fail_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const crit_diagnostics_s& init_context_setup_fail_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void init_context_setup_fail_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::pdu_session_res_failed_to_setup_list_cxt_fail:
      j.start_array("PDUSessionResourceFailedToSetupListCxtFail");
      for (const auto& e1 : c.get<pdu_session_res_failed_to_setup_list_cxt_fail_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "init_context_setup_fail_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE init_context_setup_fail_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_failed_to_setup_list_cxt_fail:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_failed_to_setup_list_cxt_fail_l>(), 1, 256, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "init_context_setup_fail_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE init_context_setup_fail_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_failed_to_setup_list_cxt_fail:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_failed_to_setup_list_cxt_fail_l>(), bref, 1, 256, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "init_context_setup_fail_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* init_context_setup_fail_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..1099511627775)",
                                "INTEGER (0..4294967295)",
                                "PDUSessionResourceFailedToSetupListCxtFail",
                                "Cause",
                                "CriticalityDiagnostics"};
  return convert_enum_idx(names, 5, value, "init_context_setup_fail_ies_o::value_c::types");
}

template struct asn1::protocol_ie_field_s<init_context_setup_fail_ies_o>;

init_context_setup_fail_ies_container::init_context_setup_fail_ies_container() :
  amf_ue_ngap_id(10, crit_e::ignore),
  ran_ue_ngap_id(85, crit_e::ignore),
  pdu_session_res_failed_to_setup_list_cxt_fail(132, crit_e::ignore),
  cause(15, crit_e::ignore),
  crit_diagnostics(19, crit_e::ignore)
{
}
SRSASN_CODE init_context_setup_fail_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += pdu_session_res_failed_to_setup_list_cxt_fail_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  if (pdu_session_res_failed_to_setup_list_cxt_fail_present) {
    HANDLE_CODE(pdu_session_res_failed_to_setup_list_cxt_fail.pack(bref));
  }
  HANDLE_CODE(cause.pack(bref));
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE init_context_setup_fail_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 132: {
        pdu_session_res_failed_to_setup_list_cxt_fail_present = true;
        pdu_session_res_failed_to_setup_list_cxt_fail.id      = id;
        HANDLE_CODE(pdu_session_res_failed_to_setup_list_cxt_fail.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pdu_session_res_failed_to_setup_list_cxt_fail.value.unpack(bref));
        break;
      }
      case 15: {
        nof_mandatory_ies--;
        cause.id = id;
        HANDLE_CODE(cause.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.value.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        crit_diagnostics.id      = id;
        HANDLE_CODE(crit_diagnostics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void init_context_setup_fail_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  if (pdu_session_res_failed_to_setup_list_cxt_fail_present) {
    j.write_fieldname("");
    pdu_session_res_failed_to_setup_list_cxt_fail.to_json(j);
  }
  j.write_fieldname("");
  cause.to_json(j);
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

// SliceSupportQMC-Item ::= SEQUENCE
SRSASN_CODE slice_support_qmc_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(s_nssai.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE slice_support_qmc_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(s_nssai.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void slice_support_qmc_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("s-NSSAI");
  s_nssai.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MDT-AlignmentInfo ::= CHOICE
void mdt_align_info_c::destroy_()
{
  switch (type_) {
    case types::s_based_mdt:
      c.destroy<fixed_octstring<8, true>>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<mdt_align_info_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void mdt_align_info_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::s_based_mdt:
      c.init<fixed_octstring<8, true>>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<mdt_align_info_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "mdt_align_info_c");
  }
}
mdt_align_info_c::mdt_align_info_c(const mdt_align_info_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::s_based_mdt:
      c.init(other.c.get<fixed_octstring<8, true>>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<mdt_align_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "mdt_align_info_c");
  }
}
mdt_align_info_c& mdt_align_info_c::operator=(const mdt_align_info_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::s_based_mdt:
      c.set(other.c.get<fixed_octstring<8, true>>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<mdt_align_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "mdt_align_info_c");
  }

  return *this;
}
fixed_octstring<8, true>& mdt_align_info_c::set_s_based_mdt()
{
  set(types::s_based_mdt);
  return c.get<fixed_octstring<8, true>>();
}
protocol_ie_single_container_s<mdt_align_info_ext_ies_o>& mdt_align_info_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<mdt_align_info_ext_ies_o>>();
}
void mdt_align_info_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::s_based_mdt:
      j.write_str("s-basedMDT", c.get<fixed_octstring<8, true>>().to_string());
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<mdt_align_info_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "mdt_align_info_c");
  }
  j.end_obj();
}
SRSASN_CODE mdt_align_info_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::s_based_mdt:
      HANDLE_CODE((c.get<fixed_octstring<8, true>>().pack(bref)));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<mdt_align_info_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "mdt_align_info_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE mdt_align_info_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::s_based_mdt:
      HANDLE_CODE((c.get<fixed_octstring<8, true>>().unpack(bref)));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<mdt_align_info_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "mdt_align_info_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* mdt_align_info_c::types_opts::to_string() const
{
  static const char* names[] = {"s-basedMDT", "choice-Extensions"};
  return convert_enum_idx(names, 2, value, "mdt_align_info_c::types");
}

// ServiceType ::= ENUMERATED
const char* service_type_opts::to_string() const
{
  static const char* names[] = {"streaming", "mTSI", "vR"};
  return convert_enum_idx(names, 3, value, "service_type_e");
}

// UEAppLayerMeasConfigInfo ::= SEQUENCE
SRSASN_CODE ue_app_layer_meas_cfg_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(qo_e_meas_status_present, 1));
  HANDLE_CODE(bref.pack(container_for_app_layer_meas_cfg.size() > 0, 1));
  HANDLE_CODE(bref.pack(meas_cfg_app_layer_id_present, 1));
  HANDLE_CODE(bref.pack(slice_support_list_qmc.size() > 0, 1));
  HANDLE_CODE(bref.pack(mdt_align_info_present, 1));
  HANDLE_CODE(bref.pack(available_ran_visible_qo_e_metrics_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(qo_e_ref.pack(bref));
  HANDLE_CODE(service_type.pack(bref));
  HANDLE_CODE(area_scope_of_qmc.pack(bref));
  HANDLE_CODE(meas_coll_entity_ip_address.pack(bref));
  if (qo_e_meas_status_present) {
    HANDLE_CODE(qo_e_meas_status.pack(bref));
  }
  if (container_for_app_layer_meas_cfg.size() > 0) {
    HANDLE_CODE(container_for_app_layer_meas_cfg.pack(bref));
  }
  if (meas_cfg_app_layer_id_present) {
    HANDLE_CODE(pack_integer(bref, meas_cfg_app_layer_id, (uint8_t)0u, (uint8_t)15u, true, true));
  }
  if (slice_support_list_qmc.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, slice_support_list_qmc, 1, 16, true));
  }
  if (mdt_align_info_present) {
    HANDLE_CODE(mdt_align_info.pack(bref));
  }
  if (available_ran_visible_qo_e_metrics_present) {
    HANDLE_CODE(available_ran_visible_qo_e_metrics.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_app_layer_meas_cfg_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(qo_e_meas_status_present, 1));
  bool container_for_app_layer_meas_cfg_present;
  HANDLE_CODE(bref.unpack(container_for_app_layer_meas_cfg_present, 1));
  HANDLE_CODE(bref.unpack(meas_cfg_app_layer_id_present, 1));
  bool slice_support_list_qmc_present;
  HANDLE_CODE(bref.unpack(slice_support_list_qmc_present, 1));
  HANDLE_CODE(bref.unpack(mdt_align_info_present, 1));
  HANDLE_CODE(bref.unpack(available_ran_visible_qo_e_metrics_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(qo_e_ref.unpack(bref));
  HANDLE_CODE(service_type.unpack(bref));
  HANDLE_CODE(area_scope_of_qmc.unpack(bref));
  HANDLE_CODE(meas_coll_entity_ip_address.unpack(bref));
  if (qo_e_meas_status_present) {
    HANDLE_CODE(qo_e_meas_status.unpack(bref));
  }
  if (container_for_app_layer_meas_cfg_present) {
    HANDLE_CODE(container_for_app_layer_meas_cfg.unpack(bref));
  }
  if (meas_cfg_app_layer_id_present) {
    HANDLE_CODE(unpack_integer(meas_cfg_app_layer_id, bref, (uint8_t)0u, (uint8_t)15u, true, true));
  }
  if (slice_support_list_qmc_present) {
    HANDLE_CODE(unpack_dyn_seq_of(slice_support_list_qmc, bref, 1, 16, true));
  }
  if (mdt_align_info_present) {
    HANDLE_CODE(mdt_align_info.unpack(bref));
  }
  if (available_ran_visible_qo_e_metrics_present) {
    HANDLE_CODE(available_ran_visible_qo_e_metrics.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ue_app_layer_meas_cfg_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("qoEReference", qo_e_ref.to_string());
  j.write_str("serviceType", service_type.to_string());
  j.write_fieldname("areaScopeOfQMC");
  area_scope_of_qmc.to_json(j);
  j.write_str("measCollEntityIPAddress", meas_coll_entity_ip_address.to_string());
  if (qo_e_meas_status_present) {
    j.write_str("qoEMeasurementStatus", "ongoing");
  }
  if (container_for_app_layer_meas_cfg.size() > 0) {
    j.write_str("containerForAppLayerMeasConfig", container_for_app_layer_meas_cfg.to_string());
  }
  if (meas_cfg_app_layer_id_present) {
    j.write_int("measConfigAppLayerID", meas_cfg_app_layer_id);
  }
  if (slice_support_list_qmc.size() > 0) {
    j.start_array("sliceSupportListQMC");
    for (const auto& e1 : slice_support_list_qmc) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (mdt_align_info_present) {
    j.write_fieldname("mDT-AlignmentInfo");
    mdt_align_info.to_json(j);
  }
  if (available_ran_visible_qo_e_metrics_present) {
    j.write_fieldname("availableRANVisibleQoEMetrics");
    available_ran_visible_qo_e_metrics.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* ue_app_layer_meas_cfg_info_s::qo_e_meas_status_opts::to_string() const
{
  static const char* names[] = {"ongoing"};
  return convert_enum_idx(names, 1, value, "ue_app_layer_meas_cfg_info_s::qo_e_meas_status_e_");
}

// PDUSessionResourceSetupItemCxtReq-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t pdu_session_res_setup_item_cxt_req_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {281};
  return map_enum_number(names, 1, idx, "id");
}
bool pdu_session_res_setup_item_cxt_req_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 281 == id;
}
crit_e pdu_session_res_setup_item_cxt_req_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 281) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
pdu_session_res_setup_item_cxt_req_ext_ies_o::ext_c
pdu_session_res_setup_item_cxt_req_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 281) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pdu_session_res_setup_item_cxt_req_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 281) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void pdu_session_res_setup_item_cxt_req_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("ExpectedUEActivityBehaviour");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE pdu_session_res_setup_item_cxt_req_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_setup_item_cxt_req_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* pdu_session_res_setup_item_cxt_req_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"ExpectedUEActivityBehaviour"};
  return convert_enum_idx(names, 1, value, "pdu_session_res_setup_item_cxt_req_ext_ies_o::ext_c::types");
}

// UEAppLayerMeasInfoItem ::= SEQUENCE
SRSASN_CODE ue_app_layer_meas_info_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(ue_app_layer_meas_cfg_info.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_app_layer_meas_info_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(ue_app_layer_meas_cfg_info.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ue_app_layer_meas_info_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("uEAppLayerMeasConfigInfo");
  ue_app_layer_meas_cfg_info.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceSetupItemCxtReq ::= SEQUENCE
SRSASN_CODE pdu_session_res_setup_item_cxt_req_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(nas_pdu.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(pack_integer(bref, pdu_session_id, (uint16_t)0u, (uint16_t)255u, false, true));
  if (nas_pdu.size() > 0) {
    HANDLE_CODE(nas_pdu.pack(bref));
  }
  HANDLE_CODE(s_nssai.pack(bref));
  HANDLE_CODE(pdu_session_res_setup_request_transfer.pack(bref));
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_setup_item_cxt_req_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool nas_pdu_present;
  HANDLE_CODE(bref.unpack(nas_pdu_present, 1));
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pdu_session_id, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  if (nas_pdu_present) {
    HANDLE_CODE(nas_pdu.unpack(bref));
  }
  HANDLE_CODE(s_nssai.unpack(bref));
  HANDLE_CODE(pdu_session_res_setup_request_transfer.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_setup_item_cxt_req_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pDUSessionID", pdu_session_id);
  if (nas_pdu.size() > 0) {
    j.write_str("nAS-PDU", nas_pdu.to_string());
  }
  j.write_fieldname("s-NSSAI");
  s_nssai.to_json(j);
  j.write_str("pDUSessionResourceSetupRequestTransfer", pdu_session_res_setup_request_transfer.to_string());
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// QMCConfigInfo ::= SEQUENCE
SRSASN_CODE q_mcc_onfig_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, ue_app_layer_meas_info_list, 1, 16, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE q_mcc_onfig_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(ue_app_layer_meas_info_list, bref, 1, 16, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void q_mcc_onfig_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("uEAppLayerMeasInfoList");
  for (const auto& e1 : ue_app_layer_meas_info_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// InitialContextSetupRequestIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t init_context_setup_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10,  85,  48,  110, 18,  28,  71,  0,   119, 94,  108, 36,  117, 31,  34,
                                   38,  24,  91,  118, 146, 33,  165, 177, 199, 205, 206, 209, 216, 215, 218,
                                   217, 219, 222, 234, 238, 254, 264, 326, 328, 334, 335, 345, 346, 347};
  return map_enum_number(names, 44, idx, "id");
}
bool init_context_setup_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10,  85,  48,  110, 18,  28,  71,  0,   119, 94,  108, 36,  117, 31,  34,
                                   38,  24,  91,  118, 146, 33,  165, 177, 199, 205, 206, 209, 216, 215, 218,
                                   217, 219, 222, 234, 238, 254, 264, 326, 328, 334, 335, 345, 346, 347};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e init_context_setup_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 48:
      return crit_e::reject;
    case 110:
      return crit_e::reject;
    case 18:
      return crit_e::ignore;
    case 28:
      return crit_e::reject;
    case 71:
      return crit_e::reject;
    case 0:
      return crit_e::reject;
    case 119:
      return crit_e::reject;
    case 94:
      return crit_e::reject;
    case 108:
      return crit_e::ignore;
    case 36:
      return crit_e::ignore;
    case 117:
      return crit_e::ignore;
    case 31:
      return crit_e::ignore;
    case 34:
      return crit_e::ignore;
    case 38:
      return crit_e::ignore;
    case 24:
      return crit_e::reject;
    case 91:
      return crit_e::ignore;
    case 118:
      return crit_e::ignore;
    case 146:
      return crit_e::ignore;
    case 33:
      return crit_e::ignore;
    case 165:
      return crit_e::ignore;
    case 177:
      return crit_e::ignore;
    case 199:
      return crit_e::ignore;
    case 205:
      return crit_e::ignore;
    case 206:
      return crit_e::ignore;
    case 209:
      return crit_e::ignore;
    case 216:
      return crit_e::ignore;
    case 215:
      return crit_e::ignore;
    case 218:
      return crit_e::ignore;
    case 217:
      return crit_e::ignore;
    case 219:
      return crit_e::ignore;
    case 222:
      return crit_e::ignore;
    case 234:
      return crit_e::ignore;
    case 238:
      return crit_e::ignore;
    case 254:
      return crit_e::ignore;
    case 264:
      return crit_e::reject;
    case 326:
      return crit_e::ignore;
    case 328:
      return crit_e::ignore;
    case 334:
      return crit_e::ignore;
    case 335:
      return crit_e::ignore;
    case 345:
      return crit_e::ignore;
    case 346:
      return crit_e::ignore;
    case 347:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
init_context_setup_request_ies_o::value_c init_context_setup_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 48:
      ret.set(value_c::types::old_amf);
      break;
    case 110:
      ret.set(value_c::types::ue_aggr_max_bit_rate);
      break;
    case 18:
      ret.set(value_c::types::core_network_assist_info_for_inactive);
      break;
    case 28:
      ret.set(value_c::types::guami);
      break;
    case 71:
      ret.set(value_c::types::pdu_session_res_setup_list_cxt_req);
      break;
    case 0:
      ret.set(value_c::types::allowed_nssai);
      break;
    case 119:
      ret.set(value_c::types::ue_security_cap);
      break;
    case 94:
      ret.set(value_c::types::security_key);
      break;
    case 108:
      ret.set(value_c::types::trace_activation);
      break;
    case 36:
      ret.set(value_c::types::mob_restrict_list);
      break;
    case 117:
      ret.set(value_c::types::ue_radio_cap);
      break;
    case 31:
      ret.set(value_c::types::idx_to_rfsp);
      break;
    case 34:
      ret.set(value_c::types::masked_imeisv);
      break;
    case 38:
      ret.set(value_c::types::nas_pdu);
      break;
    case 24:
      ret.set(value_c::types::emergency_fallback_ind);
      break;
    case 91:
      ret.set(value_c::types::rrc_inactive_transition_report_request);
      break;
    case 118:
      ret.set(value_c::types::ue_radio_cap_for_paging);
      break;
    case 146:
      ret.set(value_c::types::redirection_voice_fallback);
      break;
    case 33:
      ret.set(value_c::types::location_report_request_type);
      break;
    case 165:
      ret.set(value_c::types::cn_assisted_ran_tuning);
      break;
    case 177:
      ret.set(value_c::types::srvcc_operation_possible);
      break;
    case 199:
      ret.set(value_c::types::iab_authorized);
      break;
    case 205:
      ret.set(value_c::types::enhanced_coverage_restrict);
      break;
    case 206:
      ret.set(value_c::types::extended_connected_time);
      break;
    case 209:
      ret.set(value_c::types::ue_diff_info);
      break;
    case 216:
      ret.set(value_c::types::nr_v2x_services_authorized);
      break;
    case 215:
      ret.set(value_c::types::ltev2x_services_authorized);
      break;
    case 218:
      ret.set(value_c::types::nr_ue_sidelink_aggr_max_bitrate);
      break;
    case 217:
      ret.set(value_c::types::lte_ue_sidelink_aggr_max_bitrate);
      break;
    case 219:
      ret.set(value_c::types::pc5_qos_params);
      break;
    case 222:
      ret.set(value_c::types::ce_mode_brestricted);
      break;
    case 234:
      ret.set(value_c::types::ue_up_c_iot_support);
      break;
    case 238:
      ret.set(value_c::types::rg_level_wireline_access_characteristics);
      break;
    case 254:
      ret.set(value_c::types::management_based_mdt_plmn_list);
      break;
    case 264:
      ret.set(value_c::types::ue_radio_cap_id);
      break;
    case 326:
      ret.set(value_c::types::time_sync_assist_info);
      break;
    case 328:
      ret.set(value_c::types::q_mcc_onfig_info);
      break;
    case 334:
      ret.set(value_c::types::target_nssai_info);
      break;
    case 335:
      ret.set(value_c::types::ue_slice_max_bit_rate_list);
      break;
    case 345:
      ret.set(value_c::types::five_g_pro_se_authorized);
      break;
    case 346:
      ret.set(value_c::types::five_g_pro_se_ue_pc5_aggr_max_bit_rate);
      break;
    case 347:
      ret.set(value_c::types::five_g_pro_se_pc5_qos_params);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e init_context_setup_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 48:
      return presence_e::optional;
    case 110:
      return presence_e::conditional;
    case 18:
      return presence_e::optional;
    case 28:
      return presence_e::mandatory;
    case 71:
      return presence_e::optional;
    case 0:
      return presence_e::mandatory;
    case 119:
      return presence_e::mandatory;
    case 94:
      return presence_e::mandatory;
    case 108:
      return presence_e::optional;
    case 36:
      return presence_e::optional;
    case 117:
      return presence_e::optional;
    case 31:
      return presence_e::optional;
    case 34:
      return presence_e::optional;
    case 38:
      return presence_e::optional;
    case 24:
      return presence_e::optional;
    case 91:
      return presence_e::optional;
    case 118:
      return presence_e::optional;
    case 146:
      return presence_e::optional;
    case 33:
      return presence_e::optional;
    case 165:
      return presence_e::optional;
    case 177:
      return presence_e::optional;
    case 199:
      return presence_e::optional;
    case 205:
      return presence_e::optional;
    case 206:
      return presence_e::optional;
    case 209:
      return presence_e::optional;
    case 216:
      return presence_e::optional;
    case 215:
      return presence_e::optional;
    case 218:
      return presence_e::optional;
    case 217:
      return presence_e::optional;
    case 219:
      return presence_e::optional;
    case 222:
      return presence_e::optional;
    case 234:
      return presence_e::optional;
    case 238:
      return presence_e::optional;
    case 254:
      return presence_e::optional;
    case 264:
      return presence_e::optional;
    case 326:
      return presence_e::optional;
    case 328:
      return presence_e::optional;
    case 334:
      return presence_e::optional;
    case 335:
      return presence_e::optional;
    case 345:
      return presence_e::optional;
    case 346:
      return presence_e::optional;
    case 347:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void init_context_setup_request_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::old_amf:
      c.destroy<printable_string<1, 150, true, true>>();
      break;
    case types::ue_aggr_max_bit_rate:
      c.destroy<ue_aggr_max_bit_rate_s>();
      break;
    case types::core_network_assist_info_for_inactive:
      c.destroy<core_network_assist_info_for_inactive_s>();
      break;
    case types::guami:
      c.destroy<guami_s>();
      break;
    case types::pdu_session_res_setup_list_cxt_req:
      c.destroy<pdu_session_res_setup_list_cxt_req_l>();
      break;
    case types::allowed_nssai:
      c.destroy<allowed_nssai_l>();
      break;
    case types::ue_security_cap:
      c.destroy<ue_security_cap_s>();
      break;
    case types::security_key:
      c.destroy<fixed_bitstring<256, false, true>>();
      break;
    case types::trace_activation:
      c.destroy<trace_activation_s>();
      break;
    case types::mob_restrict_list:
      c.destroy<mob_restrict_list_s>();
      break;
    case types::ue_radio_cap:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::masked_imeisv:
      c.destroy<fixed_bitstring<64, false, true>>();
      break;
    case types::nas_pdu:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::emergency_fallback_ind:
      c.destroy<emergency_fallback_ind_s>();
      break;
    case types::ue_radio_cap_for_paging:
      c.destroy<ue_radio_cap_for_paging_s>();
      break;
    case types::location_report_request_type:
      c.destroy<location_report_request_type_s>();
      break;
    case types::cn_assisted_ran_tuning:
      c.destroy<cn_assisted_ran_tuning_s>();
      break;
    case types::ue_diff_info:
      c.destroy<ue_diff_info_s>();
      break;
    case types::nr_v2x_services_authorized:
      c.destroy<nr_v2x_services_authorized_s>();
      break;
    case types::ltev2x_services_authorized:
      c.destroy<ltev2x_services_authorized_s>();
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      c.destroy<nr_ue_sidelink_aggr_max_bitrate_s>();
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      c.destroy<lte_ue_sidelink_aggr_max_bitrate_s>();
      break;
    case types::pc5_qos_params:
      c.destroy<pc5_qos_params_s>();
      break;
    case types::rg_level_wireline_access_characteristics:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::management_based_mdt_plmn_list:
      c.destroy<mdt_plmn_list_l>();
      break;
    case types::ue_radio_cap_id:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::time_sync_assist_info:
      c.destroy<time_sync_assist_info_s>();
      break;
    case types::q_mcc_onfig_info:
      c.destroy<q_mcc_onfig_info_s>();
      break;
    case types::target_nssai_info:
      c.destroy<target_nssai_info_s>();
      break;
    case types::ue_slice_max_bit_rate_list:
      c.destroy<ue_slice_max_bit_rate_list_l>();
      break;
    case types::five_g_pro_se_authorized:
      c.destroy<five_g_pro_se_authorized_s>();
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      c.destroy<nr_ue_sidelink_aggr_max_bitrate_s>();
      break;
    case types::five_g_pro_se_pc5_qos_params:
      c.destroy<five_g_pro_se_pc5_qos_params_s>();
      break;
    default:
      break;
  }
}
void init_context_setup_request_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::old_amf:
      c.init<printable_string<1, 150, true, true>>();
      break;
    case types::ue_aggr_max_bit_rate:
      c.init<ue_aggr_max_bit_rate_s>();
      break;
    case types::core_network_assist_info_for_inactive:
      c.init<core_network_assist_info_for_inactive_s>();
      break;
    case types::guami:
      c.init<guami_s>();
      break;
    case types::pdu_session_res_setup_list_cxt_req:
      c.init<pdu_session_res_setup_list_cxt_req_l>();
      break;
    case types::allowed_nssai:
      c.init<allowed_nssai_l>();
      break;
    case types::ue_security_cap:
      c.init<ue_security_cap_s>();
      break;
    case types::security_key:
      c.init<fixed_bitstring<256, false, true>>();
      break;
    case types::trace_activation:
      c.init<trace_activation_s>();
      break;
    case types::mob_restrict_list:
      c.init<mob_restrict_list_s>();
      break;
    case types::ue_radio_cap:
      c.init<unbounded_octstring<true>>();
      break;
    case types::idx_to_rfsp:
      break;
    case types::masked_imeisv:
      c.init<fixed_bitstring<64, false, true>>();
      break;
    case types::nas_pdu:
      c.init<unbounded_octstring<true>>();
      break;
    case types::emergency_fallback_ind:
      c.init<emergency_fallback_ind_s>();
      break;
    case types::rrc_inactive_transition_report_request:
      break;
    case types::ue_radio_cap_for_paging:
      c.init<ue_radio_cap_for_paging_s>();
      break;
    case types::redirection_voice_fallback:
      break;
    case types::location_report_request_type:
      c.init<location_report_request_type_s>();
      break;
    case types::cn_assisted_ran_tuning:
      c.init<cn_assisted_ran_tuning_s>();
      break;
    case types::srvcc_operation_possible:
      break;
    case types::iab_authorized:
      break;
    case types::enhanced_coverage_restrict:
      break;
    case types::extended_connected_time:
      break;
    case types::ue_diff_info:
      c.init<ue_diff_info_s>();
      break;
    case types::nr_v2x_services_authorized:
      c.init<nr_v2x_services_authorized_s>();
      break;
    case types::ltev2x_services_authorized:
      c.init<ltev2x_services_authorized_s>();
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      c.init<nr_ue_sidelink_aggr_max_bitrate_s>();
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      c.init<lte_ue_sidelink_aggr_max_bitrate_s>();
      break;
    case types::pc5_qos_params:
      c.init<pc5_qos_params_s>();
      break;
    case types::ce_mode_brestricted:
      break;
    case types::ue_up_c_iot_support:
      break;
    case types::rg_level_wireline_access_characteristics:
      c.init<unbounded_octstring<true>>();
      break;
    case types::management_based_mdt_plmn_list:
      c.init<mdt_plmn_list_l>();
      break;
    case types::ue_radio_cap_id:
      c.init<unbounded_octstring<true>>();
      break;
    case types::time_sync_assist_info:
      c.init<time_sync_assist_info_s>();
      break;
    case types::q_mcc_onfig_info:
      c.init<q_mcc_onfig_info_s>();
      break;
    case types::target_nssai_info:
      c.init<target_nssai_info_s>();
      break;
    case types::ue_slice_max_bit_rate_list:
      c.init<ue_slice_max_bit_rate_list_l>();
      break;
    case types::five_g_pro_se_authorized:
      c.init<five_g_pro_se_authorized_s>();
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      c.init<nr_ue_sidelink_aggr_max_bitrate_s>();
      break;
    case types::five_g_pro_se_pc5_qos_params:
      c.init<five_g_pro_se_pc5_qos_params_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "init_context_setup_request_ies_o::value_c");
  }
}
init_context_setup_request_ies_o::value_c::value_c(const init_context_setup_request_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::old_amf:
      c.init(other.c.get<printable_string<1, 150, true, true>>());
      break;
    case types::ue_aggr_max_bit_rate:
      c.init(other.c.get<ue_aggr_max_bit_rate_s>());
      break;
    case types::core_network_assist_info_for_inactive:
      c.init(other.c.get<core_network_assist_info_for_inactive_s>());
      break;
    case types::guami:
      c.init(other.c.get<guami_s>());
      break;
    case types::pdu_session_res_setup_list_cxt_req:
      c.init(other.c.get<pdu_session_res_setup_list_cxt_req_l>());
      break;
    case types::allowed_nssai:
      c.init(other.c.get<allowed_nssai_l>());
      break;
    case types::ue_security_cap:
      c.init(other.c.get<ue_security_cap_s>());
      break;
    case types::security_key:
      c.init(other.c.get<fixed_bitstring<256, false, true>>());
      break;
    case types::trace_activation:
      c.init(other.c.get<trace_activation_s>());
      break;
    case types::mob_restrict_list:
      c.init(other.c.get<mob_restrict_list_s>());
      break;
    case types::ue_radio_cap:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::idx_to_rfsp:
      c.init(other.c.get<uint16_t>());
      break;
    case types::masked_imeisv:
      c.init(other.c.get<fixed_bitstring<64, false, true>>());
      break;
    case types::nas_pdu:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::emergency_fallback_ind:
      c.init(other.c.get<emergency_fallback_ind_s>());
      break;
    case types::rrc_inactive_transition_report_request:
      c.init(other.c.get<rrc_inactive_transition_report_request_e>());
      break;
    case types::ue_radio_cap_for_paging:
      c.init(other.c.get<ue_radio_cap_for_paging_s>());
      break;
    case types::redirection_voice_fallback:
      c.init(other.c.get<redirection_voice_fallback_e>());
      break;
    case types::location_report_request_type:
      c.init(other.c.get<location_report_request_type_s>());
      break;
    case types::cn_assisted_ran_tuning:
      c.init(other.c.get<cn_assisted_ran_tuning_s>());
      break;
    case types::srvcc_operation_possible:
      c.init(other.c.get<srvcc_operation_possible_e>());
      break;
    case types::iab_authorized:
      c.init(other.c.get<iab_authorized_e>());
      break;
    case types::enhanced_coverage_restrict:
      c.init(other.c.get<enhanced_coverage_restrict_e>());
      break;
    case types::extended_connected_time:
      c.init(other.c.get<uint16_t>());
      break;
    case types::ue_diff_info:
      c.init(other.c.get<ue_diff_info_s>());
      break;
    case types::nr_v2x_services_authorized:
      c.init(other.c.get<nr_v2x_services_authorized_s>());
      break;
    case types::ltev2x_services_authorized:
      c.init(other.c.get<ltev2x_services_authorized_s>());
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      c.init(other.c.get<nr_ue_sidelink_aggr_max_bitrate_s>());
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      c.init(other.c.get<lte_ue_sidelink_aggr_max_bitrate_s>());
      break;
    case types::pc5_qos_params:
      c.init(other.c.get<pc5_qos_params_s>());
      break;
    case types::ce_mode_brestricted:
      c.init(other.c.get<ce_mode_brestricted_e>());
      break;
    case types::ue_up_c_iot_support:
      c.init(other.c.get<ue_up_c_iot_support_e>());
      break;
    case types::rg_level_wireline_access_characteristics:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::management_based_mdt_plmn_list:
      c.init(other.c.get<mdt_plmn_list_l>());
      break;
    case types::ue_radio_cap_id:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::time_sync_assist_info:
      c.init(other.c.get<time_sync_assist_info_s>());
      break;
    case types::q_mcc_onfig_info:
      c.init(other.c.get<q_mcc_onfig_info_s>());
      break;
    case types::target_nssai_info:
      c.init(other.c.get<target_nssai_info_s>());
      break;
    case types::ue_slice_max_bit_rate_list:
      c.init(other.c.get<ue_slice_max_bit_rate_list_l>());
      break;
    case types::five_g_pro_se_authorized:
      c.init(other.c.get<five_g_pro_se_authorized_s>());
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      c.init(other.c.get<nr_ue_sidelink_aggr_max_bitrate_s>());
      break;
    case types::five_g_pro_se_pc5_qos_params:
      c.init(other.c.get<five_g_pro_se_pc5_qos_params_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "init_context_setup_request_ies_o::value_c");
  }
}
init_context_setup_request_ies_o::value_c&
init_context_setup_request_ies_o::value_c::operator=(const init_context_setup_request_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::old_amf:
      c.set(other.c.get<printable_string<1, 150, true, true>>());
      break;
    case types::ue_aggr_max_bit_rate:
      c.set(other.c.get<ue_aggr_max_bit_rate_s>());
      break;
    case types::core_network_assist_info_for_inactive:
      c.set(other.c.get<core_network_assist_info_for_inactive_s>());
      break;
    case types::guami:
      c.set(other.c.get<guami_s>());
      break;
    case types::pdu_session_res_setup_list_cxt_req:
      c.set(other.c.get<pdu_session_res_setup_list_cxt_req_l>());
      break;
    case types::allowed_nssai:
      c.set(other.c.get<allowed_nssai_l>());
      break;
    case types::ue_security_cap:
      c.set(other.c.get<ue_security_cap_s>());
      break;
    case types::security_key:
      c.set(other.c.get<fixed_bitstring<256, false, true>>());
      break;
    case types::trace_activation:
      c.set(other.c.get<trace_activation_s>());
      break;
    case types::mob_restrict_list:
      c.set(other.c.get<mob_restrict_list_s>());
      break;
    case types::ue_radio_cap:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::idx_to_rfsp:
      c.set(other.c.get<uint16_t>());
      break;
    case types::masked_imeisv:
      c.set(other.c.get<fixed_bitstring<64, false, true>>());
      break;
    case types::nas_pdu:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::emergency_fallback_ind:
      c.set(other.c.get<emergency_fallback_ind_s>());
      break;
    case types::rrc_inactive_transition_report_request:
      c.set(other.c.get<rrc_inactive_transition_report_request_e>());
      break;
    case types::ue_radio_cap_for_paging:
      c.set(other.c.get<ue_radio_cap_for_paging_s>());
      break;
    case types::redirection_voice_fallback:
      c.set(other.c.get<redirection_voice_fallback_e>());
      break;
    case types::location_report_request_type:
      c.set(other.c.get<location_report_request_type_s>());
      break;
    case types::cn_assisted_ran_tuning:
      c.set(other.c.get<cn_assisted_ran_tuning_s>());
      break;
    case types::srvcc_operation_possible:
      c.set(other.c.get<srvcc_operation_possible_e>());
      break;
    case types::iab_authorized:
      c.set(other.c.get<iab_authorized_e>());
      break;
    case types::enhanced_coverage_restrict:
      c.set(other.c.get<enhanced_coverage_restrict_e>());
      break;
    case types::extended_connected_time:
      c.set(other.c.get<uint16_t>());
      break;
    case types::ue_diff_info:
      c.set(other.c.get<ue_diff_info_s>());
      break;
    case types::nr_v2x_services_authorized:
      c.set(other.c.get<nr_v2x_services_authorized_s>());
      break;
    case types::ltev2x_services_authorized:
      c.set(other.c.get<ltev2x_services_authorized_s>());
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      c.set(other.c.get<nr_ue_sidelink_aggr_max_bitrate_s>());
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      c.set(other.c.get<lte_ue_sidelink_aggr_max_bitrate_s>());
      break;
    case types::pc5_qos_params:
      c.set(other.c.get<pc5_qos_params_s>());
      break;
    case types::ce_mode_brestricted:
      c.set(other.c.get<ce_mode_brestricted_e>());
      break;
    case types::ue_up_c_iot_support:
      c.set(other.c.get<ue_up_c_iot_support_e>());
      break;
    case types::rg_level_wireline_access_characteristics:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::management_based_mdt_plmn_list:
      c.set(other.c.get<mdt_plmn_list_l>());
      break;
    case types::ue_radio_cap_id:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::time_sync_assist_info:
      c.set(other.c.get<time_sync_assist_info_s>());
      break;
    case types::q_mcc_onfig_info:
      c.set(other.c.get<q_mcc_onfig_info_s>());
      break;
    case types::target_nssai_info:
      c.set(other.c.get<target_nssai_info_s>());
      break;
    case types::ue_slice_max_bit_rate_list:
      c.set(other.c.get<ue_slice_max_bit_rate_list_l>());
      break;
    case types::five_g_pro_se_authorized:
      c.set(other.c.get<five_g_pro_se_authorized_s>());
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      c.set(other.c.get<nr_ue_sidelink_aggr_max_bitrate_s>());
      break;
    case types::five_g_pro_se_pc5_qos_params:
      c.set(other.c.get<five_g_pro_se_pc5_qos_params_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "init_context_setup_request_ies_o::value_c");
  }

  return *this;
}
uint64_t& init_context_setup_request_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& init_context_setup_request_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
printable_string<1, 150, true, true>& init_context_setup_request_ies_o::value_c::old_amf()
{
  assert_choice_type(types::old_amf, type_, "Value");
  return c.get<printable_string<1, 150, true, true>>();
}
ue_aggr_max_bit_rate_s& init_context_setup_request_ies_o::value_c::ue_aggr_max_bit_rate()
{
  assert_choice_type(types::ue_aggr_max_bit_rate, type_, "Value");
  return c.get<ue_aggr_max_bit_rate_s>();
}
core_network_assist_info_for_inactive_s&
init_context_setup_request_ies_o::value_c::core_network_assist_info_for_inactive()
{
  assert_choice_type(types::core_network_assist_info_for_inactive, type_, "Value");
  return c.get<core_network_assist_info_for_inactive_s>();
}
guami_s& init_context_setup_request_ies_o::value_c::guami()
{
  assert_choice_type(types::guami, type_, "Value");
  return c.get<guami_s>();
}
pdu_session_res_setup_list_cxt_req_l& init_context_setup_request_ies_o::value_c::pdu_session_res_setup_list_cxt_req()
{
  assert_choice_type(types::pdu_session_res_setup_list_cxt_req, type_, "Value");
  return c.get<pdu_session_res_setup_list_cxt_req_l>();
}
allowed_nssai_l& init_context_setup_request_ies_o::value_c::allowed_nssai()
{
  assert_choice_type(types::allowed_nssai, type_, "Value");
  return c.get<allowed_nssai_l>();
}
ue_security_cap_s& init_context_setup_request_ies_o::value_c::ue_security_cap()
{
  assert_choice_type(types::ue_security_cap, type_, "Value");
  return c.get<ue_security_cap_s>();
}
fixed_bitstring<256, false, true>& init_context_setup_request_ies_o::value_c::security_key()
{
  assert_choice_type(types::security_key, type_, "Value");
  return c.get<fixed_bitstring<256, false, true>>();
}
trace_activation_s& init_context_setup_request_ies_o::value_c::trace_activation()
{
  assert_choice_type(types::trace_activation, type_, "Value");
  return c.get<trace_activation_s>();
}
mob_restrict_list_s& init_context_setup_request_ies_o::value_c::mob_restrict_list()
{
  assert_choice_type(types::mob_restrict_list, type_, "Value");
  return c.get<mob_restrict_list_s>();
}
unbounded_octstring<true>& init_context_setup_request_ies_o::value_c::ue_radio_cap()
{
  assert_choice_type(types::ue_radio_cap, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
uint16_t& init_context_setup_request_ies_o::value_c::idx_to_rfsp()
{
  assert_choice_type(types::idx_to_rfsp, type_, "Value");
  return c.get<uint16_t>();
}
fixed_bitstring<64, false, true>& init_context_setup_request_ies_o::value_c::masked_imeisv()
{
  assert_choice_type(types::masked_imeisv, type_, "Value");
  return c.get<fixed_bitstring<64, false, true>>();
}
unbounded_octstring<true>& init_context_setup_request_ies_o::value_c::nas_pdu()
{
  assert_choice_type(types::nas_pdu, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
emergency_fallback_ind_s& init_context_setup_request_ies_o::value_c::emergency_fallback_ind()
{
  assert_choice_type(types::emergency_fallback_ind, type_, "Value");
  return c.get<emergency_fallback_ind_s>();
}
rrc_inactive_transition_report_request_e&
init_context_setup_request_ies_o::value_c::rrc_inactive_transition_report_request()
{
  assert_choice_type(types::rrc_inactive_transition_report_request, type_, "Value");
  return c.get<rrc_inactive_transition_report_request_e>();
}
ue_radio_cap_for_paging_s& init_context_setup_request_ies_o::value_c::ue_radio_cap_for_paging()
{
  assert_choice_type(types::ue_radio_cap_for_paging, type_, "Value");
  return c.get<ue_radio_cap_for_paging_s>();
}
redirection_voice_fallback_e& init_context_setup_request_ies_o::value_c::redirection_voice_fallback()
{
  assert_choice_type(types::redirection_voice_fallback, type_, "Value");
  return c.get<redirection_voice_fallback_e>();
}
location_report_request_type_s& init_context_setup_request_ies_o::value_c::location_report_request_type()
{
  assert_choice_type(types::location_report_request_type, type_, "Value");
  return c.get<location_report_request_type_s>();
}
cn_assisted_ran_tuning_s& init_context_setup_request_ies_o::value_c::cn_assisted_ran_tuning()
{
  assert_choice_type(types::cn_assisted_ran_tuning, type_, "Value");
  return c.get<cn_assisted_ran_tuning_s>();
}
srvcc_operation_possible_e& init_context_setup_request_ies_o::value_c::srvcc_operation_possible()
{
  assert_choice_type(types::srvcc_operation_possible, type_, "Value");
  return c.get<srvcc_operation_possible_e>();
}
iab_authorized_e& init_context_setup_request_ies_o::value_c::iab_authorized()
{
  assert_choice_type(types::iab_authorized, type_, "Value");
  return c.get<iab_authorized_e>();
}
enhanced_coverage_restrict_e& init_context_setup_request_ies_o::value_c::enhanced_coverage_restrict()
{
  assert_choice_type(types::enhanced_coverage_restrict, type_, "Value");
  return c.get<enhanced_coverage_restrict_e>();
}
uint16_t& init_context_setup_request_ies_o::value_c::extended_connected_time()
{
  assert_choice_type(types::extended_connected_time, type_, "Value");
  return c.get<uint16_t>();
}
ue_diff_info_s& init_context_setup_request_ies_o::value_c::ue_diff_info()
{
  assert_choice_type(types::ue_diff_info, type_, "Value");
  return c.get<ue_diff_info_s>();
}
nr_v2x_services_authorized_s& init_context_setup_request_ies_o::value_c::nr_v2x_services_authorized()
{
  assert_choice_type(types::nr_v2x_services_authorized, type_, "Value");
  return c.get<nr_v2x_services_authorized_s>();
}
ltev2x_services_authorized_s& init_context_setup_request_ies_o::value_c::ltev2x_services_authorized()
{
  assert_choice_type(types::ltev2x_services_authorized, type_, "Value");
  return c.get<ltev2x_services_authorized_s>();
}
nr_ue_sidelink_aggr_max_bitrate_s& init_context_setup_request_ies_o::value_c::nr_ue_sidelink_aggr_max_bitrate()
{
  assert_choice_type(types::nr_ue_sidelink_aggr_max_bitrate, type_, "Value");
  return c.get<nr_ue_sidelink_aggr_max_bitrate_s>();
}
lte_ue_sidelink_aggr_max_bitrate_s& init_context_setup_request_ies_o::value_c::lte_ue_sidelink_aggr_max_bitrate()
{
  assert_choice_type(types::lte_ue_sidelink_aggr_max_bitrate, type_, "Value");
  return c.get<lte_ue_sidelink_aggr_max_bitrate_s>();
}
pc5_qos_params_s& init_context_setup_request_ies_o::value_c::pc5_qos_params()
{
  assert_choice_type(types::pc5_qos_params, type_, "Value");
  return c.get<pc5_qos_params_s>();
}
ce_mode_brestricted_e& init_context_setup_request_ies_o::value_c::ce_mode_brestricted()
{
  assert_choice_type(types::ce_mode_brestricted, type_, "Value");
  return c.get<ce_mode_brestricted_e>();
}
ue_up_c_iot_support_e& init_context_setup_request_ies_o::value_c::ue_up_c_iot_support()
{
  assert_choice_type(types::ue_up_c_iot_support, type_, "Value");
  return c.get<ue_up_c_iot_support_e>();
}
unbounded_octstring<true>& init_context_setup_request_ies_o::value_c::rg_level_wireline_access_characteristics()
{
  assert_choice_type(types::rg_level_wireline_access_characteristics, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
mdt_plmn_list_l& init_context_setup_request_ies_o::value_c::management_based_mdt_plmn_list()
{
  assert_choice_type(types::management_based_mdt_plmn_list, type_, "Value");
  return c.get<mdt_plmn_list_l>();
}
unbounded_octstring<true>& init_context_setup_request_ies_o::value_c::ue_radio_cap_id()
{
  assert_choice_type(types::ue_radio_cap_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
time_sync_assist_info_s& init_context_setup_request_ies_o::value_c::time_sync_assist_info()
{
  assert_choice_type(types::time_sync_assist_info, type_, "Value");
  return c.get<time_sync_assist_info_s>();
}
q_mcc_onfig_info_s& init_context_setup_request_ies_o::value_c::q_mcc_onfig_info()
{
  assert_choice_type(types::q_mcc_onfig_info, type_, "Value");
  return c.get<q_mcc_onfig_info_s>();
}
target_nssai_info_s& init_context_setup_request_ies_o::value_c::target_nssai_info()
{
  assert_choice_type(types::target_nssai_info, type_, "Value");
  return c.get<target_nssai_info_s>();
}
ue_slice_max_bit_rate_list_l& init_context_setup_request_ies_o::value_c::ue_slice_max_bit_rate_list()
{
  assert_choice_type(types::ue_slice_max_bit_rate_list, type_, "Value");
  return c.get<ue_slice_max_bit_rate_list_l>();
}
five_g_pro_se_authorized_s& init_context_setup_request_ies_o::value_c::five_g_pro_se_authorized()
{
  assert_choice_type(types::five_g_pro_se_authorized, type_, "Value");
  return c.get<five_g_pro_se_authorized_s>();
}
nr_ue_sidelink_aggr_max_bitrate_s& init_context_setup_request_ies_o::value_c::five_g_pro_se_ue_pc5_aggr_max_bit_rate()
{
  assert_choice_type(types::five_g_pro_se_ue_pc5_aggr_max_bit_rate, type_, "Value");
  return c.get<nr_ue_sidelink_aggr_max_bitrate_s>();
}
five_g_pro_se_pc5_qos_params_s& init_context_setup_request_ies_o::value_c::five_g_pro_se_pc5_qos_params()
{
  assert_choice_type(types::five_g_pro_se_pc5_qos_params, type_, "Value");
  return c.get<five_g_pro_se_pc5_qos_params_s>();
}
const uint64_t& init_context_setup_request_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& init_context_setup_request_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const printable_string<1, 150, true, true>& init_context_setup_request_ies_o::value_c::old_amf() const
{
  assert_choice_type(types::old_amf, type_, "Value");
  return c.get<printable_string<1, 150, true, true>>();
}
const ue_aggr_max_bit_rate_s& init_context_setup_request_ies_o::value_c::ue_aggr_max_bit_rate() const
{
  assert_choice_type(types::ue_aggr_max_bit_rate, type_, "Value");
  return c.get<ue_aggr_max_bit_rate_s>();
}
const core_network_assist_info_for_inactive_s&
init_context_setup_request_ies_o::value_c::core_network_assist_info_for_inactive() const
{
  assert_choice_type(types::core_network_assist_info_for_inactive, type_, "Value");
  return c.get<core_network_assist_info_for_inactive_s>();
}
const guami_s& init_context_setup_request_ies_o::value_c::guami() const
{
  assert_choice_type(types::guami, type_, "Value");
  return c.get<guami_s>();
}
const pdu_session_res_setup_list_cxt_req_l&
init_context_setup_request_ies_o::value_c::pdu_session_res_setup_list_cxt_req() const
{
  assert_choice_type(types::pdu_session_res_setup_list_cxt_req, type_, "Value");
  return c.get<pdu_session_res_setup_list_cxt_req_l>();
}
const allowed_nssai_l& init_context_setup_request_ies_o::value_c::allowed_nssai() const
{
  assert_choice_type(types::allowed_nssai, type_, "Value");
  return c.get<allowed_nssai_l>();
}
const ue_security_cap_s& init_context_setup_request_ies_o::value_c::ue_security_cap() const
{
  assert_choice_type(types::ue_security_cap, type_, "Value");
  return c.get<ue_security_cap_s>();
}
const fixed_bitstring<256, false, true>& init_context_setup_request_ies_o::value_c::security_key() const
{
  assert_choice_type(types::security_key, type_, "Value");
  return c.get<fixed_bitstring<256, false, true>>();
}
const trace_activation_s& init_context_setup_request_ies_o::value_c::trace_activation() const
{
  assert_choice_type(types::trace_activation, type_, "Value");
  return c.get<trace_activation_s>();
}
const mob_restrict_list_s& init_context_setup_request_ies_o::value_c::mob_restrict_list() const
{
  assert_choice_type(types::mob_restrict_list, type_, "Value");
  return c.get<mob_restrict_list_s>();
}
const unbounded_octstring<true>& init_context_setup_request_ies_o::value_c::ue_radio_cap() const
{
  assert_choice_type(types::ue_radio_cap, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const uint16_t& init_context_setup_request_ies_o::value_c::idx_to_rfsp() const
{
  assert_choice_type(types::idx_to_rfsp, type_, "Value");
  return c.get<uint16_t>();
}
const fixed_bitstring<64, false, true>& init_context_setup_request_ies_o::value_c::masked_imeisv() const
{
  assert_choice_type(types::masked_imeisv, type_, "Value");
  return c.get<fixed_bitstring<64, false, true>>();
}
const unbounded_octstring<true>& init_context_setup_request_ies_o::value_c::nas_pdu() const
{
  assert_choice_type(types::nas_pdu, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const emergency_fallback_ind_s& init_context_setup_request_ies_o::value_c::emergency_fallback_ind() const
{
  assert_choice_type(types::emergency_fallback_ind, type_, "Value");
  return c.get<emergency_fallback_ind_s>();
}
const rrc_inactive_transition_report_request_e&
init_context_setup_request_ies_o::value_c::rrc_inactive_transition_report_request() const
{
  assert_choice_type(types::rrc_inactive_transition_report_request, type_, "Value");
  return c.get<rrc_inactive_transition_report_request_e>();
}
const ue_radio_cap_for_paging_s& init_context_setup_request_ies_o::value_c::ue_radio_cap_for_paging() const
{
  assert_choice_type(types::ue_radio_cap_for_paging, type_, "Value");
  return c.get<ue_radio_cap_for_paging_s>();
}
const redirection_voice_fallback_e& init_context_setup_request_ies_o::value_c::redirection_voice_fallback() const
{
  assert_choice_type(types::redirection_voice_fallback, type_, "Value");
  return c.get<redirection_voice_fallback_e>();
}
const location_report_request_type_s& init_context_setup_request_ies_o::value_c::location_report_request_type() const
{
  assert_choice_type(types::location_report_request_type, type_, "Value");
  return c.get<location_report_request_type_s>();
}
const cn_assisted_ran_tuning_s& init_context_setup_request_ies_o::value_c::cn_assisted_ran_tuning() const
{
  assert_choice_type(types::cn_assisted_ran_tuning, type_, "Value");
  return c.get<cn_assisted_ran_tuning_s>();
}
const srvcc_operation_possible_e& init_context_setup_request_ies_o::value_c::srvcc_operation_possible() const
{
  assert_choice_type(types::srvcc_operation_possible, type_, "Value");
  return c.get<srvcc_operation_possible_e>();
}
const iab_authorized_e& init_context_setup_request_ies_o::value_c::iab_authorized() const
{
  assert_choice_type(types::iab_authorized, type_, "Value");
  return c.get<iab_authorized_e>();
}
const enhanced_coverage_restrict_e& init_context_setup_request_ies_o::value_c::enhanced_coverage_restrict() const
{
  assert_choice_type(types::enhanced_coverage_restrict, type_, "Value");
  return c.get<enhanced_coverage_restrict_e>();
}
const uint16_t& init_context_setup_request_ies_o::value_c::extended_connected_time() const
{
  assert_choice_type(types::extended_connected_time, type_, "Value");
  return c.get<uint16_t>();
}
const ue_diff_info_s& init_context_setup_request_ies_o::value_c::ue_diff_info() const
{
  assert_choice_type(types::ue_diff_info, type_, "Value");
  return c.get<ue_diff_info_s>();
}
const nr_v2x_services_authorized_s& init_context_setup_request_ies_o::value_c::nr_v2x_services_authorized() const
{
  assert_choice_type(types::nr_v2x_services_authorized, type_, "Value");
  return c.get<nr_v2x_services_authorized_s>();
}
const ltev2x_services_authorized_s& init_context_setup_request_ies_o::value_c::ltev2x_services_authorized() const
{
  assert_choice_type(types::ltev2x_services_authorized, type_, "Value");
  return c.get<ltev2x_services_authorized_s>();
}
const nr_ue_sidelink_aggr_max_bitrate_s&
init_context_setup_request_ies_o::value_c::nr_ue_sidelink_aggr_max_bitrate() const
{
  assert_choice_type(types::nr_ue_sidelink_aggr_max_bitrate, type_, "Value");
  return c.get<nr_ue_sidelink_aggr_max_bitrate_s>();
}
const lte_ue_sidelink_aggr_max_bitrate_s&
init_context_setup_request_ies_o::value_c::lte_ue_sidelink_aggr_max_bitrate() const
{
  assert_choice_type(types::lte_ue_sidelink_aggr_max_bitrate, type_, "Value");
  return c.get<lte_ue_sidelink_aggr_max_bitrate_s>();
}
const pc5_qos_params_s& init_context_setup_request_ies_o::value_c::pc5_qos_params() const
{
  assert_choice_type(types::pc5_qos_params, type_, "Value");
  return c.get<pc5_qos_params_s>();
}
const ce_mode_brestricted_e& init_context_setup_request_ies_o::value_c::ce_mode_brestricted() const
{
  assert_choice_type(types::ce_mode_brestricted, type_, "Value");
  return c.get<ce_mode_brestricted_e>();
}
const ue_up_c_iot_support_e& init_context_setup_request_ies_o::value_c::ue_up_c_iot_support() const
{
  assert_choice_type(types::ue_up_c_iot_support, type_, "Value");
  return c.get<ue_up_c_iot_support_e>();
}
const unbounded_octstring<true>&
init_context_setup_request_ies_o::value_c::rg_level_wireline_access_characteristics() const
{
  assert_choice_type(types::rg_level_wireline_access_characteristics, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const mdt_plmn_list_l& init_context_setup_request_ies_o::value_c::management_based_mdt_plmn_list() const
{
  assert_choice_type(types::management_based_mdt_plmn_list, type_, "Value");
  return c.get<mdt_plmn_list_l>();
}
const unbounded_octstring<true>& init_context_setup_request_ies_o::value_c::ue_radio_cap_id() const
{
  assert_choice_type(types::ue_radio_cap_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const time_sync_assist_info_s& init_context_setup_request_ies_o::value_c::time_sync_assist_info() const
{
  assert_choice_type(types::time_sync_assist_info, type_, "Value");
  return c.get<time_sync_assist_info_s>();
}
const q_mcc_onfig_info_s& init_context_setup_request_ies_o::value_c::q_mcc_onfig_info() const
{
  assert_choice_type(types::q_mcc_onfig_info, type_, "Value");
  return c.get<q_mcc_onfig_info_s>();
}
const target_nssai_info_s& init_context_setup_request_ies_o::value_c::target_nssai_info() const
{
  assert_choice_type(types::target_nssai_info, type_, "Value");
  return c.get<target_nssai_info_s>();
}
const ue_slice_max_bit_rate_list_l& init_context_setup_request_ies_o::value_c::ue_slice_max_bit_rate_list() const
{
  assert_choice_type(types::ue_slice_max_bit_rate_list, type_, "Value");
  return c.get<ue_slice_max_bit_rate_list_l>();
}
const five_g_pro_se_authorized_s& init_context_setup_request_ies_o::value_c::five_g_pro_se_authorized() const
{
  assert_choice_type(types::five_g_pro_se_authorized, type_, "Value");
  return c.get<five_g_pro_se_authorized_s>();
}
const nr_ue_sidelink_aggr_max_bitrate_s&
init_context_setup_request_ies_o::value_c::five_g_pro_se_ue_pc5_aggr_max_bit_rate() const
{
  assert_choice_type(types::five_g_pro_se_ue_pc5_aggr_max_bit_rate, type_, "Value");
  return c.get<nr_ue_sidelink_aggr_max_bitrate_s>();
}
const five_g_pro_se_pc5_qos_params_s& init_context_setup_request_ies_o::value_c::five_g_pro_se_pc5_qos_params() const
{
  assert_choice_type(types::five_g_pro_se_pc5_qos_params, type_, "Value");
  return c.get<five_g_pro_se_pc5_qos_params_s>();
}
void init_context_setup_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::old_amf:
      j.write_str("PrintableString", c.get<printable_string<1, 150, true, true>>().to_string());
      break;
    case types::ue_aggr_max_bit_rate:
      j.write_fieldname("UEAggregateMaximumBitRate");
      c.get<ue_aggr_max_bit_rate_s>().to_json(j);
      break;
    case types::core_network_assist_info_for_inactive:
      j.write_fieldname("CoreNetworkAssistanceInformationForInactive");
      c.get<core_network_assist_info_for_inactive_s>().to_json(j);
      break;
    case types::guami:
      j.write_fieldname("GUAMI");
      c.get<guami_s>().to_json(j);
      break;
    case types::pdu_session_res_setup_list_cxt_req:
      j.start_array("PDUSessionResourceSetupListCxtReq");
      for (const auto& e1 : c.get<pdu_session_res_setup_list_cxt_req_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::allowed_nssai:
      j.start_array("AllowedNSSAI");
      for (const auto& e1 : c.get<allowed_nssai_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::ue_security_cap:
      j.write_fieldname("UESecurityCapabilities");
      c.get<ue_security_cap_s>().to_json(j);
      break;
    case types::security_key:
      j.write_str("BIT STRING", c.get<fixed_bitstring<256, false, true>>().to_string());
      break;
    case types::trace_activation:
      j.write_fieldname("TraceActivation");
      c.get<trace_activation_s>().to_json(j);
      break;
    case types::mob_restrict_list:
      j.write_fieldname("MobilityRestrictionList");
      c.get<mob_restrict_list_s>().to_json(j);
      break;
    case types::ue_radio_cap:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::idx_to_rfsp:
      j.write_int("INTEGER (1..256,...)", c.get<uint16_t>());
      break;
    case types::masked_imeisv:
      j.write_str("BIT STRING", c.get<fixed_bitstring<64, false, true>>().to_string());
      break;
    case types::nas_pdu:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::emergency_fallback_ind:
      j.write_fieldname("EmergencyFallbackIndicator");
      c.get<emergency_fallback_ind_s>().to_json(j);
      break;
    case types::rrc_inactive_transition_report_request:
      j.write_str("RRCInactiveTransitionReportRequest", c.get<rrc_inactive_transition_report_request_e>().to_string());
      break;
    case types::ue_radio_cap_for_paging:
      j.write_fieldname("UERadioCapabilityForPaging");
      c.get<ue_radio_cap_for_paging_s>().to_json(j);
      break;
    case types::redirection_voice_fallback:
      j.write_str("RedirectionVoiceFallback", c.get<redirection_voice_fallback_e>().to_string());
      break;
    case types::location_report_request_type:
      j.write_fieldname("LocationReportingRequestType");
      c.get<location_report_request_type_s>().to_json(j);
      break;
    case types::cn_assisted_ran_tuning:
      j.write_fieldname("CNAssistedRANTuning");
      c.get<cn_assisted_ran_tuning_s>().to_json(j);
      break;
    case types::srvcc_operation_possible:
      j.write_str("SRVCCOperationPossible", c.get<srvcc_operation_possible_e>().to_string());
      break;
    case types::iab_authorized:
      j.write_str("IAB-Authorized", c.get<iab_authorized_e>().to_string());
      break;
    case types::enhanced_coverage_restrict:
      j.write_str("Enhanced-CoverageRestriction", "restricted");
      break;
    case types::extended_connected_time:
      j.write_int("INTEGER (0..255)", c.get<uint16_t>());
      break;
    case types::ue_diff_info:
      j.write_fieldname("UE-DifferentiationInfo");
      c.get<ue_diff_info_s>().to_json(j);
      break;
    case types::nr_v2x_services_authorized:
      j.write_fieldname("NRV2XServicesAuthorized");
      c.get<nr_v2x_services_authorized_s>().to_json(j);
      break;
    case types::ltev2x_services_authorized:
      j.write_fieldname("LTEV2XServicesAuthorized");
      c.get<ltev2x_services_authorized_s>().to_json(j);
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      j.write_fieldname("NRUESidelinkAggregateMaximumBitrate");
      c.get<nr_ue_sidelink_aggr_max_bitrate_s>().to_json(j);
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      j.write_fieldname("LTEUESidelinkAggregateMaximumBitrate");
      c.get<lte_ue_sidelink_aggr_max_bitrate_s>().to_json(j);
      break;
    case types::pc5_qos_params:
      j.write_fieldname("PC5QoSParameters");
      c.get<pc5_qos_params_s>().to_json(j);
      break;
    case types::ce_mode_brestricted:
      j.write_str("CEmodeBrestricted", c.get<ce_mode_brestricted_e>().to_string());
      break;
    case types::ue_up_c_iot_support:
      j.write_str("UE-UP-CIoT-Support", "supported");
      break;
    case types::rg_level_wireline_access_characteristics:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::management_based_mdt_plmn_list:
      j.start_array("MDTPLMNList");
      for (const auto& e1 : c.get<mdt_plmn_list_l>()) {
        j.write_str(e1.to_string());
      }
      j.end_array();
      break;
    case types::ue_radio_cap_id:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::time_sync_assist_info:
      j.write_fieldname("TimeSyncAssistanceInfo");
      c.get<time_sync_assist_info_s>().to_json(j);
      break;
    case types::q_mcc_onfig_info:
      j.write_fieldname("QMCConfigInfo");
      c.get<q_mcc_onfig_info_s>().to_json(j);
      break;
    case types::target_nssai_info:
      j.write_fieldname("TargetNSSAIInformation");
      c.get<target_nssai_info_s>().to_json(j);
      break;
    case types::ue_slice_max_bit_rate_list:
      j.start_array("UESliceMaximumBitRateList");
      for (const auto& e1 : c.get<ue_slice_max_bit_rate_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::five_g_pro_se_authorized:
      j.write_fieldname("FiveG-ProSeAuthorized");
      c.get<five_g_pro_se_authorized_s>().to_json(j);
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      j.write_fieldname("NRUESidelinkAggregateMaximumBitrate");
      c.get<nr_ue_sidelink_aggr_max_bitrate_s>().to_json(j);
      break;
    case types::five_g_pro_se_pc5_qos_params:
      j.write_fieldname("FiveG-ProSePC5QoSParameters");
      c.get<five_g_pro_se_pc5_qos_params_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "init_context_setup_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE init_context_setup_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::old_amf:
      HANDLE_CODE((c.get<printable_string<1, 150, true, true>>().pack(bref)));
      break;
    case types::ue_aggr_max_bit_rate:
      HANDLE_CODE(c.get<ue_aggr_max_bit_rate_s>().pack(bref));
      break;
    case types::core_network_assist_info_for_inactive:
      HANDLE_CODE(c.get<core_network_assist_info_for_inactive_s>().pack(bref));
      break;
    case types::guami:
      HANDLE_CODE(c.get<guami_s>().pack(bref));
      break;
    case types::pdu_session_res_setup_list_cxt_req:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_setup_list_cxt_req_l>(), 1, 256, true));
      break;
    case types::allowed_nssai:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<allowed_nssai_l>(), 1, 8, true));
      break;
    case types::ue_security_cap:
      HANDLE_CODE(c.get<ue_security_cap_s>().pack(bref));
      break;
    case types::security_key:
      HANDLE_CODE((c.get<fixed_bitstring<256, false, true>>().pack(bref)));
      break;
    case types::trace_activation:
      HANDLE_CODE(c.get<trace_activation_s>().pack(bref));
      break;
    case types::mob_restrict_list:
      HANDLE_CODE(c.get<mob_restrict_list_s>().pack(bref));
      break;
    case types::ue_radio_cap:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::idx_to_rfsp:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)1u, (uint16_t)256u, true, true));
      break;
    case types::masked_imeisv:
      HANDLE_CODE((c.get<fixed_bitstring<64, false, true>>().pack(bref)));
      break;
    case types::nas_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::emergency_fallback_ind:
      HANDLE_CODE(c.get<emergency_fallback_ind_s>().pack(bref));
      break;
    case types::rrc_inactive_transition_report_request:
      HANDLE_CODE(c.get<rrc_inactive_transition_report_request_e>().pack(bref));
      break;
    case types::ue_radio_cap_for_paging:
      HANDLE_CODE(c.get<ue_radio_cap_for_paging_s>().pack(bref));
      break;
    case types::redirection_voice_fallback:
      HANDLE_CODE(c.get<redirection_voice_fallback_e>().pack(bref));
      break;
    case types::location_report_request_type:
      HANDLE_CODE(c.get<location_report_request_type_s>().pack(bref));
      break;
    case types::cn_assisted_ran_tuning:
      HANDLE_CODE(c.get<cn_assisted_ran_tuning_s>().pack(bref));
      break;
    case types::srvcc_operation_possible:
      HANDLE_CODE(c.get<srvcc_operation_possible_e>().pack(bref));
      break;
    case types::iab_authorized:
      HANDLE_CODE(c.get<iab_authorized_e>().pack(bref));
      break;
    case types::enhanced_coverage_restrict:
      HANDLE_CODE(c.get<enhanced_coverage_restrict_e>().pack(bref));
      break;
    case types::extended_connected_time:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)0u, (uint16_t)255u, false, true));
      break;
    case types::ue_diff_info:
      HANDLE_CODE(c.get<ue_diff_info_s>().pack(bref));
      break;
    case types::nr_v2x_services_authorized:
      HANDLE_CODE(c.get<nr_v2x_services_authorized_s>().pack(bref));
      break;
    case types::ltev2x_services_authorized:
      HANDLE_CODE(c.get<ltev2x_services_authorized_s>().pack(bref));
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      HANDLE_CODE(c.get<nr_ue_sidelink_aggr_max_bitrate_s>().pack(bref));
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      HANDLE_CODE(c.get<lte_ue_sidelink_aggr_max_bitrate_s>().pack(bref));
      break;
    case types::pc5_qos_params:
      HANDLE_CODE(c.get<pc5_qos_params_s>().pack(bref));
      break;
    case types::ce_mode_brestricted:
      HANDLE_CODE(c.get<ce_mode_brestricted_e>().pack(bref));
      break;
    case types::ue_up_c_iot_support:
      HANDLE_CODE(c.get<ue_up_c_iot_support_e>().pack(bref));
      break;
    case types::rg_level_wireline_access_characteristics:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::management_based_mdt_plmn_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<mdt_plmn_list_l>(), 1, 16, true));
      break;
    case types::ue_radio_cap_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::time_sync_assist_info:
      HANDLE_CODE(c.get<time_sync_assist_info_s>().pack(bref));
      break;
    case types::q_mcc_onfig_info:
      HANDLE_CODE(c.get<q_mcc_onfig_info_s>().pack(bref));
      break;
    case types::target_nssai_info:
      HANDLE_CODE(c.get<target_nssai_info_s>().pack(bref));
      break;
    case types::ue_slice_max_bit_rate_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<ue_slice_max_bit_rate_list_l>(), 1, 8, true));
      break;
    case types::five_g_pro_se_authorized:
      HANDLE_CODE(c.get<five_g_pro_se_authorized_s>().pack(bref));
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      HANDLE_CODE(c.get<nr_ue_sidelink_aggr_max_bitrate_s>().pack(bref));
      break;
    case types::five_g_pro_se_pc5_qos_params:
      HANDLE_CODE(c.get<five_g_pro_se_pc5_qos_params_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "init_context_setup_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE init_context_setup_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::old_amf:
      HANDLE_CODE((c.get<printable_string<1, 150, true, true>>().unpack(bref)));
      break;
    case types::ue_aggr_max_bit_rate:
      HANDLE_CODE(c.get<ue_aggr_max_bit_rate_s>().unpack(bref));
      break;
    case types::core_network_assist_info_for_inactive:
      HANDLE_CODE(c.get<core_network_assist_info_for_inactive_s>().unpack(bref));
      break;
    case types::guami:
      HANDLE_CODE(c.get<guami_s>().unpack(bref));
      break;
    case types::pdu_session_res_setup_list_cxt_req:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_setup_list_cxt_req_l>(), bref, 1, 256, true));
      break;
    case types::allowed_nssai:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<allowed_nssai_l>(), bref, 1, 8, true));
      break;
    case types::ue_security_cap:
      HANDLE_CODE(c.get<ue_security_cap_s>().unpack(bref));
      break;
    case types::security_key:
      HANDLE_CODE((c.get<fixed_bitstring<256, false, true>>().unpack(bref)));
      break;
    case types::trace_activation:
      HANDLE_CODE(c.get<trace_activation_s>().unpack(bref));
      break;
    case types::mob_restrict_list:
      HANDLE_CODE(c.get<mob_restrict_list_s>().unpack(bref));
      break;
    case types::ue_radio_cap:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::idx_to_rfsp:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)1u, (uint16_t)256u, true, true));
      break;
    case types::masked_imeisv:
      HANDLE_CODE((c.get<fixed_bitstring<64, false, true>>().unpack(bref)));
      break;
    case types::nas_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::emergency_fallback_ind:
      HANDLE_CODE(c.get<emergency_fallback_ind_s>().unpack(bref));
      break;
    case types::rrc_inactive_transition_report_request:
      HANDLE_CODE(c.get<rrc_inactive_transition_report_request_e>().unpack(bref));
      break;
    case types::ue_radio_cap_for_paging:
      HANDLE_CODE(c.get<ue_radio_cap_for_paging_s>().unpack(bref));
      break;
    case types::redirection_voice_fallback:
      HANDLE_CODE(c.get<redirection_voice_fallback_e>().unpack(bref));
      break;
    case types::location_report_request_type:
      HANDLE_CODE(c.get<location_report_request_type_s>().unpack(bref));
      break;
    case types::cn_assisted_ran_tuning:
      HANDLE_CODE(c.get<cn_assisted_ran_tuning_s>().unpack(bref));
      break;
    case types::srvcc_operation_possible:
      HANDLE_CODE(c.get<srvcc_operation_possible_e>().unpack(bref));
      break;
    case types::iab_authorized:
      HANDLE_CODE(c.get<iab_authorized_e>().unpack(bref));
      break;
    case types::enhanced_coverage_restrict:
      HANDLE_CODE(c.get<enhanced_coverage_restrict_e>().unpack(bref));
      break;
    case types::extended_connected_time:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)0u, (uint16_t)255u, false, true));
      break;
    case types::ue_diff_info:
      HANDLE_CODE(c.get<ue_diff_info_s>().unpack(bref));
      break;
    case types::nr_v2x_services_authorized:
      HANDLE_CODE(c.get<nr_v2x_services_authorized_s>().unpack(bref));
      break;
    case types::ltev2x_services_authorized:
      HANDLE_CODE(c.get<ltev2x_services_authorized_s>().unpack(bref));
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      HANDLE_CODE(c.get<nr_ue_sidelink_aggr_max_bitrate_s>().unpack(bref));
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      HANDLE_CODE(c.get<lte_ue_sidelink_aggr_max_bitrate_s>().unpack(bref));
      break;
    case types::pc5_qos_params:
      HANDLE_CODE(c.get<pc5_qos_params_s>().unpack(bref));
      break;
    case types::ce_mode_brestricted:
      HANDLE_CODE(c.get<ce_mode_brestricted_e>().unpack(bref));
      break;
    case types::ue_up_c_iot_support:
      HANDLE_CODE(c.get<ue_up_c_iot_support_e>().unpack(bref));
      break;
    case types::rg_level_wireline_access_characteristics:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::management_based_mdt_plmn_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<mdt_plmn_list_l>(), bref, 1, 16, true));
      break;
    case types::ue_radio_cap_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::time_sync_assist_info:
      HANDLE_CODE(c.get<time_sync_assist_info_s>().unpack(bref));
      break;
    case types::q_mcc_onfig_info:
      HANDLE_CODE(c.get<q_mcc_onfig_info_s>().unpack(bref));
      break;
    case types::target_nssai_info:
      HANDLE_CODE(c.get<target_nssai_info_s>().unpack(bref));
      break;
    case types::ue_slice_max_bit_rate_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<ue_slice_max_bit_rate_list_l>(), bref, 1, 8, true));
      break;
    case types::five_g_pro_se_authorized:
      HANDLE_CODE(c.get<five_g_pro_se_authorized_s>().unpack(bref));
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      HANDLE_CODE(c.get<nr_ue_sidelink_aggr_max_bitrate_s>().unpack(bref));
      break;
    case types::five_g_pro_se_pc5_qos_params:
      HANDLE_CODE(c.get<five_g_pro_se_pc5_qos_params_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "init_context_setup_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* init_context_setup_request_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..1099511627775)",
                                "INTEGER (0..4294967295)",
                                "PrintableString",
                                "UEAggregateMaximumBitRate",
                                "CoreNetworkAssistanceInformationForInactive",
                                "GUAMI",
                                "PDUSessionResourceSetupListCxtReq",
                                "AllowedNSSAI",
                                "UESecurityCapabilities",
                                "BIT STRING",
                                "TraceActivation",
                                "MobilityRestrictionList",
                                "OCTET STRING",
                                "INTEGER (1..256,...)",
                                "BIT STRING",
                                "OCTET STRING",
                                "EmergencyFallbackIndicator",
                                "RRCInactiveTransitionReportRequest",
                                "UERadioCapabilityForPaging",
                                "RedirectionVoiceFallback",
                                "LocationReportingRequestType",
                                "CNAssistedRANTuning",
                                "SRVCCOperationPossible",
                                "IAB-Authorized",
                                "Enhanced-CoverageRestriction",
                                "INTEGER (0..255)",
                                "UE-DifferentiationInfo",
                                "NRV2XServicesAuthorized",
                                "LTEV2XServicesAuthorized",
                                "NRUESidelinkAggregateMaximumBitrate",
                                "LTEUESidelinkAggregateMaximumBitrate",
                                "PC5QoSParameters",
                                "CEmodeBrestricted",
                                "UE-UP-CIoT-Support",
                                "OCTET STRING",
                                "MDTPLMNList",
                                "OCTET STRING",
                                "TimeSyncAssistanceInfo",
                                "QMCConfigInfo",
                                "TargetNSSAIInformation",
                                "UESliceMaximumBitRateList",
                                "FiveG-ProSeAuthorized",
                                "NRUESidelinkAggregateMaximumBitrate",
                                "FiveG-ProSePC5QoSParameters"};
  return convert_enum_idx(names, 44, value, "init_context_setup_request_ies_o::value_c::types");
}

template struct asn1::protocol_ie_field_s<init_context_setup_request_ies_o>;

init_context_setup_request_ies_container::init_context_setup_request_ies_container() :
  amf_ue_ngap_id(10, crit_e::reject),
  ran_ue_ngap_id(85, crit_e::reject),
  old_amf(48, crit_e::reject),
  ue_aggr_max_bit_rate(110, crit_e::reject),
  core_network_assist_info_for_inactive(18, crit_e::ignore),
  guami(28, crit_e::reject),
  pdu_session_res_setup_list_cxt_req(71, crit_e::reject),
  allowed_nssai(0, crit_e::reject),
  ue_security_cap(119, crit_e::reject),
  security_key(94, crit_e::reject),
  trace_activation(108, crit_e::ignore),
  mob_restrict_list(36, crit_e::ignore),
  ue_radio_cap(117, crit_e::ignore),
  idx_to_rfsp(31, crit_e::ignore),
  masked_imeisv(34, crit_e::ignore),
  nas_pdu(38, crit_e::ignore),
  emergency_fallback_ind(24, crit_e::reject),
  rrc_inactive_transition_report_request(91, crit_e::ignore),
  ue_radio_cap_for_paging(118, crit_e::ignore),
  redirection_voice_fallback(146, crit_e::ignore),
  location_report_request_type(33, crit_e::ignore),
  cn_assisted_ran_tuning(165, crit_e::ignore),
  srvcc_operation_possible(177, crit_e::ignore),
  iab_authorized(199, crit_e::ignore),
  enhanced_coverage_restrict(205, crit_e::ignore),
  extended_connected_time(206, crit_e::ignore),
  ue_diff_info(209, crit_e::ignore),
  nr_v2x_services_authorized(216, crit_e::ignore),
  ltev2x_services_authorized(215, crit_e::ignore),
  nr_ue_sidelink_aggr_max_bitrate(218, crit_e::ignore),
  lte_ue_sidelink_aggr_max_bitrate(217, crit_e::ignore),
  pc5_qos_params(219, crit_e::ignore),
  ce_mode_brestricted(222, crit_e::ignore),
  ue_up_c_iot_support(234, crit_e::ignore),
  rg_level_wireline_access_characteristics(238, crit_e::ignore),
  management_based_mdt_plmn_list(254, crit_e::ignore),
  ue_radio_cap_id(264, crit_e::reject),
  time_sync_assist_info(326, crit_e::ignore),
  q_mcc_onfig_info(328, crit_e::ignore),
  target_nssai_info(334, crit_e::ignore),
  ue_slice_max_bit_rate_list(335, crit_e::ignore),
  five_g_pro_se_authorized(345, crit_e::ignore),
  five_g_pro_se_ue_pc5_aggr_max_bit_rate(346, crit_e::ignore),
  five_g_pro_se_pc5_qos_params(347, crit_e::ignore)
{
}
SRSASN_CODE init_context_setup_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 6;
  nof_ies += old_amf_present ? 1 : 0;
  nof_ies += ue_aggr_max_bit_rate_present ? 1 : 0;
  nof_ies += core_network_assist_info_for_inactive_present ? 1 : 0;
  nof_ies += pdu_session_res_setup_list_cxt_req_present ? 1 : 0;
  nof_ies += trace_activation_present ? 1 : 0;
  nof_ies += mob_restrict_list_present ? 1 : 0;
  nof_ies += ue_radio_cap_present ? 1 : 0;
  nof_ies += idx_to_rfsp_present ? 1 : 0;
  nof_ies += masked_imeisv_present ? 1 : 0;
  nof_ies += nas_pdu_present ? 1 : 0;
  nof_ies += emergency_fallback_ind_present ? 1 : 0;
  nof_ies += rrc_inactive_transition_report_request_present ? 1 : 0;
  nof_ies += ue_radio_cap_for_paging_present ? 1 : 0;
  nof_ies += redirection_voice_fallback_present ? 1 : 0;
  nof_ies += location_report_request_type_present ? 1 : 0;
  nof_ies += cn_assisted_ran_tuning_present ? 1 : 0;
  nof_ies += srvcc_operation_possible_present ? 1 : 0;
  nof_ies += iab_authorized_present ? 1 : 0;
  nof_ies += enhanced_coverage_restrict_present ? 1 : 0;
  nof_ies += extended_connected_time_present ? 1 : 0;
  nof_ies += ue_diff_info_present ? 1 : 0;
  nof_ies += nr_v2x_services_authorized_present ? 1 : 0;
  nof_ies += ltev2x_services_authorized_present ? 1 : 0;
  nof_ies += nr_ue_sidelink_aggr_max_bitrate_present ? 1 : 0;
  nof_ies += lte_ue_sidelink_aggr_max_bitrate_present ? 1 : 0;
  nof_ies += pc5_qos_params_present ? 1 : 0;
  nof_ies += ce_mode_brestricted_present ? 1 : 0;
  nof_ies += ue_up_c_iot_support_present ? 1 : 0;
  nof_ies += rg_level_wireline_access_characteristics_present ? 1 : 0;
  nof_ies += management_based_mdt_plmn_list_present ? 1 : 0;
  nof_ies += ue_radio_cap_id_present ? 1 : 0;
  nof_ies += time_sync_assist_info_present ? 1 : 0;
  nof_ies += q_mcc_onfig_info_present ? 1 : 0;
  nof_ies += target_nssai_info_present ? 1 : 0;
  nof_ies += ue_slice_max_bit_rate_list_present ? 1 : 0;
  nof_ies += five_g_pro_se_authorized_present ? 1 : 0;
  nof_ies += five_g_pro_se_ue_pc5_aggr_max_bit_rate_present ? 1 : 0;
  nof_ies += five_g_pro_se_pc5_qos_params_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  if (old_amf_present) {
    HANDLE_CODE(old_amf.pack(bref));
  }
  if (ue_aggr_max_bit_rate_present) {
    HANDLE_CODE(ue_aggr_max_bit_rate.pack(bref));
  }
  if (core_network_assist_info_for_inactive_present) {
    HANDLE_CODE(core_network_assist_info_for_inactive.pack(bref));
  }
  HANDLE_CODE(guami.pack(bref));
  if (pdu_session_res_setup_list_cxt_req_present) {
    HANDLE_CODE(pdu_session_res_setup_list_cxt_req.pack(bref));
  }
  HANDLE_CODE(allowed_nssai.pack(bref));
  HANDLE_CODE(ue_security_cap.pack(bref));
  HANDLE_CODE(security_key.pack(bref));
  if (trace_activation_present) {
    HANDLE_CODE(trace_activation.pack(bref));
  }
  if (mob_restrict_list_present) {
    HANDLE_CODE(mob_restrict_list.pack(bref));
  }
  if (ue_radio_cap_present) {
    HANDLE_CODE(ue_radio_cap.pack(bref));
  }
  if (idx_to_rfsp_present) {
    HANDLE_CODE(idx_to_rfsp.pack(bref));
  }
  if (masked_imeisv_present) {
    HANDLE_CODE(masked_imeisv.pack(bref));
  }
  if (nas_pdu_present) {
    HANDLE_CODE(nas_pdu.pack(bref));
  }
  if (emergency_fallback_ind_present) {
    HANDLE_CODE(emergency_fallback_ind.pack(bref));
  }
  if (rrc_inactive_transition_report_request_present) {
    HANDLE_CODE(rrc_inactive_transition_report_request.pack(bref));
  }
  if (ue_radio_cap_for_paging_present) {
    HANDLE_CODE(ue_radio_cap_for_paging.pack(bref));
  }
  if (redirection_voice_fallback_present) {
    HANDLE_CODE(redirection_voice_fallback.pack(bref));
  }
  if (location_report_request_type_present) {
    HANDLE_CODE(location_report_request_type.pack(bref));
  }
  if (cn_assisted_ran_tuning_present) {
    HANDLE_CODE(cn_assisted_ran_tuning.pack(bref));
  }
  if (srvcc_operation_possible_present) {
    HANDLE_CODE(srvcc_operation_possible.pack(bref));
  }
  if (iab_authorized_present) {
    HANDLE_CODE(iab_authorized.pack(bref));
  }
  if (enhanced_coverage_restrict_present) {
    HANDLE_CODE(enhanced_coverage_restrict.pack(bref));
  }
  if (extended_connected_time_present) {
    HANDLE_CODE(extended_connected_time.pack(bref));
  }
  if (ue_diff_info_present) {
    HANDLE_CODE(ue_diff_info.pack(bref));
  }
  if (nr_v2x_services_authorized_present) {
    HANDLE_CODE(nr_v2x_services_authorized.pack(bref));
  }
  if (ltev2x_services_authorized_present) {
    HANDLE_CODE(ltev2x_services_authorized.pack(bref));
  }
  if (nr_ue_sidelink_aggr_max_bitrate_present) {
    HANDLE_CODE(nr_ue_sidelink_aggr_max_bitrate.pack(bref));
  }
  if (lte_ue_sidelink_aggr_max_bitrate_present) {
    HANDLE_CODE(lte_ue_sidelink_aggr_max_bitrate.pack(bref));
  }
  if (pc5_qos_params_present) {
    HANDLE_CODE(pc5_qos_params.pack(bref));
  }
  if (ce_mode_brestricted_present) {
    HANDLE_CODE(ce_mode_brestricted.pack(bref));
  }
  if (ue_up_c_iot_support_present) {
    HANDLE_CODE(ue_up_c_iot_support.pack(bref));
  }
  if (rg_level_wireline_access_characteristics_present) {
    HANDLE_CODE(rg_level_wireline_access_characteristics.pack(bref));
  }
  if (management_based_mdt_plmn_list_present) {
    HANDLE_CODE(management_based_mdt_plmn_list.pack(bref));
  }
  if (ue_radio_cap_id_present) {
    HANDLE_CODE(ue_radio_cap_id.pack(bref));
  }
  if (time_sync_assist_info_present) {
    HANDLE_CODE(time_sync_assist_info.pack(bref));
  }
  if (q_mcc_onfig_info_present) {
    HANDLE_CODE(q_mcc_onfig_info.pack(bref));
  }
  if (target_nssai_info_present) {
    HANDLE_CODE(target_nssai_info.pack(bref));
  }
  if (ue_slice_max_bit_rate_list_present) {
    HANDLE_CODE(ue_slice_max_bit_rate_list.pack(bref));
  }
  if (five_g_pro_se_authorized_present) {
    HANDLE_CODE(five_g_pro_se_authorized.pack(bref));
  }
  if (five_g_pro_se_ue_pc5_aggr_max_bit_rate_present) {
    HANDLE_CODE(five_g_pro_se_ue_pc5_aggr_max_bit_rate.pack(bref));
  }
  if (five_g_pro_se_pc5_qos_params_present) {
    HANDLE_CODE(five_g_pro_se_pc5_qos_params.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE init_context_setup_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 6;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 48: {
        old_amf_present = true;
        old_amf.id      = id;
        HANDLE_CODE(old_amf.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(old_amf.value.unpack(bref));
        break;
      }
      case 110: {
        ue_aggr_max_bit_rate_present = true;
        ue_aggr_max_bit_rate.id      = id;
        HANDLE_CODE(ue_aggr_max_bit_rate.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_aggr_max_bit_rate.value.unpack(bref));
        break;
      }
      case 18: {
        core_network_assist_info_for_inactive_present = true;
        core_network_assist_info_for_inactive.id      = id;
        HANDLE_CODE(core_network_assist_info_for_inactive.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(core_network_assist_info_for_inactive.value.unpack(bref));
        break;
      }
      case 28: {
        nof_mandatory_ies--;
        guami.id = id;
        HANDLE_CODE(guami.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(guami.value.unpack(bref));
        break;
      }
      case 71: {
        pdu_session_res_setup_list_cxt_req_present = true;
        pdu_session_res_setup_list_cxt_req.id      = id;
        HANDLE_CODE(pdu_session_res_setup_list_cxt_req.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pdu_session_res_setup_list_cxt_req.value.unpack(bref));
        break;
      }
      case 0: {
        nof_mandatory_ies--;
        allowed_nssai.id = id;
        HANDLE_CODE(allowed_nssai.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(allowed_nssai.value.unpack(bref));
        break;
      }
      case 119: {
        nof_mandatory_ies--;
        ue_security_cap.id = id;
        HANDLE_CODE(ue_security_cap.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_security_cap.value.unpack(bref));
        break;
      }
      case 94: {
        nof_mandatory_ies--;
        security_key.id = id;
        HANDLE_CODE(security_key.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(security_key.value.unpack(bref));
        break;
      }
      case 108: {
        trace_activation_present = true;
        trace_activation.id      = id;
        HANDLE_CODE(trace_activation.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(trace_activation.value.unpack(bref));
        break;
      }
      case 36: {
        mob_restrict_list_present = true;
        mob_restrict_list.id      = id;
        HANDLE_CODE(mob_restrict_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mob_restrict_list.value.unpack(bref));
        break;
      }
      case 117: {
        ue_radio_cap_present = true;
        ue_radio_cap.id      = id;
        HANDLE_CODE(ue_radio_cap.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_radio_cap.value.unpack(bref));
        break;
      }
      case 31: {
        idx_to_rfsp_present = true;
        idx_to_rfsp.id      = id;
        HANDLE_CODE(idx_to_rfsp.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(idx_to_rfsp.value.unpack(bref));
        break;
      }
      case 34: {
        masked_imeisv_present = true;
        masked_imeisv.id      = id;
        HANDLE_CODE(masked_imeisv.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(masked_imeisv.value.unpack(bref));
        break;
      }
      case 38: {
        nas_pdu_present = true;
        nas_pdu.id      = id;
        HANDLE_CODE(nas_pdu.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nas_pdu.value.unpack(bref));
        break;
      }
      case 24: {
        emergency_fallback_ind_present = true;
        emergency_fallback_ind.id      = id;
        HANDLE_CODE(emergency_fallback_ind.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(emergency_fallback_ind.value.unpack(bref));
        break;
      }
      case 91: {
        rrc_inactive_transition_report_request_present = true;
        rrc_inactive_transition_report_request.id      = id;
        HANDLE_CODE(rrc_inactive_transition_report_request.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(rrc_inactive_transition_report_request.value.unpack(bref));
        break;
      }
      case 118: {
        ue_radio_cap_for_paging_present = true;
        ue_radio_cap_for_paging.id      = id;
        HANDLE_CODE(ue_radio_cap_for_paging.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_radio_cap_for_paging.value.unpack(bref));
        break;
      }
      case 146: {
        redirection_voice_fallback_present = true;
        redirection_voice_fallback.id      = id;
        HANDLE_CODE(redirection_voice_fallback.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(redirection_voice_fallback.value.unpack(bref));
        break;
      }
      case 33: {
        location_report_request_type_present = true;
        location_report_request_type.id      = id;
        HANDLE_CODE(location_report_request_type.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(location_report_request_type.value.unpack(bref));
        break;
      }
      case 165: {
        cn_assisted_ran_tuning_present = true;
        cn_assisted_ran_tuning.id      = id;
        HANDLE_CODE(cn_assisted_ran_tuning.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cn_assisted_ran_tuning.value.unpack(bref));
        break;
      }
      case 177: {
        srvcc_operation_possible_present = true;
        srvcc_operation_possible.id      = id;
        HANDLE_CODE(srvcc_operation_possible.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(srvcc_operation_possible.value.unpack(bref));
        break;
      }
      case 199: {
        iab_authorized_present = true;
        iab_authorized.id      = id;
        HANDLE_CODE(iab_authorized.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(iab_authorized.value.unpack(bref));
        break;
      }
      case 205: {
        enhanced_coverage_restrict_present = true;
        enhanced_coverage_restrict.id      = id;
        HANDLE_CODE(enhanced_coverage_restrict.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(enhanced_coverage_restrict.value.unpack(bref));
        break;
      }
      case 206: {
        extended_connected_time_present = true;
        extended_connected_time.id      = id;
        HANDLE_CODE(extended_connected_time.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(extended_connected_time.value.unpack(bref));
        break;
      }
      case 209: {
        ue_diff_info_present = true;
        ue_diff_info.id      = id;
        HANDLE_CODE(ue_diff_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_diff_info.value.unpack(bref));
        break;
      }
      case 216: {
        nr_v2x_services_authorized_present = true;
        nr_v2x_services_authorized.id      = id;
        HANDLE_CODE(nr_v2x_services_authorized.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nr_v2x_services_authorized.value.unpack(bref));
        break;
      }
      case 215: {
        ltev2x_services_authorized_present = true;
        ltev2x_services_authorized.id      = id;
        HANDLE_CODE(ltev2x_services_authorized.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ltev2x_services_authorized.value.unpack(bref));
        break;
      }
      case 218: {
        nr_ue_sidelink_aggr_max_bitrate_present = true;
        nr_ue_sidelink_aggr_max_bitrate.id      = id;
        HANDLE_CODE(nr_ue_sidelink_aggr_max_bitrate.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nr_ue_sidelink_aggr_max_bitrate.value.unpack(bref));
        break;
      }
      case 217: {
        lte_ue_sidelink_aggr_max_bitrate_present = true;
        lte_ue_sidelink_aggr_max_bitrate.id      = id;
        HANDLE_CODE(lte_ue_sidelink_aggr_max_bitrate.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(lte_ue_sidelink_aggr_max_bitrate.value.unpack(bref));
        break;
      }
      case 219: {
        pc5_qos_params_present = true;
        pc5_qos_params.id      = id;
        HANDLE_CODE(pc5_qos_params.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pc5_qos_params.value.unpack(bref));
        break;
      }
      case 222: {
        ce_mode_brestricted_present = true;
        ce_mode_brestricted.id      = id;
        HANDLE_CODE(ce_mode_brestricted.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ce_mode_brestricted.value.unpack(bref));
        break;
      }
      case 234: {
        ue_up_c_iot_support_present = true;
        ue_up_c_iot_support.id      = id;
        HANDLE_CODE(ue_up_c_iot_support.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_up_c_iot_support.value.unpack(bref));
        break;
      }
      case 238: {
        rg_level_wireline_access_characteristics_present = true;
        rg_level_wireline_access_characteristics.id      = id;
        HANDLE_CODE(rg_level_wireline_access_characteristics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(rg_level_wireline_access_characteristics.value.unpack(bref));
        break;
      }
      case 254: {
        management_based_mdt_plmn_list_present = true;
        management_based_mdt_plmn_list.id      = id;
        HANDLE_CODE(management_based_mdt_plmn_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(management_based_mdt_plmn_list.value.unpack(bref));
        break;
      }
      case 264: {
        ue_radio_cap_id_present = true;
        ue_radio_cap_id.id      = id;
        HANDLE_CODE(ue_radio_cap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_radio_cap_id.value.unpack(bref));
        break;
      }
      case 326: {
        time_sync_assist_info_present = true;
        time_sync_assist_info.id      = id;
        HANDLE_CODE(time_sync_assist_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(time_sync_assist_info.value.unpack(bref));
        break;
      }
      case 328: {
        q_mcc_onfig_info_present = true;
        q_mcc_onfig_info.id      = id;
        HANDLE_CODE(q_mcc_onfig_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(q_mcc_onfig_info.value.unpack(bref));
        break;
      }
      case 334: {
        target_nssai_info_present = true;
        target_nssai_info.id      = id;
        HANDLE_CODE(target_nssai_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(target_nssai_info.value.unpack(bref));
        break;
      }
      case 335: {
        ue_slice_max_bit_rate_list_present = true;
        ue_slice_max_bit_rate_list.id      = id;
        HANDLE_CODE(ue_slice_max_bit_rate_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_slice_max_bit_rate_list.value.unpack(bref));
        break;
      }
      case 345: {
        five_g_pro_se_authorized_present = true;
        five_g_pro_se_authorized.id      = id;
        HANDLE_CODE(five_g_pro_se_authorized.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(five_g_pro_se_authorized.value.unpack(bref));
        break;
      }
      case 346: {
        five_g_pro_se_ue_pc5_aggr_max_bit_rate_present = true;
        five_g_pro_se_ue_pc5_aggr_max_bit_rate.id      = id;
        HANDLE_CODE(five_g_pro_se_ue_pc5_aggr_max_bit_rate.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(five_g_pro_se_ue_pc5_aggr_max_bit_rate.value.unpack(bref));
        break;
      }
      case 347: {
        five_g_pro_se_pc5_qos_params_present = true;
        five_g_pro_se_pc5_qos_params.id      = id;
        HANDLE_CODE(five_g_pro_se_pc5_qos_params.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(five_g_pro_se_pc5_qos_params.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void init_context_setup_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  if (old_amf_present) {
    j.write_fieldname("");
    old_amf.to_json(j);
  }
  if (ue_aggr_max_bit_rate_present) {
    j.write_fieldname("");
    ue_aggr_max_bit_rate.to_json(j);
  }
  if (core_network_assist_info_for_inactive_present) {
    j.write_fieldname("");
    core_network_assist_info_for_inactive.to_json(j);
  }
  j.write_fieldname("");
  guami.to_json(j);
  if (pdu_session_res_setup_list_cxt_req_present) {
    j.write_fieldname("");
    pdu_session_res_setup_list_cxt_req.to_json(j);
  }
  j.write_fieldname("");
  allowed_nssai.to_json(j);
  j.write_fieldname("");
  ue_security_cap.to_json(j);
  j.write_fieldname("");
  security_key.to_json(j);
  if (trace_activation_present) {
    j.write_fieldname("");
    trace_activation.to_json(j);
  }
  if (mob_restrict_list_present) {
    j.write_fieldname("");
    mob_restrict_list.to_json(j);
  }
  if (ue_radio_cap_present) {
    j.write_fieldname("");
    ue_radio_cap.to_json(j);
  }
  if (idx_to_rfsp_present) {
    j.write_fieldname("");
    idx_to_rfsp.to_json(j);
  }
  if (masked_imeisv_present) {
    j.write_fieldname("");
    masked_imeisv.to_json(j);
  }
  if (nas_pdu_present) {
    j.write_fieldname("");
    nas_pdu.to_json(j);
  }
  if (emergency_fallback_ind_present) {
    j.write_fieldname("");
    emergency_fallback_ind.to_json(j);
  }
  if (rrc_inactive_transition_report_request_present) {
    j.write_fieldname("");
    rrc_inactive_transition_report_request.to_json(j);
  }
  if (ue_radio_cap_for_paging_present) {
    j.write_fieldname("");
    ue_radio_cap_for_paging.to_json(j);
  }
  if (redirection_voice_fallback_present) {
    j.write_fieldname("");
    redirection_voice_fallback.to_json(j);
  }
  if (location_report_request_type_present) {
    j.write_fieldname("");
    location_report_request_type.to_json(j);
  }
  if (cn_assisted_ran_tuning_present) {
    j.write_fieldname("");
    cn_assisted_ran_tuning.to_json(j);
  }
  if (srvcc_operation_possible_present) {
    j.write_fieldname("");
    srvcc_operation_possible.to_json(j);
  }
  if (iab_authorized_present) {
    j.write_fieldname("");
    iab_authorized.to_json(j);
  }
  if (enhanced_coverage_restrict_present) {
    j.write_fieldname("");
    enhanced_coverage_restrict.to_json(j);
  }
  if (extended_connected_time_present) {
    j.write_fieldname("");
    extended_connected_time.to_json(j);
  }
  if (ue_diff_info_present) {
    j.write_fieldname("");
    ue_diff_info.to_json(j);
  }
  if (nr_v2x_services_authorized_present) {
    j.write_fieldname("");
    nr_v2x_services_authorized.to_json(j);
  }
  if (ltev2x_services_authorized_present) {
    j.write_fieldname("");
    ltev2x_services_authorized.to_json(j);
  }
  if (nr_ue_sidelink_aggr_max_bitrate_present) {
    j.write_fieldname("");
    nr_ue_sidelink_aggr_max_bitrate.to_json(j);
  }
  if (lte_ue_sidelink_aggr_max_bitrate_present) {
    j.write_fieldname("");
    lte_ue_sidelink_aggr_max_bitrate.to_json(j);
  }
  if (pc5_qos_params_present) {
    j.write_fieldname("");
    pc5_qos_params.to_json(j);
  }
  if (ce_mode_brestricted_present) {
    j.write_fieldname("");
    ce_mode_brestricted.to_json(j);
  }
  if (ue_up_c_iot_support_present) {
    j.write_fieldname("");
    ue_up_c_iot_support.to_json(j);
  }
  if (rg_level_wireline_access_characteristics_present) {
    j.write_fieldname("");
    rg_level_wireline_access_characteristics.to_json(j);
  }
  if (management_based_mdt_plmn_list_present) {
    j.write_fieldname("");
    management_based_mdt_plmn_list.to_json(j);
  }
  if (ue_radio_cap_id_present) {
    j.write_fieldname("");
    ue_radio_cap_id.to_json(j);
  }
  if (time_sync_assist_info_present) {
    j.write_fieldname("");
    time_sync_assist_info.to_json(j);
  }
  if (q_mcc_onfig_info_present) {
    j.write_fieldname("");
    q_mcc_onfig_info.to_json(j);
  }
  if (target_nssai_info_present) {
    j.write_fieldname("");
    target_nssai_info.to_json(j);
  }
  if (ue_slice_max_bit_rate_list_present) {
    j.write_fieldname("");
    ue_slice_max_bit_rate_list.to_json(j);
  }
  if (five_g_pro_se_authorized_present) {
    j.write_fieldname("");
    five_g_pro_se_authorized.to_json(j);
  }
  if (five_g_pro_se_ue_pc5_aggr_max_bit_rate_present) {
    j.write_fieldname("");
    five_g_pro_se_ue_pc5_aggr_max_bit_rate.to_json(j);
  }
  if (five_g_pro_se_pc5_qos_params_present) {
    j.write_fieldname("");
    five_g_pro_se_pc5_qos_params.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceFailedToSetupItemCxtRes ::= SEQUENCE
SRSASN_CODE pdu_session_res_failed_to_setup_item_cxt_res_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pdu_session_id, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(pdu_session_res_setup_unsuccessful_transfer.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_failed_to_setup_item_cxt_res_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pdu_session_id, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(pdu_session_res_setup_unsuccessful_transfer.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_failed_to_setup_item_cxt_res_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pDUSessionID", pdu_session_id);
  j.write_str("pDUSessionResourceSetupUnsuccessfulTransfer", pdu_session_res_setup_unsuccessful_transfer.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceSetupItemCxtRes ::= SEQUENCE
SRSASN_CODE pdu_session_res_setup_item_cxt_res_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pdu_session_id, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(pdu_session_res_setup_resp_transfer.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_setup_item_cxt_res_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pdu_session_id, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(pdu_session_res_setup_resp_transfer.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_setup_item_cxt_res_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pDUSessionID", pdu_session_id);
  j.write_str("pDUSessionResourceSetupResponseTransfer", pdu_session_res_setup_resp_transfer.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// InitialContextSetupResponseIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t init_context_setup_resp_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 72, 55, 19};
  return map_enum_number(names, 5, idx, "id");
}
bool init_context_setup_resp_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 72, 55, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e init_context_setup_resp_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::ignore;
    case 85:
      return crit_e::ignore;
    case 72:
      return crit_e::ignore;
    case 55:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
init_context_setup_resp_ies_o::value_c init_context_setup_resp_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 72:
      ret.set(value_c::types::pdu_session_res_setup_list_cxt_res);
      break;
    case 55:
      ret.set(value_c::types::pdu_session_res_failed_to_setup_list_cxt_res);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e init_context_setup_resp_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 72:
      return presence_e::optional;
    case 55:
      return presence_e::optional;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void init_context_setup_resp_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::pdu_session_res_setup_list_cxt_res:
      c.destroy<pdu_session_res_setup_list_cxt_res_l>();
      break;
    case types::pdu_session_res_failed_to_setup_list_cxt_res:
      c.destroy<pdu_session_res_failed_to_setup_list_cxt_res_l>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void init_context_setup_resp_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::pdu_session_res_setup_list_cxt_res:
      c.init<pdu_session_res_setup_list_cxt_res_l>();
      break;
    case types::pdu_session_res_failed_to_setup_list_cxt_res:
      c.init<pdu_session_res_failed_to_setup_list_cxt_res_l>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "init_context_setup_resp_ies_o::value_c");
  }
}
init_context_setup_resp_ies_o::value_c::value_c(const init_context_setup_resp_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::pdu_session_res_setup_list_cxt_res:
      c.init(other.c.get<pdu_session_res_setup_list_cxt_res_l>());
      break;
    case types::pdu_session_res_failed_to_setup_list_cxt_res:
      c.init(other.c.get<pdu_session_res_failed_to_setup_list_cxt_res_l>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "init_context_setup_resp_ies_o::value_c");
  }
}
init_context_setup_resp_ies_o::value_c&
init_context_setup_resp_ies_o::value_c::operator=(const init_context_setup_resp_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::pdu_session_res_setup_list_cxt_res:
      c.set(other.c.get<pdu_session_res_setup_list_cxt_res_l>());
      break;
    case types::pdu_session_res_failed_to_setup_list_cxt_res:
      c.set(other.c.get<pdu_session_res_failed_to_setup_list_cxt_res_l>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "init_context_setup_resp_ies_o::value_c");
  }

  return *this;
}
uint64_t& init_context_setup_resp_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& init_context_setup_resp_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
pdu_session_res_setup_list_cxt_res_l& init_context_setup_resp_ies_o::value_c::pdu_session_res_setup_list_cxt_res()
{
  assert_choice_type(types::pdu_session_res_setup_list_cxt_res, type_, "Value");
  return c.get<pdu_session_res_setup_list_cxt_res_l>();
}
pdu_session_res_failed_to_setup_list_cxt_res_l&
init_context_setup_resp_ies_o::value_c::pdu_session_res_failed_to_setup_list_cxt_res()
{
  assert_choice_type(types::pdu_session_res_failed_to_setup_list_cxt_res, type_, "Value");
  return c.get<pdu_session_res_failed_to_setup_list_cxt_res_l>();
}
crit_diagnostics_s& init_context_setup_resp_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const uint64_t& init_context_setup_resp_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& init_context_setup_resp_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const pdu_session_res_setup_list_cxt_res_l&
init_context_setup_resp_ies_o::value_c::pdu_session_res_setup_list_cxt_res() const
{
  assert_choice_type(types::pdu_session_res_setup_list_cxt_res, type_, "Value");
  return c.get<pdu_session_res_setup_list_cxt_res_l>();
}
const pdu_session_res_failed_to_setup_list_cxt_res_l&
init_context_setup_resp_ies_o::value_c::pdu_session_res_failed_to_setup_list_cxt_res() const
{
  assert_choice_type(types::pdu_session_res_failed_to_setup_list_cxt_res, type_, "Value");
  return c.get<pdu_session_res_failed_to_setup_list_cxt_res_l>();
}
const crit_diagnostics_s& init_context_setup_resp_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void init_context_setup_resp_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::pdu_session_res_setup_list_cxt_res:
      j.start_array("PDUSessionResourceSetupListCxtRes");
      for (const auto& e1 : c.get<pdu_session_res_setup_list_cxt_res_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::pdu_session_res_failed_to_setup_list_cxt_res:
      j.start_array("PDUSessionResourceFailedToSetupListCxtRes");
      for (const auto& e1 : c.get<pdu_session_res_failed_to_setup_list_cxt_res_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "init_context_setup_resp_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE init_context_setup_resp_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_setup_list_cxt_res:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_setup_list_cxt_res_l>(), 1, 256, true));
      break;
    case types::pdu_session_res_failed_to_setup_list_cxt_res:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_failed_to_setup_list_cxt_res_l>(), 1, 256, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "init_context_setup_resp_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE init_context_setup_resp_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_setup_list_cxt_res:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_setup_list_cxt_res_l>(), bref, 1, 256, true));
      break;
    case types::pdu_session_res_failed_to_setup_list_cxt_res:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_failed_to_setup_list_cxt_res_l>(), bref, 1, 256, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "init_context_setup_resp_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* init_context_setup_resp_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..1099511627775)",
                                "INTEGER (0..4294967295)",
                                "PDUSessionResourceSetupListCxtRes",
                                "PDUSessionResourceFailedToSetupListCxtRes",
                                "CriticalityDiagnostics"};
  return convert_enum_idx(names, 5, value, "init_context_setup_resp_ies_o::value_c::types");
}

template struct asn1::protocol_ie_field_s<init_context_setup_resp_ies_o>;

init_context_setup_resp_ies_container::init_context_setup_resp_ies_container() :
  amf_ue_ngap_id(10, crit_e::ignore),
  ran_ue_ngap_id(85, crit_e::ignore),
  pdu_session_res_setup_list_cxt_res(72, crit_e::ignore),
  pdu_session_res_failed_to_setup_list_cxt_res(55, crit_e::ignore),
  crit_diagnostics(19, crit_e::ignore)
{
}
SRSASN_CODE init_context_setup_resp_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += pdu_session_res_setup_list_cxt_res_present ? 1 : 0;
  nof_ies += pdu_session_res_failed_to_setup_list_cxt_res_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  if (pdu_session_res_setup_list_cxt_res_present) {
    HANDLE_CODE(pdu_session_res_setup_list_cxt_res.pack(bref));
  }
  if (pdu_session_res_failed_to_setup_list_cxt_res_present) {
    HANDLE_CODE(pdu_session_res_failed_to_setup_list_cxt_res.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE init_context_setup_resp_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 72: {
        pdu_session_res_setup_list_cxt_res_present = true;
        pdu_session_res_setup_list_cxt_res.id      = id;
        HANDLE_CODE(pdu_session_res_setup_list_cxt_res.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pdu_session_res_setup_list_cxt_res.value.unpack(bref));
        break;
      }
      case 55: {
        pdu_session_res_failed_to_setup_list_cxt_res_present = true;
        pdu_session_res_failed_to_setup_list_cxt_res.id      = id;
        HANDLE_CODE(pdu_session_res_failed_to_setup_list_cxt_res.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pdu_session_res_failed_to_setup_list_cxt_res.value.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        crit_diagnostics.id      = id;
        HANDLE_CODE(crit_diagnostics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void init_context_setup_resp_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  if (pdu_session_res_setup_list_cxt_res_present) {
    j.write_fieldname("");
    pdu_session_res_setup_list_cxt_res.to_json(j);
  }
  if (pdu_session_res_failed_to_setup_list_cxt_res_present) {
    j.write_fieldname("");
    pdu_session_res_failed_to_setup_list_cxt_res.to_json(j);
  }
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

// AuthenticatedIndication ::= ENUMERATED
const char* authenticated_ind_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "authenticated_ind_e");
}

// CEmodeBSupport-Indicator ::= ENUMERATED
const char* ce_mode_b_support_ind_opts::to_string() const
{
  static const char* names[] = {"supported"};
  return convert_enum_idx(names, 1, value, "ce_mode_b_support_ind_e");
}

// EDT-Session ::= ENUMERATED
const char* edt_session_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "edt_session_e");
}

// IABNodeIndication ::= ENUMERATED
const char* iab_node_ind_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "iab_node_ind_e");
}

// LTEM-Indication ::= ENUMERATED
const char* ltem_ind_opts::to_string() const
{
  static const char* names[] = {"lte-m"};
  return convert_enum_idx(names, 1, value, "ltem_ind_e");
}

// RRCEstablishmentCause ::= ENUMERATED
const char* rrc_establishment_cause_opts::to_string() const
{
  static const char* names[] = {"emergency",
                                "highPriorityAccess",
                                "mt-Access",
                                "mo-Signalling",
                                "mo-Data",
                                "mo-VoiceCall",
                                "mo-VideoCall",
                                "mo-SMS",
                                "mps-PriorityAccess",
                                "mcs-PriorityAccess",
                                "notAvailable",
                                "mo-ExceptionData"};
  return convert_enum_idx(names, 12, value, "rrc_establishment_cause_e");
}

// SourceToTarget-AMFInformationReroute ::= SEQUENCE
SRSASN_CODE source_to_target_amf_info_reroute_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(cfg_nssai_present, 1));
  HANDLE_CODE(bref.pack(rejected_nssai_in_plmn_present, 1));
  HANDLE_CODE(bref.pack(rejected_nssai_in_ta_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (cfg_nssai_present) {
    HANDLE_CODE(cfg_nssai.pack(bref));
  }
  if (rejected_nssai_in_plmn_present) {
    HANDLE_CODE(rejected_nssai_in_plmn.pack(bref));
  }
  if (rejected_nssai_in_ta_present) {
    HANDLE_CODE(rejected_nssai_in_ta.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE source_to_target_amf_info_reroute_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(cfg_nssai_present, 1));
  HANDLE_CODE(bref.unpack(rejected_nssai_in_plmn_present, 1));
  HANDLE_CODE(bref.unpack(rejected_nssai_in_ta_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (cfg_nssai_present) {
    HANDLE_CODE(cfg_nssai.unpack(bref));
  }
  if (rejected_nssai_in_plmn_present) {
    HANDLE_CODE(rejected_nssai_in_plmn.unpack(bref));
  }
  if (rejected_nssai_in_ta_present) {
    HANDLE_CODE(rejected_nssai_in_ta.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void source_to_target_amf_info_reroute_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (cfg_nssai_present) {
    j.write_str("configuredNSSAI", cfg_nssai.to_string());
  }
  if (rejected_nssai_in_plmn_present) {
    j.write_str("rejectedNSSAIinPLMN", rejected_nssai_in_plmn.to_string());
  }
  if (rejected_nssai_in_ta_present) {
    j.write_str("rejectedNSSAIinTA", rejected_nssai_in_ta.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// UEContextRequest ::= ENUMERATED
const char* ue_context_request_opts::to_string() const
{
  static const char* names[] = {"requested"};
  return convert_enum_idx(names, 1, value, "ue_context_request_e");
}

// InitialUEMessage-IEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t init_ue_msg_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {85, 38, 121, 90, 26, 3, 112, 0, 171, 174, 201, 224, 225, 227, 245, 259, 333};
  return map_enum_number(names, 17, idx, "id");
}
bool init_ue_msg_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {85, 38, 121, 90, 26, 3, 112, 0, 171, 174, 201, 224, 225, 227, 245, 259, 333};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e init_ue_msg_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 85:
      return crit_e::reject;
    case 38:
      return crit_e::reject;
    case 121:
      return crit_e::reject;
    case 90:
      return crit_e::ignore;
    case 26:
      return crit_e::reject;
    case 3:
      return crit_e::ignore;
    case 112:
      return crit_e::ignore;
    case 0:
      return crit_e::reject;
    case 171:
      return crit_e::ignore;
    case 174:
      return crit_e::ignore;
    case 201:
      return crit_e::reject;
    case 224:
      return crit_e::reject;
    case 225:
      return crit_e::ignore;
    case 227:
      return crit_e::ignore;
    case 245:
      return crit_e::ignore;
    case 259:
      return crit_e::reject;
    case 333:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
init_ue_msg_ies_o::value_c init_ue_msg_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 38:
      ret.set(value_c::types::nas_pdu);
      break;
    case 121:
      ret.set(value_c::types::user_location_info);
      break;
    case 90:
      ret.set(value_c::types::rrc_establishment_cause);
      break;
    case 26:
      ret.set(value_c::types::five_g_s_tmsi);
      break;
    case 3:
      ret.set(value_c::types::amf_set_id);
      break;
    case 112:
      ret.set(value_c::types::ue_context_request);
      break;
    case 0:
      ret.set(value_c::types::allowed_nssai);
      break;
    case 171:
      ret.set(value_c::types::source_to_target_amf_info_reroute);
      break;
    case 174:
      ret.set(value_c::types::sel_plmn_id);
      break;
    case 201:
      ret.set(value_c::types::iab_node_ind);
      break;
    case 224:
      ret.set(value_c::types::ce_mode_b_support_ind);
      break;
    case 225:
      ret.set(value_c::types::ltem_ind);
      break;
    case 227:
      ret.set(value_c::types::edt_session);
      break;
    case 245:
      ret.set(value_c::types::authenticated_ind);
      break;
    case 259:
      ret.set(value_c::types::npn_access_info);
      break;
    case 333:
      ret.set(value_c::types::red_cap_ind);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e init_ue_msg_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 85:
      return presence_e::mandatory;
    case 38:
      return presence_e::mandatory;
    case 121:
      return presence_e::mandatory;
    case 90:
      return presence_e::mandatory;
    case 26:
      return presence_e::optional;
    case 3:
      return presence_e::optional;
    case 112:
      return presence_e::optional;
    case 0:
      return presence_e::optional;
    case 171:
      return presence_e::optional;
    case 174:
      return presence_e::optional;
    case 201:
      return presence_e::optional;
    case 224:
      return presence_e::optional;
    case 225:
      return presence_e::optional;
    case 227:
      return presence_e::optional;
    case 245:
      return presence_e::optional;
    case 259:
      return presence_e::optional;
    case 333:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void init_ue_msg_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::nas_pdu:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::user_location_info:
      c.destroy<user_location_info_c>();
      break;
    case types::five_g_s_tmsi:
      c.destroy<five_g_s_tmsi_s>();
      break;
    case types::amf_set_id:
      c.destroy<fixed_bitstring<10, false, true>>();
      break;
    case types::allowed_nssai:
      c.destroy<allowed_nssai_l>();
      break;
    case types::source_to_target_amf_info_reroute:
      c.destroy<source_to_target_amf_info_reroute_s>();
      break;
    case types::sel_plmn_id:
      c.destroy<fixed_octstring<3, true>>();
      break;
    case types::npn_access_info:
      c.destroy<npn_access_info_c>();
      break;
    default:
      break;
  }
}
void init_ue_msg_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::ran_ue_ngap_id:
      break;
    case types::nas_pdu:
      c.init<unbounded_octstring<true>>();
      break;
    case types::user_location_info:
      c.init<user_location_info_c>();
      break;
    case types::rrc_establishment_cause:
      break;
    case types::five_g_s_tmsi:
      c.init<five_g_s_tmsi_s>();
      break;
    case types::amf_set_id:
      c.init<fixed_bitstring<10, false, true>>();
      break;
    case types::ue_context_request:
      break;
    case types::allowed_nssai:
      c.init<allowed_nssai_l>();
      break;
    case types::source_to_target_amf_info_reroute:
      c.init<source_to_target_amf_info_reroute_s>();
      break;
    case types::sel_plmn_id:
      c.init<fixed_octstring<3, true>>();
      break;
    case types::iab_node_ind:
      break;
    case types::ce_mode_b_support_ind:
      break;
    case types::ltem_ind:
      break;
    case types::edt_session:
      break;
    case types::authenticated_ind:
      break;
    case types::npn_access_info:
      c.init<npn_access_info_c>();
      break;
    case types::red_cap_ind:
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "init_ue_msg_ies_o::value_c");
  }
}
init_ue_msg_ies_o::value_c::value_c(const init_ue_msg_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::nas_pdu:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::user_location_info:
      c.init(other.c.get<user_location_info_c>());
      break;
    case types::rrc_establishment_cause:
      c.init(other.c.get<rrc_establishment_cause_e>());
      break;
    case types::five_g_s_tmsi:
      c.init(other.c.get<five_g_s_tmsi_s>());
      break;
    case types::amf_set_id:
      c.init(other.c.get<fixed_bitstring<10, false, true>>());
      break;
    case types::ue_context_request:
      c.init(other.c.get<ue_context_request_e>());
      break;
    case types::allowed_nssai:
      c.init(other.c.get<allowed_nssai_l>());
      break;
    case types::source_to_target_amf_info_reroute:
      c.init(other.c.get<source_to_target_amf_info_reroute_s>());
      break;
    case types::sel_plmn_id:
      c.init(other.c.get<fixed_octstring<3, true>>());
      break;
    case types::iab_node_ind:
      c.init(other.c.get<iab_node_ind_e>());
      break;
    case types::ce_mode_b_support_ind:
      c.init(other.c.get<ce_mode_b_support_ind_e>());
      break;
    case types::ltem_ind:
      c.init(other.c.get<ltem_ind_e>());
      break;
    case types::edt_session:
      c.init(other.c.get<edt_session_e>());
      break;
    case types::authenticated_ind:
      c.init(other.c.get<authenticated_ind_e>());
      break;
    case types::npn_access_info:
      c.init(other.c.get<npn_access_info_c>());
      break;
    case types::red_cap_ind:
      c.init(other.c.get<red_cap_ind_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "init_ue_msg_ies_o::value_c");
  }
}
init_ue_msg_ies_o::value_c& init_ue_msg_ies_o::value_c::operator=(const init_ue_msg_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::nas_pdu:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::user_location_info:
      c.set(other.c.get<user_location_info_c>());
      break;
    case types::rrc_establishment_cause:
      c.set(other.c.get<rrc_establishment_cause_e>());
      break;
    case types::five_g_s_tmsi:
      c.set(other.c.get<five_g_s_tmsi_s>());
      break;
    case types::amf_set_id:
      c.set(other.c.get<fixed_bitstring<10, false, true>>());
      break;
    case types::ue_context_request:
      c.set(other.c.get<ue_context_request_e>());
      break;
    case types::allowed_nssai:
      c.set(other.c.get<allowed_nssai_l>());
      break;
    case types::source_to_target_amf_info_reroute:
      c.set(other.c.get<source_to_target_amf_info_reroute_s>());
      break;
    case types::sel_plmn_id:
      c.set(other.c.get<fixed_octstring<3, true>>());
      break;
    case types::iab_node_ind:
      c.set(other.c.get<iab_node_ind_e>());
      break;
    case types::ce_mode_b_support_ind:
      c.set(other.c.get<ce_mode_b_support_ind_e>());
      break;
    case types::ltem_ind:
      c.set(other.c.get<ltem_ind_e>());
      break;
    case types::edt_session:
      c.set(other.c.get<edt_session_e>());
      break;
    case types::authenticated_ind:
      c.set(other.c.get<authenticated_ind_e>());
      break;
    case types::npn_access_info:
      c.set(other.c.get<npn_access_info_c>());
      break;
    case types::red_cap_ind:
      c.set(other.c.get<red_cap_ind_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "init_ue_msg_ies_o::value_c");
  }

  return *this;
}
uint64_t& init_ue_msg_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
unbounded_octstring<true>& init_ue_msg_ies_o::value_c::nas_pdu()
{
  assert_choice_type(types::nas_pdu, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
user_location_info_c& init_ue_msg_ies_o::value_c::user_location_info()
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
rrc_establishment_cause_e& init_ue_msg_ies_o::value_c::rrc_establishment_cause()
{
  assert_choice_type(types::rrc_establishment_cause, type_, "Value");
  return c.get<rrc_establishment_cause_e>();
}
five_g_s_tmsi_s& init_ue_msg_ies_o::value_c::five_g_s_tmsi()
{
  assert_choice_type(types::five_g_s_tmsi, type_, "Value");
  return c.get<five_g_s_tmsi_s>();
}
fixed_bitstring<10, false, true>& init_ue_msg_ies_o::value_c::amf_set_id()
{
  assert_choice_type(types::amf_set_id, type_, "Value");
  return c.get<fixed_bitstring<10, false, true>>();
}
ue_context_request_e& init_ue_msg_ies_o::value_c::ue_context_request()
{
  assert_choice_type(types::ue_context_request, type_, "Value");
  return c.get<ue_context_request_e>();
}
allowed_nssai_l& init_ue_msg_ies_o::value_c::allowed_nssai()
{
  assert_choice_type(types::allowed_nssai, type_, "Value");
  return c.get<allowed_nssai_l>();
}
source_to_target_amf_info_reroute_s& init_ue_msg_ies_o::value_c::source_to_target_amf_info_reroute()
{
  assert_choice_type(types::source_to_target_amf_info_reroute, type_, "Value");
  return c.get<source_to_target_amf_info_reroute_s>();
}
fixed_octstring<3, true>& init_ue_msg_ies_o::value_c::sel_plmn_id()
{
  assert_choice_type(types::sel_plmn_id, type_, "Value");
  return c.get<fixed_octstring<3, true>>();
}
iab_node_ind_e& init_ue_msg_ies_o::value_c::iab_node_ind()
{
  assert_choice_type(types::iab_node_ind, type_, "Value");
  return c.get<iab_node_ind_e>();
}
ce_mode_b_support_ind_e& init_ue_msg_ies_o::value_c::ce_mode_b_support_ind()
{
  assert_choice_type(types::ce_mode_b_support_ind, type_, "Value");
  return c.get<ce_mode_b_support_ind_e>();
}
ltem_ind_e& init_ue_msg_ies_o::value_c::ltem_ind()
{
  assert_choice_type(types::ltem_ind, type_, "Value");
  return c.get<ltem_ind_e>();
}
edt_session_e& init_ue_msg_ies_o::value_c::edt_session()
{
  assert_choice_type(types::edt_session, type_, "Value");
  return c.get<edt_session_e>();
}
authenticated_ind_e& init_ue_msg_ies_o::value_c::authenticated_ind()
{
  assert_choice_type(types::authenticated_ind, type_, "Value");
  return c.get<authenticated_ind_e>();
}
npn_access_info_c& init_ue_msg_ies_o::value_c::npn_access_info()
{
  assert_choice_type(types::npn_access_info, type_, "Value");
  return c.get<npn_access_info_c>();
}
red_cap_ind_e& init_ue_msg_ies_o::value_c::red_cap_ind()
{
  assert_choice_type(types::red_cap_ind, type_, "Value");
  return c.get<red_cap_ind_e>();
}
const uint64_t& init_ue_msg_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const unbounded_octstring<true>& init_ue_msg_ies_o::value_c::nas_pdu() const
{
  assert_choice_type(types::nas_pdu, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const user_location_info_c& init_ue_msg_ies_o::value_c::user_location_info() const
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
const rrc_establishment_cause_e& init_ue_msg_ies_o::value_c::rrc_establishment_cause() const
{
  assert_choice_type(types::rrc_establishment_cause, type_, "Value");
  return c.get<rrc_establishment_cause_e>();
}
const five_g_s_tmsi_s& init_ue_msg_ies_o::value_c::five_g_s_tmsi() const
{
  assert_choice_type(types::five_g_s_tmsi, type_, "Value");
  return c.get<five_g_s_tmsi_s>();
}
const fixed_bitstring<10, false, true>& init_ue_msg_ies_o::value_c::amf_set_id() const
{
  assert_choice_type(types::amf_set_id, type_, "Value");
  return c.get<fixed_bitstring<10, false, true>>();
}
const ue_context_request_e& init_ue_msg_ies_o::value_c::ue_context_request() const
{
  assert_choice_type(types::ue_context_request, type_, "Value");
  return c.get<ue_context_request_e>();
}
const allowed_nssai_l& init_ue_msg_ies_o::value_c::allowed_nssai() const
{
  assert_choice_type(types::allowed_nssai, type_, "Value");
  return c.get<allowed_nssai_l>();
}
const source_to_target_amf_info_reroute_s& init_ue_msg_ies_o::value_c::source_to_target_amf_info_reroute() const
{
  assert_choice_type(types::source_to_target_amf_info_reroute, type_, "Value");
  return c.get<source_to_target_amf_info_reroute_s>();
}
const fixed_octstring<3, true>& init_ue_msg_ies_o::value_c::sel_plmn_id() const
{
  assert_choice_type(types::sel_plmn_id, type_, "Value");
  return c.get<fixed_octstring<3, true>>();
}
const iab_node_ind_e& init_ue_msg_ies_o::value_c::iab_node_ind() const
{
  assert_choice_type(types::iab_node_ind, type_, "Value");
  return c.get<iab_node_ind_e>();
}
const ce_mode_b_support_ind_e& init_ue_msg_ies_o::value_c::ce_mode_b_support_ind() const
{
  assert_choice_type(types::ce_mode_b_support_ind, type_, "Value");
  return c.get<ce_mode_b_support_ind_e>();
}
const ltem_ind_e& init_ue_msg_ies_o::value_c::ltem_ind() const
{
  assert_choice_type(types::ltem_ind, type_, "Value");
  return c.get<ltem_ind_e>();
}
const edt_session_e& init_ue_msg_ies_o::value_c::edt_session() const
{
  assert_choice_type(types::edt_session, type_, "Value");
  return c.get<edt_session_e>();
}
const authenticated_ind_e& init_ue_msg_ies_o::value_c::authenticated_ind() const
{
  assert_choice_type(types::authenticated_ind, type_, "Value");
  return c.get<authenticated_ind_e>();
}
const npn_access_info_c& init_ue_msg_ies_o::value_c::npn_access_info() const
{
  assert_choice_type(types::npn_access_info, type_, "Value");
  return c.get<npn_access_info_c>();
}
const red_cap_ind_e& init_ue_msg_ies_o::value_c::red_cap_ind() const
{
  assert_choice_type(types::red_cap_ind, type_, "Value");
  return c.get<red_cap_ind_e>();
}
void init_ue_msg_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::nas_pdu:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::user_location_info:
      j.write_fieldname("UserLocationInformation");
      c.get<user_location_info_c>().to_json(j);
      break;
    case types::rrc_establishment_cause:
      j.write_str("RRCEstablishmentCause", c.get<rrc_establishment_cause_e>().to_string());
      break;
    case types::five_g_s_tmsi:
      j.write_fieldname("FiveG-S-TMSI");
      c.get<five_g_s_tmsi_s>().to_json(j);
      break;
    case types::amf_set_id:
      j.write_str("BIT STRING", c.get<fixed_bitstring<10, false, true>>().to_string());
      break;
    case types::ue_context_request:
      j.write_str("UEContextRequest", "requested");
      break;
    case types::allowed_nssai:
      j.start_array("AllowedNSSAI");
      for (const auto& e1 : c.get<allowed_nssai_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::source_to_target_amf_info_reroute:
      j.write_fieldname("SourceToTarget-AMFInformationReroute");
      c.get<source_to_target_amf_info_reroute_s>().to_json(j);
      break;
    case types::sel_plmn_id:
      j.write_str("OCTET STRING", c.get<fixed_octstring<3, true>>().to_string());
      break;
    case types::iab_node_ind:
      j.write_str("IABNodeIndication", "true");
      break;
    case types::ce_mode_b_support_ind:
      j.write_str("CEmodeBSupport-Indicator", "supported");
      break;
    case types::ltem_ind:
      j.write_str("LTEM-Indication", "lte-m");
      break;
    case types::edt_session:
      j.write_str("EDT-Session", "true");
      break;
    case types::authenticated_ind:
      j.write_str("AuthenticatedIndication", "true");
      break;
    case types::npn_access_info:
      j.write_fieldname("NPN-AccessInformation");
      c.get<npn_access_info_c>().to_json(j);
      break;
    case types::red_cap_ind:
      j.write_str("RedCapIndication", "redcap");
      break;
    default:
      log_invalid_choice_id(type_, "init_ue_msg_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE init_ue_msg_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::nas_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().pack(bref));
      break;
    case types::rrc_establishment_cause:
      HANDLE_CODE(c.get<rrc_establishment_cause_e>().pack(bref));
      break;
    case types::five_g_s_tmsi:
      HANDLE_CODE(c.get<five_g_s_tmsi_s>().pack(bref));
      break;
    case types::amf_set_id:
      HANDLE_CODE((c.get<fixed_bitstring<10, false, true>>().pack(bref)));
      break;
    case types::ue_context_request:
      HANDLE_CODE(c.get<ue_context_request_e>().pack(bref));
      break;
    case types::allowed_nssai:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<allowed_nssai_l>(), 1, 8, true));
      break;
    case types::source_to_target_amf_info_reroute:
      HANDLE_CODE(c.get<source_to_target_amf_info_reroute_s>().pack(bref));
      break;
    case types::sel_plmn_id:
      HANDLE_CODE((c.get<fixed_octstring<3, true>>().pack(bref)));
      break;
    case types::iab_node_ind:
      HANDLE_CODE(c.get<iab_node_ind_e>().pack(bref));
      break;
    case types::ce_mode_b_support_ind:
      HANDLE_CODE(c.get<ce_mode_b_support_ind_e>().pack(bref));
      break;
    case types::ltem_ind:
      HANDLE_CODE(c.get<ltem_ind_e>().pack(bref));
      break;
    case types::edt_session:
      HANDLE_CODE(c.get<edt_session_e>().pack(bref));
      break;
    case types::authenticated_ind:
      HANDLE_CODE(c.get<authenticated_ind_e>().pack(bref));
      break;
    case types::npn_access_info:
      HANDLE_CODE(c.get<npn_access_info_c>().pack(bref));
      break;
    case types::red_cap_ind:
      HANDLE_CODE(c.get<red_cap_ind_e>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "init_ue_msg_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE init_ue_msg_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::nas_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().unpack(bref));
      break;
    case types::rrc_establishment_cause:
      HANDLE_CODE(c.get<rrc_establishment_cause_e>().unpack(bref));
      break;
    case types::five_g_s_tmsi:
      HANDLE_CODE(c.get<five_g_s_tmsi_s>().unpack(bref));
      break;
    case types::amf_set_id:
      HANDLE_CODE((c.get<fixed_bitstring<10, false, true>>().unpack(bref)));
      break;
    case types::ue_context_request:
      HANDLE_CODE(c.get<ue_context_request_e>().unpack(bref));
      break;
    case types::allowed_nssai:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<allowed_nssai_l>(), bref, 1, 8, true));
      break;
    case types::source_to_target_amf_info_reroute:
      HANDLE_CODE(c.get<source_to_target_amf_info_reroute_s>().unpack(bref));
      break;
    case types::sel_plmn_id:
      HANDLE_CODE((c.get<fixed_octstring<3, true>>().unpack(bref)));
      break;
    case types::iab_node_ind:
      HANDLE_CODE(c.get<iab_node_ind_e>().unpack(bref));
      break;
    case types::ce_mode_b_support_ind:
      HANDLE_CODE(c.get<ce_mode_b_support_ind_e>().unpack(bref));
      break;
    case types::ltem_ind:
      HANDLE_CODE(c.get<ltem_ind_e>().unpack(bref));
      break;
    case types::edt_session:
      HANDLE_CODE(c.get<edt_session_e>().unpack(bref));
      break;
    case types::authenticated_ind:
      HANDLE_CODE(c.get<authenticated_ind_e>().unpack(bref));
      break;
    case types::npn_access_info:
      HANDLE_CODE(c.get<npn_access_info_c>().unpack(bref));
      break;
    case types::red_cap_ind:
      HANDLE_CODE(c.get<red_cap_ind_e>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "init_ue_msg_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* init_ue_msg_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..4294967295)",
                                "OCTET STRING",
                                "UserLocationInformation",
                                "RRCEstablishmentCause",
                                "FiveG-S-TMSI",
                                "BIT STRING",
                                "UEContextRequest",
                                "AllowedNSSAI",
                                "SourceToTarget-AMFInformationReroute",
                                "OCTET STRING",
                                "IABNodeIndication",
                                "CEmodeBSupport-Indicator",
                                "LTEM-Indication",
                                "EDT-Session",
                                "AuthenticatedIndication",
                                "NPN-AccessInformation",
                                "RedCapIndication"};
  return convert_enum_idx(names, 17, value, "init_ue_msg_ies_o::value_c::types");
}
uint8_t init_ue_msg_ies_o::value_c::types_opts::to_number() const
{
  static const uint8_t numbers[] = {0};
  return map_enum_number(numbers, 1, value, "init_ue_msg_ies_o::value_c::types");
}

template struct asn1::protocol_ie_field_s<init_ue_msg_ies_o>;

init_ue_msg_ies_container::init_ue_msg_ies_container() :
  ran_ue_ngap_id(85, crit_e::reject),
  nas_pdu(38, crit_e::reject),
  user_location_info(121, crit_e::reject),
  rrc_establishment_cause(90, crit_e::ignore),
  five_g_s_tmsi(26, crit_e::reject),
  amf_set_id(3, crit_e::ignore),
  ue_context_request(112, crit_e::ignore),
  allowed_nssai(0, crit_e::reject),
  source_to_target_amf_info_reroute(171, crit_e::ignore),
  sel_plmn_id(174, crit_e::ignore),
  iab_node_ind(201, crit_e::reject),
  ce_mode_b_support_ind(224, crit_e::reject),
  ltem_ind(225, crit_e::ignore),
  edt_session(227, crit_e::ignore),
  authenticated_ind(245, crit_e::ignore),
  npn_access_info(259, crit_e::reject),
  red_cap_ind(333, crit_e::ignore)
{
}
SRSASN_CODE init_ue_msg_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 4;
  nof_ies += five_g_s_tmsi_present ? 1 : 0;
  nof_ies += amf_set_id_present ? 1 : 0;
  nof_ies += ue_context_request_present ? 1 : 0;
  nof_ies += allowed_nssai_present ? 1 : 0;
  nof_ies += source_to_target_amf_info_reroute_present ? 1 : 0;
  nof_ies += sel_plmn_id_present ? 1 : 0;
  nof_ies += iab_node_ind_present ? 1 : 0;
  nof_ies += ce_mode_b_support_ind_present ? 1 : 0;
  nof_ies += ltem_ind_present ? 1 : 0;
  nof_ies += edt_session_present ? 1 : 0;
  nof_ies += authenticated_ind_present ? 1 : 0;
  nof_ies += npn_access_info_present ? 1 : 0;
  nof_ies += red_cap_ind_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  HANDLE_CODE(nas_pdu.pack(bref));
  HANDLE_CODE(user_location_info.pack(bref));
  HANDLE_CODE(rrc_establishment_cause.pack(bref));
  if (five_g_s_tmsi_present) {
    HANDLE_CODE(five_g_s_tmsi.pack(bref));
  }
  if (amf_set_id_present) {
    HANDLE_CODE(amf_set_id.pack(bref));
  }
  if (ue_context_request_present) {
    HANDLE_CODE(ue_context_request.pack(bref));
  }
  if (allowed_nssai_present) {
    HANDLE_CODE(allowed_nssai.pack(bref));
  }
  if (source_to_target_amf_info_reroute_present) {
    HANDLE_CODE(source_to_target_amf_info_reroute.pack(bref));
  }
  if (sel_plmn_id_present) {
    HANDLE_CODE(sel_plmn_id.pack(bref));
  }
  if (iab_node_ind_present) {
    HANDLE_CODE(iab_node_ind.pack(bref));
  }
  if (ce_mode_b_support_ind_present) {
    HANDLE_CODE(ce_mode_b_support_ind.pack(bref));
  }
  if (ltem_ind_present) {
    HANDLE_CODE(ltem_ind.pack(bref));
  }
  if (edt_session_present) {
    HANDLE_CODE(edt_session.pack(bref));
  }
  if (authenticated_ind_present) {
    HANDLE_CODE(authenticated_ind.pack(bref));
  }
  if (npn_access_info_present) {
    HANDLE_CODE(npn_access_info.pack(bref));
  }
  if (red_cap_ind_present) {
    HANDLE_CODE(red_cap_ind.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE init_ue_msg_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 4;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 38: {
        nof_mandatory_ies--;
        nas_pdu.id = id;
        HANDLE_CODE(nas_pdu.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nas_pdu.value.unpack(bref));
        break;
      }
      case 121: {
        nof_mandatory_ies--;
        user_location_info.id = id;
        HANDLE_CODE(user_location_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(user_location_info.value.unpack(bref));
        break;
      }
      case 90: {
        nof_mandatory_ies--;
        rrc_establishment_cause.id = id;
        HANDLE_CODE(rrc_establishment_cause.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(rrc_establishment_cause.value.unpack(bref));
        break;
      }
      case 26: {
        five_g_s_tmsi_present = true;
        five_g_s_tmsi.id      = id;
        HANDLE_CODE(five_g_s_tmsi.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(five_g_s_tmsi.value.unpack(bref));
        break;
      }
      case 3: {
        amf_set_id_present = true;
        amf_set_id.id      = id;
        HANDLE_CODE(amf_set_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_set_id.value.unpack(bref));
        break;
      }
      case 112: {
        ue_context_request_present = true;
        ue_context_request.id      = id;
        HANDLE_CODE(ue_context_request.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_context_request.value.unpack(bref));
        break;
      }
      case 0: {
        allowed_nssai_present = true;
        allowed_nssai.id      = id;
        HANDLE_CODE(allowed_nssai.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(allowed_nssai.value.unpack(bref));
        break;
      }
      case 171: {
        source_to_target_amf_info_reroute_present = true;
        source_to_target_amf_info_reroute.id      = id;
        HANDLE_CODE(source_to_target_amf_info_reroute.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(source_to_target_amf_info_reroute.value.unpack(bref));
        break;
      }
      case 174: {
        sel_plmn_id_present = true;
        sel_plmn_id.id      = id;
        HANDLE_CODE(sel_plmn_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(sel_plmn_id.value.unpack(bref));
        break;
      }
      case 201: {
        iab_node_ind_present = true;
        iab_node_ind.id      = id;
        HANDLE_CODE(iab_node_ind.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(iab_node_ind.value.unpack(bref));
        break;
      }
      case 224: {
        ce_mode_b_support_ind_present = true;
        ce_mode_b_support_ind.id      = id;
        HANDLE_CODE(ce_mode_b_support_ind.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ce_mode_b_support_ind.value.unpack(bref));
        break;
      }
      case 225: {
        ltem_ind_present = true;
        ltem_ind.id      = id;
        HANDLE_CODE(ltem_ind.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ltem_ind.value.unpack(bref));
        break;
      }
      case 227: {
        edt_session_present = true;
        edt_session.id      = id;
        HANDLE_CODE(edt_session.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(edt_session.value.unpack(bref));
        break;
      }
      case 245: {
        authenticated_ind_present = true;
        authenticated_ind.id      = id;
        HANDLE_CODE(authenticated_ind.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(authenticated_ind.value.unpack(bref));
        break;
      }
      case 259: {
        npn_access_info_present = true;
        npn_access_info.id      = id;
        HANDLE_CODE(npn_access_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(npn_access_info.value.unpack(bref));
        break;
      }
      case 333: {
        red_cap_ind_present = true;
        red_cap_ind.id      = id;
        HANDLE_CODE(red_cap_ind.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(red_cap_ind.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void init_ue_msg_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  nas_pdu.to_json(j);
  j.write_fieldname("");
  user_location_info.to_json(j);
  j.write_fieldname("");
  rrc_establishment_cause.to_json(j);
  if (five_g_s_tmsi_present) {
    j.write_fieldname("");
    five_g_s_tmsi.to_json(j);
  }
  if (amf_set_id_present) {
    j.write_fieldname("");
    amf_set_id.to_json(j);
  }
  if (ue_context_request_present) {
    j.write_fieldname("");
    ue_context_request.to_json(j);
  }
  if (allowed_nssai_present) {
    j.write_fieldname("");
    allowed_nssai.to_json(j);
  }
  if (source_to_target_amf_info_reroute_present) {
    j.write_fieldname("");
    source_to_target_amf_info_reroute.to_json(j);
  }
  if (sel_plmn_id_present) {
    j.write_fieldname("");
    sel_plmn_id.to_json(j);
  }
  if (iab_node_ind_present) {
    j.write_fieldname("");
    iab_node_ind.to_json(j);
  }
  if (ce_mode_b_support_ind_present) {
    j.write_fieldname("");
    ce_mode_b_support_ind.to_json(j);
  }
  if (ltem_ind_present) {
    j.write_fieldname("");
    ltem_ind.to_json(j);
  }
  if (edt_session_present) {
    j.write_fieldname("");
    edt_session.to_json(j);
  }
  if (authenticated_ind_present) {
    j.write_fieldname("");
    authenticated_ind.to_json(j);
  }
  if (npn_access_info_present) {
    j.write_fieldname("");
    npn_access_info.to_json(j);
  }
  if (red_cap_ind_present) {
    j.write_fieldname("");
    red_cap_ind.to_json(j);
  }
  j.end_obj();
}

// ConfiguredTACIndication ::= ENUMERATED
const char* cfg_tac_ind_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "cfg_tac_ind_e");
}

// OverloadAction ::= ENUMERATED
const char* overload_action_opts::to_string() const
{
  static const char* names[] = {"reject-non-emergency-mo-dt",
                                "reject-rrc-cr-signalling",
                                "permit-emergency-sessions-and-mobile-terminated-services-only",
                                "permit-high-priority-sessions-and-mobile-terminated-services-only"};
  return convert_enum_idx(names, 4, value, "overload_action_e");
}

// RAT-Information ::= ENUMERATED
const char* rat_info_opts::to_string() const
{
  static const char* names[] = {"unlicensed", "nb-IoT", "nR-LEO", "nR-MEO", "nR-GEO", "nR-OTHERSAT"};
  return convert_enum_idx(names, 6, value, "rat_info_e");
}

// SliceOverloadItem ::= SEQUENCE
SRSASN_CODE slice_overload_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(s_nssai.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE slice_overload_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(s_nssai.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void slice_overload_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("s-NSSAI");
  s_nssai.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// UE-PagingItem ::= SEQUENCE
SRSASN_CODE ue_paging_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(paging_drx_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(ue_id_idx_value.pack(bref));
  if (paging_drx_present) {
    HANDLE_CODE(paging_drx.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_paging_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(paging_drx_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(ue_id_idx_value.unpack(bref));
  if (paging_drx_present) {
    HANDLE_CODE(paging_drx.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ue_paging_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("uEIdentityIndexValue");
  ue_id_idx_value.to_json(j);
  if (paging_drx_present) {
    j.write_str("pagingDRX", paging_drx.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MulticastGroupPagingArea ::= SEQUENCE
SRSASN_CODE multicast_group_paging_area_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, mbs_area_tai_list, 1, 16, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_group_paging_area_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(mbs_area_tai_list, bref, 1, 16, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void multicast_group_paging_area_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("mBS-AreaTAIList");
  for (const auto& e1 : mbs_area_tai_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// OverloadResponse ::= CHOICE
void overload_resp_c::destroy_()
{
  switch (type_) {
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<overload_resp_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void overload_resp_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::overload_action:
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<overload_resp_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "overload_resp_c");
  }
}
overload_resp_c::overload_resp_c(const overload_resp_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::overload_action:
      c.init(other.c.get<overload_action_e>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<overload_resp_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "overload_resp_c");
  }
}
overload_resp_c& overload_resp_c::operator=(const overload_resp_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::overload_action:
      c.set(other.c.get<overload_action_e>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<overload_resp_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "overload_resp_c");
  }

  return *this;
}
overload_action_e& overload_resp_c::set_overload_action()
{
  set(types::overload_action);
  return c.get<overload_action_e>();
}
protocol_ie_single_container_s<overload_resp_ext_ies_o>& overload_resp_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<overload_resp_ext_ies_o>>();
}
void overload_resp_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::overload_action:
      j.write_str("overloadAction", c.get<overload_action_e>().to_string());
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<overload_resp_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "overload_resp_c");
  }
  j.end_obj();
}
SRSASN_CODE overload_resp_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::overload_action:
      HANDLE_CODE(c.get<overload_action_e>().pack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<overload_resp_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "overload_resp_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE overload_resp_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::overload_action:
      HANDLE_CODE(c.get<overload_action_e>().unpack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<overload_resp_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "overload_resp_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* overload_resp_c::types_opts::to_string() const
{
  static const char* names[] = {"overloadAction", "choice-Extensions"};
  return convert_enum_idx(names, 2, value, "overload_resp_c::types");
}

// PDUSessionResourceItemCxtRelCpl-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t pdu_session_res_item_cxt_rel_cpl_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {145};
  return map_enum_number(names, 1, idx, "id");
}
bool pdu_session_res_item_cxt_rel_cpl_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 145 == id;
}
crit_e pdu_session_res_item_cxt_rel_cpl_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 145) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
pdu_session_res_item_cxt_rel_cpl_ext_ies_o::ext_c
pdu_session_res_item_cxt_rel_cpl_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 145) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pdu_session_res_item_cxt_rel_cpl_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 145) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void pdu_session_res_item_cxt_rel_cpl_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("OCTET STRING", c.to_string());
  j.end_obj();
}
SRSASN_CODE pdu_session_res_item_cxt_rel_cpl_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_item_cxt_rel_cpl_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* pdu_session_res_item_cxt_rel_cpl_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"OCTET STRING"};
  return convert_enum_idx(names, 1, value, "pdu_session_res_item_cxt_rel_cpl_ext_ies_o::ext_c::types");
}

// PDUSessionResourceModifyItemModReq-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t pdu_session_res_modify_item_mod_req_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {148, 281};
  return map_enum_number(names, 2, idx, "id");
}
bool pdu_session_res_modify_item_mod_req_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {148, 281};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e pdu_session_res_modify_item_mod_req_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 148:
      return crit_e::reject;
    case 281:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
pdu_session_res_modify_item_mod_req_ext_ies_o::ext_c
pdu_session_res_modify_item_mod_req_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 148:
      ret.set(ext_c::types::s_nssai);
      break;
    case 281:
      ret.set(ext_c::types::pdu_session_expected_ue_activity_behaviour);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pdu_session_res_modify_item_mod_req_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 148:
      return presence_e::optional;
    case 281:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void pdu_session_res_modify_item_mod_req_ext_ies_o::ext_c::destroy_()
{
  switch (type_) {
    case types::s_nssai:
      c.destroy<s_nssai_s>();
      break;
    case types::pdu_session_expected_ue_activity_behaviour:
      c.destroy<expected_ue_activity_behaviour_s>();
      break;
    default:
      break;
  }
}
void pdu_session_res_modify_item_mod_req_ext_ies_o::ext_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::s_nssai:
      c.init<s_nssai_s>();
      break;
    case types::pdu_session_expected_ue_activity_behaviour:
      c.init<expected_ue_activity_behaviour_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_item_mod_req_ext_ies_o::ext_c");
  }
}
pdu_session_res_modify_item_mod_req_ext_ies_o::ext_c::ext_c(
    const pdu_session_res_modify_item_mod_req_ext_ies_o::ext_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::s_nssai:
      c.init(other.c.get<s_nssai_s>());
      break;
    case types::pdu_session_expected_ue_activity_behaviour:
      c.init(other.c.get<expected_ue_activity_behaviour_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_item_mod_req_ext_ies_o::ext_c");
  }
}
pdu_session_res_modify_item_mod_req_ext_ies_o::ext_c& pdu_session_res_modify_item_mod_req_ext_ies_o::ext_c::operator=(
    const pdu_session_res_modify_item_mod_req_ext_ies_o::ext_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::s_nssai:
      c.set(other.c.get<s_nssai_s>());
      break;
    case types::pdu_session_expected_ue_activity_behaviour:
      c.set(other.c.get<expected_ue_activity_behaviour_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_item_mod_req_ext_ies_o::ext_c");
  }

  return *this;
}
s_nssai_s& pdu_session_res_modify_item_mod_req_ext_ies_o::ext_c::s_nssai()
{
  assert_choice_type(types::s_nssai, type_, "Extension");
  return c.get<s_nssai_s>();
}
expected_ue_activity_behaviour_s&
pdu_session_res_modify_item_mod_req_ext_ies_o::ext_c::pdu_session_expected_ue_activity_behaviour()
{
  assert_choice_type(types::pdu_session_expected_ue_activity_behaviour, type_, "Extension");
  return c.get<expected_ue_activity_behaviour_s>();
}
const s_nssai_s& pdu_session_res_modify_item_mod_req_ext_ies_o::ext_c::s_nssai() const
{
  assert_choice_type(types::s_nssai, type_, "Extension");
  return c.get<s_nssai_s>();
}
const expected_ue_activity_behaviour_s&
pdu_session_res_modify_item_mod_req_ext_ies_o::ext_c::pdu_session_expected_ue_activity_behaviour() const
{
  assert_choice_type(types::pdu_session_expected_ue_activity_behaviour, type_, "Extension");
  return c.get<expected_ue_activity_behaviour_s>();
}
void pdu_session_res_modify_item_mod_req_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::s_nssai:
      j.write_fieldname("S-NSSAI");
      c.get<s_nssai_s>().to_json(j);
      break;
    case types::pdu_session_expected_ue_activity_behaviour:
      j.write_fieldname("ExpectedUEActivityBehaviour");
      c.get<expected_ue_activity_behaviour_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_item_mod_req_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE pdu_session_res_modify_item_mod_req_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::s_nssai:
      HANDLE_CODE(c.get<s_nssai_s>().pack(bref));
      break;
    case types::pdu_session_expected_ue_activity_behaviour:
      HANDLE_CODE(c.get<expected_ue_activity_behaviour_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_item_mod_req_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_modify_item_mod_req_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::s_nssai:
      HANDLE_CODE(c.get<s_nssai_s>().unpack(bref));
      break;
    case types::pdu_session_expected_ue_activity_behaviour:
      HANDLE_CODE(c.get<expected_ue_activity_behaviour_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_item_mod_req_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* pdu_session_res_modify_item_mod_req_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"S-NSSAI", "ExpectedUEActivityBehaviour"};
  return convert_enum_idx(names, 2, value, "pdu_session_res_modify_item_mod_req_ext_ies_o::ext_c::types");
}

// PDUSessionResourceSetupItemSUReq-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t pdu_session_res_setup_item_su_req_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {281};
  return map_enum_number(names, 1, idx, "id");
}
bool pdu_session_res_setup_item_su_req_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 281 == id;
}
crit_e pdu_session_res_setup_item_su_req_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 281) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
pdu_session_res_setup_item_su_req_ext_ies_o::ext_c
pdu_session_res_setup_item_su_req_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 281) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pdu_session_res_setup_item_su_req_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 281) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void pdu_session_res_setup_item_su_req_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("ExpectedUEActivityBehaviour");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE pdu_session_res_setup_item_su_req_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_setup_item_su_req_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* pdu_session_res_setup_item_su_req_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"ExpectedUEActivityBehaviour"};
  return convert_enum_idx(names, 1, value, "pdu_session_res_setup_item_su_req_ext_ies_o::ext_c::types");
}

// PDUSessionResourceSwitchedItem-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t pdu_session_res_switched_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {281};
  return map_enum_number(names, 1, idx, "id");
}
bool pdu_session_res_switched_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 281 == id;
}
crit_e pdu_session_res_switched_item_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 281) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
pdu_session_res_switched_item_ext_ies_o::ext_c pdu_session_res_switched_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 281) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pdu_session_res_switched_item_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 281) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void pdu_session_res_switched_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("ExpectedUEActivityBehaviour");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE pdu_session_res_switched_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_switched_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* pdu_session_res_switched_item_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"ExpectedUEActivityBehaviour"};
  return convert_enum_idx(names, 1, value, "pdu_session_res_switched_item_ext_ies_o::ext_c::types");
}

// PrivateIE-ID ::= CHOICE
void private_ie_id_c::set(types::options e)
{
  type_ = e;
}
uint32_t& private_ie_id_c::set_local()
{
  set(types::local);
  return c;
}
void private_ie_id_c::set_global()
{
  set(types::global);
}
void private_ie_id_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::local:
      j.write_int("local", c);
      break;
    case types::global:
      break;
    default:
      log_invalid_choice_id(type_, "private_ie_id_c");
  }
  j.end_obj();
}
SRSASN_CODE private_ie_id_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::local:
      HANDLE_CODE(pack_integer(bref, c, (uint32_t)0u, (uint32_t)65535u, false, true));
      break;
    case types::global:
      break;
    default:
      log_invalid_choice_id(type_, "private_ie_id_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE private_ie_id_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::local:
      HANDLE_CODE(unpack_integer(c, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
      break;
    case types::global:
      break;
    default:
      log_invalid_choice_id(type_, "private_ie_id_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* private_ie_id_c::types_opts::to_string() const
{
  static const char* names[] = {"local", "global"};
  return convert_enum_idx(names, 2, value, "private_ie_id_c::types");
}

// SupportedTAItem-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t supported_ta_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {272, 179};
  return map_enum_number(names, 2, idx, "id");
}
bool supported_ta_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {272, 179};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e supported_ta_item_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 272:
      return crit_e::ignore;
    case 179:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
supported_ta_item_ext_ies_o::ext_c supported_ta_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 272:
      ret.set(ext_c::types::cfg_tac_ind);
      break;
    case 179:
      ret.set(ext_c::types::rat_info);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e supported_ta_item_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 272:
      return presence_e::optional;
    case 179:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void supported_ta_item_ext_ies_o::ext_c::destroy_() {}
void supported_ta_item_ext_ies_o::ext_c::set(types::options e)
{
  destroy_();
  type_ = e;
}
supported_ta_item_ext_ies_o::ext_c::ext_c(const supported_ta_item_ext_ies_o::ext_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::cfg_tac_ind:
      c.init(other.c.get<cfg_tac_ind_e>());
      break;
    case types::rat_info:
      c.init(other.c.get<rat_info_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "supported_ta_item_ext_ies_o::ext_c");
  }
}
supported_ta_item_ext_ies_o::ext_c&
supported_ta_item_ext_ies_o::ext_c::operator=(const supported_ta_item_ext_ies_o::ext_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::cfg_tac_ind:
      c.set(other.c.get<cfg_tac_ind_e>());
      break;
    case types::rat_info:
      c.set(other.c.get<rat_info_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "supported_ta_item_ext_ies_o::ext_c");
  }

  return *this;
}
cfg_tac_ind_e& supported_ta_item_ext_ies_o::ext_c::cfg_tac_ind()
{
  assert_choice_type(types::cfg_tac_ind, type_, "Extension");
  return c.get<cfg_tac_ind_e>();
}
rat_info_e& supported_ta_item_ext_ies_o::ext_c::rat_info()
{
  assert_choice_type(types::rat_info, type_, "Extension");
  return c.get<rat_info_e>();
}
const cfg_tac_ind_e& supported_ta_item_ext_ies_o::ext_c::cfg_tac_ind() const
{
  assert_choice_type(types::cfg_tac_ind, type_, "Extension");
  return c.get<cfg_tac_ind_e>();
}
const rat_info_e& supported_ta_item_ext_ies_o::ext_c::rat_info() const
{
  assert_choice_type(types::rat_info, type_, "Extension");
  return c.get<rat_info_e>();
}
void supported_ta_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::cfg_tac_ind:
      j.write_str("ConfiguredTACIndication", "true");
      break;
    case types::rat_info:
      j.write_str("RAT-Information", c.get<rat_info_e>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "supported_ta_item_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE supported_ta_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::cfg_tac_ind:
      HANDLE_CODE(c.get<cfg_tac_ind_e>().pack(bref));
      break;
    case types::rat_info:
      HANDLE_CODE(c.get<rat_info_e>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "supported_ta_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE supported_ta_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::cfg_tac_ind:
      HANDLE_CODE(c.get<cfg_tac_ind_e>().unpack(bref));
      break;
    case types::rat_info:
      HANDLE_CODE(c.get<rat_info_e>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "supported_ta_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* supported_ta_item_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"ConfiguredTACIndication", "RAT-Information"};
  return convert_enum_idx(names, 2, value, "supported_ta_item_ext_ies_o::ext_c::types");
}

// UE-associatedLogicalNG-connectionItem ::= SEQUENCE
SRSASN_CODE ue_associated_lc_ng_conn_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(amf_ue_ngap_id_present, 1));
  HANDLE_CODE(bref.pack(ran_ue_ngap_id_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (amf_ue_ngap_id_present) {
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  if (ran_ue_ngap_id_present) {
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_associated_lc_ng_conn_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(amf_ue_ngap_id_present, 1));
  HANDLE_CODE(bref.unpack(ran_ue_ngap_id_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (amf_ue_ngap_id_present) {
    HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  if (ran_ue_ngap_id_present) {
    HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ue_associated_lc_ng_conn_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (amf_ue_ngap_id_present) {
    j.write_int("aMF-UE-NGAP-ID", amf_ue_ngap_id);
  }
  if (ran_ue_ngap_id_present) {
    j.write_int("rAN-UE-NGAP-ID", ran_ue_ngap_id);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// UEPresence ::= ENUMERATED
const char* ue_presence_opts::to_string() const
{
  static const char* names[] = {"in", "out", "unknown"};
  return convert_enum_idx(names, 3, value, "ue_presence_e");
}

// MulticastGroupPagingAreaItem ::= SEQUENCE
SRSASN_CODE multicast_group_paging_area_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ue_paging_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(multicast_group_paging_area.pack(bref));
  if (ue_paging_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ue_paging_list, 1, 4096, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_group_paging_area_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool ue_paging_list_present;
  HANDLE_CODE(bref.unpack(ue_paging_list_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(multicast_group_paging_area.unpack(bref));
  if (ue_paging_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ue_paging_list, bref, 1, 4096, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void multicast_group_paging_area_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("multicastGroupPagingArea");
  multicast_group_paging_area.to_json(j);
  if (ue_paging_list.size() > 0) {
    j.start_array("uE-PagingList");
    for (const auto& e1 : ue_paging_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// NB-IoT-Paging-TimeWindow ::= ENUMERATED
const char* nb_iot_paging_time_win_opts::to_string() const
{
  static const char* names[] = {
      "s1", "s2", "s3", "s4", "s5", "s6", "s7", "s8", "s9", "s10", "s11", "s12", "s13", "s14", "s15", "s16"};
  return convert_enum_idx(names, 16, value, "nb_iot_paging_time_win_e");
}
uint8_t nb_iot_paging_time_win_opts::to_number() const
{
  static const uint8_t numbers[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16};
  return map_enum_number(numbers, 16, value, "nb_iot_paging_time_win_e");
}

// NB-IoT-Paging-eDRXCycle ::= ENUMERATED
const char* nb_iot_paging_e_drx_cycle_opts::to_string() const
{
  static const char* names[] = {
      "hf2", "hf4", "hf6", "hf8", "hf10", "hf12", "hf14", "hf16", "hf32", "hf64", "hf128", "hf256", "hf512", "hf1024"};
  return convert_enum_idx(names, 14, value, "nb_iot_paging_e_drx_cycle_e");
}
uint16_t nb_iot_paging_e_drx_cycle_opts::to_number() const
{
  static const uint16_t numbers[] = {2, 4, 6, 8, 10, 12, 14, 16, 32, 64, 128, 256, 512, 1024};
  return map_enum_number(numbers, 14, value, "nb_iot_paging_e_drx_cycle_e");
}

// NGRAN-TNLAssociationToRemoveItem ::= SEQUENCE
SRSASN_CODE ngran_tnl_assoc_to_rem_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(tnl_assoc_transport_layer_address_amf_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(tnl_assoc_transport_layer_address.pack(bref));
  if (tnl_assoc_transport_layer_address_amf_present) {
    HANDLE_CODE(tnl_assoc_transport_layer_address_amf.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ngran_tnl_assoc_to_rem_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(tnl_assoc_transport_layer_address_amf_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(tnl_assoc_transport_layer_address.unpack(bref));
  if (tnl_assoc_transport_layer_address_amf_present) {
    HANDLE_CODE(tnl_assoc_transport_layer_address_amf.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ngran_tnl_assoc_to_rem_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("tNLAssociationTransportLayerAddress");
  tnl_assoc_transport_layer_address.to_json(j);
  if (tnl_assoc_transport_layer_address_amf_present) {
    j.write_fieldname("tNLAssociationTransportLayerAddressAMF");
    tnl_assoc_transport_layer_address_amf.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// OverloadStartNSSAIItem ::= SEQUENCE
SRSASN_CODE overload_start_nssai_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(slice_overload_resp_present, 1));
  HANDLE_CODE(bref.pack(slice_traffic_load_reduction_ind_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, slice_overload_list, 1, 1024, true));
  if (slice_overload_resp_present) {
    HANDLE_CODE(slice_overload_resp.pack(bref));
  }
  if (slice_traffic_load_reduction_ind_present) {
    HANDLE_CODE(pack_integer(bref, slice_traffic_load_reduction_ind, (uint8_t)1u, (uint8_t)99u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE overload_start_nssai_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(slice_overload_resp_present, 1));
  HANDLE_CODE(bref.unpack(slice_traffic_load_reduction_ind_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(slice_overload_list, bref, 1, 1024, true));
  if (slice_overload_resp_present) {
    HANDLE_CODE(slice_overload_resp.unpack(bref));
  }
  if (slice_traffic_load_reduction_ind_present) {
    HANDLE_CODE(unpack_integer(slice_traffic_load_reduction_ind, bref, (uint8_t)1u, (uint8_t)99u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void overload_start_nssai_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("sliceOverloadList");
  for (const auto& e1 : slice_overload_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (slice_overload_resp_present) {
    j.write_fieldname("sliceOverloadResponse");
    slice_overload_resp.to_json(j);
  }
  if (slice_traffic_load_reduction_ind_present) {
    j.write_int("sliceTrafficLoadReductionIndication", slice_traffic_load_reduction_ind);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceFailedToModifyItemModCfm ::= SEQUENCE
SRSASN_CODE pdu_session_res_failed_to_modify_item_mod_cfm_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pdu_session_id, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(pdu_session_res_modify_ind_unsuccessful_transfer.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_failed_to_modify_item_mod_cfm_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pdu_session_id, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(pdu_session_res_modify_ind_unsuccessful_transfer.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_failed_to_modify_item_mod_cfm_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pDUSessionID", pdu_session_id);
  j.write_str("pDUSessionResourceModifyIndicationUnsuccessfulTransfer",
              pdu_session_res_modify_ind_unsuccessful_transfer.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceFailedToModifyItemModRes ::= SEQUENCE
SRSASN_CODE pdu_session_res_failed_to_modify_item_mod_res_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pdu_session_id, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(pdu_session_res_modify_unsuccessful_transfer.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_failed_to_modify_item_mod_res_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pdu_session_id, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(pdu_session_res_modify_unsuccessful_transfer.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_failed_to_modify_item_mod_res_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pDUSessionID", pdu_session_id);
  j.write_str("pDUSessionResourceModifyUnsuccessfulTransfer", pdu_session_res_modify_unsuccessful_transfer.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceFailedToResumeItemRESReq ::= SEQUENCE
SRSASN_CODE pdu_session_res_failed_to_resume_item_res_req_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pdu_session_id, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(cause.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_failed_to_resume_item_res_req_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pdu_session_id, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(cause.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_failed_to_resume_item_res_req_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pDUSessionID", pdu_session_id);
  j.write_fieldname("cause");
  cause.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceFailedToResumeItemRESRes ::= SEQUENCE
SRSASN_CODE pdu_session_res_failed_to_resume_item_res_res_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pdu_session_id, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(cause.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_failed_to_resume_item_res_res_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pdu_session_id, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(cause.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_failed_to_resume_item_res_res_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pDUSessionID", pdu_session_id);
  j.write_fieldname("cause");
  cause.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceFailedToSetupItemPSReq ::= SEQUENCE
SRSASN_CODE pdu_session_res_failed_to_setup_item_ps_req_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pdu_session_id, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(path_switch_request_setup_failed_transfer.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_failed_to_setup_item_ps_req_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pdu_session_id, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(path_switch_request_setup_failed_transfer.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_failed_to_setup_item_ps_req_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pDUSessionID", pdu_session_id);
  j.write_str("pathSwitchRequestSetupFailedTransfer", path_switch_request_setup_failed_transfer.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceFailedToSetupItemSURes ::= SEQUENCE
SRSASN_CODE pdu_session_res_failed_to_setup_item_su_res_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pdu_session_id, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(pdu_session_res_setup_unsuccessful_transfer.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_failed_to_setup_item_su_res_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pdu_session_id, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(pdu_session_res_setup_unsuccessful_transfer.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_failed_to_setup_item_su_res_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pDUSessionID", pdu_session_id);
  j.write_str("pDUSessionResourceSetupUnsuccessfulTransfer", pdu_session_res_setup_unsuccessful_transfer.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceItemCxtRelCpl ::= SEQUENCE
SRSASN_CODE pdu_session_res_item_cxt_rel_cpl_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(pack_integer(bref, pdu_session_id, (uint16_t)0u, (uint16_t)255u, false, true));
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_item_cxt_rel_cpl_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pdu_session_id, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_item_cxt_rel_cpl_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pDUSessionID", pdu_session_id);
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// PDUSessionResourceItemCxtRelReq ::= SEQUENCE
SRSASN_CODE pdu_session_res_item_cxt_rel_req_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pdu_session_id, (uint16_t)0u, (uint16_t)255u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_item_cxt_rel_req_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pdu_session_id, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_item_cxt_rel_req_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pDUSessionID", pdu_session_id);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceModifyItemModCfm ::= SEQUENCE
SRSASN_CODE pdu_session_res_modify_item_mod_cfm_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pdu_session_id, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(pdu_session_res_modify_confirm_transfer.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_modify_item_mod_cfm_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pdu_session_id, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(pdu_session_res_modify_confirm_transfer.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_modify_item_mod_cfm_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pDUSessionID", pdu_session_id);
  j.write_str("pDUSessionResourceModifyConfirmTransfer", pdu_session_res_modify_confirm_transfer.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceModifyItemModInd ::= SEQUENCE
SRSASN_CODE pdu_session_res_modify_item_mod_ind_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pdu_session_id, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(pdu_session_res_modify_ind_transfer.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_modify_item_mod_ind_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pdu_session_id, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(pdu_session_res_modify_ind_transfer.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_modify_item_mod_ind_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pDUSessionID", pdu_session_id);
  j.write_str("pDUSessionResourceModifyIndicationTransfer", pdu_session_res_modify_ind_transfer.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ext_field_s<pdu_session_res_modify_item_mod_req_ext_ies_o>;

pdu_session_res_modify_item_mod_req_ext_ies_container::pdu_session_res_modify_item_mod_req_ext_ies_container() :
  s_nssai(148, crit_e::reject), pdu_session_expected_ue_activity_behaviour(281, crit_e::ignore)
{
}
SRSASN_CODE pdu_session_res_modify_item_mod_req_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += s_nssai_present ? 1 : 0;
  nof_ies += pdu_session_expected_ue_activity_behaviour_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (s_nssai_present) {
    HANDLE_CODE(s_nssai.pack(bref));
  }
  if (pdu_session_expected_ue_activity_behaviour_present) {
    HANDLE_CODE(pdu_session_expected_ue_activity_behaviour.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_modify_item_mod_req_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 148: {
        s_nssai_present = true;
        s_nssai.id      = id;
        HANDLE_CODE(s_nssai.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(s_nssai.ext.unpack(bref));
        break;
      }
      case 281: {
        pdu_session_expected_ue_activity_behaviour_present = true;
        pdu_session_expected_ue_activity_behaviour.id      = id;
        HANDLE_CODE(pdu_session_expected_ue_activity_behaviour.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pdu_session_expected_ue_activity_behaviour.ext.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_modify_item_mod_req_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (s_nssai_present) {
    j.write_fieldname("");
    s_nssai.to_json(j);
  }
  if (pdu_session_expected_ue_activity_behaviour_present) {
    j.write_fieldname("");
    pdu_session_expected_ue_activity_behaviour.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceModifyItemModReq ::= SEQUENCE
SRSASN_CODE pdu_session_res_modify_item_mod_req_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(nas_pdu.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pdu_session_id, (uint16_t)0u, (uint16_t)255u, false, true));
  if (nas_pdu.size() > 0) {
    HANDLE_CODE(nas_pdu.pack(bref));
  }
  HANDLE_CODE(pdu_session_res_modify_request_transfer.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_modify_item_mod_req_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool nas_pdu_present;
  HANDLE_CODE(bref.unpack(nas_pdu_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pdu_session_id, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  if (nas_pdu_present) {
    HANDLE_CODE(nas_pdu.unpack(bref));
  }
  HANDLE_CODE(pdu_session_res_modify_request_transfer.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_modify_item_mod_req_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pDUSessionID", pdu_session_id);
  if (nas_pdu.size() > 0) {
    j.write_str("nAS-PDU", nas_pdu.to_string());
  }
  j.write_str("pDUSessionResourceModifyRequestTransfer", pdu_session_res_modify_request_transfer.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceModifyItemModRes ::= SEQUENCE
SRSASN_CODE pdu_session_res_modify_item_mod_res_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pdu_session_id, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(pdu_session_res_modify_resp_transfer.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_modify_item_mod_res_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pdu_session_id, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(pdu_session_res_modify_resp_transfer.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_modify_item_mod_res_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pDUSessionID", pdu_session_id);
  j.write_str("pDUSessionResourceModifyResponseTransfer", pdu_session_res_modify_resp_transfer.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceNotifyItem ::= SEQUENCE
SRSASN_CODE pdu_session_res_notify_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pdu_session_id, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(pdu_session_res_notify_transfer.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_notify_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pdu_session_id, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(pdu_session_res_notify_transfer.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_notify_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pDUSessionID", pdu_session_id);
  j.write_str("pDUSessionResourceNotifyTransfer", pdu_session_res_notify_transfer.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceReleasedItemNot ::= SEQUENCE
SRSASN_CODE pdu_session_res_released_item_not_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pdu_session_id, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(pdu_session_res_notify_released_transfer.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_released_item_not_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pdu_session_id, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(pdu_session_res_notify_released_transfer.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_released_item_not_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pDUSessionID", pdu_session_id);
  j.write_str("pDUSessionResourceNotifyReleasedTransfer", pdu_session_res_notify_released_transfer.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceReleasedItemPSAck ::= SEQUENCE
SRSASN_CODE pdu_session_res_released_item_ps_ack_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pdu_session_id, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(path_switch_request_unsuccessful_transfer.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_released_item_ps_ack_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pdu_session_id, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(path_switch_request_unsuccessful_transfer.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_released_item_ps_ack_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pDUSessionID", pdu_session_id);
  j.write_str("pathSwitchRequestUnsuccessfulTransfer", path_switch_request_unsuccessful_transfer.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceReleasedItemPSFail ::= SEQUENCE
SRSASN_CODE pdu_session_res_released_item_ps_fail_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pdu_session_id, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(path_switch_request_unsuccessful_transfer.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_released_item_ps_fail_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pdu_session_id, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(path_switch_request_unsuccessful_transfer.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_released_item_ps_fail_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pDUSessionID", pdu_session_id);
  j.write_str("pathSwitchRequestUnsuccessfulTransfer", path_switch_request_unsuccessful_transfer.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceReleasedItemRelRes ::= SEQUENCE
SRSASN_CODE pdu_session_res_released_item_rel_res_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pdu_session_id, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(pdu_session_res_release_resp_transfer.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_released_item_rel_res_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pdu_session_id, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(pdu_session_res_release_resp_transfer.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_released_item_rel_res_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pDUSessionID", pdu_session_id);
  j.write_str("pDUSessionResourceReleaseResponseTransfer", pdu_session_res_release_resp_transfer.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceResumeItemRESReq ::= SEQUENCE
SRSASN_CODE pdu_session_res_resume_item_res_req_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pdu_session_id, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(ue_context_resume_request_transfer.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_resume_item_res_req_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pdu_session_id, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(ue_context_resume_request_transfer.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_resume_item_res_req_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pDUSessionID", pdu_session_id);
  j.write_str("uEContextResumeRequestTransfer", ue_context_resume_request_transfer.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceResumeItemRESRes ::= SEQUENCE
SRSASN_CODE pdu_session_res_resume_item_res_res_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pdu_session_id, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(ue_context_resume_resp_transfer.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_resume_item_res_res_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pdu_session_id, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(ue_context_resume_resp_transfer.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_resume_item_res_res_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pDUSessionID", pdu_session_id);
  j.write_str("uEContextResumeResponseTransfer", ue_context_resume_resp_transfer.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceSecondaryRATUsageItem ::= SEQUENCE
SRSASN_CODE pdu_session_res_secondary_rat_usage_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pdu_session_id, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(secondary_rat_data_usage_report_transfer.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_secondary_rat_usage_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pdu_session_id, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(secondary_rat_data_usage_report_transfer.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_secondary_rat_usage_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pDUSessionID", pdu_session_id);
  j.write_str("secondaryRATDataUsageReportTransfer", secondary_rat_data_usage_report_transfer.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceSetupItemSUReq ::= SEQUENCE
SRSASN_CODE pdu_session_res_setup_item_su_req_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(pdu_session_nas_pdu.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(pack_integer(bref, pdu_session_id, (uint16_t)0u, (uint16_t)255u, false, true));
  if (pdu_session_nas_pdu.size() > 0) {
    HANDLE_CODE(pdu_session_nas_pdu.pack(bref));
  }
  HANDLE_CODE(s_nssai.pack(bref));
  HANDLE_CODE(pdu_session_res_setup_request_transfer.pack(bref));
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_setup_item_su_req_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool pdu_session_nas_pdu_present;
  HANDLE_CODE(bref.unpack(pdu_session_nas_pdu_present, 1));
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pdu_session_id, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  if (pdu_session_nas_pdu_present) {
    HANDLE_CODE(pdu_session_nas_pdu.unpack(bref));
  }
  HANDLE_CODE(s_nssai.unpack(bref));
  HANDLE_CODE(pdu_session_res_setup_request_transfer.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_setup_item_su_req_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pDUSessionID", pdu_session_id);
  if (pdu_session_nas_pdu.size() > 0) {
    j.write_str("pDUSessionNAS-PDU", pdu_session_nas_pdu.to_string());
  }
  j.write_fieldname("s-NSSAI");
  s_nssai.to_json(j);
  j.write_str("pDUSessionResourceSetupRequestTransfer", pdu_session_res_setup_request_transfer.to_string());
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// PDUSessionResourceSetupItemSURes ::= SEQUENCE
SRSASN_CODE pdu_session_res_setup_item_su_res_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pdu_session_id, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(pdu_session_res_setup_resp_transfer.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_setup_item_su_res_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pdu_session_id, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(pdu_session_res_setup_resp_transfer.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_setup_item_su_res_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pDUSessionID", pdu_session_id);
  j.write_str("pDUSessionResourceSetupResponseTransfer", pdu_session_res_setup_resp_transfer.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceSuspendItemSUSReq ::= SEQUENCE
SRSASN_CODE pdu_session_res_suspend_item_sus_req_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pdu_session_id, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(ue_context_suspend_request_transfer.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_suspend_item_sus_req_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pdu_session_id, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(ue_context_suspend_request_transfer.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_suspend_item_sus_req_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pDUSessionID", pdu_session_id);
  j.write_str("uEContextSuspendRequestTransfer", ue_context_suspend_request_transfer.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceSwitchedItem ::= SEQUENCE
SRSASN_CODE pdu_session_res_switched_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(pack_integer(bref, pdu_session_id, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(path_switch_request_ack_transfer.pack(bref));
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_switched_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pdu_session_id, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(path_switch_request_ack_transfer.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_switched_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pDUSessionID", pdu_session_id);
  j.write_str("pathSwitchRequestAcknowledgeTransfer", path_switch_request_ack_transfer.to_string());
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// PDUSessionResourceToBeSwitchedDLItem ::= SEQUENCE
SRSASN_CODE pdu_session_res_to_be_switched_dl_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pdu_session_id, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(path_switch_request_transfer.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_to_be_switched_dl_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pdu_session_id, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(path_switch_request_transfer.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_to_be_switched_dl_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pDUSessionID", pdu_session_id);
  j.write_str("pathSwitchRequestTransfer", path_switch_request_transfer.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceToReleaseItemRelCmd ::= SEQUENCE
SRSASN_CODE pdu_session_res_to_release_item_rel_cmd_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pdu_session_id, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(pdu_session_res_release_cmd_transfer.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_to_release_item_rel_cmd_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pdu_session_id, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(pdu_session_res_release_cmd_transfer.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_to_release_item_rel_cmd_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pDUSessionID", pdu_session_id);
  j.write_str("pDUSessionResourceReleaseCommandTransfer", pdu_session_res_release_cmd_transfer.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PagingProbabilityInformation ::= ENUMERATED
const char* paging_probability_info_opts::to_string() const
{
  static const char* names[] = {"p00", "p05", "p10", "p15", "p20", "p25", "p30", "p35", "p40", "p45", "p50",
                                "p55", "p60", "p65", "p70", "p75", "p80", "p85", "p90", "p95", "p100"};
  return convert_enum_idx(names, 21, value, "paging_probability_info_e");
}
float paging_probability_info_opts::to_number() const
{
  static const float numbers[] = {0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5, 5.0,
                                  5.5, 6.0, 6.5, 7.0, 7.5, 8.0, 8.5, 9.0, 9.5, 1.0};
  return map_enum_number(numbers, 21, value, "paging_probability_info_e");
}
const char* paging_probability_info_opts::to_number_string() const
{
  static const char* number_strs[] = {"0.0", "0.5", "1.0", "1.5", "2.0", "2.5", "3.0", "3.5", "4.0", "4.5", "5.0",
                                      "5.5", "6.0", "6.5", "7.0", "7.5", "8.0", "8.5", "9.0", "9.5", "1.00"};
  return convert_enum_idx(number_strs, 21, value, "paging_probability_info_e");
}

// ResetAll ::= ENUMERATED
const char* reset_all_opts::to_string() const
{
  static const char* names[] = {"reset-all"};
  return convert_enum_idx(names, 1, value, "reset_all_e");
}

template struct asn1::protocol_ext_field_s<supported_ta_item_ext_ies_o>;

supported_ta_item_ext_ies_container::supported_ta_item_ext_ies_container() :
  cfg_tac_ind(272, crit_e::ignore), rat_info(179, crit_e::reject)
{
}
SRSASN_CODE supported_ta_item_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += cfg_tac_ind_present ? 1 : 0;
  nof_ies += rat_info_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (cfg_tac_ind_present) {
    HANDLE_CODE(cfg_tac_ind.pack(bref));
  }
  if (rat_info_present) {
    HANDLE_CODE(rat_info.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE supported_ta_item_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 272: {
        cfg_tac_ind_present = true;
        cfg_tac_ind.id      = id;
        HANDLE_CODE(cfg_tac_ind.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cfg_tac_ind.ext.unpack(bref));
        break;
      }
      case 179: {
        rat_info_present = true;
        rat_info.id      = id;
        HANDLE_CODE(rat_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(rat_info.ext.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void supported_ta_item_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (cfg_tac_ind_present) {
    j.write_fieldname("");
    cfg_tac_ind.to_json(j);
  }
  if (rat_info_present) {
    j.write_fieldname("");
    rat_info.to_json(j);
  }
  j.end_obj();
}

// SupportedTAItem ::= SEQUENCE
SRSASN_CODE supported_ta_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(tac.pack(bref));
  HANDLE_CODE(pack_dyn_seq_of(bref, broadcast_plmn_list, 1, 12, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE supported_ta_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(tac.unpack(bref));
  HANDLE_CODE(unpack_dyn_seq_of(broadcast_plmn_list, bref, 1, 12, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void supported_ta_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("tAC", tac.to_string());
  j.start_array("broadcastPLMNList");
  for (const auto& e1 : broadcast_plmn_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TAIListForPagingItem ::= SEQUENCE
SRSASN_CODE tai_list_for_paging_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(tai.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE tai_list_for_paging_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(tai.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void tai_list_for_paging_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("tAI");
  tai.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// UE-NGAP-ID-pair ::= SEQUENCE
SRSASN_CODE ue_ngap_id_pair_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_ngap_id_pair_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ue_ngap_id_pair_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("aMF-UE-NGAP-ID", amf_ue_ngap_id);
  j.write_int("rAN-UE-NGAP-ID", ran_ue_ngap_id);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// UEPresenceInAreaOfInterestItem ::= SEQUENCE
SRSASN_CODE ue_presence_in_area_of_interest_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, location_report_ref_id, (uint8_t)1u, (uint8_t)64u, true, true));
  HANDLE_CODE(ue_presence.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_presence_in_area_of_interest_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(location_report_ref_id, bref, (uint8_t)1u, (uint8_t)64u, true, true));
  HANDLE_CODE(ue_presence.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ue_presence_in_area_of_interest_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("locationReportingReferenceID", location_report_ref_id);
  j.write_str("uEPresence", ue_presence.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CancelAllWarningMessages ::= ENUMERATED
const char* cancel_all_warning_msgs_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "cancel_all_warning_msgs_e");
}

// ConcurrentWarningMessageInd ::= ENUMERATED
const char* concurrent_warning_msg_ind_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "concurrent_warning_msg_ind_e");
}

// HandoverFlag ::= ENUMERATED
const char* ho_flag_opts::to_string() const
{
  static const char* names[] = {"handover-preparation"};
  return convert_enum_idx(names, 1, value, "ho_flag_e");
}

// IAB-Supported ::= ENUMERATED
const char* iab_supported_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "iab_supported_e");
}

// IMSVoiceSupportIndicator ::= ENUMERATED
const char* ims_voice_support_ind_opts::to_string() const
{
  static const char* names[] = {"supported", "not-supported"};
  return convert_enum_idx(names, 2, value, "ims_voice_support_ind_e");
}

// NB-IoT-DefaultPagingDRX ::= ENUMERATED
const char* nb_iot_default_paging_drx_opts::to_string() const
{
  static const char* names[] = {"rf128", "rf256", "rf512", "rf1024"};
  return convert_enum_idx(names, 4, value, "nb_iot_default_paging_drx_e");
}
uint16_t nb_iot_default_paging_drx_opts::to_number() const
{
  static const uint16_t numbers[] = {128, 256, 512, 1024};
  return map_enum_number(numbers, 4, value, "nb_iot_default_paging_drx_e");
}

// NB-IoT-Paging-eDRXInfo ::= SEQUENCE
SRSASN_CODE nb_iot_paging_e_drx_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(nb_iot_paging_time_win_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(nb_iot_paging_e_drx_cycle.pack(bref));
  if (nb_iot_paging_time_win_present) {
    HANDLE_CODE(nb_iot_paging_time_win.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE nb_iot_paging_e_drx_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(nb_iot_paging_time_win_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(nb_iot_paging_e_drx_cycle.unpack(bref));
  if (nb_iot_paging_time_win_present) {
    HANDLE_CODE(nb_iot_paging_time_win.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void nb_iot_paging_e_drx_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("nB-IoT-Paging-eDRXCycle", nb_iot_paging_e_drx_cycle.to_string());
  if (nb_iot_paging_time_win_present) {
    j.write_str("nB-IoT-Paging-TimeWindow", nb_iot_paging_time_win.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// NB-IoT-PagingDRX ::= ENUMERATED
const char* nb_iot_paging_drx_opts::to_string() const
{
  static const char* names[] = {"rf32", "rf64", "rf128", "rf256", "rf512", "rf1024"};
  return convert_enum_idx(names, 6, value, "nb_iot_paging_drx_e");
}
uint16_t nb_iot_paging_drx_opts::to_number() const
{
  static const uint16_t numbers[] = {32, 64, 128, 256, 512, 1024};
  return map_enum_number(numbers, 6, value, "nb_iot_paging_drx_e");
}

// PWSFailedCellIDList ::= CHOICE
void pws_failed_cell_id_list_c::destroy_()
{
  switch (type_) {
    case types::eutra_cgi_pws_failed_list:
      c.destroy<eutra_cgi_list_l>();
      break;
    case types::nr_cgi_pws_failed_list:
      c.destroy<nr_cgi_list_l>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<pws_failed_cell_id_list_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void pws_failed_cell_id_list_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::eutra_cgi_pws_failed_list:
      c.init<eutra_cgi_list_l>();
      break;
    case types::nr_cgi_pws_failed_list:
      c.init<nr_cgi_list_l>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<pws_failed_cell_id_list_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pws_failed_cell_id_list_c");
  }
}
pws_failed_cell_id_list_c::pws_failed_cell_id_list_c(const pws_failed_cell_id_list_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::eutra_cgi_pws_failed_list:
      c.init(other.c.get<eutra_cgi_list_l>());
      break;
    case types::nr_cgi_pws_failed_list:
      c.init(other.c.get<nr_cgi_list_l>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<pws_failed_cell_id_list_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pws_failed_cell_id_list_c");
  }
}
pws_failed_cell_id_list_c& pws_failed_cell_id_list_c::operator=(const pws_failed_cell_id_list_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::eutra_cgi_pws_failed_list:
      c.set(other.c.get<eutra_cgi_list_l>());
      break;
    case types::nr_cgi_pws_failed_list:
      c.set(other.c.get<nr_cgi_list_l>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<pws_failed_cell_id_list_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pws_failed_cell_id_list_c");
  }

  return *this;
}
eutra_cgi_list_l& pws_failed_cell_id_list_c::set_eutra_cgi_pws_failed_list()
{
  set(types::eutra_cgi_pws_failed_list);
  return c.get<eutra_cgi_list_l>();
}
nr_cgi_list_l& pws_failed_cell_id_list_c::set_nr_cgi_pws_failed_list()
{
  set(types::nr_cgi_pws_failed_list);
  return c.get<nr_cgi_list_l>();
}
protocol_ie_single_container_s<pws_failed_cell_id_list_ext_ies_o>& pws_failed_cell_id_list_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<pws_failed_cell_id_list_ext_ies_o>>();
}
void pws_failed_cell_id_list_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::eutra_cgi_pws_failed_list:
      j.start_array("eUTRA-CGI-PWSFailedList");
      for (const auto& e1 : c.get<eutra_cgi_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::nr_cgi_pws_failed_list:
      j.start_array("nR-CGI-PWSFailedList");
      for (const auto& e1 : c.get<nr_cgi_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<pws_failed_cell_id_list_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "pws_failed_cell_id_list_c");
  }
  j.end_obj();
}
SRSASN_CODE pws_failed_cell_id_list_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::eutra_cgi_pws_failed_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<eutra_cgi_list_l>(), 1, 256, true));
      break;
    case types::nr_cgi_pws_failed_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<nr_cgi_list_l>(), 1, 16384, true));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<pws_failed_cell_id_list_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pws_failed_cell_id_list_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE pws_failed_cell_id_list_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::eutra_cgi_pws_failed_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<eutra_cgi_list_l>(), bref, 1, 256, true));
      break;
    case types::nr_cgi_pws_failed_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<nr_cgi_list_l>(), bref, 1, 16384, true));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<pws_failed_cell_id_list_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pws_failed_cell_id_list_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* pws_failed_cell_id_list_c::types_opts::to_string() const
{
  static const char* names[] = {"eUTRA-CGI-PWSFailedList", "nR-CGI-PWSFailedList", "choice-Extensions"};
  return convert_enum_idx(names, 3, value, "pws_failed_cell_id_list_c::types");
}

// PagingCause ::= ENUMERATED
const char* paging_cause_opts::to_string() const
{
  static const char* names[] = {"voice"};
  return convert_enum_idx(names, 1, value, "paging_cause_e");
}

// PagingOrigin ::= ENUMERATED
const char* paging_origin_opts::to_string() const
{
  static const char* names[] = {"non-3gpp"};
  return convert_enum_idx(names, 1, value, "paging_origin_e");
}
int8_t paging_origin_opts::to_number() const
{
  static const int8_t numbers[] = {-3};
  return map_enum_number(numbers, 1, value, "paging_origin_e");
}

// PagingPriority ::= ENUMERATED
const char* paging_prio_opts::to_string() const
{
  static const char* names[] = {
      "priolevel1", "priolevel2", "priolevel3", "priolevel4", "priolevel5", "priolevel6", "priolevel7", "priolevel8"};
  return convert_enum_idx(names, 8, value, "paging_prio_e");
}
uint8_t paging_prio_opts::to_number() const
{
  static const uint8_t numbers[] = {1, 2, 3, 4, 5, 6, 7, 8};
  return map_enum_number(numbers, 8, value, "paging_prio_e");
}

// PrivateIE-Field{NGAP-PRIVATE-IES : IEsSetParam} ::= SEQUENCE{{NGAP-PRIVATE-IES}}
template <class ies_set_paramT_>
SRSASN_CODE private_ie_field_s<ies_set_paramT_>::pack(bit_ref& bref) const
{
  HANDLE_CODE(id.pack(bref));
  HANDLE_CODE(crit.pack(bref));
  HANDLE_CODE(value.pack(bref));

  return SRSASN_SUCCESS;
}
template <class ies_set_paramT_>
SRSASN_CODE private_ie_field_s<ies_set_paramT_>::unpack(cbit_ref& bref)
{
  HANDLE_CODE(id.unpack(bref));
  HANDLE_CODE(crit.unpack(bref));
  HANDLE_CODE(value.unpack(bref));

  return SRSASN_SUCCESS;
}
template <class ies_set_paramT_>
void private_ie_field_s<ies_set_paramT_>::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("id");
  id.to_json(j);
  j.write_str("criticality", crit.to_string());
  j.end_obj();
}

// QMCDeactivation ::= SEQUENCE
SRSASN_CODE qmc_deactivation_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, qo_e_ref_list, 1, 16, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE qmc_deactivation_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(qo_e_ref_list, bref, 1, 16, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void qmc_deactivation_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("qoEReferenceList");
  for (const auto& e1 : qo_e_ref_list) {
    j.write_str(e1.to_string());
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// RRCState ::= ENUMERATED
const char* rrc_state_opts::to_string() const
{
  static const char* names[] = {"inactive", "connected"};
  return convert_enum_idx(names, 2, value, "rrc_state_e");
}

// ResetType ::= CHOICE
void reset_type_c::destroy_()
{
  switch (type_) {
    case types::part_of_ng_interface:
      c.destroy<ue_associated_lc_ng_conn_list_l>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<reset_type_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void reset_type_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::ng_interface:
      break;
    case types::part_of_ng_interface:
      c.init<ue_associated_lc_ng_conn_list_l>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<reset_type_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "reset_type_c");
  }
}
reset_type_c::reset_type_c(const reset_type_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::ng_interface:
      c.init(other.c.get<reset_all_e>());
      break;
    case types::part_of_ng_interface:
      c.init(other.c.get<ue_associated_lc_ng_conn_list_l>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<reset_type_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "reset_type_c");
  }
}
reset_type_c& reset_type_c::operator=(const reset_type_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::ng_interface:
      c.set(other.c.get<reset_all_e>());
      break;
    case types::part_of_ng_interface:
      c.set(other.c.get<ue_associated_lc_ng_conn_list_l>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<reset_type_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "reset_type_c");
  }

  return *this;
}
reset_all_e& reset_type_c::set_ng_interface()
{
  set(types::ng_interface);
  return c.get<reset_all_e>();
}
ue_associated_lc_ng_conn_list_l& reset_type_c::set_part_of_ng_interface()
{
  set(types::part_of_ng_interface);
  return c.get<ue_associated_lc_ng_conn_list_l>();
}
protocol_ie_single_container_s<reset_type_ext_ies_o>& reset_type_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<reset_type_ext_ies_o>>();
}
void reset_type_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::ng_interface:
      j.write_str("nG-Interface", "reset-all");
      break;
    case types::part_of_ng_interface:
      j.start_array("partOfNG-Interface");
      for (const auto& e1 : c.get<ue_associated_lc_ng_conn_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<reset_type_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "reset_type_c");
  }
  j.end_obj();
}
SRSASN_CODE reset_type_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::ng_interface:
      HANDLE_CODE(c.get<reset_all_e>().pack(bref));
      break;
    case types::part_of_ng_interface:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<ue_associated_lc_ng_conn_list_l>(), 1, 65536, true));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<reset_type_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "reset_type_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE reset_type_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::ng_interface:
      HANDLE_CODE(c.get<reset_all_e>().unpack(bref));
      break;
    case types::part_of_ng_interface:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<ue_associated_lc_ng_conn_list_l>(), bref, 1, 65536, true));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<reset_type_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "reset_type_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* reset_type_c::types_opts::to_string() const
{
  static const char* names[] = {"nG-Interface", "partOfNG-Interface", "choice-Extensions"};
  return convert_enum_idx(names, 3, value, "reset_type_c::types");
}

// Suspend-Request-Indication ::= ENUMERATED
const char* suspend_request_ind_opts::to_string() const
{
  static const char* names[] = {"suspend-requested"};
  return convert_enum_idx(names, 1, value, "suspend_request_ind_e");
}

// Suspend-Response-Indication ::= ENUMERATED
const char* suspend_resp_ind_opts::to_string() const
{
  static const char* names[] = {"suspend-indicated"};
  return convert_enum_idx(names, 1, value, "suspend_resp_ind_e");
}

// UE-NGAP-IDs ::= CHOICE
void ue_ngap_ids_c::destroy_()
{
  switch (type_) {
    case types::ue_ngap_id_pair:
      c.destroy<ue_ngap_id_pair_s>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<ue_ngap_ids_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void ue_ngap_ids_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::ue_ngap_id_pair:
      c.init<ue_ngap_id_pair_s>();
      break;
    case types::amf_ue_ngap_id:
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<ue_ngap_ids_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_ngap_ids_c");
  }
}
ue_ngap_ids_c::ue_ngap_ids_c(const ue_ngap_ids_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::ue_ngap_id_pair:
      c.init(other.c.get<ue_ngap_id_pair_s>());
      break;
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<ue_ngap_ids_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_ngap_ids_c");
  }
}
ue_ngap_ids_c& ue_ngap_ids_c::operator=(const ue_ngap_ids_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::ue_ngap_id_pair:
      c.set(other.c.get<ue_ngap_id_pair_s>());
      break;
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<ue_ngap_ids_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_ngap_ids_c");
  }

  return *this;
}
ue_ngap_id_pair_s& ue_ngap_ids_c::set_ue_ngap_id_pair()
{
  set(types::ue_ngap_id_pair);
  return c.get<ue_ngap_id_pair_s>();
}
uint64_t& ue_ngap_ids_c::set_amf_ue_ngap_id()
{
  set(types::amf_ue_ngap_id);
  return c.get<uint64_t>();
}
protocol_ie_single_container_s<ue_ngap_ids_ext_ies_o>& ue_ngap_ids_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<ue_ngap_ids_ext_ies_o>>();
}
void ue_ngap_ids_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::ue_ngap_id_pair:
      j.write_fieldname("uE-NGAP-ID-pair");
      c.get<ue_ngap_id_pair_s>().to_json(j);
      break;
    case types::amf_ue_ngap_id:
      j.write_int("aMF-UE-NGAP-ID", c.get<uint64_t>());
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<ue_ngap_ids_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ue_ngap_ids_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_ngap_ids_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::ue_ngap_id_pair:
      HANDLE_CODE(c.get<ue_ngap_id_pair_s>().pack(bref));
      break;
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<ue_ngap_ids_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_ngap_ids_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_ngap_ids_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::ue_ngap_id_pair:
      HANDLE_CODE(c.get<ue_ngap_id_pair_s>().unpack(bref));
      break;
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<ue_ngap_ids_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_ngap_ids_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ue_ngap_ids_c::types_opts::to_string() const
{
  static const char* names[] = {"uE-NGAP-ID-pair", "aMF-UE-NGAP-ID", "choice-Extensions"};
  return convert_enum_idx(names, 3, value, "ue_ngap_ids_c::types");
}

// UEPagingIdentity ::= CHOICE
void ue_paging_id_c::destroy_()
{
  switch (type_) {
    case types::five_g_s_tmsi:
      c.destroy<five_g_s_tmsi_s>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<ue_paging_id_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void ue_paging_id_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::five_g_s_tmsi:
      c.init<five_g_s_tmsi_s>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<ue_paging_id_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_paging_id_c");
  }
}
ue_paging_id_c::ue_paging_id_c(const ue_paging_id_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::five_g_s_tmsi:
      c.init(other.c.get<five_g_s_tmsi_s>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<ue_paging_id_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_paging_id_c");
  }
}
ue_paging_id_c& ue_paging_id_c::operator=(const ue_paging_id_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::five_g_s_tmsi:
      c.set(other.c.get<five_g_s_tmsi_s>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<ue_paging_id_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_paging_id_c");
  }

  return *this;
}
five_g_s_tmsi_s& ue_paging_id_c::set_five_g_s_tmsi()
{
  set(types::five_g_s_tmsi);
  return c.get<five_g_s_tmsi_s>();
}
protocol_ie_single_container_s<ue_paging_id_ext_ies_o>& ue_paging_id_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<ue_paging_id_ext_ies_o>>();
}
void ue_paging_id_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::five_g_s_tmsi:
      j.write_fieldname("fiveG-S-TMSI");
      c.get<five_g_s_tmsi_s>().to_json(j);
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<ue_paging_id_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ue_paging_id_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_paging_id_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::five_g_s_tmsi:
      HANDLE_CODE(c.get<five_g_s_tmsi_s>().pack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<ue_paging_id_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_paging_id_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_paging_id_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::five_g_s_tmsi:
      HANDLE_CODE(c.get<five_g_s_tmsi_s>().unpack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<ue_paging_id_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_paging_id_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ue_paging_id_c::types_opts::to_string() const
{
  static const char* names[] = {"fiveG-S-TMSI", "choice-Extensions"};
  return convert_enum_idx(names, 2, value, "ue_paging_id_c::types");
}
uint8_t ue_paging_id_c::types_opts::to_number() const
{
  static const uint8_t numbers[] = {5};
  return map_enum_number(numbers, 1, value, "ue_paging_id_c::types");
}

// UERetentionInformation ::= ENUMERATED
const char* ue_retention_info_opts::to_string() const
{
  static const char* names[] = {"ues-retained"};
  return convert_enum_idx(names, 1, value, "ue_retention_info_e");
}

// UL-CP-SecurityInformation ::= SEQUENCE
SRSASN_CODE ul_cp_security_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(ul_nas_mac.pack(bref));
  HANDLE_CODE(ul_nas_count.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ul_cp_security_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(ul_nas_mac.unpack(bref));
  HANDLE_CODE(ul_nas_count.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ul_cp_security_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("ul-NAS-MAC", ul_nas_mac.to_string());
  j.write_str("ul-NAS-Count", ul_nas_count.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// WUS-Assistance-Information ::= SEQUENCE
SRSASN_CODE wus_assist_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(paging_probability_info.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE wus_assist_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(paging_probability_info.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void wus_assist_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("pagingProbabilityInformation", paging_probability_info.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// WarningAreaList ::= CHOICE
void warning_area_list_c::destroy_()
{
  switch (type_) {
    case types::eutra_cgi_list_for_warning:
      c.destroy<eutra_cgi_list_for_warning_l>();
      break;
    case types::nr_cgi_list_for_warning:
      c.destroy<nr_cgi_list_for_warning_l>();
      break;
    case types::tai_list_for_warning:
      c.destroy<tai_list_for_warning_l>();
      break;
    case types::emergency_area_id_list:
      c.destroy<emergency_area_id_list_l>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<warning_area_list_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void warning_area_list_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::eutra_cgi_list_for_warning:
      c.init<eutra_cgi_list_for_warning_l>();
      break;
    case types::nr_cgi_list_for_warning:
      c.init<nr_cgi_list_for_warning_l>();
      break;
    case types::tai_list_for_warning:
      c.init<tai_list_for_warning_l>();
      break;
    case types::emergency_area_id_list:
      c.init<emergency_area_id_list_l>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<warning_area_list_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "warning_area_list_c");
  }
}
warning_area_list_c::warning_area_list_c(const warning_area_list_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::eutra_cgi_list_for_warning:
      c.init(other.c.get<eutra_cgi_list_for_warning_l>());
      break;
    case types::nr_cgi_list_for_warning:
      c.init(other.c.get<nr_cgi_list_for_warning_l>());
      break;
    case types::tai_list_for_warning:
      c.init(other.c.get<tai_list_for_warning_l>());
      break;
    case types::emergency_area_id_list:
      c.init(other.c.get<emergency_area_id_list_l>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<warning_area_list_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "warning_area_list_c");
  }
}
warning_area_list_c& warning_area_list_c::operator=(const warning_area_list_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::eutra_cgi_list_for_warning:
      c.set(other.c.get<eutra_cgi_list_for_warning_l>());
      break;
    case types::nr_cgi_list_for_warning:
      c.set(other.c.get<nr_cgi_list_for_warning_l>());
      break;
    case types::tai_list_for_warning:
      c.set(other.c.get<tai_list_for_warning_l>());
      break;
    case types::emergency_area_id_list:
      c.set(other.c.get<emergency_area_id_list_l>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<warning_area_list_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "warning_area_list_c");
  }

  return *this;
}
eutra_cgi_list_for_warning_l& warning_area_list_c::set_eutra_cgi_list_for_warning()
{
  set(types::eutra_cgi_list_for_warning);
  return c.get<eutra_cgi_list_for_warning_l>();
}
nr_cgi_list_for_warning_l& warning_area_list_c::set_nr_cgi_list_for_warning()
{
  set(types::nr_cgi_list_for_warning);
  return c.get<nr_cgi_list_for_warning_l>();
}
tai_list_for_warning_l& warning_area_list_c::set_tai_list_for_warning()
{
  set(types::tai_list_for_warning);
  return c.get<tai_list_for_warning_l>();
}
emergency_area_id_list_l& warning_area_list_c::set_emergency_area_id_list()
{
  set(types::emergency_area_id_list);
  return c.get<emergency_area_id_list_l>();
}
protocol_ie_single_container_s<warning_area_list_ext_ies_o>& warning_area_list_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<warning_area_list_ext_ies_o>>();
}
void warning_area_list_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::eutra_cgi_list_for_warning:
      j.start_array("eUTRA-CGIListForWarning");
      for (const auto& e1 : c.get<eutra_cgi_list_for_warning_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::nr_cgi_list_for_warning:
      j.start_array("nR-CGIListForWarning");
      for (const auto& e1 : c.get<nr_cgi_list_for_warning_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::tai_list_for_warning:
      j.start_array("tAIListForWarning");
      for (const auto& e1 : c.get<tai_list_for_warning_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::emergency_area_id_list:
      j.start_array("emergencyAreaIDList");
      for (const auto& e1 : c.get<emergency_area_id_list_l>()) {
        j.write_str(e1.to_string());
      }
      j.end_array();
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<warning_area_list_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "warning_area_list_c");
  }
  j.end_obj();
}
SRSASN_CODE warning_area_list_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::eutra_cgi_list_for_warning:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<eutra_cgi_list_for_warning_l>(), 1, 65535, true));
      break;
    case types::nr_cgi_list_for_warning:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<nr_cgi_list_for_warning_l>(), 1, 65535, true));
      break;
    case types::tai_list_for_warning:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<tai_list_for_warning_l>(), 1, 65535, true));
      break;
    case types::emergency_area_id_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<emergency_area_id_list_l>(), 1, 65535, true));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<warning_area_list_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "warning_area_list_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE warning_area_list_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::eutra_cgi_list_for_warning:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<eutra_cgi_list_for_warning_l>(), bref, 1, 65535, true));
      break;
    case types::nr_cgi_list_for_warning:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<nr_cgi_list_for_warning_l>(), bref, 1, 65535, true));
      break;
    case types::tai_list_for_warning:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<tai_list_for_warning_l>(), bref, 1, 65535, true));
      break;
    case types::emergency_area_id_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<emergency_area_id_list_l>(), bref, 1, 65535, true));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<warning_area_list_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "warning_area_list_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* warning_area_list_c::types_opts::to_string() const
{
  static const char* names[] = {"eUTRA-CGIListForWarning",
                                "nR-CGIListForWarning",
                                "tAIListForWarning",
                                "emergencyAreaIDList",
                                "choice-Extensions"};
  return convert_enum_idx(names, 5, value, "warning_area_list_c::types");
}

// LocationReportIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t location_report_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 121, 116, 33};
  return map_enum_number(names, 5, idx, "id");
}
bool location_report_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 121, 116, 33};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e location_report_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 121:
      return crit_e::ignore;
    case 116:
      return crit_e::ignore;
    case 33:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
location_report_ies_o::value_c location_report_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 121:
      ret.set(value_c::types::user_location_info);
      break;
    case 116:
      ret.set(value_c::types::ue_presence_in_area_of_interest_list);
      break;
    case 33:
      ret.set(value_c::types::location_report_request_type);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e location_report_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 121:
      return presence_e::mandatory;
    case 116:
      return presence_e::optional;
    case 33:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void location_report_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::user_location_info:
      c.destroy<user_location_info_c>();
      break;
    case types::ue_presence_in_area_of_interest_list:
      c.destroy<ue_presence_in_area_of_interest_list_l>();
      break;
    case types::location_report_request_type:
      c.destroy<location_report_request_type_s>();
      break;
    default:
      break;
  }
}
void location_report_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::user_location_info:
      c.init<user_location_info_c>();
      break;
    case types::ue_presence_in_area_of_interest_list:
      c.init<ue_presence_in_area_of_interest_list_l>();
      break;
    case types::location_report_request_type:
      c.init<location_report_request_type_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "location_report_ies_o::value_c");
  }
}
location_report_ies_o::value_c::value_c(const location_report_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::user_location_info:
      c.init(other.c.get<user_location_info_c>());
      break;
    case types::ue_presence_in_area_of_interest_list:
      c.init(other.c.get<ue_presence_in_area_of_interest_list_l>());
      break;
    case types::location_report_request_type:
      c.init(other.c.get<location_report_request_type_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "location_report_ies_o::value_c");
  }
}
location_report_ies_o::value_c& location_report_ies_o::value_c::operator=(const location_report_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::user_location_info:
      c.set(other.c.get<user_location_info_c>());
      break;
    case types::ue_presence_in_area_of_interest_list:
      c.set(other.c.get<ue_presence_in_area_of_interest_list_l>());
      break;
    case types::location_report_request_type:
      c.set(other.c.get<location_report_request_type_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "location_report_ies_o::value_c");
  }

  return *this;
}
uint64_t& location_report_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& location_report_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
user_location_info_c& location_report_ies_o::value_c::user_location_info()
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
ue_presence_in_area_of_interest_list_l& location_report_ies_o::value_c::ue_presence_in_area_of_interest_list()
{
  assert_choice_type(types::ue_presence_in_area_of_interest_list, type_, "Value");
  return c.get<ue_presence_in_area_of_interest_list_l>();
}
location_report_request_type_s& location_report_ies_o::value_c::location_report_request_type()
{
  assert_choice_type(types::location_report_request_type, type_, "Value");
  return c.get<location_report_request_type_s>();
}
const uint64_t& location_report_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& location_report_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const user_location_info_c& location_report_ies_o::value_c::user_location_info() const
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
const ue_presence_in_area_of_interest_list_l&
location_report_ies_o::value_c::ue_presence_in_area_of_interest_list() const
{
  assert_choice_type(types::ue_presence_in_area_of_interest_list, type_, "Value");
  return c.get<ue_presence_in_area_of_interest_list_l>();
}
const location_report_request_type_s& location_report_ies_o::value_c::location_report_request_type() const
{
  assert_choice_type(types::location_report_request_type, type_, "Value");
  return c.get<location_report_request_type_s>();
}
void location_report_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::user_location_info:
      j.write_fieldname("UserLocationInformation");
      c.get<user_location_info_c>().to_json(j);
      break;
    case types::ue_presence_in_area_of_interest_list:
      j.start_array("UEPresenceInAreaOfInterestList");
      for (const auto& e1 : c.get<ue_presence_in_area_of_interest_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::location_report_request_type:
      j.write_fieldname("LocationReportingRequestType");
      c.get<location_report_request_type_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "location_report_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE location_report_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().pack(bref));
      break;
    case types::ue_presence_in_area_of_interest_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<ue_presence_in_area_of_interest_list_l>(), 1, 64, true));
      break;
    case types::location_report_request_type:
      HANDLE_CODE(c.get<location_report_request_type_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "location_report_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE location_report_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().unpack(bref));
      break;
    case types::ue_presence_in_area_of_interest_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<ue_presence_in_area_of_interest_list_l>(), bref, 1, 64, true));
      break;
    case types::location_report_request_type:
      HANDLE_CODE(c.get<location_report_request_type_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "location_report_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* location_report_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..1099511627775)",
                                "INTEGER (0..4294967295)",
                                "UserLocationInformation",
                                "UEPresenceInAreaOfInterestList",
                                "LocationReportingRequestType"};
  return convert_enum_idx(names, 5, value, "location_report_ies_o::value_c::types");
}

// LocationReportingControlIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t location_report_ctrl_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 33};
  return map_enum_number(names, 3, idx, "id");
}
bool location_report_ctrl_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 33};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e location_report_ctrl_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 33:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
location_report_ctrl_ies_o::value_c location_report_ctrl_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 33:
      ret.set(value_c::types::location_report_request_type);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e location_report_ctrl_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 33:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void location_report_ctrl_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::location_report_request_type:
      c.destroy<location_report_request_type_s>();
      break;
    default:
      break;
  }
}
void location_report_ctrl_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::location_report_request_type:
      c.init<location_report_request_type_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "location_report_ctrl_ies_o::value_c");
  }
}
location_report_ctrl_ies_o::value_c::value_c(const location_report_ctrl_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::location_report_request_type:
      c.init(other.c.get<location_report_request_type_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "location_report_ctrl_ies_o::value_c");
  }
}
location_report_ctrl_ies_o::value_c&
location_report_ctrl_ies_o::value_c::operator=(const location_report_ctrl_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::location_report_request_type:
      c.set(other.c.get<location_report_request_type_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "location_report_ctrl_ies_o::value_c");
  }

  return *this;
}
uint64_t& location_report_ctrl_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& location_report_ctrl_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
location_report_request_type_s& location_report_ctrl_ies_o::value_c::location_report_request_type()
{
  assert_choice_type(types::location_report_request_type, type_, "Value");
  return c.get<location_report_request_type_s>();
}
const uint64_t& location_report_ctrl_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& location_report_ctrl_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const location_report_request_type_s& location_report_ctrl_ies_o::value_c::location_report_request_type() const
{
  assert_choice_type(types::location_report_request_type, type_, "Value");
  return c.get<location_report_request_type_s>();
}
void location_report_ctrl_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::location_report_request_type:
      j.write_fieldname("LocationReportingRequestType");
      c.get<location_report_request_type_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "location_report_ctrl_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE location_report_ctrl_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::location_report_request_type:
      HANDLE_CODE(c.get<location_report_request_type_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "location_report_ctrl_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE location_report_ctrl_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::location_report_request_type:
      HANDLE_CODE(c.get<location_report_request_type_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "location_report_ctrl_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* location_report_ctrl_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {
      "INTEGER (0..1099511627775)", "INTEGER (0..4294967295)", "LocationReportingRequestType"};
  return convert_enum_idx(names, 3, value, "location_report_ctrl_ies_o::value_c::types");
}

// LocationReportingFailureIndicationIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t location_report_fail_ind_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 15};
  return map_enum_number(names, 3, idx, "id");
}
bool location_report_fail_ind_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 15};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e location_report_fail_ind_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 15:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
location_report_fail_ind_ies_o::value_c location_report_fail_ind_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 15:
      ret.set(value_c::types::cause);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e location_report_fail_ind_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 15:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void location_report_fail_ind_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::cause:
      c.destroy<cause_c>();
      break;
    default:
      break;
  }
}
void location_report_fail_ind_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::cause:
      c.init<cause_c>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "location_report_fail_ind_ies_o::value_c");
  }
}
location_report_fail_ind_ies_o::value_c::value_c(const location_report_fail_ind_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "location_report_fail_ind_ies_o::value_c");
  }
}
location_report_fail_ind_ies_o::value_c&
location_report_fail_ind_ies_o::value_c::operator=(const location_report_fail_ind_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "location_report_fail_ind_ies_o::value_c");
  }

  return *this;
}
uint64_t& location_report_fail_ind_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& location_report_fail_ind_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
cause_c& location_report_fail_ind_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const uint64_t& location_report_fail_ind_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& location_report_fail_ind_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const cause_c& location_report_fail_ind_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
void location_report_fail_ind_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "location_report_fail_ind_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE location_report_fail_ind_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "location_report_fail_ind_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE location_report_fail_ind_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "location_report_fail_ind_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* location_report_fail_ind_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..1099511627775)", "INTEGER (0..4294967295)", "Cause"};
  return convert_enum_idx(names, 3, value, "location_report_fail_ind_ies_o::value_c::types");
}

// MulticastGroupPagingIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t multicast_group_paging_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 298, 307};
  return map_enum_number(names, 3, idx, "id");
}
bool multicast_group_paging_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 298, 307};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e multicast_group_paging_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::ignore;
    case 298:
      return crit_e::ignore;
    case 307:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
multicast_group_paging_ies_o::value_c multicast_group_paging_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 298:
      ret.set(value_c::types::mbs_service_area);
      break;
    case 307:
      ret.set(value_c::types::multicast_group_paging_area_list);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e multicast_group_paging_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 298:
      return presence_e::optional;
    case 307:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void multicast_group_paging_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::mbs_session_id:
      c.destroy<mbs_session_id_s>();
      break;
    case types::mbs_service_area:
      c.destroy<mbs_service_area_c>();
      break;
    case types::multicast_group_paging_area_list:
      c.destroy<multicast_group_paging_area_list_l>();
      break;
    default:
      break;
  }
}
void multicast_group_paging_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c.init<mbs_session_id_s>();
      break;
    case types::mbs_service_area:
      c.init<mbs_service_area_c>();
      break;
    case types::multicast_group_paging_area_list:
      c.init<multicast_group_paging_area_list_l>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_group_paging_ies_o::value_c");
  }
}
multicast_group_paging_ies_o::value_c::value_c(const multicast_group_paging_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mbs_session_id:
      c.init(other.c.get<mbs_session_id_s>());
      break;
    case types::mbs_service_area:
      c.init(other.c.get<mbs_service_area_c>());
      break;
    case types::multicast_group_paging_area_list:
      c.init(other.c.get<multicast_group_paging_area_list_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_group_paging_ies_o::value_c");
  }
}
multicast_group_paging_ies_o::value_c&
multicast_group_paging_ies_o::value_c::operator=(const multicast_group_paging_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mbs_session_id:
      c.set(other.c.get<mbs_session_id_s>());
      break;
    case types::mbs_service_area:
      c.set(other.c.get<mbs_service_area_c>());
      break;
    case types::multicast_group_paging_area_list:
      c.set(other.c.get<multicast_group_paging_area_list_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_group_paging_ies_o::value_c");
  }

  return *this;
}
mbs_session_id_s& multicast_group_paging_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
mbs_service_area_c& multicast_group_paging_ies_o::value_c::mbs_service_area()
{
  assert_choice_type(types::mbs_service_area, type_, "Value");
  return c.get<mbs_service_area_c>();
}
multicast_group_paging_area_list_l& multicast_group_paging_ies_o::value_c::multicast_group_paging_area_list()
{
  assert_choice_type(types::multicast_group_paging_area_list, type_, "Value");
  return c.get<multicast_group_paging_area_list_l>();
}
const mbs_session_id_s& multicast_group_paging_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const mbs_service_area_c& multicast_group_paging_ies_o::value_c::mbs_service_area() const
{
  assert_choice_type(types::mbs_service_area, type_, "Value");
  return c.get<mbs_service_area_c>();
}
const multicast_group_paging_area_list_l&
multicast_group_paging_ies_o::value_c::multicast_group_paging_area_list() const
{
  assert_choice_type(types::multicast_group_paging_area_list, type_, "Value");
  return c.get<multicast_group_paging_area_list_l>();
}
void multicast_group_paging_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::mbs_service_area:
      j.write_fieldname("MBS-ServiceArea");
      c.get<mbs_service_area_c>().to_json(j);
      break;
    case types::multicast_group_paging_area_list:
      j.start_array("MulticastGroupPagingAreaList");
      for (const auto& e1 : c.get<multicast_group_paging_area_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    default:
      log_invalid_choice_id(type_, "multicast_group_paging_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE multicast_group_paging_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::mbs_service_area:
      HANDLE_CODE(c.get<mbs_service_area_c>().pack(bref));
      break;
    case types::multicast_group_paging_area_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<multicast_group_paging_area_list_l>(), 1, 64, true));
      break;
    default:
      log_invalid_choice_id(type_, "multicast_group_paging_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_group_paging_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::mbs_service_area:
      HANDLE_CODE(c.get<mbs_service_area_c>().unpack(bref));
      break;
    case types::multicast_group_paging_area_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<multicast_group_paging_area_list_l>(), bref, 1, 64, true));
      break;
    default:
      log_invalid_choice_id(type_, "multicast_group_paging_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* multicast_group_paging_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"MBS-SessionID", "MBS-ServiceArea", "MulticastGroupPagingAreaList"};
  return convert_enum_idx(names, 3, value, "multicast_group_paging_ies_o::value_c::types");
}

// MulticastSessionActivationFailureIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t multicast_session_activation_fail_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 15, 19};
  return map_enum_number(names, 3, idx, "id");
}
bool multicast_session_activation_fail_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 15, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e multicast_session_activation_fail_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::reject;
    case 15:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
multicast_session_activation_fail_ies_o::value_c multicast_session_activation_fail_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 15:
      ret.set(value_c::types::cause);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e multicast_session_activation_fail_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 15:
      return presence_e::mandatory;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void multicast_session_activation_fail_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::mbs_session_id:
      c.destroy<mbs_session_id_s>();
      break;
    case types::cause:
      c.destroy<cause_c>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void multicast_session_activation_fail_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c.init<mbs_session_id_s>();
      break;
    case types::cause:
      c.init<cause_c>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_activation_fail_ies_o::value_c");
  }
}
multicast_session_activation_fail_ies_o::value_c::value_c(const multicast_session_activation_fail_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mbs_session_id:
      c.init(other.c.get<mbs_session_id_s>());
      break;
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_activation_fail_ies_o::value_c");
  }
}
multicast_session_activation_fail_ies_o::value_c& multicast_session_activation_fail_ies_o::value_c::operator=(
    const multicast_session_activation_fail_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mbs_session_id:
      c.set(other.c.get<mbs_session_id_s>());
      break;
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_activation_fail_ies_o::value_c");
  }

  return *this;
}
mbs_session_id_s& multicast_session_activation_fail_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
cause_c& multicast_session_activation_fail_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
crit_diagnostics_s& multicast_session_activation_fail_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const mbs_session_id_s& multicast_session_activation_fail_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const cause_c& multicast_session_activation_fail_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const crit_diagnostics_s& multicast_session_activation_fail_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void multicast_session_activation_fail_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_activation_fail_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE multicast_session_activation_fail_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_activation_fail_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_session_activation_fail_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_activation_fail_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* multicast_session_activation_fail_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"MBS-SessionID", "Cause", "CriticalityDiagnostics"};
  return convert_enum_idx(names, 3, value, "multicast_session_activation_fail_ies_o::value_c::types");
}

// MulticastSessionActivationRequestIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t multicast_session_activation_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 304};
  return map_enum_number(names, 2, idx, "id");
}
bool multicast_session_activation_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 304};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e multicast_session_activation_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::reject;
    case 304:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
multicast_session_activation_request_ies_o::value_c
multicast_session_activation_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 304:
      ret.set(value_c::types::multicast_session_activation_request_transfer);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e multicast_session_activation_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 304:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void multicast_session_activation_request_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::mbs_session_id:
      c.destroy<mbs_session_id_s>();
      break;
    case types::multicast_session_activation_request_transfer:
      c.destroy<unbounded_octstring<true>>();
      break;
    default:
      break;
  }
}
void multicast_session_activation_request_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c.init<mbs_session_id_s>();
      break;
    case types::multicast_session_activation_request_transfer:
      c.init<unbounded_octstring<true>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_activation_request_ies_o::value_c");
  }
}
multicast_session_activation_request_ies_o::value_c::value_c(
    const multicast_session_activation_request_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mbs_session_id:
      c.init(other.c.get<mbs_session_id_s>());
      break;
    case types::multicast_session_activation_request_transfer:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_activation_request_ies_o::value_c");
  }
}
multicast_session_activation_request_ies_o::value_c& multicast_session_activation_request_ies_o::value_c::operator=(
    const multicast_session_activation_request_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mbs_session_id:
      c.set(other.c.get<mbs_session_id_s>());
      break;
    case types::multicast_session_activation_request_transfer:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_activation_request_ies_o::value_c");
  }

  return *this;
}
mbs_session_id_s& multicast_session_activation_request_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
unbounded_octstring<true>&
multicast_session_activation_request_ies_o::value_c::multicast_session_activation_request_transfer()
{
  assert_choice_type(types::multicast_session_activation_request_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const mbs_session_id_s& multicast_session_activation_request_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const unbounded_octstring<true>&
multicast_session_activation_request_ies_o::value_c::multicast_session_activation_request_transfer() const
{
  assert_choice_type(types::multicast_session_activation_request_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
void multicast_session_activation_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::multicast_session_activation_request_transfer:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_activation_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE multicast_session_activation_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::multicast_session_activation_request_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_activation_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_session_activation_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::multicast_session_activation_request_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_activation_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* multicast_session_activation_request_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"MBS-SessionID", "OCTET STRING"};
  return convert_enum_idx(names, 2, value, "multicast_session_activation_request_ies_o::value_c::types");
}

// MulticastSessionActivationResponseIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t multicast_session_activation_resp_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 19};
  return map_enum_number(names, 2, idx, "id");
}
bool multicast_session_activation_resp_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e multicast_session_activation_resp_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::reject;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
multicast_session_activation_resp_ies_o::value_c multicast_session_activation_resp_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e multicast_session_activation_resp_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void multicast_session_activation_resp_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::mbs_session_id:
      c.destroy<mbs_session_id_s>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void multicast_session_activation_resp_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c.init<mbs_session_id_s>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_activation_resp_ies_o::value_c");
  }
}
multicast_session_activation_resp_ies_o::value_c::value_c(const multicast_session_activation_resp_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mbs_session_id:
      c.init(other.c.get<mbs_session_id_s>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_activation_resp_ies_o::value_c");
  }
}
multicast_session_activation_resp_ies_o::value_c& multicast_session_activation_resp_ies_o::value_c::operator=(
    const multicast_session_activation_resp_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mbs_session_id:
      c.set(other.c.get<mbs_session_id_s>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_activation_resp_ies_o::value_c");
  }

  return *this;
}
mbs_session_id_s& multicast_session_activation_resp_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
crit_diagnostics_s& multicast_session_activation_resp_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const mbs_session_id_s& multicast_session_activation_resp_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const crit_diagnostics_s& multicast_session_activation_resp_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void multicast_session_activation_resp_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_activation_resp_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE multicast_session_activation_resp_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_activation_resp_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_session_activation_resp_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_activation_resp_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* multicast_session_activation_resp_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"MBS-SessionID", "CriticalityDiagnostics"};
  return convert_enum_idx(names, 2, value, "multicast_session_activation_resp_ies_o::value_c::types");
}

// MulticastSessionDeactivationRequestIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t multicast_session_deactivation_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 305};
  return map_enum_number(names, 2, idx, "id");
}
bool multicast_session_deactivation_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 305};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e multicast_session_deactivation_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::reject;
    case 305:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
multicast_session_deactivation_request_ies_o::value_c
multicast_session_deactivation_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 305:
      ret.set(value_c::types::multicast_session_deactivation_request_transfer);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e multicast_session_deactivation_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 305:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void multicast_session_deactivation_request_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::mbs_session_id:
      c.destroy<mbs_session_id_s>();
      break;
    case types::multicast_session_deactivation_request_transfer:
      c.destroy<unbounded_octstring<true>>();
      break;
    default:
      break;
  }
}
void multicast_session_deactivation_request_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c.init<mbs_session_id_s>();
      break;
    case types::multicast_session_deactivation_request_transfer:
      c.init<unbounded_octstring<true>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_deactivation_request_ies_o::value_c");
  }
}
multicast_session_deactivation_request_ies_o::value_c::value_c(
    const multicast_session_deactivation_request_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mbs_session_id:
      c.init(other.c.get<mbs_session_id_s>());
      break;
    case types::multicast_session_deactivation_request_transfer:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_deactivation_request_ies_o::value_c");
  }
}
multicast_session_deactivation_request_ies_o::value_c& multicast_session_deactivation_request_ies_o::value_c::operator=(
    const multicast_session_deactivation_request_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mbs_session_id:
      c.set(other.c.get<mbs_session_id_s>());
      break;
    case types::multicast_session_deactivation_request_transfer:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_deactivation_request_ies_o::value_c");
  }

  return *this;
}
mbs_session_id_s& multicast_session_deactivation_request_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
unbounded_octstring<true>&
multicast_session_deactivation_request_ies_o::value_c::multicast_session_deactivation_request_transfer()
{
  assert_choice_type(types::multicast_session_deactivation_request_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const mbs_session_id_s& multicast_session_deactivation_request_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const unbounded_octstring<true>&
multicast_session_deactivation_request_ies_o::value_c::multicast_session_deactivation_request_transfer() const
{
  assert_choice_type(types::multicast_session_deactivation_request_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
void multicast_session_deactivation_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::multicast_session_deactivation_request_transfer:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_deactivation_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE multicast_session_deactivation_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::multicast_session_deactivation_request_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_deactivation_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_session_deactivation_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::multicast_session_deactivation_request_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_deactivation_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* multicast_session_deactivation_request_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"MBS-SessionID", "OCTET STRING"};
  return convert_enum_idx(names, 2, value, "multicast_session_deactivation_request_ies_o::value_c::types");
}

// MulticastSessionDeactivationResponseIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t multicast_session_deactivation_resp_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 19};
  return map_enum_number(names, 2, idx, "id");
}
bool multicast_session_deactivation_resp_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e multicast_session_deactivation_resp_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::reject;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
multicast_session_deactivation_resp_ies_o::value_c
multicast_session_deactivation_resp_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e multicast_session_deactivation_resp_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void multicast_session_deactivation_resp_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::mbs_session_id:
      c.destroy<mbs_session_id_s>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void multicast_session_deactivation_resp_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c.init<mbs_session_id_s>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_deactivation_resp_ies_o::value_c");
  }
}
multicast_session_deactivation_resp_ies_o::value_c::value_c(
    const multicast_session_deactivation_resp_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mbs_session_id:
      c.init(other.c.get<mbs_session_id_s>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_deactivation_resp_ies_o::value_c");
  }
}
multicast_session_deactivation_resp_ies_o::value_c& multicast_session_deactivation_resp_ies_o::value_c::operator=(
    const multicast_session_deactivation_resp_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mbs_session_id:
      c.set(other.c.get<mbs_session_id_s>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_deactivation_resp_ies_o::value_c");
  }

  return *this;
}
mbs_session_id_s& multicast_session_deactivation_resp_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
crit_diagnostics_s& multicast_session_deactivation_resp_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const mbs_session_id_s& multicast_session_deactivation_resp_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const crit_diagnostics_s& multicast_session_deactivation_resp_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void multicast_session_deactivation_resp_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_deactivation_resp_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE multicast_session_deactivation_resp_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_deactivation_resp_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_session_deactivation_resp_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_deactivation_resp_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* multicast_session_deactivation_resp_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"MBS-SessionID", "CriticalityDiagnostics"};
  return convert_enum_idx(names, 2, value, "multicast_session_deactivation_resp_ies_o::value_c::types");
}

// MulticastSessionUpdateFailureIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t multicast_session_upd_fail_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 295, 15, 19};
  return map_enum_number(names, 4, idx, "id");
}
bool multicast_session_upd_fail_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 295, 15, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e multicast_session_upd_fail_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::reject;
    case 295:
      return crit_e::reject;
    case 15:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
multicast_session_upd_fail_ies_o::value_c multicast_session_upd_fail_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 295:
      ret.set(value_c::types::mbs_area_session_id);
      break;
    case 15:
      ret.set(value_c::types::cause);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e multicast_session_upd_fail_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 295:
      return presence_e::optional;
    case 15:
      return presence_e::mandatory;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void multicast_session_upd_fail_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::mbs_session_id:
      c.destroy<mbs_session_id_s>();
      break;
    case types::cause:
      c.destroy<cause_c>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void multicast_session_upd_fail_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c.init<mbs_session_id_s>();
      break;
    case types::mbs_area_session_id:
      break;
    case types::cause:
      c.init<cause_c>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_upd_fail_ies_o::value_c");
  }
}
multicast_session_upd_fail_ies_o::value_c::value_c(const multicast_session_upd_fail_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mbs_session_id:
      c.init(other.c.get<mbs_session_id_s>());
      break;
    case types::mbs_area_session_id:
      c.init(other.c.get<uint32_t>());
      break;
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_upd_fail_ies_o::value_c");
  }
}
multicast_session_upd_fail_ies_o::value_c&
multicast_session_upd_fail_ies_o::value_c::operator=(const multicast_session_upd_fail_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mbs_session_id:
      c.set(other.c.get<mbs_session_id_s>());
      break;
    case types::mbs_area_session_id:
      c.set(other.c.get<uint32_t>());
      break;
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_upd_fail_ies_o::value_c");
  }

  return *this;
}
mbs_session_id_s& multicast_session_upd_fail_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
uint32_t& multicast_session_upd_fail_ies_o::value_c::mbs_area_session_id()
{
  assert_choice_type(types::mbs_area_session_id, type_, "Value");
  return c.get<uint32_t>();
}
cause_c& multicast_session_upd_fail_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
crit_diagnostics_s& multicast_session_upd_fail_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const mbs_session_id_s& multicast_session_upd_fail_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const uint32_t& multicast_session_upd_fail_ies_o::value_c::mbs_area_session_id() const
{
  assert_choice_type(types::mbs_area_session_id, type_, "Value");
  return c.get<uint32_t>();
}
const cause_c& multicast_session_upd_fail_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const crit_diagnostics_s& multicast_session_upd_fail_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void multicast_session_upd_fail_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::mbs_area_session_id:
      j.write_int("INTEGER (0..65535,...)", c.get<uint32_t>());
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_upd_fail_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE multicast_session_upd_fail_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::mbs_area_session_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)65535u, true, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_upd_fail_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_session_upd_fail_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::mbs_area_session_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)65535u, true, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_upd_fail_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* multicast_session_upd_fail_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"MBS-SessionID", "INTEGER (0..65535,...)", "Cause", "CriticalityDiagnostics"};
  return convert_enum_idx(names, 4, value, "multicast_session_upd_fail_ies_o::value_c::types");
}
uint8_t multicast_session_upd_fail_ies_o::value_c::types_opts::to_number() const
{
  if (value == mbs_area_session_id) {
    return 0;
  }
  invalid_enum_number(value, "multicast_session_upd_fail_ies_o::value_c::types");
  return 0;
}

// MulticastSessionUpdateRequestIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t multicast_session_upd_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 295, 306};
  return map_enum_number(names, 3, idx, "id");
}
bool multicast_session_upd_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 295, 306};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e multicast_session_upd_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::reject;
    case 295:
      return crit_e::reject;
    case 306:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
multicast_session_upd_request_ies_o::value_c multicast_session_upd_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 295:
      ret.set(value_c::types::mbs_area_session_id);
      break;
    case 306:
      ret.set(value_c::types::multicast_session_upd_request_transfer);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e multicast_session_upd_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 295:
      return presence_e::optional;
    case 306:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void multicast_session_upd_request_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::mbs_session_id:
      c.destroy<mbs_session_id_s>();
      break;
    case types::multicast_session_upd_request_transfer:
      c.destroy<unbounded_octstring<true>>();
      break;
    default:
      break;
  }
}
void multicast_session_upd_request_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c.init<mbs_session_id_s>();
      break;
    case types::mbs_area_session_id:
      break;
    case types::multicast_session_upd_request_transfer:
      c.init<unbounded_octstring<true>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_upd_request_ies_o::value_c");
  }
}
multicast_session_upd_request_ies_o::value_c::value_c(const multicast_session_upd_request_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mbs_session_id:
      c.init(other.c.get<mbs_session_id_s>());
      break;
    case types::mbs_area_session_id:
      c.init(other.c.get<uint32_t>());
      break;
    case types::multicast_session_upd_request_transfer:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_upd_request_ies_o::value_c");
  }
}
multicast_session_upd_request_ies_o::value_c&
multicast_session_upd_request_ies_o::value_c::operator=(const multicast_session_upd_request_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mbs_session_id:
      c.set(other.c.get<mbs_session_id_s>());
      break;
    case types::mbs_area_session_id:
      c.set(other.c.get<uint32_t>());
      break;
    case types::multicast_session_upd_request_transfer:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_upd_request_ies_o::value_c");
  }

  return *this;
}
mbs_session_id_s& multicast_session_upd_request_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
uint32_t& multicast_session_upd_request_ies_o::value_c::mbs_area_session_id()
{
  assert_choice_type(types::mbs_area_session_id, type_, "Value");
  return c.get<uint32_t>();
}
unbounded_octstring<true>& multicast_session_upd_request_ies_o::value_c::multicast_session_upd_request_transfer()
{
  assert_choice_type(types::multicast_session_upd_request_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const mbs_session_id_s& multicast_session_upd_request_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const uint32_t& multicast_session_upd_request_ies_o::value_c::mbs_area_session_id() const
{
  assert_choice_type(types::mbs_area_session_id, type_, "Value");
  return c.get<uint32_t>();
}
const unbounded_octstring<true>&
multicast_session_upd_request_ies_o::value_c::multicast_session_upd_request_transfer() const
{
  assert_choice_type(types::multicast_session_upd_request_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
void multicast_session_upd_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::mbs_area_session_id:
      j.write_int("INTEGER (0..65535,...)", c.get<uint32_t>());
      break;
    case types::multicast_session_upd_request_transfer:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_upd_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE multicast_session_upd_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::mbs_area_session_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)65535u, true, true));
      break;
    case types::multicast_session_upd_request_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_upd_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_session_upd_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::mbs_area_session_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)65535u, true, true));
      break;
    case types::multicast_session_upd_request_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_upd_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* multicast_session_upd_request_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"MBS-SessionID", "INTEGER (0..65535,...)", "OCTET STRING"};
  return convert_enum_idx(names, 3, value, "multicast_session_upd_request_ies_o::value_c::types");
}
uint8_t multicast_session_upd_request_ies_o::value_c::types_opts::to_number() const
{
  if (value == mbs_area_session_id) {
    return 0;
  }
  invalid_enum_number(value, "multicast_session_upd_request_ies_o::value_c::types");
  return 0;
}

// MulticastSessionUpdateResponseIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t multicast_session_upd_resp_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 295, 19};
  return map_enum_number(names, 3, idx, "id");
}
bool multicast_session_upd_resp_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 295, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e multicast_session_upd_resp_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::reject;
    case 295:
      return crit_e::reject;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
multicast_session_upd_resp_ies_o::value_c multicast_session_upd_resp_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 295:
      ret.set(value_c::types::mbs_area_session_id);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e multicast_session_upd_resp_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 295:
      return presence_e::optional;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void multicast_session_upd_resp_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::mbs_session_id:
      c.destroy<mbs_session_id_s>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void multicast_session_upd_resp_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c.init<mbs_session_id_s>();
      break;
    case types::mbs_area_session_id:
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_upd_resp_ies_o::value_c");
  }
}
multicast_session_upd_resp_ies_o::value_c::value_c(const multicast_session_upd_resp_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mbs_session_id:
      c.init(other.c.get<mbs_session_id_s>());
      break;
    case types::mbs_area_session_id:
      c.init(other.c.get<uint32_t>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_upd_resp_ies_o::value_c");
  }
}
multicast_session_upd_resp_ies_o::value_c&
multicast_session_upd_resp_ies_o::value_c::operator=(const multicast_session_upd_resp_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mbs_session_id:
      c.set(other.c.get<mbs_session_id_s>());
      break;
    case types::mbs_area_session_id:
      c.set(other.c.get<uint32_t>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_upd_resp_ies_o::value_c");
  }

  return *this;
}
mbs_session_id_s& multicast_session_upd_resp_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
uint32_t& multicast_session_upd_resp_ies_o::value_c::mbs_area_session_id()
{
  assert_choice_type(types::mbs_area_session_id, type_, "Value");
  return c.get<uint32_t>();
}
crit_diagnostics_s& multicast_session_upd_resp_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const mbs_session_id_s& multicast_session_upd_resp_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const uint32_t& multicast_session_upd_resp_ies_o::value_c::mbs_area_session_id() const
{
  assert_choice_type(types::mbs_area_session_id, type_, "Value");
  return c.get<uint32_t>();
}
const crit_diagnostics_s& multicast_session_upd_resp_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void multicast_session_upd_resp_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::mbs_area_session_id:
      j.write_int("INTEGER (0..65535,...)", c.get<uint32_t>());
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_upd_resp_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE multicast_session_upd_resp_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::mbs_area_session_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)65535u, true, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_upd_resp_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_session_upd_resp_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::mbs_area_session_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)65535u, true, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_upd_resp_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* multicast_session_upd_resp_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"MBS-SessionID", "INTEGER (0..65535,...)", "CriticalityDiagnostics"};
  return convert_enum_idx(names, 3, value, "multicast_session_upd_resp_ies_o::value_c::types");
}
uint8_t multicast_session_upd_resp_ies_o::value_c::types_opts::to_number() const
{
  if (value == mbs_area_session_id) {
    return 0;
  }
  invalid_enum_number(value, "multicast_session_upd_resp_ies_o::value_c::types");
  return 0;
}

// NASNonDeliveryIndication-IEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t nas_non_delivery_ind_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 38, 15};
  return map_enum_number(names, 4, idx, "id");
}
bool nas_non_delivery_ind_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 38, 15};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e nas_non_delivery_ind_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 38:
      return crit_e::ignore;
    case 15:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
nas_non_delivery_ind_ies_o::value_c nas_non_delivery_ind_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 38:
      ret.set(value_c::types::nas_pdu);
      break;
    case 15:
      ret.set(value_c::types::cause);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e nas_non_delivery_ind_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 38:
      return presence_e::mandatory;
    case 15:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void nas_non_delivery_ind_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::nas_pdu:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::cause:
      c.destroy<cause_c>();
      break;
    default:
      break;
  }
}
void nas_non_delivery_ind_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::nas_pdu:
      c.init<unbounded_octstring<true>>();
      break;
    case types::cause:
      c.init<cause_c>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "nas_non_delivery_ind_ies_o::value_c");
  }
}
nas_non_delivery_ind_ies_o::value_c::value_c(const nas_non_delivery_ind_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::nas_pdu:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "nas_non_delivery_ind_ies_o::value_c");
  }
}
nas_non_delivery_ind_ies_o::value_c&
nas_non_delivery_ind_ies_o::value_c::operator=(const nas_non_delivery_ind_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::nas_pdu:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "nas_non_delivery_ind_ies_o::value_c");
  }

  return *this;
}
uint64_t& nas_non_delivery_ind_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& nas_non_delivery_ind_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
unbounded_octstring<true>& nas_non_delivery_ind_ies_o::value_c::nas_pdu()
{
  assert_choice_type(types::nas_pdu, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
cause_c& nas_non_delivery_ind_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const uint64_t& nas_non_delivery_ind_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& nas_non_delivery_ind_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const unbounded_octstring<true>& nas_non_delivery_ind_ies_o::value_c::nas_pdu() const
{
  assert_choice_type(types::nas_pdu, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const cause_c& nas_non_delivery_ind_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
void nas_non_delivery_ind_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::nas_pdu:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "nas_non_delivery_ind_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE nas_non_delivery_ind_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::nas_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "nas_non_delivery_ind_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE nas_non_delivery_ind_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::nas_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "nas_non_delivery_ind_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* nas_non_delivery_ind_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..1099511627775)", "INTEGER (0..4294967295)", "OCTET STRING", "Cause"};
  return convert_enum_idx(names, 4, value, "nas_non_delivery_ind_ies_o::value_c::types");
}

// NGResetAcknowledgeIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ng_reset_ack_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {111, 19};
  return map_enum_number(names, 2, idx, "id");
}
bool ng_reset_ack_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {111, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ng_reset_ack_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 111:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ng_reset_ack_ies_o::value_c ng_reset_ack_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 111:
      ret.set(value_c::types::ue_associated_lc_ng_conn_list);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ng_reset_ack_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 111:
      return presence_e::optional;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ng_reset_ack_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::ue_associated_lc_ng_conn_list:
      c.destroy<ue_associated_lc_ng_conn_list_l>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void ng_reset_ack_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::ue_associated_lc_ng_conn_list:
      c.init<ue_associated_lc_ng_conn_list_l>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ng_reset_ack_ies_o::value_c");
  }
}
ng_reset_ack_ies_o::value_c::value_c(const ng_reset_ack_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::ue_associated_lc_ng_conn_list:
      c.init(other.c.get<ue_associated_lc_ng_conn_list_l>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ng_reset_ack_ies_o::value_c");
  }
}
ng_reset_ack_ies_o::value_c& ng_reset_ack_ies_o::value_c::operator=(const ng_reset_ack_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::ue_associated_lc_ng_conn_list:
      c.set(other.c.get<ue_associated_lc_ng_conn_list_l>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ng_reset_ack_ies_o::value_c");
  }

  return *this;
}
ue_associated_lc_ng_conn_list_l& ng_reset_ack_ies_o::value_c::ue_associated_lc_ng_conn_list()
{
  assert_choice_type(types::ue_associated_lc_ng_conn_list, type_, "Value");
  return c.get<ue_associated_lc_ng_conn_list_l>();
}
crit_diagnostics_s& ng_reset_ack_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const ue_associated_lc_ng_conn_list_l& ng_reset_ack_ies_o::value_c::ue_associated_lc_ng_conn_list() const
{
  assert_choice_type(types::ue_associated_lc_ng_conn_list, type_, "Value");
  return c.get<ue_associated_lc_ng_conn_list_l>();
}
const crit_diagnostics_s& ng_reset_ack_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void ng_reset_ack_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::ue_associated_lc_ng_conn_list:
      j.start_array("UE-associatedLogicalNG-connectionList");
      for (const auto& e1 : c.get<ue_associated_lc_ng_conn_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ng_reset_ack_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ng_reset_ack_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ue_associated_lc_ng_conn_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<ue_associated_lc_ng_conn_list_l>(), 1, 65536, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ng_reset_ack_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ng_reset_ack_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ue_associated_lc_ng_conn_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<ue_associated_lc_ng_conn_list_l>(), bref, 1, 65536, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ng_reset_ack_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ng_reset_ack_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"UE-associatedLogicalNG-connectionList", "CriticalityDiagnostics"};
  return convert_enum_idx(names, 2, value, "ng_reset_ack_ies_o::value_c::types");
}

// NGResetIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ng_reset_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {15, 88};
  return map_enum_number(names, 2, idx, "id");
}
bool ng_reset_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {15, 88};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ng_reset_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 15:
      return crit_e::ignore;
    case 88:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ng_reset_ies_o::value_c ng_reset_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 15:
      ret.set(value_c::types::cause);
      break;
    case 88:
      ret.set(value_c::types::reset_type);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ng_reset_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 15:
      return presence_e::mandatory;
    case 88:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ng_reset_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::cause:
      c.destroy<cause_c>();
      break;
    case types::reset_type:
      c.destroy<reset_type_c>();
      break;
    default:
      break;
  }
}
void ng_reset_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::cause:
      c.init<cause_c>();
      break;
    case types::reset_type:
      c.init<reset_type_c>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ng_reset_ies_o::value_c");
  }
}
ng_reset_ies_o::value_c::value_c(const ng_reset_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::reset_type:
      c.init(other.c.get<reset_type_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ng_reset_ies_o::value_c");
  }
}
ng_reset_ies_o::value_c& ng_reset_ies_o::value_c::operator=(const ng_reset_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::reset_type:
      c.set(other.c.get<reset_type_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ng_reset_ies_o::value_c");
  }

  return *this;
}
cause_c& ng_reset_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
reset_type_c& ng_reset_ies_o::value_c::reset_type()
{
  assert_choice_type(types::reset_type, type_, "Value");
  return c.get<reset_type_c>();
}
const cause_c& ng_reset_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const reset_type_c& ng_reset_ies_o::value_c::reset_type() const
{
  assert_choice_type(types::reset_type, type_, "Value");
  return c.get<reset_type_c>();
}
void ng_reset_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    case types::reset_type:
      j.write_fieldname("ResetType");
      c.get<reset_type_c>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ng_reset_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ng_reset_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    case types::reset_type:
      HANDLE_CODE(c.get<reset_type_c>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ng_reset_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ng_reset_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    case types::reset_type:
      HANDLE_CODE(c.get<reset_type_c>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ng_reset_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ng_reset_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"Cause", "ResetType"};
  return convert_enum_idx(names, 2, value, "ng_reset_ies_o::value_c::types");
}

// NGSetupFailureIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ng_setup_fail_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {15, 107, 19};
  return map_enum_number(names, 3, idx, "id");
}
bool ng_setup_fail_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {15, 107, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ng_setup_fail_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 15:
      return crit_e::ignore;
    case 107:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ng_setup_fail_ies_o::value_c ng_setup_fail_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 15:
      ret.set(value_c::types::cause);
      break;
    case 107:
      ret.set(value_c::types::time_to_wait);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ng_setup_fail_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 15:
      return presence_e::mandatory;
    case 107:
      return presence_e::optional;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ng_setup_fail_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::cause:
      c.destroy<cause_c>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void ng_setup_fail_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::cause:
      c.init<cause_c>();
      break;
    case types::time_to_wait:
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ng_setup_fail_ies_o::value_c");
  }
}
ng_setup_fail_ies_o::value_c::value_c(const ng_setup_fail_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::time_to_wait:
      c.init(other.c.get<time_to_wait_e>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ng_setup_fail_ies_o::value_c");
  }
}
ng_setup_fail_ies_o::value_c& ng_setup_fail_ies_o::value_c::operator=(const ng_setup_fail_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::time_to_wait:
      c.set(other.c.get<time_to_wait_e>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ng_setup_fail_ies_o::value_c");
  }

  return *this;
}
cause_c& ng_setup_fail_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
time_to_wait_e& ng_setup_fail_ies_o::value_c::time_to_wait()
{
  assert_choice_type(types::time_to_wait, type_, "Value");
  return c.get<time_to_wait_e>();
}
crit_diagnostics_s& ng_setup_fail_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const cause_c& ng_setup_fail_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const time_to_wait_e& ng_setup_fail_ies_o::value_c::time_to_wait() const
{
  assert_choice_type(types::time_to_wait, type_, "Value");
  return c.get<time_to_wait_e>();
}
const crit_diagnostics_s& ng_setup_fail_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void ng_setup_fail_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    case types::time_to_wait:
      j.write_str("TimeToWait", c.get<time_to_wait_e>().to_string());
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ng_setup_fail_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ng_setup_fail_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    case types::time_to_wait:
      HANDLE_CODE(c.get<time_to_wait_e>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ng_setup_fail_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ng_setup_fail_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    case types::time_to_wait:
      HANDLE_CODE(c.get<time_to_wait_e>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ng_setup_fail_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ng_setup_fail_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"Cause", "TimeToWait", "CriticalityDiagnostics"};
  return convert_enum_idx(names, 3, value, "ng_setup_fail_ies_o::value_c::types");
}

// NGSetupRequestIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ng_setup_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {27, 82, 102, 21, 147, 204, 273};
  return map_enum_number(names, 7, idx, "id");
}
bool ng_setup_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {27, 82, 102, 21, 147, 204, 273};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ng_setup_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 27:
      return crit_e::reject;
    case 82:
      return crit_e::ignore;
    case 102:
      return crit_e::reject;
    case 21:
      return crit_e::ignore;
    case 147:
      return crit_e::ignore;
    case 204:
      return crit_e::ignore;
    case 273:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ng_setup_request_ies_o::value_c ng_setup_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 27:
      ret.set(value_c::types::global_ran_node_id);
      break;
    case 82:
      ret.set(value_c::types::ran_node_name);
      break;
    case 102:
      ret.set(value_c::types::supported_ta_list);
      break;
    case 21:
      ret.set(value_c::types::default_paging_drx);
      break;
    case 147:
      ret.set(value_c::types::ue_retention_info);
      break;
    case 204:
      ret.set(value_c::types::nb_iot_default_paging_drx);
      break;
    case 273:
      ret.set(value_c::types::extended_ran_node_name);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ng_setup_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 27:
      return presence_e::mandatory;
    case 82:
      return presence_e::optional;
    case 102:
      return presence_e::mandatory;
    case 21:
      return presence_e::mandatory;
    case 147:
      return presence_e::optional;
    case 204:
      return presence_e::optional;
    case 273:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ng_setup_request_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::global_ran_node_id:
      c.destroy<global_ran_node_id_c>();
      break;
    case types::ran_node_name:
      c.destroy<printable_string<1, 150, true, true>>();
      break;
    case types::supported_ta_list:
      c.destroy<supported_ta_list_l>();
      break;
    case types::extended_ran_node_name:
      c.destroy<extended_ran_node_name_s>();
      break;
    default:
      break;
  }
}
void ng_setup_request_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::global_ran_node_id:
      c.init<global_ran_node_id_c>();
      break;
    case types::ran_node_name:
      c.init<printable_string<1, 150, true, true>>();
      break;
    case types::supported_ta_list:
      c.init<supported_ta_list_l>();
      break;
    case types::default_paging_drx:
      break;
    case types::ue_retention_info:
      break;
    case types::nb_iot_default_paging_drx:
      break;
    case types::extended_ran_node_name:
      c.init<extended_ran_node_name_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ng_setup_request_ies_o::value_c");
  }
}
ng_setup_request_ies_o::value_c::value_c(const ng_setup_request_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::global_ran_node_id:
      c.init(other.c.get<global_ran_node_id_c>());
      break;
    case types::ran_node_name:
      c.init(other.c.get<printable_string<1, 150, true, true>>());
      break;
    case types::supported_ta_list:
      c.init(other.c.get<supported_ta_list_l>());
      break;
    case types::default_paging_drx:
      c.init(other.c.get<paging_drx_e>());
      break;
    case types::ue_retention_info:
      c.init(other.c.get<ue_retention_info_e>());
      break;
    case types::nb_iot_default_paging_drx:
      c.init(other.c.get<nb_iot_default_paging_drx_e>());
      break;
    case types::extended_ran_node_name:
      c.init(other.c.get<extended_ran_node_name_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ng_setup_request_ies_o::value_c");
  }
}
ng_setup_request_ies_o::value_c&
ng_setup_request_ies_o::value_c::operator=(const ng_setup_request_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::global_ran_node_id:
      c.set(other.c.get<global_ran_node_id_c>());
      break;
    case types::ran_node_name:
      c.set(other.c.get<printable_string<1, 150, true, true>>());
      break;
    case types::supported_ta_list:
      c.set(other.c.get<supported_ta_list_l>());
      break;
    case types::default_paging_drx:
      c.set(other.c.get<paging_drx_e>());
      break;
    case types::ue_retention_info:
      c.set(other.c.get<ue_retention_info_e>());
      break;
    case types::nb_iot_default_paging_drx:
      c.set(other.c.get<nb_iot_default_paging_drx_e>());
      break;
    case types::extended_ran_node_name:
      c.set(other.c.get<extended_ran_node_name_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ng_setup_request_ies_o::value_c");
  }

  return *this;
}
global_ran_node_id_c& ng_setup_request_ies_o::value_c::global_ran_node_id()
{
  assert_choice_type(types::global_ran_node_id, type_, "Value");
  return c.get<global_ran_node_id_c>();
}
printable_string<1, 150, true, true>& ng_setup_request_ies_o::value_c::ran_node_name()
{
  assert_choice_type(types::ran_node_name, type_, "Value");
  return c.get<printable_string<1, 150, true, true>>();
}
supported_ta_list_l& ng_setup_request_ies_o::value_c::supported_ta_list()
{
  assert_choice_type(types::supported_ta_list, type_, "Value");
  return c.get<supported_ta_list_l>();
}
paging_drx_e& ng_setup_request_ies_o::value_c::default_paging_drx()
{
  assert_choice_type(types::default_paging_drx, type_, "Value");
  return c.get<paging_drx_e>();
}
ue_retention_info_e& ng_setup_request_ies_o::value_c::ue_retention_info()
{
  assert_choice_type(types::ue_retention_info, type_, "Value");
  return c.get<ue_retention_info_e>();
}
nb_iot_default_paging_drx_e& ng_setup_request_ies_o::value_c::nb_iot_default_paging_drx()
{
  assert_choice_type(types::nb_iot_default_paging_drx, type_, "Value");
  return c.get<nb_iot_default_paging_drx_e>();
}
extended_ran_node_name_s& ng_setup_request_ies_o::value_c::extended_ran_node_name()
{
  assert_choice_type(types::extended_ran_node_name, type_, "Value");
  return c.get<extended_ran_node_name_s>();
}
const global_ran_node_id_c& ng_setup_request_ies_o::value_c::global_ran_node_id() const
{
  assert_choice_type(types::global_ran_node_id, type_, "Value");
  return c.get<global_ran_node_id_c>();
}
const printable_string<1, 150, true, true>& ng_setup_request_ies_o::value_c::ran_node_name() const
{
  assert_choice_type(types::ran_node_name, type_, "Value");
  return c.get<printable_string<1, 150, true, true>>();
}
const supported_ta_list_l& ng_setup_request_ies_o::value_c::supported_ta_list() const
{
  assert_choice_type(types::supported_ta_list, type_, "Value");
  return c.get<supported_ta_list_l>();
}
const paging_drx_e& ng_setup_request_ies_o::value_c::default_paging_drx() const
{
  assert_choice_type(types::default_paging_drx, type_, "Value");
  return c.get<paging_drx_e>();
}
const ue_retention_info_e& ng_setup_request_ies_o::value_c::ue_retention_info() const
{
  assert_choice_type(types::ue_retention_info, type_, "Value");
  return c.get<ue_retention_info_e>();
}
const nb_iot_default_paging_drx_e& ng_setup_request_ies_o::value_c::nb_iot_default_paging_drx() const
{
  assert_choice_type(types::nb_iot_default_paging_drx, type_, "Value");
  return c.get<nb_iot_default_paging_drx_e>();
}
const extended_ran_node_name_s& ng_setup_request_ies_o::value_c::extended_ran_node_name() const
{
  assert_choice_type(types::extended_ran_node_name, type_, "Value");
  return c.get<extended_ran_node_name_s>();
}
void ng_setup_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::global_ran_node_id:
      j.write_fieldname("GlobalRANNodeID");
      c.get<global_ran_node_id_c>().to_json(j);
      break;
    case types::ran_node_name:
      j.write_str("PrintableString", c.get<printable_string<1, 150, true, true>>().to_string());
      break;
    case types::supported_ta_list:
      j.start_array("SupportedTAList");
      for (const auto& e1 : c.get<supported_ta_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::default_paging_drx:
      j.write_str("PagingDRX", c.get<paging_drx_e>().to_string());
      break;
    case types::ue_retention_info:
      j.write_str("UERetentionInformation", "ues-retained");
      break;
    case types::nb_iot_default_paging_drx:
      j.write_str("NB-IoT-DefaultPagingDRX", c.get<nb_iot_default_paging_drx_e>().to_string());
      break;
    case types::extended_ran_node_name:
      j.write_fieldname("Extended-RANNodeName");
      c.get<extended_ran_node_name_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ng_setup_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ng_setup_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::global_ran_node_id:
      HANDLE_CODE(c.get<global_ran_node_id_c>().pack(bref));
      break;
    case types::ran_node_name:
      HANDLE_CODE((c.get<printable_string<1, 150, true, true>>().pack(bref)));
      break;
    case types::supported_ta_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<supported_ta_list_l>(), 1, 256, true));
      break;
    case types::default_paging_drx:
      HANDLE_CODE(c.get<paging_drx_e>().pack(bref));
      break;
    case types::ue_retention_info:
      HANDLE_CODE(c.get<ue_retention_info_e>().pack(bref));
      break;
    case types::nb_iot_default_paging_drx:
      HANDLE_CODE(c.get<nb_iot_default_paging_drx_e>().pack(bref));
      break;
    case types::extended_ran_node_name:
      HANDLE_CODE(c.get<extended_ran_node_name_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ng_setup_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ng_setup_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::global_ran_node_id:
      HANDLE_CODE(c.get<global_ran_node_id_c>().unpack(bref));
      break;
    case types::ran_node_name:
      HANDLE_CODE((c.get<printable_string<1, 150, true, true>>().unpack(bref)));
      break;
    case types::supported_ta_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<supported_ta_list_l>(), bref, 1, 256, true));
      break;
    case types::default_paging_drx:
      HANDLE_CODE(c.get<paging_drx_e>().unpack(bref));
      break;
    case types::ue_retention_info:
      HANDLE_CODE(c.get<ue_retention_info_e>().unpack(bref));
      break;
    case types::nb_iot_default_paging_drx:
      HANDLE_CODE(c.get<nb_iot_default_paging_drx_e>().unpack(bref));
      break;
    case types::extended_ran_node_name:
      HANDLE_CODE(c.get<extended_ran_node_name_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ng_setup_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ng_setup_request_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"GlobalRANNodeID",
                                "PrintableString",
                                "SupportedTAList",
                                "PagingDRX",
                                "UERetentionInformation",
                                "NB-IoT-DefaultPagingDRX",
                                "Extended-RANNodeName"};
  return convert_enum_idx(names, 7, value, "ng_setup_request_ies_o::value_c::types");
}

// NGSetupResponseIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ng_setup_resp_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {1, 96, 86, 80, 19, 147, 200, 274};
  return map_enum_number(names, 8, idx, "id");
}
bool ng_setup_resp_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {1, 96, 86, 80, 19, 147, 200, 274};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ng_setup_resp_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 1:
      return crit_e::reject;
    case 96:
      return crit_e::reject;
    case 86:
      return crit_e::ignore;
    case 80:
      return crit_e::reject;
    case 19:
      return crit_e::ignore;
    case 147:
      return crit_e::ignore;
    case 200:
      return crit_e::ignore;
    case 274:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ng_setup_resp_ies_o::value_c ng_setup_resp_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 1:
      ret.set(value_c::types::amf_name);
      break;
    case 96:
      ret.set(value_c::types::served_guami_list);
      break;
    case 86:
      ret.set(value_c::types::relative_amf_capacity);
      break;
    case 80:
      ret.set(value_c::types::plmn_support_list);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    case 147:
      ret.set(value_c::types::ue_retention_info);
      break;
    case 200:
      ret.set(value_c::types::iab_supported);
      break;
    case 274:
      ret.set(value_c::types::extended_amf_name);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ng_setup_resp_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 1:
      return presence_e::mandatory;
    case 96:
      return presence_e::mandatory;
    case 86:
      return presence_e::mandatory;
    case 80:
      return presence_e::mandatory;
    case 19:
      return presence_e::optional;
    case 147:
      return presence_e::optional;
    case 200:
      return presence_e::optional;
    case 274:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ng_setup_resp_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::amf_name:
      c.destroy<printable_string<1, 150, true, true>>();
      break;
    case types::served_guami_list:
      c.destroy<served_guami_list_l>();
      break;
    case types::plmn_support_list:
      c.destroy<plmn_support_list_l>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    case types::extended_amf_name:
      c.destroy<extended_amf_name_s>();
      break;
    default:
      break;
  }
}
void ng_setup_resp_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_name:
      c.init<printable_string<1, 150, true, true>>();
      break;
    case types::served_guami_list:
      c.init<served_guami_list_l>();
      break;
    case types::relative_amf_capacity:
      break;
    case types::plmn_support_list:
      c.init<plmn_support_list_l>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::ue_retention_info:
      break;
    case types::iab_supported:
      break;
    case types::extended_amf_name:
      c.init<extended_amf_name_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ng_setup_resp_ies_o::value_c");
  }
}
ng_setup_resp_ies_o::value_c::value_c(const ng_setup_resp_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_name:
      c.init(other.c.get<printable_string<1, 150, true, true>>());
      break;
    case types::served_guami_list:
      c.init(other.c.get<served_guami_list_l>());
      break;
    case types::relative_amf_capacity:
      c.init(other.c.get<uint16_t>());
      break;
    case types::plmn_support_list:
      c.init(other.c.get<plmn_support_list_l>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::ue_retention_info:
      c.init(other.c.get<ue_retention_info_e>());
      break;
    case types::iab_supported:
      c.init(other.c.get<iab_supported_e>());
      break;
    case types::extended_amf_name:
      c.init(other.c.get<extended_amf_name_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ng_setup_resp_ies_o::value_c");
  }
}
ng_setup_resp_ies_o::value_c& ng_setup_resp_ies_o::value_c::operator=(const ng_setup_resp_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_name:
      c.set(other.c.get<printable_string<1, 150, true, true>>());
      break;
    case types::served_guami_list:
      c.set(other.c.get<served_guami_list_l>());
      break;
    case types::relative_amf_capacity:
      c.set(other.c.get<uint16_t>());
      break;
    case types::plmn_support_list:
      c.set(other.c.get<plmn_support_list_l>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::ue_retention_info:
      c.set(other.c.get<ue_retention_info_e>());
      break;
    case types::iab_supported:
      c.set(other.c.get<iab_supported_e>());
      break;
    case types::extended_amf_name:
      c.set(other.c.get<extended_amf_name_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ng_setup_resp_ies_o::value_c");
  }

  return *this;
}
printable_string<1, 150, true, true>& ng_setup_resp_ies_o::value_c::amf_name()
{
  assert_choice_type(types::amf_name, type_, "Value");
  return c.get<printable_string<1, 150, true, true>>();
}
served_guami_list_l& ng_setup_resp_ies_o::value_c::served_guami_list()
{
  assert_choice_type(types::served_guami_list, type_, "Value");
  return c.get<served_guami_list_l>();
}
uint16_t& ng_setup_resp_ies_o::value_c::relative_amf_capacity()
{
  assert_choice_type(types::relative_amf_capacity, type_, "Value");
  return c.get<uint16_t>();
}
plmn_support_list_l& ng_setup_resp_ies_o::value_c::plmn_support_list()
{
  assert_choice_type(types::plmn_support_list, type_, "Value");
  return c.get<plmn_support_list_l>();
}
crit_diagnostics_s& ng_setup_resp_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
ue_retention_info_e& ng_setup_resp_ies_o::value_c::ue_retention_info()
{
  assert_choice_type(types::ue_retention_info, type_, "Value");
  return c.get<ue_retention_info_e>();
}
iab_supported_e& ng_setup_resp_ies_o::value_c::iab_supported()
{
  assert_choice_type(types::iab_supported, type_, "Value");
  return c.get<iab_supported_e>();
}
extended_amf_name_s& ng_setup_resp_ies_o::value_c::extended_amf_name()
{
  assert_choice_type(types::extended_amf_name, type_, "Value");
  return c.get<extended_amf_name_s>();
}
const printable_string<1, 150, true, true>& ng_setup_resp_ies_o::value_c::amf_name() const
{
  assert_choice_type(types::amf_name, type_, "Value");
  return c.get<printable_string<1, 150, true, true>>();
}
const served_guami_list_l& ng_setup_resp_ies_o::value_c::served_guami_list() const
{
  assert_choice_type(types::served_guami_list, type_, "Value");
  return c.get<served_guami_list_l>();
}
const uint16_t& ng_setup_resp_ies_o::value_c::relative_amf_capacity() const
{
  assert_choice_type(types::relative_amf_capacity, type_, "Value");
  return c.get<uint16_t>();
}
const plmn_support_list_l& ng_setup_resp_ies_o::value_c::plmn_support_list() const
{
  assert_choice_type(types::plmn_support_list, type_, "Value");
  return c.get<plmn_support_list_l>();
}
const crit_diagnostics_s& ng_setup_resp_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const ue_retention_info_e& ng_setup_resp_ies_o::value_c::ue_retention_info() const
{
  assert_choice_type(types::ue_retention_info, type_, "Value");
  return c.get<ue_retention_info_e>();
}
const iab_supported_e& ng_setup_resp_ies_o::value_c::iab_supported() const
{
  assert_choice_type(types::iab_supported, type_, "Value");
  return c.get<iab_supported_e>();
}
const extended_amf_name_s& ng_setup_resp_ies_o::value_c::extended_amf_name() const
{
  assert_choice_type(types::extended_amf_name, type_, "Value");
  return c.get<extended_amf_name_s>();
}
void ng_setup_resp_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_name:
      j.write_str("PrintableString", c.get<printable_string<1, 150, true, true>>().to_string());
      break;
    case types::served_guami_list:
      j.start_array("ServedGUAMIList");
      for (const auto& e1 : c.get<served_guami_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::relative_amf_capacity:
      j.write_int("INTEGER (0..255)", c.get<uint16_t>());
      break;
    case types::plmn_support_list:
      j.start_array("PLMNSupportList");
      for (const auto& e1 : c.get<plmn_support_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    case types::ue_retention_info:
      j.write_str("UERetentionInformation", "ues-retained");
      break;
    case types::iab_supported:
      j.write_str("IAB-Supported", "true");
      break;
    case types::extended_amf_name:
      j.write_fieldname("Extended-AMFName");
      c.get<extended_amf_name_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ng_setup_resp_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ng_setup_resp_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_name:
      HANDLE_CODE((c.get<printable_string<1, 150, true, true>>().pack(bref)));
      break;
    case types::served_guami_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<served_guami_list_l>(), 1, 256, true));
      break;
    case types::relative_amf_capacity:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)0u, (uint16_t)255u, false, true));
      break;
    case types::plmn_support_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<plmn_support_list_l>(), 1, 12, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    case types::ue_retention_info:
      HANDLE_CODE(c.get<ue_retention_info_e>().pack(bref));
      break;
    case types::iab_supported:
      HANDLE_CODE(c.get<iab_supported_e>().pack(bref));
      break;
    case types::extended_amf_name:
      HANDLE_CODE(c.get<extended_amf_name_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ng_setup_resp_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ng_setup_resp_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_name:
      HANDLE_CODE((c.get<printable_string<1, 150, true, true>>().unpack(bref)));
      break;
    case types::served_guami_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<served_guami_list_l>(), bref, 1, 256, true));
      break;
    case types::relative_amf_capacity:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)0u, (uint16_t)255u, false, true));
      break;
    case types::plmn_support_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<plmn_support_list_l>(), bref, 1, 12, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    case types::ue_retention_info:
      HANDLE_CODE(c.get<ue_retention_info_e>().unpack(bref));
      break;
    case types::iab_supported:
      HANDLE_CODE(c.get<iab_supported_e>().unpack(bref));
      break;
    case types::extended_amf_name:
      HANDLE_CODE(c.get<extended_amf_name_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ng_setup_resp_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ng_setup_resp_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"PrintableString",
                                "ServedGUAMIList",
                                "INTEGER (0..255)",
                                "PLMNSupportList",
                                "CriticalityDiagnostics",
                                "UERetentionInformation",
                                "IAB-Supported",
                                "Extended-AMFName"};
  return convert_enum_idx(names, 8, value, "ng_setup_resp_ies_o::value_c::types");
}
uint8_t ng_setup_resp_ies_o::value_c::types_opts::to_number() const
{
  if (value == relative_amf_capacity) {
    return 0;
  }
  invalid_enum_number(value, "ng_setup_resp_ies_o::value_c::types");
  return 0;
}

// OverloadStartIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t overload_start_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {2, 9, 49};
  return map_enum_number(names, 3, idx, "id");
}
bool overload_start_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {2, 9, 49};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e overload_start_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 2:
      return crit_e::reject;
    case 9:
      return crit_e::ignore;
    case 49:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
overload_start_ies_o::value_c overload_start_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 2:
      ret.set(value_c::types::amf_overload_resp);
      break;
    case 9:
      ret.set(value_c::types::amf_traffic_load_reduction_ind);
      break;
    case 49:
      ret.set(value_c::types::overload_start_nssai_list);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e overload_start_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 2:
      return presence_e::optional;
    case 9:
      return presence_e::optional;
    case 49:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void overload_start_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::amf_overload_resp:
      c.destroy<overload_resp_c>();
      break;
    case types::overload_start_nssai_list:
      c.destroy<overload_start_nssai_list_l>();
      break;
    default:
      break;
  }
}
void overload_start_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_overload_resp:
      c.init<overload_resp_c>();
      break;
    case types::amf_traffic_load_reduction_ind:
      break;
    case types::overload_start_nssai_list:
      c.init<overload_start_nssai_list_l>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "overload_start_ies_o::value_c");
  }
}
overload_start_ies_o::value_c::value_c(const overload_start_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_overload_resp:
      c.init(other.c.get<overload_resp_c>());
      break;
    case types::amf_traffic_load_reduction_ind:
      c.init(other.c.get<uint8_t>());
      break;
    case types::overload_start_nssai_list:
      c.init(other.c.get<overload_start_nssai_list_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "overload_start_ies_o::value_c");
  }
}
overload_start_ies_o::value_c& overload_start_ies_o::value_c::operator=(const overload_start_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_overload_resp:
      c.set(other.c.get<overload_resp_c>());
      break;
    case types::amf_traffic_load_reduction_ind:
      c.set(other.c.get<uint8_t>());
      break;
    case types::overload_start_nssai_list:
      c.set(other.c.get<overload_start_nssai_list_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "overload_start_ies_o::value_c");
  }

  return *this;
}
overload_resp_c& overload_start_ies_o::value_c::amf_overload_resp()
{
  assert_choice_type(types::amf_overload_resp, type_, "Value");
  return c.get<overload_resp_c>();
}
uint8_t& overload_start_ies_o::value_c::amf_traffic_load_reduction_ind()
{
  assert_choice_type(types::amf_traffic_load_reduction_ind, type_, "Value");
  return c.get<uint8_t>();
}
overload_start_nssai_list_l& overload_start_ies_o::value_c::overload_start_nssai_list()
{
  assert_choice_type(types::overload_start_nssai_list, type_, "Value");
  return c.get<overload_start_nssai_list_l>();
}
const overload_resp_c& overload_start_ies_o::value_c::amf_overload_resp() const
{
  assert_choice_type(types::amf_overload_resp, type_, "Value");
  return c.get<overload_resp_c>();
}
const uint8_t& overload_start_ies_o::value_c::amf_traffic_load_reduction_ind() const
{
  assert_choice_type(types::amf_traffic_load_reduction_ind, type_, "Value");
  return c.get<uint8_t>();
}
const overload_start_nssai_list_l& overload_start_ies_o::value_c::overload_start_nssai_list() const
{
  assert_choice_type(types::overload_start_nssai_list, type_, "Value");
  return c.get<overload_start_nssai_list_l>();
}
void overload_start_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_overload_resp:
      j.write_fieldname("OverloadResponse");
      c.get<overload_resp_c>().to_json(j);
      break;
    case types::amf_traffic_load_reduction_ind:
      j.write_int("INTEGER (1..99)", c.get<uint8_t>());
      break;
    case types::overload_start_nssai_list:
      j.start_array("OverloadStartNSSAIList");
      for (const auto& e1 : c.get<overload_start_nssai_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    default:
      log_invalid_choice_id(type_, "overload_start_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE overload_start_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_overload_resp:
      HANDLE_CODE(c.get<overload_resp_c>().pack(bref));
      break;
    case types::amf_traffic_load_reduction_ind:
      HANDLE_CODE(pack_integer(bref, c.get<uint8_t>(), (uint8_t)1u, (uint8_t)99u, false, true));
      break;
    case types::overload_start_nssai_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<overload_start_nssai_list_l>(), 1, 1024, true));
      break;
    default:
      log_invalid_choice_id(type_, "overload_start_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE overload_start_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_overload_resp:
      HANDLE_CODE(c.get<overload_resp_c>().unpack(bref));
      break;
    case types::amf_traffic_load_reduction_ind:
      HANDLE_CODE(unpack_integer(c.get<uint8_t>(), bref, (uint8_t)1u, (uint8_t)99u, false, true));
      break;
    case types::overload_start_nssai_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<overload_start_nssai_list_l>(), bref, 1, 1024, true));
      break;
    default:
      log_invalid_choice_id(type_, "overload_start_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* overload_start_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"OverloadResponse", "INTEGER (1..99)", "OverloadStartNSSAIList"};
  return convert_enum_idx(names, 3, value, "overload_start_ies_o::value_c::types");
}
uint8_t overload_start_ies_o::value_c::types_opts::to_number() const
{
  if (value == amf_traffic_load_reduction_ind) {
    return 1;
  }
  invalid_enum_number(value, "overload_start_ies_o::value_c::types");
  return 0;
}

// PDUSessionResourceModifyConfirmIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t pdu_session_res_modify_confirm_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 62, 131, 19};
  return map_enum_number(names, 5, idx, "id");
}
bool pdu_session_res_modify_confirm_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 62, 131, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e pdu_session_res_modify_confirm_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::ignore;
    case 85:
      return crit_e::ignore;
    case 62:
      return crit_e::ignore;
    case 131:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
pdu_session_res_modify_confirm_ies_o::value_c pdu_session_res_modify_confirm_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 62:
      ret.set(value_c::types::pdu_session_res_modify_list_mod_cfm);
      break;
    case 131:
      ret.set(value_c::types::pdu_session_res_failed_to_modify_list_mod_cfm);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pdu_session_res_modify_confirm_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 62:
      return presence_e::optional;
    case 131:
      return presence_e::optional;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void pdu_session_res_modify_confirm_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::pdu_session_res_modify_list_mod_cfm:
      c.destroy<pdu_session_res_modify_list_mod_cfm_l>();
      break;
    case types::pdu_session_res_failed_to_modify_list_mod_cfm:
      c.destroy<pdu_session_res_failed_to_modify_list_mod_cfm_l>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void pdu_session_res_modify_confirm_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::pdu_session_res_modify_list_mod_cfm:
      c.init<pdu_session_res_modify_list_mod_cfm_l>();
      break;
    case types::pdu_session_res_failed_to_modify_list_mod_cfm:
      c.init<pdu_session_res_failed_to_modify_list_mod_cfm_l>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_confirm_ies_o::value_c");
  }
}
pdu_session_res_modify_confirm_ies_o::value_c::value_c(const pdu_session_res_modify_confirm_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::pdu_session_res_modify_list_mod_cfm:
      c.init(other.c.get<pdu_session_res_modify_list_mod_cfm_l>());
      break;
    case types::pdu_session_res_failed_to_modify_list_mod_cfm:
      c.init(other.c.get<pdu_session_res_failed_to_modify_list_mod_cfm_l>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_confirm_ies_o::value_c");
  }
}
pdu_session_res_modify_confirm_ies_o::value_c&
pdu_session_res_modify_confirm_ies_o::value_c::operator=(const pdu_session_res_modify_confirm_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::pdu_session_res_modify_list_mod_cfm:
      c.set(other.c.get<pdu_session_res_modify_list_mod_cfm_l>());
      break;
    case types::pdu_session_res_failed_to_modify_list_mod_cfm:
      c.set(other.c.get<pdu_session_res_failed_to_modify_list_mod_cfm_l>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_confirm_ies_o::value_c");
  }

  return *this;
}
uint64_t& pdu_session_res_modify_confirm_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& pdu_session_res_modify_confirm_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
pdu_session_res_modify_list_mod_cfm_l&
pdu_session_res_modify_confirm_ies_o::value_c::pdu_session_res_modify_list_mod_cfm()
{
  assert_choice_type(types::pdu_session_res_modify_list_mod_cfm, type_, "Value");
  return c.get<pdu_session_res_modify_list_mod_cfm_l>();
}
pdu_session_res_failed_to_modify_list_mod_cfm_l&
pdu_session_res_modify_confirm_ies_o::value_c::pdu_session_res_failed_to_modify_list_mod_cfm()
{
  assert_choice_type(types::pdu_session_res_failed_to_modify_list_mod_cfm, type_, "Value");
  return c.get<pdu_session_res_failed_to_modify_list_mod_cfm_l>();
}
crit_diagnostics_s& pdu_session_res_modify_confirm_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const uint64_t& pdu_session_res_modify_confirm_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& pdu_session_res_modify_confirm_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const pdu_session_res_modify_list_mod_cfm_l&
pdu_session_res_modify_confirm_ies_o::value_c::pdu_session_res_modify_list_mod_cfm() const
{
  assert_choice_type(types::pdu_session_res_modify_list_mod_cfm, type_, "Value");
  return c.get<pdu_session_res_modify_list_mod_cfm_l>();
}
const pdu_session_res_failed_to_modify_list_mod_cfm_l&
pdu_session_res_modify_confirm_ies_o::value_c::pdu_session_res_failed_to_modify_list_mod_cfm() const
{
  assert_choice_type(types::pdu_session_res_failed_to_modify_list_mod_cfm, type_, "Value");
  return c.get<pdu_session_res_failed_to_modify_list_mod_cfm_l>();
}
const crit_diagnostics_s& pdu_session_res_modify_confirm_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void pdu_session_res_modify_confirm_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::pdu_session_res_modify_list_mod_cfm:
      j.start_array("PDUSessionResourceModifyListModCfm");
      for (const auto& e1 : c.get<pdu_session_res_modify_list_mod_cfm_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::pdu_session_res_failed_to_modify_list_mod_cfm:
      j.start_array("PDUSessionResourceFailedToModifyListModCfm");
      for (const auto& e1 : c.get<pdu_session_res_failed_to_modify_list_mod_cfm_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_confirm_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE pdu_session_res_modify_confirm_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_modify_list_mod_cfm:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_modify_list_mod_cfm_l>(), 1, 256, true));
      break;
    case types::pdu_session_res_failed_to_modify_list_mod_cfm:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_failed_to_modify_list_mod_cfm_l>(), 1, 256, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_confirm_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_modify_confirm_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_modify_list_mod_cfm:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_modify_list_mod_cfm_l>(), bref, 1, 256, true));
      break;
    case types::pdu_session_res_failed_to_modify_list_mod_cfm:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_failed_to_modify_list_mod_cfm_l>(), bref, 1, 256, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_confirm_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* pdu_session_res_modify_confirm_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..1099511627775)",
                                "INTEGER (0..4294967295)",
                                "PDUSessionResourceModifyListModCfm",
                                "PDUSessionResourceFailedToModifyListModCfm",
                                "CriticalityDiagnostics"};
  return convert_enum_idx(names, 5, value, "pdu_session_res_modify_confirm_ies_o::value_c::types");
}

// PDUSessionResourceModifyIndicationIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t pdu_session_res_modify_ind_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 63, 121};
  return map_enum_number(names, 4, idx, "id");
}
bool pdu_session_res_modify_ind_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 63, 121};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e pdu_session_res_modify_ind_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 63:
      return crit_e::reject;
    case 121:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
pdu_session_res_modify_ind_ies_o::value_c pdu_session_res_modify_ind_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 63:
      ret.set(value_c::types::pdu_session_res_modify_list_mod_ind);
      break;
    case 121:
      ret.set(value_c::types::user_location_info);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pdu_session_res_modify_ind_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 63:
      return presence_e::mandatory;
    case 121:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void pdu_session_res_modify_ind_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::pdu_session_res_modify_list_mod_ind:
      c.destroy<pdu_session_res_modify_list_mod_ind_l>();
      break;
    case types::user_location_info:
      c.destroy<user_location_info_c>();
      break;
    default:
      break;
  }
}
void pdu_session_res_modify_ind_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::pdu_session_res_modify_list_mod_ind:
      c.init<pdu_session_res_modify_list_mod_ind_l>();
      break;
    case types::user_location_info:
      c.init<user_location_info_c>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_ind_ies_o::value_c");
  }
}
pdu_session_res_modify_ind_ies_o::value_c::value_c(const pdu_session_res_modify_ind_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::pdu_session_res_modify_list_mod_ind:
      c.init(other.c.get<pdu_session_res_modify_list_mod_ind_l>());
      break;
    case types::user_location_info:
      c.init(other.c.get<user_location_info_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_ind_ies_o::value_c");
  }
}
pdu_session_res_modify_ind_ies_o::value_c&
pdu_session_res_modify_ind_ies_o::value_c::operator=(const pdu_session_res_modify_ind_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::pdu_session_res_modify_list_mod_ind:
      c.set(other.c.get<pdu_session_res_modify_list_mod_ind_l>());
      break;
    case types::user_location_info:
      c.set(other.c.get<user_location_info_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_ind_ies_o::value_c");
  }

  return *this;
}
uint64_t& pdu_session_res_modify_ind_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& pdu_session_res_modify_ind_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
pdu_session_res_modify_list_mod_ind_l& pdu_session_res_modify_ind_ies_o::value_c::pdu_session_res_modify_list_mod_ind()
{
  assert_choice_type(types::pdu_session_res_modify_list_mod_ind, type_, "Value");
  return c.get<pdu_session_res_modify_list_mod_ind_l>();
}
user_location_info_c& pdu_session_res_modify_ind_ies_o::value_c::user_location_info()
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
const uint64_t& pdu_session_res_modify_ind_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& pdu_session_res_modify_ind_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const pdu_session_res_modify_list_mod_ind_l&
pdu_session_res_modify_ind_ies_o::value_c::pdu_session_res_modify_list_mod_ind() const
{
  assert_choice_type(types::pdu_session_res_modify_list_mod_ind, type_, "Value");
  return c.get<pdu_session_res_modify_list_mod_ind_l>();
}
const user_location_info_c& pdu_session_res_modify_ind_ies_o::value_c::user_location_info() const
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
void pdu_session_res_modify_ind_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::pdu_session_res_modify_list_mod_ind:
      j.start_array("PDUSessionResourceModifyListModInd");
      for (const auto& e1 : c.get<pdu_session_res_modify_list_mod_ind_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::user_location_info:
      j.write_fieldname("UserLocationInformation");
      c.get<user_location_info_c>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_ind_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE pdu_session_res_modify_ind_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_modify_list_mod_ind:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_modify_list_mod_ind_l>(), 1, 256, true));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_ind_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_modify_ind_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_modify_list_mod_ind:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_modify_list_mod_ind_l>(), bref, 1, 256, true));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_ind_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* pdu_session_res_modify_ind_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..1099511627775)",
                                "INTEGER (0..4294967295)",
                                "PDUSessionResourceModifyListModInd",
                                "UserLocationInformation"};
  return convert_enum_idx(names, 4, value, "pdu_session_res_modify_ind_ies_o::value_c::types");
}

// PDUSessionResourceModifyRequestIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t pdu_session_res_modify_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 83, 64};
  return map_enum_number(names, 4, idx, "id");
}
bool pdu_session_res_modify_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 83, 64};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e pdu_session_res_modify_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 83:
      return crit_e::ignore;
    case 64:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
pdu_session_res_modify_request_ies_o::value_c pdu_session_res_modify_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 83:
      ret.set(value_c::types::ran_paging_prio);
      break;
    case 64:
      ret.set(value_c::types::pdu_session_res_modify_list_mod_req);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pdu_session_res_modify_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 83:
      return presence_e::optional;
    case 64:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void pdu_session_res_modify_request_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::pdu_session_res_modify_list_mod_req:
      c.destroy<pdu_session_res_modify_list_mod_req_l>();
      break;
    default:
      break;
  }
}
void pdu_session_res_modify_request_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::ran_paging_prio:
      break;
    case types::pdu_session_res_modify_list_mod_req:
      c.init<pdu_session_res_modify_list_mod_req_l>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_request_ies_o::value_c");
  }
}
pdu_session_res_modify_request_ies_o::value_c::value_c(const pdu_session_res_modify_request_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_paging_prio:
      c.init(other.c.get<uint16_t>());
      break;
    case types::pdu_session_res_modify_list_mod_req:
      c.init(other.c.get<pdu_session_res_modify_list_mod_req_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_request_ies_o::value_c");
  }
}
pdu_session_res_modify_request_ies_o::value_c&
pdu_session_res_modify_request_ies_o::value_c::operator=(const pdu_session_res_modify_request_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_paging_prio:
      c.set(other.c.get<uint16_t>());
      break;
    case types::pdu_session_res_modify_list_mod_req:
      c.set(other.c.get<pdu_session_res_modify_list_mod_req_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_request_ies_o::value_c");
  }

  return *this;
}
uint64_t& pdu_session_res_modify_request_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& pdu_session_res_modify_request_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint16_t& pdu_session_res_modify_request_ies_o::value_c::ran_paging_prio()
{
  assert_choice_type(types::ran_paging_prio, type_, "Value");
  return c.get<uint16_t>();
}
pdu_session_res_modify_list_mod_req_l&
pdu_session_res_modify_request_ies_o::value_c::pdu_session_res_modify_list_mod_req()
{
  assert_choice_type(types::pdu_session_res_modify_list_mod_req, type_, "Value");
  return c.get<pdu_session_res_modify_list_mod_req_l>();
}
const uint64_t& pdu_session_res_modify_request_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& pdu_session_res_modify_request_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint16_t& pdu_session_res_modify_request_ies_o::value_c::ran_paging_prio() const
{
  assert_choice_type(types::ran_paging_prio, type_, "Value");
  return c.get<uint16_t>();
}
const pdu_session_res_modify_list_mod_req_l&
pdu_session_res_modify_request_ies_o::value_c::pdu_session_res_modify_list_mod_req() const
{
  assert_choice_type(types::pdu_session_res_modify_list_mod_req, type_, "Value");
  return c.get<pdu_session_res_modify_list_mod_req_l>();
}
void pdu_session_res_modify_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::ran_paging_prio:
      j.write_int("INTEGER (1..256)", c.get<uint16_t>());
      break;
    case types::pdu_session_res_modify_list_mod_req:
      j.start_array("PDUSessionResourceModifyListModReq");
      for (const auto& e1 : c.get<pdu_session_res_modify_list_mod_req_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE pdu_session_res_modify_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ran_paging_prio:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)1u, (uint16_t)256u, false, true));
      break;
    case types::pdu_session_res_modify_list_mod_req:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_modify_list_mod_req_l>(), 1, 256, true));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_modify_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ran_paging_prio:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)1u, (uint16_t)256u, false, true));
      break;
    case types::pdu_session_res_modify_list_mod_req:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_modify_list_mod_req_l>(), bref, 1, 256, true));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* pdu_session_res_modify_request_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..1099511627775)",
                                "INTEGER (0..4294967295)",
                                "INTEGER (1..256)",
                                "PDUSessionResourceModifyListModReq"};
  return convert_enum_idx(names, 4, value, "pdu_session_res_modify_request_ies_o::value_c::types");
}

// PDUSessionResourceModifyResponseIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t pdu_session_res_modify_resp_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 65, 54, 121, 19};
  return map_enum_number(names, 6, idx, "id");
}
bool pdu_session_res_modify_resp_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 65, 54, 121, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e pdu_session_res_modify_resp_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::ignore;
    case 85:
      return crit_e::ignore;
    case 65:
      return crit_e::ignore;
    case 54:
      return crit_e::ignore;
    case 121:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
pdu_session_res_modify_resp_ies_o::value_c pdu_session_res_modify_resp_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 65:
      ret.set(value_c::types::pdu_session_res_modify_list_mod_res);
      break;
    case 54:
      ret.set(value_c::types::pdu_session_res_failed_to_modify_list_mod_res);
      break;
    case 121:
      ret.set(value_c::types::user_location_info);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pdu_session_res_modify_resp_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 65:
      return presence_e::optional;
    case 54:
      return presence_e::optional;
    case 121:
      return presence_e::optional;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void pdu_session_res_modify_resp_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::pdu_session_res_modify_list_mod_res:
      c.destroy<pdu_session_res_modify_list_mod_res_l>();
      break;
    case types::pdu_session_res_failed_to_modify_list_mod_res:
      c.destroy<pdu_session_res_failed_to_modify_list_mod_res_l>();
      break;
    case types::user_location_info:
      c.destroy<user_location_info_c>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void pdu_session_res_modify_resp_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::pdu_session_res_modify_list_mod_res:
      c.init<pdu_session_res_modify_list_mod_res_l>();
      break;
    case types::pdu_session_res_failed_to_modify_list_mod_res:
      c.init<pdu_session_res_failed_to_modify_list_mod_res_l>();
      break;
    case types::user_location_info:
      c.init<user_location_info_c>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_resp_ies_o::value_c");
  }
}
pdu_session_res_modify_resp_ies_o::value_c::value_c(const pdu_session_res_modify_resp_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::pdu_session_res_modify_list_mod_res:
      c.init(other.c.get<pdu_session_res_modify_list_mod_res_l>());
      break;
    case types::pdu_session_res_failed_to_modify_list_mod_res:
      c.init(other.c.get<pdu_session_res_failed_to_modify_list_mod_res_l>());
      break;
    case types::user_location_info:
      c.init(other.c.get<user_location_info_c>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_resp_ies_o::value_c");
  }
}
pdu_session_res_modify_resp_ies_o::value_c&
pdu_session_res_modify_resp_ies_o::value_c::operator=(const pdu_session_res_modify_resp_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::pdu_session_res_modify_list_mod_res:
      c.set(other.c.get<pdu_session_res_modify_list_mod_res_l>());
      break;
    case types::pdu_session_res_failed_to_modify_list_mod_res:
      c.set(other.c.get<pdu_session_res_failed_to_modify_list_mod_res_l>());
      break;
    case types::user_location_info:
      c.set(other.c.get<user_location_info_c>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_resp_ies_o::value_c");
  }

  return *this;
}
uint64_t& pdu_session_res_modify_resp_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& pdu_session_res_modify_resp_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
pdu_session_res_modify_list_mod_res_l& pdu_session_res_modify_resp_ies_o::value_c::pdu_session_res_modify_list_mod_res()
{
  assert_choice_type(types::pdu_session_res_modify_list_mod_res, type_, "Value");
  return c.get<pdu_session_res_modify_list_mod_res_l>();
}
pdu_session_res_failed_to_modify_list_mod_res_l&
pdu_session_res_modify_resp_ies_o::value_c::pdu_session_res_failed_to_modify_list_mod_res()
{
  assert_choice_type(types::pdu_session_res_failed_to_modify_list_mod_res, type_, "Value");
  return c.get<pdu_session_res_failed_to_modify_list_mod_res_l>();
}
user_location_info_c& pdu_session_res_modify_resp_ies_o::value_c::user_location_info()
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
crit_diagnostics_s& pdu_session_res_modify_resp_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const uint64_t& pdu_session_res_modify_resp_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& pdu_session_res_modify_resp_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const pdu_session_res_modify_list_mod_res_l&
pdu_session_res_modify_resp_ies_o::value_c::pdu_session_res_modify_list_mod_res() const
{
  assert_choice_type(types::pdu_session_res_modify_list_mod_res, type_, "Value");
  return c.get<pdu_session_res_modify_list_mod_res_l>();
}
const pdu_session_res_failed_to_modify_list_mod_res_l&
pdu_session_res_modify_resp_ies_o::value_c::pdu_session_res_failed_to_modify_list_mod_res() const
{
  assert_choice_type(types::pdu_session_res_failed_to_modify_list_mod_res, type_, "Value");
  return c.get<pdu_session_res_failed_to_modify_list_mod_res_l>();
}
const user_location_info_c& pdu_session_res_modify_resp_ies_o::value_c::user_location_info() const
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
const crit_diagnostics_s& pdu_session_res_modify_resp_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void pdu_session_res_modify_resp_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::pdu_session_res_modify_list_mod_res:
      j.start_array("PDUSessionResourceModifyListModRes");
      for (const auto& e1 : c.get<pdu_session_res_modify_list_mod_res_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::pdu_session_res_failed_to_modify_list_mod_res:
      j.start_array("PDUSessionResourceFailedToModifyListModRes");
      for (const auto& e1 : c.get<pdu_session_res_failed_to_modify_list_mod_res_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::user_location_info:
      j.write_fieldname("UserLocationInformation");
      c.get<user_location_info_c>().to_json(j);
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_resp_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE pdu_session_res_modify_resp_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_modify_list_mod_res:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_modify_list_mod_res_l>(), 1, 256, true));
      break;
    case types::pdu_session_res_failed_to_modify_list_mod_res:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_failed_to_modify_list_mod_res_l>(), 1, 256, true));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_resp_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_modify_resp_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_modify_list_mod_res:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_modify_list_mod_res_l>(), bref, 1, 256, true));
      break;
    case types::pdu_session_res_failed_to_modify_list_mod_res:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_failed_to_modify_list_mod_res_l>(), bref, 1, 256, true));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_resp_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* pdu_session_res_modify_resp_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..1099511627775)",
                                "INTEGER (0..4294967295)",
                                "PDUSessionResourceModifyListModRes",
                                "PDUSessionResourceFailedToModifyListModRes",
                                "UserLocationInformation",
                                "CriticalityDiagnostics"};
  return convert_enum_idx(names, 6, value, "pdu_session_res_modify_resp_ies_o::value_c::types");
}

// PDUSessionResourceNotifyIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t pdu_session_res_notify_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 66, 67, 121};
  return map_enum_number(names, 5, idx, "id");
}
bool pdu_session_res_notify_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 66, 67, 121};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e pdu_session_res_notify_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 66:
      return crit_e::reject;
    case 67:
      return crit_e::ignore;
    case 121:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
pdu_session_res_notify_ies_o::value_c pdu_session_res_notify_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 66:
      ret.set(value_c::types::pdu_session_res_notify_list);
      break;
    case 67:
      ret.set(value_c::types::pdu_session_res_released_list_not);
      break;
    case 121:
      ret.set(value_c::types::user_location_info);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pdu_session_res_notify_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 66:
      return presence_e::optional;
    case 67:
      return presence_e::optional;
    case 121:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void pdu_session_res_notify_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::pdu_session_res_notify_list:
      c.destroy<pdu_session_res_notify_list_l>();
      break;
    case types::pdu_session_res_released_list_not:
      c.destroy<pdu_session_res_released_list_not_l>();
      break;
    case types::user_location_info:
      c.destroy<user_location_info_c>();
      break;
    default:
      break;
  }
}
void pdu_session_res_notify_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::pdu_session_res_notify_list:
      c.init<pdu_session_res_notify_list_l>();
      break;
    case types::pdu_session_res_released_list_not:
      c.init<pdu_session_res_released_list_not_l>();
      break;
    case types::user_location_info:
      c.init<user_location_info_c>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_notify_ies_o::value_c");
  }
}
pdu_session_res_notify_ies_o::value_c::value_c(const pdu_session_res_notify_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::pdu_session_res_notify_list:
      c.init(other.c.get<pdu_session_res_notify_list_l>());
      break;
    case types::pdu_session_res_released_list_not:
      c.init(other.c.get<pdu_session_res_released_list_not_l>());
      break;
    case types::user_location_info:
      c.init(other.c.get<user_location_info_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_notify_ies_o::value_c");
  }
}
pdu_session_res_notify_ies_o::value_c&
pdu_session_res_notify_ies_o::value_c::operator=(const pdu_session_res_notify_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::pdu_session_res_notify_list:
      c.set(other.c.get<pdu_session_res_notify_list_l>());
      break;
    case types::pdu_session_res_released_list_not:
      c.set(other.c.get<pdu_session_res_released_list_not_l>());
      break;
    case types::user_location_info:
      c.set(other.c.get<user_location_info_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_notify_ies_o::value_c");
  }

  return *this;
}
uint64_t& pdu_session_res_notify_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& pdu_session_res_notify_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
pdu_session_res_notify_list_l& pdu_session_res_notify_ies_o::value_c::pdu_session_res_notify_list()
{
  assert_choice_type(types::pdu_session_res_notify_list, type_, "Value");
  return c.get<pdu_session_res_notify_list_l>();
}
pdu_session_res_released_list_not_l& pdu_session_res_notify_ies_o::value_c::pdu_session_res_released_list_not()
{
  assert_choice_type(types::pdu_session_res_released_list_not, type_, "Value");
  return c.get<pdu_session_res_released_list_not_l>();
}
user_location_info_c& pdu_session_res_notify_ies_o::value_c::user_location_info()
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
const uint64_t& pdu_session_res_notify_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& pdu_session_res_notify_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const pdu_session_res_notify_list_l& pdu_session_res_notify_ies_o::value_c::pdu_session_res_notify_list() const
{
  assert_choice_type(types::pdu_session_res_notify_list, type_, "Value");
  return c.get<pdu_session_res_notify_list_l>();
}
const pdu_session_res_released_list_not_l&
pdu_session_res_notify_ies_o::value_c::pdu_session_res_released_list_not() const
{
  assert_choice_type(types::pdu_session_res_released_list_not, type_, "Value");
  return c.get<pdu_session_res_released_list_not_l>();
}
const user_location_info_c& pdu_session_res_notify_ies_o::value_c::user_location_info() const
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
void pdu_session_res_notify_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::pdu_session_res_notify_list:
      j.start_array("PDUSessionResourceNotifyList");
      for (const auto& e1 : c.get<pdu_session_res_notify_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::pdu_session_res_released_list_not:
      j.start_array("PDUSessionResourceReleasedListNot");
      for (const auto& e1 : c.get<pdu_session_res_released_list_not_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::user_location_info:
      j.write_fieldname("UserLocationInformation");
      c.get<user_location_info_c>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_notify_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE pdu_session_res_notify_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_notify_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_notify_list_l>(), 1, 256, true));
      break;
    case types::pdu_session_res_released_list_not:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_released_list_not_l>(), 1, 256, true));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_notify_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_notify_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_notify_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_notify_list_l>(), bref, 1, 256, true));
      break;
    case types::pdu_session_res_released_list_not:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_released_list_not_l>(), bref, 1, 256, true));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_notify_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* pdu_session_res_notify_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..1099511627775)",
                                "INTEGER (0..4294967295)",
                                "PDUSessionResourceNotifyList",
                                "PDUSessionResourceReleasedListNot",
                                "UserLocationInformation"};
  return convert_enum_idx(names, 5, value, "pdu_session_res_notify_ies_o::value_c::types");
}

// PDUSessionResourceReleaseCommandIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t pdu_session_res_release_cmd_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 83, 38, 79};
  return map_enum_number(names, 5, idx, "id");
}
bool pdu_session_res_release_cmd_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 83, 38, 79};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e pdu_session_res_release_cmd_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 83:
      return crit_e::ignore;
    case 38:
      return crit_e::ignore;
    case 79:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
pdu_session_res_release_cmd_ies_o::value_c pdu_session_res_release_cmd_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 83:
      ret.set(value_c::types::ran_paging_prio);
      break;
    case 38:
      ret.set(value_c::types::nas_pdu);
      break;
    case 79:
      ret.set(value_c::types::pdu_session_res_to_release_list_rel_cmd);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pdu_session_res_release_cmd_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 83:
      return presence_e::optional;
    case 38:
      return presence_e::optional;
    case 79:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void pdu_session_res_release_cmd_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::nas_pdu:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::pdu_session_res_to_release_list_rel_cmd:
      c.destroy<pdu_session_res_to_release_list_rel_cmd_l>();
      break;
    default:
      break;
  }
}
void pdu_session_res_release_cmd_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::ran_paging_prio:
      break;
    case types::nas_pdu:
      c.init<unbounded_octstring<true>>();
      break;
    case types::pdu_session_res_to_release_list_rel_cmd:
      c.init<pdu_session_res_to_release_list_rel_cmd_l>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_release_cmd_ies_o::value_c");
  }
}
pdu_session_res_release_cmd_ies_o::value_c::value_c(const pdu_session_res_release_cmd_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_paging_prio:
      c.init(other.c.get<uint16_t>());
      break;
    case types::nas_pdu:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::pdu_session_res_to_release_list_rel_cmd:
      c.init(other.c.get<pdu_session_res_to_release_list_rel_cmd_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_release_cmd_ies_o::value_c");
  }
}
pdu_session_res_release_cmd_ies_o::value_c&
pdu_session_res_release_cmd_ies_o::value_c::operator=(const pdu_session_res_release_cmd_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_paging_prio:
      c.set(other.c.get<uint16_t>());
      break;
    case types::nas_pdu:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::pdu_session_res_to_release_list_rel_cmd:
      c.set(other.c.get<pdu_session_res_to_release_list_rel_cmd_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_release_cmd_ies_o::value_c");
  }

  return *this;
}
uint64_t& pdu_session_res_release_cmd_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& pdu_session_res_release_cmd_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint16_t& pdu_session_res_release_cmd_ies_o::value_c::ran_paging_prio()
{
  assert_choice_type(types::ran_paging_prio, type_, "Value");
  return c.get<uint16_t>();
}
unbounded_octstring<true>& pdu_session_res_release_cmd_ies_o::value_c::nas_pdu()
{
  assert_choice_type(types::nas_pdu, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
pdu_session_res_to_release_list_rel_cmd_l&
pdu_session_res_release_cmd_ies_o::value_c::pdu_session_res_to_release_list_rel_cmd()
{
  assert_choice_type(types::pdu_session_res_to_release_list_rel_cmd, type_, "Value");
  return c.get<pdu_session_res_to_release_list_rel_cmd_l>();
}
const uint64_t& pdu_session_res_release_cmd_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& pdu_session_res_release_cmd_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint16_t& pdu_session_res_release_cmd_ies_o::value_c::ran_paging_prio() const
{
  assert_choice_type(types::ran_paging_prio, type_, "Value");
  return c.get<uint16_t>();
}
const unbounded_octstring<true>& pdu_session_res_release_cmd_ies_o::value_c::nas_pdu() const
{
  assert_choice_type(types::nas_pdu, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const pdu_session_res_to_release_list_rel_cmd_l&
pdu_session_res_release_cmd_ies_o::value_c::pdu_session_res_to_release_list_rel_cmd() const
{
  assert_choice_type(types::pdu_session_res_to_release_list_rel_cmd, type_, "Value");
  return c.get<pdu_session_res_to_release_list_rel_cmd_l>();
}
void pdu_session_res_release_cmd_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::ran_paging_prio:
      j.write_int("INTEGER (1..256)", c.get<uint16_t>());
      break;
    case types::nas_pdu:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::pdu_session_res_to_release_list_rel_cmd:
      j.start_array("PDUSessionResourceToReleaseListRelCmd");
      for (const auto& e1 : c.get<pdu_session_res_to_release_list_rel_cmd_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_release_cmd_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE pdu_session_res_release_cmd_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ran_paging_prio:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)1u, (uint16_t)256u, false, true));
      break;
    case types::nas_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::pdu_session_res_to_release_list_rel_cmd:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_to_release_list_rel_cmd_l>(), 1, 256, true));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_release_cmd_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_release_cmd_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ran_paging_prio:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)1u, (uint16_t)256u, false, true));
      break;
    case types::nas_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::pdu_session_res_to_release_list_rel_cmd:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_to_release_list_rel_cmd_l>(), bref, 1, 256, true));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_release_cmd_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* pdu_session_res_release_cmd_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..1099511627775)",
                                "INTEGER (0..4294967295)",
                                "INTEGER (1..256)",
                                "OCTET STRING",
                                "PDUSessionResourceToReleaseListRelCmd"};
  return convert_enum_idx(names, 5, value, "pdu_session_res_release_cmd_ies_o::value_c::types");
}

// PDUSessionResourceReleaseResponseIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t pdu_session_res_release_resp_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 70, 121, 19};
  return map_enum_number(names, 5, idx, "id");
}
bool pdu_session_res_release_resp_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 70, 121, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e pdu_session_res_release_resp_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::ignore;
    case 85:
      return crit_e::ignore;
    case 70:
      return crit_e::ignore;
    case 121:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
pdu_session_res_release_resp_ies_o::value_c pdu_session_res_release_resp_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 70:
      ret.set(value_c::types::pdu_session_res_released_list_rel_res);
      break;
    case 121:
      ret.set(value_c::types::user_location_info);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pdu_session_res_release_resp_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 70:
      return presence_e::mandatory;
    case 121:
      return presence_e::optional;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void pdu_session_res_release_resp_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::pdu_session_res_released_list_rel_res:
      c.destroy<pdu_session_res_released_list_rel_res_l>();
      break;
    case types::user_location_info:
      c.destroy<user_location_info_c>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void pdu_session_res_release_resp_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::pdu_session_res_released_list_rel_res:
      c.init<pdu_session_res_released_list_rel_res_l>();
      break;
    case types::user_location_info:
      c.init<user_location_info_c>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_release_resp_ies_o::value_c");
  }
}
pdu_session_res_release_resp_ies_o::value_c::value_c(const pdu_session_res_release_resp_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::pdu_session_res_released_list_rel_res:
      c.init(other.c.get<pdu_session_res_released_list_rel_res_l>());
      break;
    case types::user_location_info:
      c.init(other.c.get<user_location_info_c>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_release_resp_ies_o::value_c");
  }
}
pdu_session_res_release_resp_ies_o::value_c&
pdu_session_res_release_resp_ies_o::value_c::operator=(const pdu_session_res_release_resp_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::pdu_session_res_released_list_rel_res:
      c.set(other.c.get<pdu_session_res_released_list_rel_res_l>());
      break;
    case types::user_location_info:
      c.set(other.c.get<user_location_info_c>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_release_resp_ies_o::value_c");
  }

  return *this;
}
uint64_t& pdu_session_res_release_resp_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& pdu_session_res_release_resp_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
pdu_session_res_released_list_rel_res_l&
pdu_session_res_release_resp_ies_o::value_c::pdu_session_res_released_list_rel_res()
{
  assert_choice_type(types::pdu_session_res_released_list_rel_res, type_, "Value");
  return c.get<pdu_session_res_released_list_rel_res_l>();
}
user_location_info_c& pdu_session_res_release_resp_ies_o::value_c::user_location_info()
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
crit_diagnostics_s& pdu_session_res_release_resp_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const uint64_t& pdu_session_res_release_resp_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& pdu_session_res_release_resp_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const pdu_session_res_released_list_rel_res_l&
pdu_session_res_release_resp_ies_o::value_c::pdu_session_res_released_list_rel_res() const
{
  assert_choice_type(types::pdu_session_res_released_list_rel_res, type_, "Value");
  return c.get<pdu_session_res_released_list_rel_res_l>();
}
const user_location_info_c& pdu_session_res_release_resp_ies_o::value_c::user_location_info() const
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
const crit_diagnostics_s& pdu_session_res_release_resp_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void pdu_session_res_release_resp_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::pdu_session_res_released_list_rel_res:
      j.start_array("PDUSessionResourceReleasedListRelRes");
      for (const auto& e1 : c.get<pdu_session_res_released_list_rel_res_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::user_location_info:
      j.write_fieldname("UserLocationInformation");
      c.get<user_location_info_c>().to_json(j);
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_release_resp_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE pdu_session_res_release_resp_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_released_list_rel_res:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_released_list_rel_res_l>(), 1, 256, true));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_release_resp_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_release_resp_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_released_list_rel_res:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_released_list_rel_res_l>(), bref, 1, 256, true));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_release_resp_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* pdu_session_res_release_resp_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..1099511627775)",
                                "INTEGER (0..4294967295)",
                                "PDUSessionResourceReleasedListRelRes",
                                "UserLocationInformation",
                                "CriticalityDiagnostics"};
  return convert_enum_idx(names, 5, value, "pdu_session_res_release_resp_ies_o::value_c::types");
}

// PDUSessionResourceSetupRequestIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t pdu_session_res_setup_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 83, 38, 74, 110, 335};
  return map_enum_number(names, 7, idx, "id");
}
bool pdu_session_res_setup_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 83, 38, 74, 110, 335};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e pdu_session_res_setup_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 83:
      return crit_e::ignore;
    case 38:
      return crit_e::reject;
    case 74:
      return crit_e::reject;
    case 110:
      return crit_e::ignore;
    case 335:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
pdu_session_res_setup_request_ies_o::value_c pdu_session_res_setup_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 83:
      ret.set(value_c::types::ran_paging_prio);
      break;
    case 38:
      ret.set(value_c::types::nas_pdu);
      break;
    case 74:
      ret.set(value_c::types::pdu_session_res_setup_list_su_req);
      break;
    case 110:
      ret.set(value_c::types::ue_aggr_max_bit_rate);
      break;
    case 335:
      ret.set(value_c::types::ue_slice_max_bit_rate_list);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pdu_session_res_setup_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 83:
      return presence_e::optional;
    case 38:
      return presence_e::optional;
    case 74:
      return presence_e::mandatory;
    case 110:
      return presence_e::optional;
    case 335:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void pdu_session_res_setup_request_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::nas_pdu:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::pdu_session_res_setup_list_su_req:
      c.destroy<pdu_session_res_setup_list_su_req_l>();
      break;
    case types::ue_aggr_max_bit_rate:
      c.destroy<ue_aggr_max_bit_rate_s>();
      break;
    case types::ue_slice_max_bit_rate_list:
      c.destroy<ue_slice_max_bit_rate_list_l>();
      break;
    default:
      break;
  }
}
void pdu_session_res_setup_request_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::ran_paging_prio:
      break;
    case types::nas_pdu:
      c.init<unbounded_octstring<true>>();
      break;
    case types::pdu_session_res_setup_list_su_req:
      c.init<pdu_session_res_setup_list_su_req_l>();
      break;
    case types::ue_aggr_max_bit_rate:
      c.init<ue_aggr_max_bit_rate_s>();
      break;
    case types::ue_slice_max_bit_rate_list:
      c.init<ue_slice_max_bit_rate_list_l>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_setup_request_ies_o::value_c");
  }
}
pdu_session_res_setup_request_ies_o::value_c::value_c(const pdu_session_res_setup_request_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_paging_prio:
      c.init(other.c.get<uint16_t>());
      break;
    case types::nas_pdu:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::pdu_session_res_setup_list_su_req:
      c.init(other.c.get<pdu_session_res_setup_list_su_req_l>());
      break;
    case types::ue_aggr_max_bit_rate:
      c.init(other.c.get<ue_aggr_max_bit_rate_s>());
      break;
    case types::ue_slice_max_bit_rate_list:
      c.init(other.c.get<ue_slice_max_bit_rate_list_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_setup_request_ies_o::value_c");
  }
}
pdu_session_res_setup_request_ies_o::value_c&
pdu_session_res_setup_request_ies_o::value_c::operator=(const pdu_session_res_setup_request_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_paging_prio:
      c.set(other.c.get<uint16_t>());
      break;
    case types::nas_pdu:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::pdu_session_res_setup_list_su_req:
      c.set(other.c.get<pdu_session_res_setup_list_su_req_l>());
      break;
    case types::ue_aggr_max_bit_rate:
      c.set(other.c.get<ue_aggr_max_bit_rate_s>());
      break;
    case types::ue_slice_max_bit_rate_list:
      c.set(other.c.get<ue_slice_max_bit_rate_list_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_setup_request_ies_o::value_c");
  }

  return *this;
}
uint64_t& pdu_session_res_setup_request_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& pdu_session_res_setup_request_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint16_t& pdu_session_res_setup_request_ies_o::value_c::ran_paging_prio()
{
  assert_choice_type(types::ran_paging_prio, type_, "Value");
  return c.get<uint16_t>();
}
unbounded_octstring<true>& pdu_session_res_setup_request_ies_o::value_c::nas_pdu()
{
  assert_choice_type(types::nas_pdu, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
pdu_session_res_setup_list_su_req_l& pdu_session_res_setup_request_ies_o::value_c::pdu_session_res_setup_list_su_req()
{
  assert_choice_type(types::pdu_session_res_setup_list_su_req, type_, "Value");
  return c.get<pdu_session_res_setup_list_su_req_l>();
}
ue_aggr_max_bit_rate_s& pdu_session_res_setup_request_ies_o::value_c::ue_aggr_max_bit_rate()
{
  assert_choice_type(types::ue_aggr_max_bit_rate, type_, "Value");
  return c.get<ue_aggr_max_bit_rate_s>();
}
ue_slice_max_bit_rate_list_l& pdu_session_res_setup_request_ies_o::value_c::ue_slice_max_bit_rate_list()
{
  assert_choice_type(types::ue_slice_max_bit_rate_list, type_, "Value");
  return c.get<ue_slice_max_bit_rate_list_l>();
}
const uint64_t& pdu_session_res_setup_request_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& pdu_session_res_setup_request_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint16_t& pdu_session_res_setup_request_ies_o::value_c::ran_paging_prio() const
{
  assert_choice_type(types::ran_paging_prio, type_, "Value");
  return c.get<uint16_t>();
}
const unbounded_octstring<true>& pdu_session_res_setup_request_ies_o::value_c::nas_pdu() const
{
  assert_choice_type(types::nas_pdu, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const pdu_session_res_setup_list_su_req_l&
pdu_session_res_setup_request_ies_o::value_c::pdu_session_res_setup_list_su_req() const
{
  assert_choice_type(types::pdu_session_res_setup_list_su_req, type_, "Value");
  return c.get<pdu_session_res_setup_list_su_req_l>();
}
const ue_aggr_max_bit_rate_s& pdu_session_res_setup_request_ies_o::value_c::ue_aggr_max_bit_rate() const
{
  assert_choice_type(types::ue_aggr_max_bit_rate, type_, "Value");
  return c.get<ue_aggr_max_bit_rate_s>();
}
const ue_slice_max_bit_rate_list_l& pdu_session_res_setup_request_ies_o::value_c::ue_slice_max_bit_rate_list() const
{
  assert_choice_type(types::ue_slice_max_bit_rate_list, type_, "Value");
  return c.get<ue_slice_max_bit_rate_list_l>();
}
void pdu_session_res_setup_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::ran_paging_prio:
      j.write_int("INTEGER (1..256)", c.get<uint16_t>());
      break;
    case types::nas_pdu:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::pdu_session_res_setup_list_su_req:
      j.start_array("PDUSessionResourceSetupListSUReq");
      for (const auto& e1 : c.get<pdu_session_res_setup_list_su_req_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::ue_aggr_max_bit_rate:
      j.write_fieldname("UEAggregateMaximumBitRate");
      c.get<ue_aggr_max_bit_rate_s>().to_json(j);
      break;
    case types::ue_slice_max_bit_rate_list:
      j.start_array("UESliceMaximumBitRateList");
      for (const auto& e1 : c.get<ue_slice_max_bit_rate_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_setup_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE pdu_session_res_setup_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ran_paging_prio:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)1u, (uint16_t)256u, false, true));
      break;
    case types::nas_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::pdu_session_res_setup_list_su_req:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_setup_list_su_req_l>(), 1, 256, true));
      break;
    case types::ue_aggr_max_bit_rate:
      HANDLE_CODE(c.get<ue_aggr_max_bit_rate_s>().pack(bref));
      break;
    case types::ue_slice_max_bit_rate_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<ue_slice_max_bit_rate_list_l>(), 1, 8, true));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_setup_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_setup_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ran_paging_prio:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)1u, (uint16_t)256u, false, true));
      break;
    case types::nas_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::pdu_session_res_setup_list_su_req:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_setup_list_su_req_l>(), bref, 1, 256, true));
      break;
    case types::ue_aggr_max_bit_rate:
      HANDLE_CODE(c.get<ue_aggr_max_bit_rate_s>().unpack(bref));
      break;
    case types::ue_slice_max_bit_rate_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<ue_slice_max_bit_rate_list_l>(), bref, 1, 8, true));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_setup_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* pdu_session_res_setup_request_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..1099511627775)",
                                "INTEGER (0..4294967295)",
                                "INTEGER (1..256)",
                                "OCTET STRING",
                                "PDUSessionResourceSetupListSUReq",
                                "UEAggregateMaximumBitRate",
                                "UESliceMaximumBitRateList"};
  return convert_enum_idx(names, 7, value, "pdu_session_res_setup_request_ies_o::value_c::types");
}

// PDUSessionResourceSetupResponseIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t pdu_session_res_setup_resp_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 75, 58, 19, 121};
  return map_enum_number(names, 6, idx, "id");
}
bool pdu_session_res_setup_resp_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 75, 58, 19, 121};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e pdu_session_res_setup_resp_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::ignore;
    case 85:
      return crit_e::ignore;
    case 75:
      return crit_e::ignore;
    case 58:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    case 121:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
pdu_session_res_setup_resp_ies_o::value_c pdu_session_res_setup_resp_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 75:
      ret.set(value_c::types::pdu_session_res_setup_list_su_res);
      break;
    case 58:
      ret.set(value_c::types::pdu_session_res_failed_to_setup_list_su_res);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    case 121:
      ret.set(value_c::types::user_location_info);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pdu_session_res_setup_resp_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 75:
      return presence_e::optional;
    case 58:
      return presence_e::optional;
    case 19:
      return presence_e::optional;
    case 121:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void pdu_session_res_setup_resp_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::pdu_session_res_setup_list_su_res:
      c.destroy<pdu_session_res_setup_list_su_res_l>();
      break;
    case types::pdu_session_res_failed_to_setup_list_su_res:
      c.destroy<pdu_session_res_failed_to_setup_list_su_res_l>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    case types::user_location_info:
      c.destroy<user_location_info_c>();
      break;
    default:
      break;
  }
}
void pdu_session_res_setup_resp_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::pdu_session_res_setup_list_su_res:
      c.init<pdu_session_res_setup_list_su_res_l>();
      break;
    case types::pdu_session_res_failed_to_setup_list_su_res:
      c.init<pdu_session_res_failed_to_setup_list_su_res_l>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::user_location_info:
      c.init<user_location_info_c>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_setup_resp_ies_o::value_c");
  }
}
pdu_session_res_setup_resp_ies_o::value_c::value_c(const pdu_session_res_setup_resp_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::pdu_session_res_setup_list_su_res:
      c.init(other.c.get<pdu_session_res_setup_list_su_res_l>());
      break;
    case types::pdu_session_res_failed_to_setup_list_su_res:
      c.init(other.c.get<pdu_session_res_failed_to_setup_list_su_res_l>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::user_location_info:
      c.init(other.c.get<user_location_info_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_setup_resp_ies_o::value_c");
  }
}
pdu_session_res_setup_resp_ies_o::value_c&
pdu_session_res_setup_resp_ies_o::value_c::operator=(const pdu_session_res_setup_resp_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::pdu_session_res_setup_list_su_res:
      c.set(other.c.get<pdu_session_res_setup_list_su_res_l>());
      break;
    case types::pdu_session_res_failed_to_setup_list_su_res:
      c.set(other.c.get<pdu_session_res_failed_to_setup_list_su_res_l>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::user_location_info:
      c.set(other.c.get<user_location_info_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_setup_resp_ies_o::value_c");
  }

  return *this;
}
uint64_t& pdu_session_res_setup_resp_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& pdu_session_res_setup_resp_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
pdu_session_res_setup_list_su_res_l& pdu_session_res_setup_resp_ies_o::value_c::pdu_session_res_setup_list_su_res()
{
  assert_choice_type(types::pdu_session_res_setup_list_su_res, type_, "Value");
  return c.get<pdu_session_res_setup_list_su_res_l>();
}
pdu_session_res_failed_to_setup_list_su_res_l&
pdu_session_res_setup_resp_ies_o::value_c::pdu_session_res_failed_to_setup_list_su_res()
{
  assert_choice_type(types::pdu_session_res_failed_to_setup_list_su_res, type_, "Value");
  return c.get<pdu_session_res_failed_to_setup_list_su_res_l>();
}
crit_diagnostics_s& pdu_session_res_setup_resp_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
user_location_info_c& pdu_session_res_setup_resp_ies_o::value_c::user_location_info()
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
const uint64_t& pdu_session_res_setup_resp_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& pdu_session_res_setup_resp_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const pdu_session_res_setup_list_su_res_l&
pdu_session_res_setup_resp_ies_o::value_c::pdu_session_res_setup_list_su_res() const
{
  assert_choice_type(types::pdu_session_res_setup_list_su_res, type_, "Value");
  return c.get<pdu_session_res_setup_list_su_res_l>();
}
const pdu_session_res_failed_to_setup_list_su_res_l&
pdu_session_res_setup_resp_ies_o::value_c::pdu_session_res_failed_to_setup_list_su_res() const
{
  assert_choice_type(types::pdu_session_res_failed_to_setup_list_su_res, type_, "Value");
  return c.get<pdu_session_res_failed_to_setup_list_su_res_l>();
}
const crit_diagnostics_s& pdu_session_res_setup_resp_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const user_location_info_c& pdu_session_res_setup_resp_ies_o::value_c::user_location_info() const
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
void pdu_session_res_setup_resp_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::pdu_session_res_setup_list_su_res:
      j.start_array("PDUSessionResourceSetupListSURes");
      for (const auto& e1 : c.get<pdu_session_res_setup_list_su_res_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::pdu_session_res_failed_to_setup_list_su_res:
      j.start_array("PDUSessionResourceFailedToSetupListSURes");
      for (const auto& e1 : c.get<pdu_session_res_failed_to_setup_list_su_res_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    case types::user_location_info:
      j.write_fieldname("UserLocationInformation");
      c.get<user_location_info_c>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_setup_resp_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE pdu_session_res_setup_resp_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_setup_list_su_res:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_setup_list_su_res_l>(), 1, 256, true));
      break;
    case types::pdu_session_res_failed_to_setup_list_su_res:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_failed_to_setup_list_su_res_l>(), 1, 256, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_setup_resp_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_setup_resp_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_setup_list_su_res:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_setup_list_su_res_l>(), bref, 1, 256, true));
      break;
    case types::pdu_session_res_failed_to_setup_list_su_res:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_failed_to_setup_list_su_res_l>(), bref, 1, 256, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_setup_resp_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* pdu_session_res_setup_resp_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..1099511627775)",
                                "INTEGER (0..4294967295)",
                                "PDUSessionResourceSetupListSURes",
                                "PDUSessionResourceFailedToSetupListSURes",
                                "CriticalityDiagnostics",
                                "UserLocationInformation"};
  return convert_enum_idx(names, 6, value, "pdu_session_res_setup_resp_ies_o::value_c::types");
}

// PWSCancelRequestIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t pws_cancel_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {35, 95, 122, 14};
  return map_enum_number(names, 4, idx, "id");
}
bool pws_cancel_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {35, 95, 122, 14};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e pws_cancel_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 35:
      return crit_e::reject;
    case 95:
      return crit_e::reject;
    case 122:
      return crit_e::ignore;
    case 14:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
pws_cancel_request_ies_o::value_c pws_cancel_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 35:
      ret.set(value_c::types::msg_id);
      break;
    case 95:
      ret.set(value_c::types::serial_num);
      break;
    case 122:
      ret.set(value_c::types::warning_area_list);
      break;
    case 14:
      ret.set(value_c::types::cancel_all_warning_msgs);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pws_cancel_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 35:
      return presence_e::mandatory;
    case 95:
      return presence_e::mandatory;
    case 122:
      return presence_e::optional;
    case 14:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void pws_cancel_request_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::msg_id:
      c.destroy<fixed_bitstring<16, false, true>>();
      break;
    case types::serial_num:
      c.destroy<fixed_bitstring<16, false, true>>();
      break;
    case types::warning_area_list:
      c.destroy<warning_area_list_c>();
      break;
    default:
      break;
  }
}
void pws_cancel_request_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::msg_id:
      c.init<fixed_bitstring<16, false, true>>();
      break;
    case types::serial_num:
      c.init<fixed_bitstring<16, false, true>>();
      break;
    case types::warning_area_list:
      c.init<warning_area_list_c>();
      break;
    case types::cancel_all_warning_msgs:
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pws_cancel_request_ies_o::value_c");
  }
}
pws_cancel_request_ies_o::value_c::value_c(const pws_cancel_request_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::msg_id:
      c.init(other.c.get<fixed_bitstring<16, false, true>>());
      break;
    case types::serial_num:
      c.init(other.c.get<fixed_bitstring<16, false, true>>());
      break;
    case types::warning_area_list:
      c.init(other.c.get<warning_area_list_c>());
      break;
    case types::cancel_all_warning_msgs:
      c.init(other.c.get<cancel_all_warning_msgs_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pws_cancel_request_ies_o::value_c");
  }
}
pws_cancel_request_ies_o::value_c&
pws_cancel_request_ies_o::value_c::operator=(const pws_cancel_request_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::msg_id:
      c.set(other.c.get<fixed_bitstring<16, false, true>>());
      break;
    case types::serial_num:
      c.set(other.c.get<fixed_bitstring<16, false, true>>());
      break;
    case types::warning_area_list:
      c.set(other.c.get<warning_area_list_c>());
      break;
    case types::cancel_all_warning_msgs:
      c.set(other.c.get<cancel_all_warning_msgs_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pws_cancel_request_ies_o::value_c");
  }

  return *this;
}
fixed_bitstring<16, false, true>& pws_cancel_request_ies_o::value_c::msg_id()
{
  assert_choice_type(types::msg_id, type_, "Value");
  return c.get<fixed_bitstring<16, false, true>>();
}
fixed_bitstring<16, false, true>& pws_cancel_request_ies_o::value_c::serial_num()
{
  assert_choice_type(types::serial_num, type_, "Value");
  return c.get<fixed_bitstring<16, false, true>>();
}
warning_area_list_c& pws_cancel_request_ies_o::value_c::warning_area_list()
{
  assert_choice_type(types::warning_area_list, type_, "Value");
  return c.get<warning_area_list_c>();
}
cancel_all_warning_msgs_e& pws_cancel_request_ies_o::value_c::cancel_all_warning_msgs()
{
  assert_choice_type(types::cancel_all_warning_msgs, type_, "Value");
  return c.get<cancel_all_warning_msgs_e>();
}
const fixed_bitstring<16, false, true>& pws_cancel_request_ies_o::value_c::msg_id() const
{
  assert_choice_type(types::msg_id, type_, "Value");
  return c.get<fixed_bitstring<16, false, true>>();
}
const fixed_bitstring<16, false, true>& pws_cancel_request_ies_o::value_c::serial_num() const
{
  assert_choice_type(types::serial_num, type_, "Value");
  return c.get<fixed_bitstring<16, false, true>>();
}
const warning_area_list_c& pws_cancel_request_ies_o::value_c::warning_area_list() const
{
  assert_choice_type(types::warning_area_list, type_, "Value");
  return c.get<warning_area_list_c>();
}
const cancel_all_warning_msgs_e& pws_cancel_request_ies_o::value_c::cancel_all_warning_msgs() const
{
  assert_choice_type(types::cancel_all_warning_msgs, type_, "Value");
  return c.get<cancel_all_warning_msgs_e>();
}
void pws_cancel_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::msg_id:
      j.write_str("BIT STRING", c.get<fixed_bitstring<16, false, true>>().to_string());
      break;
    case types::serial_num:
      j.write_str("BIT STRING", c.get<fixed_bitstring<16, false, true>>().to_string());
      break;
    case types::warning_area_list:
      j.write_fieldname("WarningAreaList");
      c.get<warning_area_list_c>().to_json(j);
      break;
    case types::cancel_all_warning_msgs:
      j.write_str("CancelAllWarningMessages", "true");
      break;
    default:
      log_invalid_choice_id(type_, "pws_cancel_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE pws_cancel_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::msg_id:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true>>().pack(bref)));
      break;
    case types::serial_num:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true>>().pack(bref)));
      break;
    case types::warning_area_list:
      HANDLE_CODE(c.get<warning_area_list_c>().pack(bref));
      break;
    case types::cancel_all_warning_msgs:
      HANDLE_CODE(c.get<cancel_all_warning_msgs_e>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pws_cancel_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE pws_cancel_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::msg_id:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true>>().unpack(bref)));
      break;
    case types::serial_num:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true>>().unpack(bref)));
      break;
    case types::warning_area_list:
      HANDLE_CODE(c.get<warning_area_list_c>().unpack(bref));
      break;
    case types::cancel_all_warning_msgs:
      HANDLE_CODE(c.get<cancel_all_warning_msgs_e>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pws_cancel_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* pws_cancel_request_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"BIT STRING", "BIT STRING", "WarningAreaList", "CancelAllWarningMessages"};
  return convert_enum_idx(names, 4, value, "pws_cancel_request_ies_o::value_c::types");
}

// PWSCancelResponseIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t pws_cancel_resp_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {35, 95, 12, 19};
  return map_enum_number(names, 4, idx, "id");
}
bool pws_cancel_resp_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {35, 95, 12, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e pws_cancel_resp_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 35:
      return crit_e::reject;
    case 95:
      return crit_e::reject;
    case 12:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
pws_cancel_resp_ies_o::value_c pws_cancel_resp_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 35:
      ret.set(value_c::types::msg_id);
      break;
    case 95:
      ret.set(value_c::types::serial_num);
      break;
    case 12:
      ret.set(value_c::types::broadcast_cancelled_area_list);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pws_cancel_resp_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 35:
      return presence_e::mandatory;
    case 95:
      return presence_e::mandatory;
    case 12:
      return presence_e::optional;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void pws_cancel_resp_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::msg_id:
      c.destroy<fixed_bitstring<16, false, true>>();
      break;
    case types::serial_num:
      c.destroy<fixed_bitstring<16, false, true>>();
      break;
    case types::broadcast_cancelled_area_list:
      c.destroy<broadcast_cancelled_area_list_c>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void pws_cancel_resp_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::msg_id:
      c.init<fixed_bitstring<16, false, true>>();
      break;
    case types::serial_num:
      c.init<fixed_bitstring<16, false, true>>();
      break;
    case types::broadcast_cancelled_area_list:
      c.init<broadcast_cancelled_area_list_c>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pws_cancel_resp_ies_o::value_c");
  }
}
pws_cancel_resp_ies_o::value_c::value_c(const pws_cancel_resp_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::msg_id:
      c.init(other.c.get<fixed_bitstring<16, false, true>>());
      break;
    case types::serial_num:
      c.init(other.c.get<fixed_bitstring<16, false, true>>());
      break;
    case types::broadcast_cancelled_area_list:
      c.init(other.c.get<broadcast_cancelled_area_list_c>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pws_cancel_resp_ies_o::value_c");
  }
}
pws_cancel_resp_ies_o::value_c& pws_cancel_resp_ies_o::value_c::operator=(const pws_cancel_resp_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::msg_id:
      c.set(other.c.get<fixed_bitstring<16, false, true>>());
      break;
    case types::serial_num:
      c.set(other.c.get<fixed_bitstring<16, false, true>>());
      break;
    case types::broadcast_cancelled_area_list:
      c.set(other.c.get<broadcast_cancelled_area_list_c>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pws_cancel_resp_ies_o::value_c");
  }

  return *this;
}
fixed_bitstring<16, false, true>& pws_cancel_resp_ies_o::value_c::msg_id()
{
  assert_choice_type(types::msg_id, type_, "Value");
  return c.get<fixed_bitstring<16, false, true>>();
}
fixed_bitstring<16, false, true>& pws_cancel_resp_ies_o::value_c::serial_num()
{
  assert_choice_type(types::serial_num, type_, "Value");
  return c.get<fixed_bitstring<16, false, true>>();
}
broadcast_cancelled_area_list_c& pws_cancel_resp_ies_o::value_c::broadcast_cancelled_area_list()
{
  assert_choice_type(types::broadcast_cancelled_area_list, type_, "Value");
  return c.get<broadcast_cancelled_area_list_c>();
}
crit_diagnostics_s& pws_cancel_resp_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const fixed_bitstring<16, false, true>& pws_cancel_resp_ies_o::value_c::msg_id() const
{
  assert_choice_type(types::msg_id, type_, "Value");
  return c.get<fixed_bitstring<16, false, true>>();
}
const fixed_bitstring<16, false, true>& pws_cancel_resp_ies_o::value_c::serial_num() const
{
  assert_choice_type(types::serial_num, type_, "Value");
  return c.get<fixed_bitstring<16, false, true>>();
}
const broadcast_cancelled_area_list_c& pws_cancel_resp_ies_o::value_c::broadcast_cancelled_area_list() const
{
  assert_choice_type(types::broadcast_cancelled_area_list, type_, "Value");
  return c.get<broadcast_cancelled_area_list_c>();
}
const crit_diagnostics_s& pws_cancel_resp_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void pws_cancel_resp_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::msg_id:
      j.write_str("BIT STRING", c.get<fixed_bitstring<16, false, true>>().to_string());
      break;
    case types::serial_num:
      j.write_str("BIT STRING", c.get<fixed_bitstring<16, false, true>>().to_string());
      break;
    case types::broadcast_cancelled_area_list:
      j.write_fieldname("BroadcastCancelledAreaList");
      c.get<broadcast_cancelled_area_list_c>().to_json(j);
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "pws_cancel_resp_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE pws_cancel_resp_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::msg_id:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true>>().pack(bref)));
      break;
    case types::serial_num:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true>>().pack(bref)));
      break;
    case types::broadcast_cancelled_area_list:
      HANDLE_CODE(c.get<broadcast_cancelled_area_list_c>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pws_cancel_resp_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE pws_cancel_resp_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::msg_id:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true>>().unpack(bref)));
      break;
    case types::serial_num:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true>>().unpack(bref)));
      break;
    case types::broadcast_cancelled_area_list:
      HANDLE_CODE(c.get<broadcast_cancelled_area_list_c>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pws_cancel_resp_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* pws_cancel_resp_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"BIT STRING", "BIT STRING", "BroadcastCancelledAreaList", "CriticalityDiagnostics"};
  return convert_enum_idx(names, 4, value, "pws_cancel_resp_ies_o::value_c::types");
}

// PWSFailureIndicationIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t pws_fail_ind_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {81, 27};
  return map_enum_number(names, 2, idx, "id");
}
bool pws_fail_ind_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {81, 27};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e pws_fail_ind_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 81:
      return crit_e::reject;
    case 27:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
pws_fail_ind_ies_o::value_c pws_fail_ind_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 81:
      ret.set(value_c::types::pws_failed_cell_id_list);
      break;
    case 27:
      ret.set(value_c::types::global_ran_node_id);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pws_fail_ind_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 81:
      return presence_e::mandatory;
    case 27:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void pws_fail_ind_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::pws_failed_cell_id_list:
      c.destroy<pws_failed_cell_id_list_c>();
      break;
    case types::global_ran_node_id:
      c.destroy<global_ran_node_id_c>();
      break;
    default:
      break;
  }
}
void pws_fail_ind_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::pws_failed_cell_id_list:
      c.init<pws_failed_cell_id_list_c>();
      break;
    case types::global_ran_node_id:
      c.init<global_ran_node_id_c>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pws_fail_ind_ies_o::value_c");
  }
}
pws_fail_ind_ies_o::value_c::value_c(const pws_fail_ind_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::pws_failed_cell_id_list:
      c.init(other.c.get<pws_failed_cell_id_list_c>());
      break;
    case types::global_ran_node_id:
      c.init(other.c.get<global_ran_node_id_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pws_fail_ind_ies_o::value_c");
  }
}
pws_fail_ind_ies_o::value_c& pws_fail_ind_ies_o::value_c::operator=(const pws_fail_ind_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::pws_failed_cell_id_list:
      c.set(other.c.get<pws_failed_cell_id_list_c>());
      break;
    case types::global_ran_node_id:
      c.set(other.c.get<global_ran_node_id_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pws_fail_ind_ies_o::value_c");
  }

  return *this;
}
pws_failed_cell_id_list_c& pws_fail_ind_ies_o::value_c::pws_failed_cell_id_list()
{
  assert_choice_type(types::pws_failed_cell_id_list, type_, "Value");
  return c.get<pws_failed_cell_id_list_c>();
}
global_ran_node_id_c& pws_fail_ind_ies_o::value_c::global_ran_node_id()
{
  assert_choice_type(types::global_ran_node_id, type_, "Value");
  return c.get<global_ran_node_id_c>();
}
const pws_failed_cell_id_list_c& pws_fail_ind_ies_o::value_c::pws_failed_cell_id_list() const
{
  assert_choice_type(types::pws_failed_cell_id_list, type_, "Value");
  return c.get<pws_failed_cell_id_list_c>();
}
const global_ran_node_id_c& pws_fail_ind_ies_o::value_c::global_ran_node_id() const
{
  assert_choice_type(types::global_ran_node_id, type_, "Value");
  return c.get<global_ran_node_id_c>();
}
void pws_fail_ind_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::pws_failed_cell_id_list:
      j.write_fieldname("PWSFailedCellIDList");
      c.get<pws_failed_cell_id_list_c>().to_json(j);
      break;
    case types::global_ran_node_id:
      j.write_fieldname("GlobalRANNodeID");
      c.get<global_ran_node_id_c>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "pws_fail_ind_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE pws_fail_ind_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::pws_failed_cell_id_list:
      HANDLE_CODE(c.get<pws_failed_cell_id_list_c>().pack(bref));
      break;
    case types::global_ran_node_id:
      HANDLE_CODE(c.get<global_ran_node_id_c>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pws_fail_ind_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE pws_fail_ind_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::pws_failed_cell_id_list:
      HANDLE_CODE(c.get<pws_failed_cell_id_list_c>().unpack(bref));
      break;
    case types::global_ran_node_id:
      HANDLE_CODE(c.get<global_ran_node_id_c>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pws_fail_ind_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* pws_fail_ind_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"PWSFailedCellIDList", "GlobalRANNodeID"};
  return convert_enum_idx(names, 2, value, "pws_fail_ind_ies_o::value_c::types");
}

// PWSRestartIndicationIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t pws_restart_ind_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {16, 27, 104, 23};
  return map_enum_number(names, 4, idx, "id");
}
bool pws_restart_ind_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {16, 27, 104, 23};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e pws_restart_ind_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 16:
      return crit_e::reject;
    case 27:
      return crit_e::reject;
    case 104:
      return crit_e::reject;
    case 23:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
pws_restart_ind_ies_o::value_c pws_restart_ind_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 16:
      ret.set(value_c::types::cell_id_list_for_restart);
      break;
    case 27:
      ret.set(value_c::types::global_ran_node_id);
      break;
    case 104:
      ret.set(value_c::types::tai_list_for_restart);
      break;
    case 23:
      ret.set(value_c::types::emergency_area_id_list_for_restart);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pws_restart_ind_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 16:
      return presence_e::mandatory;
    case 27:
      return presence_e::mandatory;
    case 104:
      return presence_e::mandatory;
    case 23:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void pws_restart_ind_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::cell_id_list_for_restart:
      c.destroy<cell_id_list_for_restart_c>();
      break;
    case types::global_ran_node_id:
      c.destroy<global_ran_node_id_c>();
      break;
    case types::tai_list_for_restart:
      c.destroy<tai_list_for_restart_l>();
      break;
    case types::emergency_area_id_list_for_restart:
      c.destroy<emergency_area_id_list_for_restart_l>();
      break;
    default:
      break;
  }
}
void pws_restart_ind_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::cell_id_list_for_restart:
      c.init<cell_id_list_for_restart_c>();
      break;
    case types::global_ran_node_id:
      c.init<global_ran_node_id_c>();
      break;
    case types::tai_list_for_restart:
      c.init<tai_list_for_restart_l>();
      break;
    case types::emergency_area_id_list_for_restart:
      c.init<emergency_area_id_list_for_restart_l>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pws_restart_ind_ies_o::value_c");
  }
}
pws_restart_ind_ies_o::value_c::value_c(const pws_restart_ind_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::cell_id_list_for_restart:
      c.init(other.c.get<cell_id_list_for_restart_c>());
      break;
    case types::global_ran_node_id:
      c.init(other.c.get<global_ran_node_id_c>());
      break;
    case types::tai_list_for_restart:
      c.init(other.c.get<tai_list_for_restart_l>());
      break;
    case types::emergency_area_id_list_for_restart:
      c.init(other.c.get<emergency_area_id_list_for_restart_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pws_restart_ind_ies_o::value_c");
  }
}
pws_restart_ind_ies_o::value_c& pws_restart_ind_ies_o::value_c::operator=(const pws_restart_ind_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::cell_id_list_for_restart:
      c.set(other.c.get<cell_id_list_for_restart_c>());
      break;
    case types::global_ran_node_id:
      c.set(other.c.get<global_ran_node_id_c>());
      break;
    case types::tai_list_for_restart:
      c.set(other.c.get<tai_list_for_restart_l>());
      break;
    case types::emergency_area_id_list_for_restart:
      c.set(other.c.get<emergency_area_id_list_for_restart_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pws_restart_ind_ies_o::value_c");
  }

  return *this;
}
cell_id_list_for_restart_c& pws_restart_ind_ies_o::value_c::cell_id_list_for_restart()
{
  assert_choice_type(types::cell_id_list_for_restart, type_, "Value");
  return c.get<cell_id_list_for_restart_c>();
}
global_ran_node_id_c& pws_restart_ind_ies_o::value_c::global_ran_node_id()
{
  assert_choice_type(types::global_ran_node_id, type_, "Value");
  return c.get<global_ran_node_id_c>();
}
tai_list_for_restart_l& pws_restart_ind_ies_o::value_c::tai_list_for_restart()
{
  assert_choice_type(types::tai_list_for_restart, type_, "Value");
  return c.get<tai_list_for_restart_l>();
}
emergency_area_id_list_for_restart_l& pws_restart_ind_ies_o::value_c::emergency_area_id_list_for_restart()
{
  assert_choice_type(types::emergency_area_id_list_for_restart, type_, "Value");
  return c.get<emergency_area_id_list_for_restart_l>();
}
const cell_id_list_for_restart_c& pws_restart_ind_ies_o::value_c::cell_id_list_for_restart() const
{
  assert_choice_type(types::cell_id_list_for_restart, type_, "Value");
  return c.get<cell_id_list_for_restart_c>();
}
const global_ran_node_id_c& pws_restart_ind_ies_o::value_c::global_ran_node_id() const
{
  assert_choice_type(types::global_ran_node_id, type_, "Value");
  return c.get<global_ran_node_id_c>();
}
const tai_list_for_restart_l& pws_restart_ind_ies_o::value_c::tai_list_for_restart() const
{
  assert_choice_type(types::tai_list_for_restart, type_, "Value");
  return c.get<tai_list_for_restart_l>();
}
const emergency_area_id_list_for_restart_l& pws_restart_ind_ies_o::value_c::emergency_area_id_list_for_restart() const
{
  assert_choice_type(types::emergency_area_id_list_for_restart, type_, "Value");
  return c.get<emergency_area_id_list_for_restart_l>();
}
void pws_restart_ind_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::cell_id_list_for_restart:
      j.write_fieldname("CellIDListForRestart");
      c.get<cell_id_list_for_restart_c>().to_json(j);
      break;
    case types::global_ran_node_id:
      j.write_fieldname("GlobalRANNodeID");
      c.get<global_ran_node_id_c>().to_json(j);
      break;
    case types::tai_list_for_restart:
      j.start_array("TAIListForRestart");
      for (const auto& e1 : c.get<tai_list_for_restart_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::emergency_area_id_list_for_restart:
      j.start_array("EmergencyAreaIDListForRestart");
      for (const auto& e1 : c.get<emergency_area_id_list_for_restart_l>()) {
        j.write_str(e1.to_string());
      }
      j.end_array();
      break;
    default:
      log_invalid_choice_id(type_, "pws_restart_ind_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE pws_restart_ind_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::cell_id_list_for_restart:
      HANDLE_CODE(c.get<cell_id_list_for_restart_c>().pack(bref));
      break;
    case types::global_ran_node_id:
      HANDLE_CODE(c.get<global_ran_node_id_c>().pack(bref));
      break;
    case types::tai_list_for_restart:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<tai_list_for_restart_l>(), 1, 2048, true));
      break;
    case types::emergency_area_id_list_for_restart:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<emergency_area_id_list_for_restart_l>(), 1, 256, true));
      break;
    default:
      log_invalid_choice_id(type_, "pws_restart_ind_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE pws_restart_ind_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::cell_id_list_for_restart:
      HANDLE_CODE(c.get<cell_id_list_for_restart_c>().unpack(bref));
      break;
    case types::global_ran_node_id:
      HANDLE_CODE(c.get<global_ran_node_id_c>().unpack(bref));
      break;
    case types::tai_list_for_restart:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<tai_list_for_restart_l>(), bref, 1, 2048, true));
      break;
    case types::emergency_area_id_list_for_restart:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<emergency_area_id_list_for_restart_l>(), bref, 1, 256, true));
      break;
    default:
      log_invalid_choice_id(type_, "pws_restart_ind_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* pws_restart_ind_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {
      "CellIDListForRestart", "GlobalRANNodeID", "TAIListForRestart", "EmergencyAreaIDListForRestart"};
  return convert_enum_idx(names, 4, value, "pws_restart_ind_ies_o::value_c::types");
}

// PagingIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t paging_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {115, 50, 103, 52, 118, 51, 11, 203, 202, 205, 208, 223, 222, 332, 342, 344};
  return map_enum_number(names, 16, idx, "id");
}
bool paging_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {115, 50, 103, 52, 118, 51, 11, 203, 202, 205, 208, 223, 222, 332, 342, 344};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e paging_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 115:
      return crit_e::ignore;
    case 50:
      return crit_e::ignore;
    case 103:
      return crit_e::ignore;
    case 52:
      return crit_e::ignore;
    case 118:
      return crit_e::ignore;
    case 51:
      return crit_e::ignore;
    case 11:
      return crit_e::ignore;
    case 203:
      return crit_e::ignore;
    case 202:
      return crit_e::ignore;
    case 205:
      return crit_e::ignore;
    case 208:
      return crit_e::ignore;
    case 223:
      return crit_e::ignore;
    case 222:
      return crit_e::ignore;
    case 332:
      return crit_e::ignore;
    case 342:
      return crit_e::ignore;
    case 344:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
paging_ies_o::value_c paging_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 115:
      ret.set(value_c::types::ue_paging_id);
      break;
    case 50:
      ret.set(value_c::types::paging_drx);
      break;
    case 103:
      ret.set(value_c::types::tai_list_for_paging);
      break;
    case 52:
      ret.set(value_c::types::paging_prio);
      break;
    case 118:
      ret.set(value_c::types::ue_radio_cap_for_paging);
      break;
    case 51:
      ret.set(value_c::types::paging_origin);
      break;
    case 11:
      ret.set(value_c::types::assist_data_for_paging);
      break;
    case 203:
      ret.set(value_c::types::nb_iot_paging_e_drx_info);
      break;
    case 202:
      ret.set(value_c::types::nb_iot_paging_drx);
      break;
    case 205:
      ret.set(value_c::types::enhanced_coverage_restrict);
      break;
    case 208:
      ret.set(value_c::types::wus_assist_info);
      break;
    case 223:
      ret.set(value_c::types::eutra_paginge_drx_info);
      break;
    case 222:
      ret.set(value_c::types::ce_mode_brestricted);
      break;
    case 332:
      ret.set(value_c::types::nr_paginge_drx_info);
      break;
    case 342:
      ret.set(value_c::types::paging_cause);
      break;
    case 344:
      ret.set(value_c::types::pe_ip_sassist_info);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e paging_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 115:
      return presence_e::mandatory;
    case 50:
      return presence_e::optional;
    case 103:
      return presence_e::mandatory;
    case 52:
      return presence_e::optional;
    case 118:
      return presence_e::optional;
    case 51:
      return presence_e::optional;
    case 11:
      return presence_e::optional;
    case 203:
      return presence_e::optional;
    case 202:
      return presence_e::optional;
    case 205:
      return presence_e::optional;
    case 208:
      return presence_e::optional;
    case 223:
      return presence_e::optional;
    case 222:
      return presence_e::optional;
    case 332:
      return presence_e::optional;
    case 342:
      return presence_e::optional;
    case 344:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void paging_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::ue_paging_id:
      c.destroy<ue_paging_id_c>();
      break;
    case types::tai_list_for_paging:
      c.destroy<tai_list_for_paging_l>();
      break;
    case types::ue_radio_cap_for_paging:
      c.destroy<ue_radio_cap_for_paging_s>();
      break;
    case types::assist_data_for_paging:
      c.destroy<assist_data_for_paging_s>();
      break;
    case types::nb_iot_paging_e_drx_info:
      c.destroy<nb_iot_paging_e_drx_info_s>();
      break;
    case types::wus_assist_info:
      c.destroy<wus_assist_info_s>();
      break;
    case types::eutra_paginge_drx_info:
      c.destroy<eutra_paginge_drx_info_s>();
      break;
    case types::nr_paginge_drx_info:
      c.destroy<nr_paginge_drx_info_s>();
      break;
    case types::pe_ip_sassist_info:
      c.destroy<pe_ip_sassist_info_s>();
      break;
    default:
      break;
  }
}
void paging_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::ue_paging_id:
      c.init<ue_paging_id_c>();
      break;
    case types::paging_drx:
      break;
    case types::tai_list_for_paging:
      c.init<tai_list_for_paging_l>();
      break;
    case types::paging_prio:
      break;
    case types::ue_radio_cap_for_paging:
      c.init<ue_radio_cap_for_paging_s>();
      break;
    case types::paging_origin:
      break;
    case types::assist_data_for_paging:
      c.init<assist_data_for_paging_s>();
      break;
    case types::nb_iot_paging_e_drx_info:
      c.init<nb_iot_paging_e_drx_info_s>();
      break;
    case types::nb_iot_paging_drx:
      break;
    case types::enhanced_coverage_restrict:
      break;
    case types::wus_assist_info:
      c.init<wus_assist_info_s>();
      break;
    case types::eutra_paginge_drx_info:
      c.init<eutra_paginge_drx_info_s>();
      break;
    case types::ce_mode_brestricted:
      break;
    case types::nr_paginge_drx_info:
      c.init<nr_paginge_drx_info_s>();
      break;
    case types::paging_cause:
      break;
    case types::pe_ip_sassist_info:
      c.init<pe_ip_sassist_info_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "paging_ies_o::value_c");
  }
}
paging_ies_o::value_c::value_c(const paging_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::ue_paging_id:
      c.init(other.c.get<ue_paging_id_c>());
      break;
    case types::paging_drx:
      c.init(other.c.get<paging_drx_e>());
      break;
    case types::tai_list_for_paging:
      c.init(other.c.get<tai_list_for_paging_l>());
      break;
    case types::paging_prio:
      c.init(other.c.get<paging_prio_e>());
      break;
    case types::ue_radio_cap_for_paging:
      c.init(other.c.get<ue_radio_cap_for_paging_s>());
      break;
    case types::paging_origin:
      c.init(other.c.get<paging_origin_e>());
      break;
    case types::assist_data_for_paging:
      c.init(other.c.get<assist_data_for_paging_s>());
      break;
    case types::nb_iot_paging_e_drx_info:
      c.init(other.c.get<nb_iot_paging_e_drx_info_s>());
      break;
    case types::nb_iot_paging_drx:
      c.init(other.c.get<nb_iot_paging_drx_e>());
      break;
    case types::enhanced_coverage_restrict:
      c.init(other.c.get<enhanced_coverage_restrict_e>());
      break;
    case types::wus_assist_info:
      c.init(other.c.get<wus_assist_info_s>());
      break;
    case types::eutra_paginge_drx_info:
      c.init(other.c.get<eutra_paginge_drx_info_s>());
      break;
    case types::ce_mode_brestricted:
      c.init(other.c.get<ce_mode_brestricted_e>());
      break;
    case types::nr_paginge_drx_info:
      c.init(other.c.get<nr_paginge_drx_info_s>());
      break;
    case types::paging_cause:
      c.init(other.c.get<paging_cause_e>());
      break;
    case types::pe_ip_sassist_info:
      c.init(other.c.get<pe_ip_sassist_info_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "paging_ies_o::value_c");
  }
}
paging_ies_o::value_c& paging_ies_o::value_c::operator=(const paging_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::ue_paging_id:
      c.set(other.c.get<ue_paging_id_c>());
      break;
    case types::paging_drx:
      c.set(other.c.get<paging_drx_e>());
      break;
    case types::tai_list_for_paging:
      c.set(other.c.get<tai_list_for_paging_l>());
      break;
    case types::paging_prio:
      c.set(other.c.get<paging_prio_e>());
      break;
    case types::ue_radio_cap_for_paging:
      c.set(other.c.get<ue_radio_cap_for_paging_s>());
      break;
    case types::paging_origin:
      c.set(other.c.get<paging_origin_e>());
      break;
    case types::assist_data_for_paging:
      c.set(other.c.get<assist_data_for_paging_s>());
      break;
    case types::nb_iot_paging_e_drx_info:
      c.set(other.c.get<nb_iot_paging_e_drx_info_s>());
      break;
    case types::nb_iot_paging_drx:
      c.set(other.c.get<nb_iot_paging_drx_e>());
      break;
    case types::enhanced_coverage_restrict:
      c.set(other.c.get<enhanced_coverage_restrict_e>());
      break;
    case types::wus_assist_info:
      c.set(other.c.get<wus_assist_info_s>());
      break;
    case types::eutra_paginge_drx_info:
      c.set(other.c.get<eutra_paginge_drx_info_s>());
      break;
    case types::ce_mode_brestricted:
      c.set(other.c.get<ce_mode_brestricted_e>());
      break;
    case types::nr_paginge_drx_info:
      c.set(other.c.get<nr_paginge_drx_info_s>());
      break;
    case types::paging_cause:
      c.set(other.c.get<paging_cause_e>());
      break;
    case types::pe_ip_sassist_info:
      c.set(other.c.get<pe_ip_sassist_info_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "paging_ies_o::value_c");
  }

  return *this;
}
ue_paging_id_c& paging_ies_o::value_c::ue_paging_id()
{
  assert_choice_type(types::ue_paging_id, type_, "Value");
  return c.get<ue_paging_id_c>();
}
paging_drx_e& paging_ies_o::value_c::paging_drx()
{
  assert_choice_type(types::paging_drx, type_, "Value");
  return c.get<paging_drx_e>();
}
tai_list_for_paging_l& paging_ies_o::value_c::tai_list_for_paging()
{
  assert_choice_type(types::tai_list_for_paging, type_, "Value");
  return c.get<tai_list_for_paging_l>();
}
paging_prio_e& paging_ies_o::value_c::paging_prio()
{
  assert_choice_type(types::paging_prio, type_, "Value");
  return c.get<paging_prio_e>();
}
ue_radio_cap_for_paging_s& paging_ies_o::value_c::ue_radio_cap_for_paging()
{
  assert_choice_type(types::ue_radio_cap_for_paging, type_, "Value");
  return c.get<ue_radio_cap_for_paging_s>();
}
paging_origin_e& paging_ies_o::value_c::paging_origin()
{
  assert_choice_type(types::paging_origin, type_, "Value");
  return c.get<paging_origin_e>();
}
assist_data_for_paging_s& paging_ies_o::value_c::assist_data_for_paging()
{
  assert_choice_type(types::assist_data_for_paging, type_, "Value");
  return c.get<assist_data_for_paging_s>();
}
nb_iot_paging_e_drx_info_s& paging_ies_o::value_c::nb_iot_paging_e_drx_info()
{
  assert_choice_type(types::nb_iot_paging_e_drx_info, type_, "Value");
  return c.get<nb_iot_paging_e_drx_info_s>();
}
nb_iot_paging_drx_e& paging_ies_o::value_c::nb_iot_paging_drx()
{
  assert_choice_type(types::nb_iot_paging_drx, type_, "Value");
  return c.get<nb_iot_paging_drx_e>();
}
enhanced_coverage_restrict_e& paging_ies_o::value_c::enhanced_coverage_restrict()
{
  assert_choice_type(types::enhanced_coverage_restrict, type_, "Value");
  return c.get<enhanced_coverage_restrict_e>();
}
wus_assist_info_s& paging_ies_o::value_c::wus_assist_info()
{
  assert_choice_type(types::wus_assist_info, type_, "Value");
  return c.get<wus_assist_info_s>();
}
eutra_paginge_drx_info_s& paging_ies_o::value_c::eutra_paginge_drx_info()
{
  assert_choice_type(types::eutra_paginge_drx_info, type_, "Value");
  return c.get<eutra_paginge_drx_info_s>();
}
ce_mode_brestricted_e& paging_ies_o::value_c::ce_mode_brestricted()
{
  assert_choice_type(types::ce_mode_brestricted, type_, "Value");
  return c.get<ce_mode_brestricted_e>();
}
nr_paginge_drx_info_s& paging_ies_o::value_c::nr_paginge_drx_info()
{
  assert_choice_type(types::nr_paginge_drx_info, type_, "Value");
  return c.get<nr_paginge_drx_info_s>();
}
paging_cause_e& paging_ies_o::value_c::paging_cause()
{
  assert_choice_type(types::paging_cause, type_, "Value");
  return c.get<paging_cause_e>();
}
pe_ip_sassist_info_s& paging_ies_o::value_c::pe_ip_sassist_info()
{
  assert_choice_type(types::pe_ip_sassist_info, type_, "Value");
  return c.get<pe_ip_sassist_info_s>();
}
const ue_paging_id_c& paging_ies_o::value_c::ue_paging_id() const
{
  assert_choice_type(types::ue_paging_id, type_, "Value");
  return c.get<ue_paging_id_c>();
}
const paging_drx_e& paging_ies_o::value_c::paging_drx() const
{
  assert_choice_type(types::paging_drx, type_, "Value");
  return c.get<paging_drx_e>();
}
const tai_list_for_paging_l& paging_ies_o::value_c::tai_list_for_paging() const
{
  assert_choice_type(types::tai_list_for_paging, type_, "Value");
  return c.get<tai_list_for_paging_l>();
}
const paging_prio_e& paging_ies_o::value_c::paging_prio() const
{
  assert_choice_type(types::paging_prio, type_, "Value");
  return c.get<paging_prio_e>();
}
const ue_radio_cap_for_paging_s& paging_ies_o::value_c::ue_radio_cap_for_paging() const
{
  assert_choice_type(types::ue_radio_cap_for_paging, type_, "Value");
  return c.get<ue_radio_cap_for_paging_s>();
}
const paging_origin_e& paging_ies_o::value_c::paging_origin() const
{
  assert_choice_type(types::paging_origin, type_, "Value");
  return c.get<paging_origin_e>();
}
const assist_data_for_paging_s& paging_ies_o::value_c::assist_data_for_paging() const
{
  assert_choice_type(types::assist_data_for_paging, type_, "Value");
  return c.get<assist_data_for_paging_s>();
}
const nb_iot_paging_e_drx_info_s& paging_ies_o::value_c::nb_iot_paging_e_drx_info() const
{
  assert_choice_type(types::nb_iot_paging_e_drx_info, type_, "Value");
  return c.get<nb_iot_paging_e_drx_info_s>();
}
const nb_iot_paging_drx_e& paging_ies_o::value_c::nb_iot_paging_drx() const
{
  assert_choice_type(types::nb_iot_paging_drx, type_, "Value");
  return c.get<nb_iot_paging_drx_e>();
}
const enhanced_coverage_restrict_e& paging_ies_o::value_c::enhanced_coverage_restrict() const
{
  assert_choice_type(types::enhanced_coverage_restrict, type_, "Value");
  return c.get<enhanced_coverage_restrict_e>();
}
const wus_assist_info_s& paging_ies_o::value_c::wus_assist_info() const
{
  assert_choice_type(types::wus_assist_info, type_, "Value");
  return c.get<wus_assist_info_s>();
}
const eutra_paginge_drx_info_s& paging_ies_o::value_c::eutra_paginge_drx_info() const
{
  assert_choice_type(types::eutra_paginge_drx_info, type_, "Value");
  return c.get<eutra_paginge_drx_info_s>();
}
const ce_mode_brestricted_e& paging_ies_o::value_c::ce_mode_brestricted() const
{
  assert_choice_type(types::ce_mode_brestricted, type_, "Value");
  return c.get<ce_mode_brestricted_e>();
}
const nr_paginge_drx_info_s& paging_ies_o::value_c::nr_paginge_drx_info() const
{
  assert_choice_type(types::nr_paginge_drx_info, type_, "Value");
  return c.get<nr_paginge_drx_info_s>();
}
const paging_cause_e& paging_ies_o::value_c::paging_cause() const
{
  assert_choice_type(types::paging_cause, type_, "Value");
  return c.get<paging_cause_e>();
}
const pe_ip_sassist_info_s& paging_ies_o::value_c::pe_ip_sassist_info() const
{
  assert_choice_type(types::pe_ip_sassist_info, type_, "Value");
  return c.get<pe_ip_sassist_info_s>();
}
void paging_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::ue_paging_id:
      j.write_fieldname("UEPagingIdentity");
      c.get<ue_paging_id_c>().to_json(j);
      break;
    case types::paging_drx:
      j.write_str("PagingDRX", c.get<paging_drx_e>().to_string());
      break;
    case types::tai_list_for_paging:
      j.start_array("TAIListForPaging");
      for (const auto& e1 : c.get<tai_list_for_paging_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::paging_prio:
      j.write_str("PagingPriority", c.get<paging_prio_e>().to_string());
      break;
    case types::ue_radio_cap_for_paging:
      j.write_fieldname("UERadioCapabilityForPaging");
      c.get<ue_radio_cap_for_paging_s>().to_json(j);
      break;
    case types::paging_origin:
      j.write_str("PagingOrigin", "non-3gpp");
      break;
    case types::assist_data_for_paging:
      j.write_fieldname("AssistanceDataForPaging");
      c.get<assist_data_for_paging_s>().to_json(j);
      break;
    case types::nb_iot_paging_e_drx_info:
      j.write_fieldname("NB-IoT-Paging-eDRXInfo");
      c.get<nb_iot_paging_e_drx_info_s>().to_json(j);
      break;
    case types::nb_iot_paging_drx:
      j.write_str("NB-IoT-PagingDRX", c.get<nb_iot_paging_drx_e>().to_string());
      break;
    case types::enhanced_coverage_restrict:
      j.write_str("Enhanced-CoverageRestriction", "restricted");
      break;
    case types::wus_assist_info:
      j.write_fieldname("WUS-Assistance-Information");
      c.get<wus_assist_info_s>().to_json(j);
      break;
    case types::eutra_paginge_drx_info:
      j.write_fieldname("EUTRA-PagingeDRXInformation");
      c.get<eutra_paginge_drx_info_s>().to_json(j);
      break;
    case types::ce_mode_brestricted:
      j.write_str("CEmodeBrestricted", c.get<ce_mode_brestricted_e>().to_string());
      break;
    case types::nr_paginge_drx_info:
      j.write_fieldname("NR-PagingeDRXInformation");
      c.get<nr_paginge_drx_info_s>().to_json(j);
      break;
    case types::paging_cause:
      j.write_str("PagingCause", "voice");
      break;
    case types::pe_ip_sassist_info:
      j.write_fieldname("PEIPSassistanceInformation");
      c.get<pe_ip_sassist_info_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "paging_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE paging_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ue_paging_id:
      HANDLE_CODE(c.get<ue_paging_id_c>().pack(bref));
      break;
    case types::paging_drx:
      HANDLE_CODE(c.get<paging_drx_e>().pack(bref));
      break;
    case types::tai_list_for_paging:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<tai_list_for_paging_l>(), 1, 16, true));
      break;
    case types::paging_prio:
      HANDLE_CODE(c.get<paging_prio_e>().pack(bref));
      break;
    case types::ue_radio_cap_for_paging:
      HANDLE_CODE(c.get<ue_radio_cap_for_paging_s>().pack(bref));
      break;
    case types::paging_origin:
      HANDLE_CODE(c.get<paging_origin_e>().pack(bref));
      break;
    case types::assist_data_for_paging:
      HANDLE_CODE(c.get<assist_data_for_paging_s>().pack(bref));
      break;
    case types::nb_iot_paging_e_drx_info:
      HANDLE_CODE(c.get<nb_iot_paging_e_drx_info_s>().pack(bref));
      break;
    case types::nb_iot_paging_drx:
      HANDLE_CODE(c.get<nb_iot_paging_drx_e>().pack(bref));
      break;
    case types::enhanced_coverage_restrict:
      HANDLE_CODE(c.get<enhanced_coverage_restrict_e>().pack(bref));
      break;
    case types::wus_assist_info:
      HANDLE_CODE(c.get<wus_assist_info_s>().pack(bref));
      break;
    case types::eutra_paginge_drx_info:
      HANDLE_CODE(c.get<eutra_paginge_drx_info_s>().pack(bref));
      break;
    case types::ce_mode_brestricted:
      HANDLE_CODE(c.get<ce_mode_brestricted_e>().pack(bref));
      break;
    case types::nr_paginge_drx_info:
      HANDLE_CODE(c.get<nr_paginge_drx_info_s>().pack(bref));
      break;
    case types::paging_cause:
      HANDLE_CODE(c.get<paging_cause_e>().pack(bref));
      break;
    case types::pe_ip_sassist_info:
      HANDLE_CODE(c.get<pe_ip_sassist_info_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "paging_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE paging_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ue_paging_id:
      HANDLE_CODE(c.get<ue_paging_id_c>().unpack(bref));
      break;
    case types::paging_drx:
      HANDLE_CODE(c.get<paging_drx_e>().unpack(bref));
      break;
    case types::tai_list_for_paging:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<tai_list_for_paging_l>(), bref, 1, 16, true));
      break;
    case types::paging_prio:
      HANDLE_CODE(c.get<paging_prio_e>().unpack(bref));
      break;
    case types::ue_radio_cap_for_paging:
      HANDLE_CODE(c.get<ue_radio_cap_for_paging_s>().unpack(bref));
      break;
    case types::paging_origin:
      HANDLE_CODE(c.get<paging_origin_e>().unpack(bref));
      break;
    case types::assist_data_for_paging:
      HANDLE_CODE(c.get<assist_data_for_paging_s>().unpack(bref));
      break;
    case types::nb_iot_paging_e_drx_info:
      HANDLE_CODE(c.get<nb_iot_paging_e_drx_info_s>().unpack(bref));
      break;
    case types::nb_iot_paging_drx:
      HANDLE_CODE(c.get<nb_iot_paging_drx_e>().unpack(bref));
      break;
    case types::enhanced_coverage_restrict:
      HANDLE_CODE(c.get<enhanced_coverage_restrict_e>().unpack(bref));
      break;
    case types::wus_assist_info:
      HANDLE_CODE(c.get<wus_assist_info_s>().unpack(bref));
      break;
    case types::eutra_paginge_drx_info:
      HANDLE_CODE(c.get<eutra_paginge_drx_info_s>().unpack(bref));
      break;
    case types::ce_mode_brestricted:
      HANDLE_CODE(c.get<ce_mode_brestricted_e>().unpack(bref));
      break;
    case types::nr_paginge_drx_info:
      HANDLE_CODE(c.get<nr_paginge_drx_info_s>().unpack(bref));
      break;
    case types::paging_cause:
      HANDLE_CODE(c.get<paging_cause_e>().unpack(bref));
      break;
    case types::pe_ip_sassist_info:
      HANDLE_CODE(c.get<pe_ip_sassist_info_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "paging_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* paging_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"UEPagingIdentity",
                                "PagingDRX",
                                "TAIListForPaging",
                                "PagingPriority",
                                "UERadioCapabilityForPaging",
                                "PagingOrigin",
                                "AssistanceDataForPaging",
                                "NB-IoT-Paging-eDRXInfo",
                                "NB-IoT-PagingDRX",
                                "Enhanced-CoverageRestriction",
                                "WUS-Assistance-Information",
                                "EUTRA-PagingeDRXInformation",
                                "CEmodeBrestricted",
                                "NR-PagingeDRXInformation",
                                "PagingCause",
                                "PEIPSassistanceInformation"};
  return convert_enum_idx(names, 16, value, "paging_ies_o::value_c::types");
}

// PathSwitchRequestAcknowledgeIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t path_switch_request_ack_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10,  85,  119, 93,  41,  77,  68,  0,   18,  91,  19,  146, 165, 177, 205, 206,
                                   209, 216, 215, 218, 217, 219, 222, 234, 264, 254, 326, 345, 346, 347, 359};
  return map_enum_number(names, 31, idx, "id");
}
bool path_switch_request_ack_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10,  85,  119, 93,  41,  77,  68,  0,   18,  91,  19,  146, 165, 177, 205, 206,
                                   209, 216, 215, 218, 217, 219, 222, 234, 264, 254, 326, 345, 346, 347, 359};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e path_switch_request_ack_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::ignore;
    case 85:
      return crit_e::ignore;
    case 119:
      return crit_e::reject;
    case 93:
      return crit_e::reject;
    case 41:
      return crit_e::reject;
    case 77:
      return crit_e::ignore;
    case 68:
      return crit_e::ignore;
    case 0:
      return crit_e::reject;
    case 18:
      return crit_e::ignore;
    case 91:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    case 146:
      return crit_e::ignore;
    case 165:
      return crit_e::ignore;
    case 177:
      return crit_e::ignore;
    case 205:
      return crit_e::ignore;
    case 206:
      return crit_e::ignore;
    case 209:
      return crit_e::ignore;
    case 216:
      return crit_e::ignore;
    case 215:
      return crit_e::ignore;
    case 218:
      return crit_e::ignore;
    case 217:
      return crit_e::ignore;
    case 219:
      return crit_e::ignore;
    case 222:
      return crit_e::ignore;
    case 234:
      return crit_e::ignore;
    case 264:
      return crit_e::reject;
    case 254:
      return crit_e::ignore;
    case 326:
      return crit_e::ignore;
    case 345:
      return crit_e::ignore;
    case 346:
      return crit_e::ignore;
    case 347:
      return crit_e::ignore;
    case 359:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
path_switch_request_ack_ies_o::value_c path_switch_request_ack_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 119:
      ret.set(value_c::types::ue_security_cap);
      break;
    case 93:
      ret.set(value_c::types::security_context);
      break;
    case 41:
      ret.set(value_c::types::new_security_context_ind);
      break;
    case 77:
      ret.set(value_c::types::pdu_session_res_switched_list);
      break;
    case 68:
      ret.set(value_c::types::pdu_session_res_released_list_ps_ack);
      break;
    case 0:
      ret.set(value_c::types::allowed_nssai);
      break;
    case 18:
      ret.set(value_c::types::core_network_assist_info_for_inactive);
      break;
    case 91:
      ret.set(value_c::types::rrc_inactive_transition_report_request);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    case 146:
      ret.set(value_c::types::redirection_voice_fallback);
      break;
    case 165:
      ret.set(value_c::types::cn_assisted_ran_tuning);
      break;
    case 177:
      ret.set(value_c::types::srvcc_operation_possible);
      break;
    case 205:
      ret.set(value_c::types::enhanced_coverage_restrict);
      break;
    case 206:
      ret.set(value_c::types::extended_connected_time);
      break;
    case 209:
      ret.set(value_c::types::ue_diff_info);
      break;
    case 216:
      ret.set(value_c::types::nr_v2x_services_authorized);
      break;
    case 215:
      ret.set(value_c::types::ltev2x_services_authorized);
      break;
    case 218:
      ret.set(value_c::types::nr_ue_sidelink_aggr_max_bitrate);
      break;
    case 217:
      ret.set(value_c::types::lte_ue_sidelink_aggr_max_bitrate);
      break;
    case 219:
      ret.set(value_c::types::pc5_qos_params);
      break;
    case 222:
      ret.set(value_c::types::ce_mode_brestricted);
      break;
    case 234:
      ret.set(value_c::types::ue_up_c_iot_support);
      break;
    case 264:
      ret.set(value_c::types::ue_radio_cap_id);
      break;
    case 254:
      ret.set(value_c::types::management_based_mdt_plmn_list);
      break;
    case 326:
      ret.set(value_c::types::time_sync_assist_info);
      break;
    case 345:
      ret.set(value_c::types::five_g_pro_se_authorized);
      break;
    case 346:
      ret.set(value_c::types::five_g_pro_se_ue_pc5_aggr_max_bit_rate);
      break;
    case 347:
      ret.set(value_c::types::five_g_pro_se_pc5_qos_params);
      break;
    case 359:
      ret.set(value_c::types::management_based_mdt_plmn_mod_list);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e path_switch_request_ack_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 119:
      return presence_e::optional;
    case 93:
      return presence_e::mandatory;
    case 41:
      return presence_e::optional;
    case 77:
      return presence_e::mandatory;
    case 68:
      return presence_e::optional;
    case 0:
      return presence_e::mandatory;
    case 18:
      return presence_e::optional;
    case 91:
      return presence_e::optional;
    case 19:
      return presence_e::optional;
    case 146:
      return presence_e::optional;
    case 165:
      return presence_e::optional;
    case 177:
      return presence_e::optional;
    case 205:
      return presence_e::optional;
    case 206:
      return presence_e::optional;
    case 209:
      return presence_e::optional;
    case 216:
      return presence_e::optional;
    case 215:
      return presence_e::optional;
    case 218:
      return presence_e::optional;
    case 217:
      return presence_e::optional;
    case 219:
      return presence_e::optional;
    case 222:
      return presence_e::optional;
    case 234:
      return presence_e::optional;
    case 264:
      return presence_e::optional;
    case 254:
      return presence_e::optional;
    case 326:
      return presence_e::optional;
    case 345:
      return presence_e::optional;
    case 346:
      return presence_e::optional;
    case 347:
      return presence_e::optional;
    case 359:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void path_switch_request_ack_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::ue_security_cap:
      c.destroy<ue_security_cap_s>();
      break;
    case types::security_context:
      c.destroy<security_context_s>();
      break;
    case types::pdu_session_res_switched_list:
      c.destroy<pdu_session_res_switched_list_l>();
      break;
    case types::pdu_session_res_released_list_ps_ack:
      c.destroy<pdu_session_res_released_list_ps_ack_l>();
      break;
    case types::allowed_nssai:
      c.destroy<allowed_nssai_l>();
      break;
    case types::core_network_assist_info_for_inactive:
      c.destroy<core_network_assist_info_for_inactive_s>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    case types::cn_assisted_ran_tuning:
      c.destroy<cn_assisted_ran_tuning_s>();
      break;
    case types::ue_diff_info:
      c.destroy<ue_diff_info_s>();
      break;
    case types::nr_v2x_services_authorized:
      c.destroy<nr_v2x_services_authorized_s>();
      break;
    case types::ltev2x_services_authorized:
      c.destroy<ltev2x_services_authorized_s>();
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      c.destroy<nr_ue_sidelink_aggr_max_bitrate_s>();
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      c.destroy<lte_ue_sidelink_aggr_max_bitrate_s>();
      break;
    case types::pc5_qos_params:
      c.destroy<pc5_qos_params_s>();
      break;
    case types::ue_radio_cap_id:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::management_based_mdt_plmn_list:
      c.destroy<mdt_plmn_list_l>();
      break;
    case types::time_sync_assist_info:
      c.destroy<time_sync_assist_info_s>();
      break;
    case types::five_g_pro_se_authorized:
      c.destroy<five_g_pro_se_authorized_s>();
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      c.destroy<nr_ue_sidelink_aggr_max_bitrate_s>();
      break;
    case types::five_g_pro_se_pc5_qos_params:
      c.destroy<five_g_pro_se_pc5_qos_params_s>();
      break;
    case types::management_based_mdt_plmn_mod_list:
      c.destroy<mdt_plmn_mod_list_l>();
      break;
    default:
      break;
  }
}
void path_switch_request_ack_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::ue_security_cap:
      c.init<ue_security_cap_s>();
      break;
    case types::security_context:
      c.init<security_context_s>();
      break;
    case types::new_security_context_ind:
      break;
    case types::pdu_session_res_switched_list:
      c.init<pdu_session_res_switched_list_l>();
      break;
    case types::pdu_session_res_released_list_ps_ack:
      c.init<pdu_session_res_released_list_ps_ack_l>();
      break;
    case types::allowed_nssai:
      c.init<allowed_nssai_l>();
      break;
    case types::core_network_assist_info_for_inactive:
      c.init<core_network_assist_info_for_inactive_s>();
      break;
    case types::rrc_inactive_transition_report_request:
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::redirection_voice_fallback:
      break;
    case types::cn_assisted_ran_tuning:
      c.init<cn_assisted_ran_tuning_s>();
      break;
    case types::srvcc_operation_possible:
      break;
    case types::enhanced_coverage_restrict:
      break;
    case types::extended_connected_time:
      break;
    case types::ue_diff_info:
      c.init<ue_diff_info_s>();
      break;
    case types::nr_v2x_services_authorized:
      c.init<nr_v2x_services_authorized_s>();
      break;
    case types::ltev2x_services_authorized:
      c.init<ltev2x_services_authorized_s>();
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      c.init<nr_ue_sidelink_aggr_max_bitrate_s>();
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      c.init<lte_ue_sidelink_aggr_max_bitrate_s>();
      break;
    case types::pc5_qos_params:
      c.init<pc5_qos_params_s>();
      break;
    case types::ce_mode_brestricted:
      break;
    case types::ue_up_c_iot_support:
      break;
    case types::ue_radio_cap_id:
      c.init<unbounded_octstring<true>>();
      break;
    case types::management_based_mdt_plmn_list:
      c.init<mdt_plmn_list_l>();
      break;
    case types::time_sync_assist_info:
      c.init<time_sync_assist_info_s>();
      break;
    case types::five_g_pro_se_authorized:
      c.init<five_g_pro_se_authorized_s>();
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      c.init<nr_ue_sidelink_aggr_max_bitrate_s>();
      break;
    case types::five_g_pro_se_pc5_qos_params:
      c.init<five_g_pro_se_pc5_qos_params_s>();
      break;
    case types::management_based_mdt_plmn_mod_list:
      c.init<mdt_plmn_mod_list_l>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_ack_ies_o::value_c");
  }
}
path_switch_request_ack_ies_o::value_c::value_c(const path_switch_request_ack_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ue_security_cap:
      c.init(other.c.get<ue_security_cap_s>());
      break;
    case types::security_context:
      c.init(other.c.get<security_context_s>());
      break;
    case types::new_security_context_ind:
      c.init(other.c.get<new_security_context_ind_e>());
      break;
    case types::pdu_session_res_switched_list:
      c.init(other.c.get<pdu_session_res_switched_list_l>());
      break;
    case types::pdu_session_res_released_list_ps_ack:
      c.init(other.c.get<pdu_session_res_released_list_ps_ack_l>());
      break;
    case types::allowed_nssai:
      c.init(other.c.get<allowed_nssai_l>());
      break;
    case types::core_network_assist_info_for_inactive:
      c.init(other.c.get<core_network_assist_info_for_inactive_s>());
      break;
    case types::rrc_inactive_transition_report_request:
      c.init(other.c.get<rrc_inactive_transition_report_request_e>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::redirection_voice_fallback:
      c.init(other.c.get<redirection_voice_fallback_e>());
      break;
    case types::cn_assisted_ran_tuning:
      c.init(other.c.get<cn_assisted_ran_tuning_s>());
      break;
    case types::srvcc_operation_possible:
      c.init(other.c.get<srvcc_operation_possible_e>());
      break;
    case types::enhanced_coverage_restrict:
      c.init(other.c.get<enhanced_coverage_restrict_e>());
      break;
    case types::extended_connected_time:
      c.init(other.c.get<uint16_t>());
      break;
    case types::ue_diff_info:
      c.init(other.c.get<ue_diff_info_s>());
      break;
    case types::nr_v2x_services_authorized:
      c.init(other.c.get<nr_v2x_services_authorized_s>());
      break;
    case types::ltev2x_services_authorized:
      c.init(other.c.get<ltev2x_services_authorized_s>());
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      c.init(other.c.get<nr_ue_sidelink_aggr_max_bitrate_s>());
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      c.init(other.c.get<lte_ue_sidelink_aggr_max_bitrate_s>());
      break;
    case types::pc5_qos_params:
      c.init(other.c.get<pc5_qos_params_s>());
      break;
    case types::ce_mode_brestricted:
      c.init(other.c.get<ce_mode_brestricted_e>());
      break;
    case types::ue_up_c_iot_support:
      c.init(other.c.get<ue_up_c_iot_support_e>());
      break;
    case types::ue_radio_cap_id:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::management_based_mdt_plmn_list:
      c.init(other.c.get<mdt_plmn_list_l>());
      break;
    case types::time_sync_assist_info:
      c.init(other.c.get<time_sync_assist_info_s>());
      break;
    case types::five_g_pro_se_authorized:
      c.init(other.c.get<five_g_pro_se_authorized_s>());
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      c.init(other.c.get<nr_ue_sidelink_aggr_max_bitrate_s>());
      break;
    case types::five_g_pro_se_pc5_qos_params:
      c.init(other.c.get<five_g_pro_se_pc5_qos_params_s>());
      break;
    case types::management_based_mdt_plmn_mod_list:
      c.init(other.c.get<mdt_plmn_mod_list_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_ack_ies_o::value_c");
  }
}
path_switch_request_ack_ies_o::value_c&
path_switch_request_ack_ies_o::value_c::operator=(const path_switch_request_ack_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ue_security_cap:
      c.set(other.c.get<ue_security_cap_s>());
      break;
    case types::security_context:
      c.set(other.c.get<security_context_s>());
      break;
    case types::new_security_context_ind:
      c.set(other.c.get<new_security_context_ind_e>());
      break;
    case types::pdu_session_res_switched_list:
      c.set(other.c.get<pdu_session_res_switched_list_l>());
      break;
    case types::pdu_session_res_released_list_ps_ack:
      c.set(other.c.get<pdu_session_res_released_list_ps_ack_l>());
      break;
    case types::allowed_nssai:
      c.set(other.c.get<allowed_nssai_l>());
      break;
    case types::core_network_assist_info_for_inactive:
      c.set(other.c.get<core_network_assist_info_for_inactive_s>());
      break;
    case types::rrc_inactive_transition_report_request:
      c.set(other.c.get<rrc_inactive_transition_report_request_e>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::redirection_voice_fallback:
      c.set(other.c.get<redirection_voice_fallback_e>());
      break;
    case types::cn_assisted_ran_tuning:
      c.set(other.c.get<cn_assisted_ran_tuning_s>());
      break;
    case types::srvcc_operation_possible:
      c.set(other.c.get<srvcc_operation_possible_e>());
      break;
    case types::enhanced_coverage_restrict:
      c.set(other.c.get<enhanced_coverage_restrict_e>());
      break;
    case types::extended_connected_time:
      c.set(other.c.get<uint16_t>());
      break;
    case types::ue_diff_info:
      c.set(other.c.get<ue_diff_info_s>());
      break;
    case types::nr_v2x_services_authorized:
      c.set(other.c.get<nr_v2x_services_authorized_s>());
      break;
    case types::ltev2x_services_authorized:
      c.set(other.c.get<ltev2x_services_authorized_s>());
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      c.set(other.c.get<nr_ue_sidelink_aggr_max_bitrate_s>());
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      c.set(other.c.get<lte_ue_sidelink_aggr_max_bitrate_s>());
      break;
    case types::pc5_qos_params:
      c.set(other.c.get<pc5_qos_params_s>());
      break;
    case types::ce_mode_brestricted:
      c.set(other.c.get<ce_mode_brestricted_e>());
      break;
    case types::ue_up_c_iot_support:
      c.set(other.c.get<ue_up_c_iot_support_e>());
      break;
    case types::ue_radio_cap_id:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::management_based_mdt_plmn_list:
      c.set(other.c.get<mdt_plmn_list_l>());
      break;
    case types::time_sync_assist_info:
      c.set(other.c.get<time_sync_assist_info_s>());
      break;
    case types::five_g_pro_se_authorized:
      c.set(other.c.get<five_g_pro_se_authorized_s>());
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      c.set(other.c.get<nr_ue_sidelink_aggr_max_bitrate_s>());
      break;
    case types::five_g_pro_se_pc5_qos_params:
      c.set(other.c.get<five_g_pro_se_pc5_qos_params_s>());
      break;
    case types::management_based_mdt_plmn_mod_list:
      c.set(other.c.get<mdt_plmn_mod_list_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_ack_ies_o::value_c");
  }

  return *this;
}
uint64_t& path_switch_request_ack_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& path_switch_request_ack_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
ue_security_cap_s& path_switch_request_ack_ies_o::value_c::ue_security_cap()
{
  assert_choice_type(types::ue_security_cap, type_, "Value");
  return c.get<ue_security_cap_s>();
}
security_context_s& path_switch_request_ack_ies_o::value_c::security_context()
{
  assert_choice_type(types::security_context, type_, "Value");
  return c.get<security_context_s>();
}
new_security_context_ind_e& path_switch_request_ack_ies_o::value_c::new_security_context_ind()
{
  assert_choice_type(types::new_security_context_ind, type_, "Value");
  return c.get<new_security_context_ind_e>();
}
pdu_session_res_switched_list_l& path_switch_request_ack_ies_o::value_c::pdu_session_res_switched_list()
{
  assert_choice_type(types::pdu_session_res_switched_list, type_, "Value");
  return c.get<pdu_session_res_switched_list_l>();
}
pdu_session_res_released_list_ps_ack_l& path_switch_request_ack_ies_o::value_c::pdu_session_res_released_list_ps_ack()
{
  assert_choice_type(types::pdu_session_res_released_list_ps_ack, type_, "Value");
  return c.get<pdu_session_res_released_list_ps_ack_l>();
}
allowed_nssai_l& path_switch_request_ack_ies_o::value_c::allowed_nssai()
{
  assert_choice_type(types::allowed_nssai, type_, "Value");
  return c.get<allowed_nssai_l>();
}
core_network_assist_info_for_inactive_s& path_switch_request_ack_ies_o::value_c::core_network_assist_info_for_inactive()
{
  assert_choice_type(types::core_network_assist_info_for_inactive, type_, "Value");
  return c.get<core_network_assist_info_for_inactive_s>();
}
rrc_inactive_transition_report_request_e&
path_switch_request_ack_ies_o::value_c::rrc_inactive_transition_report_request()
{
  assert_choice_type(types::rrc_inactive_transition_report_request, type_, "Value");
  return c.get<rrc_inactive_transition_report_request_e>();
}
crit_diagnostics_s& path_switch_request_ack_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
redirection_voice_fallback_e& path_switch_request_ack_ies_o::value_c::redirection_voice_fallback()
{
  assert_choice_type(types::redirection_voice_fallback, type_, "Value");
  return c.get<redirection_voice_fallback_e>();
}
cn_assisted_ran_tuning_s& path_switch_request_ack_ies_o::value_c::cn_assisted_ran_tuning()
{
  assert_choice_type(types::cn_assisted_ran_tuning, type_, "Value");
  return c.get<cn_assisted_ran_tuning_s>();
}
srvcc_operation_possible_e& path_switch_request_ack_ies_o::value_c::srvcc_operation_possible()
{
  assert_choice_type(types::srvcc_operation_possible, type_, "Value");
  return c.get<srvcc_operation_possible_e>();
}
enhanced_coverage_restrict_e& path_switch_request_ack_ies_o::value_c::enhanced_coverage_restrict()
{
  assert_choice_type(types::enhanced_coverage_restrict, type_, "Value");
  return c.get<enhanced_coverage_restrict_e>();
}
uint16_t& path_switch_request_ack_ies_o::value_c::extended_connected_time()
{
  assert_choice_type(types::extended_connected_time, type_, "Value");
  return c.get<uint16_t>();
}
ue_diff_info_s& path_switch_request_ack_ies_o::value_c::ue_diff_info()
{
  assert_choice_type(types::ue_diff_info, type_, "Value");
  return c.get<ue_diff_info_s>();
}
nr_v2x_services_authorized_s& path_switch_request_ack_ies_o::value_c::nr_v2x_services_authorized()
{
  assert_choice_type(types::nr_v2x_services_authorized, type_, "Value");
  return c.get<nr_v2x_services_authorized_s>();
}
ltev2x_services_authorized_s& path_switch_request_ack_ies_o::value_c::ltev2x_services_authorized()
{
  assert_choice_type(types::ltev2x_services_authorized, type_, "Value");
  return c.get<ltev2x_services_authorized_s>();
}
nr_ue_sidelink_aggr_max_bitrate_s& path_switch_request_ack_ies_o::value_c::nr_ue_sidelink_aggr_max_bitrate()
{
  assert_choice_type(types::nr_ue_sidelink_aggr_max_bitrate, type_, "Value");
  return c.get<nr_ue_sidelink_aggr_max_bitrate_s>();
}
lte_ue_sidelink_aggr_max_bitrate_s& path_switch_request_ack_ies_o::value_c::lte_ue_sidelink_aggr_max_bitrate()
{
  assert_choice_type(types::lte_ue_sidelink_aggr_max_bitrate, type_, "Value");
  return c.get<lte_ue_sidelink_aggr_max_bitrate_s>();
}
pc5_qos_params_s& path_switch_request_ack_ies_o::value_c::pc5_qos_params()
{
  assert_choice_type(types::pc5_qos_params, type_, "Value");
  return c.get<pc5_qos_params_s>();
}
ce_mode_brestricted_e& path_switch_request_ack_ies_o::value_c::ce_mode_brestricted()
{
  assert_choice_type(types::ce_mode_brestricted, type_, "Value");
  return c.get<ce_mode_brestricted_e>();
}
ue_up_c_iot_support_e& path_switch_request_ack_ies_o::value_c::ue_up_c_iot_support()
{
  assert_choice_type(types::ue_up_c_iot_support, type_, "Value");
  return c.get<ue_up_c_iot_support_e>();
}
unbounded_octstring<true>& path_switch_request_ack_ies_o::value_c::ue_radio_cap_id()
{
  assert_choice_type(types::ue_radio_cap_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
mdt_plmn_list_l& path_switch_request_ack_ies_o::value_c::management_based_mdt_plmn_list()
{
  assert_choice_type(types::management_based_mdt_plmn_list, type_, "Value");
  return c.get<mdt_plmn_list_l>();
}
time_sync_assist_info_s& path_switch_request_ack_ies_o::value_c::time_sync_assist_info()
{
  assert_choice_type(types::time_sync_assist_info, type_, "Value");
  return c.get<time_sync_assist_info_s>();
}
five_g_pro_se_authorized_s& path_switch_request_ack_ies_o::value_c::five_g_pro_se_authorized()
{
  assert_choice_type(types::five_g_pro_se_authorized, type_, "Value");
  return c.get<five_g_pro_se_authorized_s>();
}
nr_ue_sidelink_aggr_max_bitrate_s& path_switch_request_ack_ies_o::value_c::five_g_pro_se_ue_pc5_aggr_max_bit_rate()
{
  assert_choice_type(types::five_g_pro_se_ue_pc5_aggr_max_bit_rate, type_, "Value");
  return c.get<nr_ue_sidelink_aggr_max_bitrate_s>();
}
five_g_pro_se_pc5_qos_params_s& path_switch_request_ack_ies_o::value_c::five_g_pro_se_pc5_qos_params()
{
  assert_choice_type(types::five_g_pro_se_pc5_qos_params, type_, "Value");
  return c.get<five_g_pro_se_pc5_qos_params_s>();
}
mdt_plmn_mod_list_l& path_switch_request_ack_ies_o::value_c::management_based_mdt_plmn_mod_list()
{
  assert_choice_type(types::management_based_mdt_plmn_mod_list, type_, "Value");
  return c.get<mdt_plmn_mod_list_l>();
}
const uint64_t& path_switch_request_ack_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& path_switch_request_ack_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const ue_security_cap_s& path_switch_request_ack_ies_o::value_c::ue_security_cap() const
{
  assert_choice_type(types::ue_security_cap, type_, "Value");
  return c.get<ue_security_cap_s>();
}
const security_context_s& path_switch_request_ack_ies_o::value_c::security_context() const
{
  assert_choice_type(types::security_context, type_, "Value");
  return c.get<security_context_s>();
}
const new_security_context_ind_e& path_switch_request_ack_ies_o::value_c::new_security_context_ind() const
{
  assert_choice_type(types::new_security_context_ind, type_, "Value");
  return c.get<new_security_context_ind_e>();
}
const pdu_session_res_switched_list_l& path_switch_request_ack_ies_o::value_c::pdu_session_res_switched_list() const
{
  assert_choice_type(types::pdu_session_res_switched_list, type_, "Value");
  return c.get<pdu_session_res_switched_list_l>();
}
const pdu_session_res_released_list_ps_ack_l&
path_switch_request_ack_ies_o::value_c::pdu_session_res_released_list_ps_ack() const
{
  assert_choice_type(types::pdu_session_res_released_list_ps_ack, type_, "Value");
  return c.get<pdu_session_res_released_list_ps_ack_l>();
}
const allowed_nssai_l& path_switch_request_ack_ies_o::value_c::allowed_nssai() const
{
  assert_choice_type(types::allowed_nssai, type_, "Value");
  return c.get<allowed_nssai_l>();
}
const core_network_assist_info_for_inactive_s&
path_switch_request_ack_ies_o::value_c::core_network_assist_info_for_inactive() const
{
  assert_choice_type(types::core_network_assist_info_for_inactive, type_, "Value");
  return c.get<core_network_assist_info_for_inactive_s>();
}
const rrc_inactive_transition_report_request_e&
path_switch_request_ack_ies_o::value_c::rrc_inactive_transition_report_request() const
{
  assert_choice_type(types::rrc_inactive_transition_report_request, type_, "Value");
  return c.get<rrc_inactive_transition_report_request_e>();
}
const crit_diagnostics_s& path_switch_request_ack_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const redirection_voice_fallback_e& path_switch_request_ack_ies_o::value_c::redirection_voice_fallback() const
{
  assert_choice_type(types::redirection_voice_fallback, type_, "Value");
  return c.get<redirection_voice_fallback_e>();
}
const cn_assisted_ran_tuning_s& path_switch_request_ack_ies_o::value_c::cn_assisted_ran_tuning() const
{
  assert_choice_type(types::cn_assisted_ran_tuning, type_, "Value");
  return c.get<cn_assisted_ran_tuning_s>();
}
const srvcc_operation_possible_e& path_switch_request_ack_ies_o::value_c::srvcc_operation_possible() const
{
  assert_choice_type(types::srvcc_operation_possible, type_, "Value");
  return c.get<srvcc_operation_possible_e>();
}
const enhanced_coverage_restrict_e& path_switch_request_ack_ies_o::value_c::enhanced_coverage_restrict() const
{
  assert_choice_type(types::enhanced_coverage_restrict, type_, "Value");
  return c.get<enhanced_coverage_restrict_e>();
}
const uint16_t& path_switch_request_ack_ies_o::value_c::extended_connected_time() const
{
  assert_choice_type(types::extended_connected_time, type_, "Value");
  return c.get<uint16_t>();
}
const ue_diff_info_s& path_switch_request_ack_ies_o::value_c::ue_diff_info() const
{
  assert_choice_type(types::ue_diff_info, type_, "Value");
  return c.get<ue_diff_info_s>();
}
const nr_v2x_services_authorized_s& path_switch_request_ack_ies_o::value_c::nr_v2x_services_authorized() const
{
  assert_choice_type(types::nr_v2x_services_authorized, type_, "Value");
  return c.get<nr_v2x_services_authorized_s>();
}
const ltev2x_services_authorized_s& path_switch_request_ack_ies_o::value_c::ltev2x_services_authorized() const
{
  assert_choice_type(types::ltev2x_services_authorized, type_, "Value");
  return c.get<ltev2x_services_authorized_s>();
}
const nr_ue_sidelink_aggr_max_bitrate_s& path_switch_request_ack_ies_o::value_c::nr_ue_sidelink_aggr_max_bitrate() const
{
  assert_choice_type(types::nr_ue_sidelink_aggr_max_bitrate, type_, "Value");
  return c.get<nr_ue_sidelink_aggr_max_bitrate_s>();
}
const lte_ue_sidelink_aggr_max_bitrate_s&
path_switch_request_ack_ies_o::value_c::lte_ue_sidelink_aggr_max_bitrate() const
{
  assert_choice_type(types::lte_ue_sidelink_aggr_max_bitrate, type_, "Value");
  return c.get<lte_ue_sidelink_aggr_max_bitrate_s>();
}
const pc5_qos_params_s& path_switch_request_ack_ies_o::value_c::pc5_qos_params() const
{
  assert_choice_type(types::pc5_qos_params, type_, "Value");
  return c.get<pc5_qos_params_s>();
}
const ce_mode_brestricted_e& path_switch_request_ack_ies_o::value_c::ce_mode_brestricted() const
{
  assert_choice_type(types::ce_mode_brestricted, type_, "Value");
  return c.get<ce_mode_brestricted_e>();
}
const ue_up_c_iot_support_e& path_switch_request_ack_ies_o::value_c::ue_up_c_iot_support() const
{
  assert_choice_type(types::ue_up_c_iot_support, type_, "Value");
  return c.get<ue_up_c_iot_support_e>();
}
const unbounded_octstring<true>& path_switch_request_ack_ies_o::value_c::ue_radio_cap_id() const
{
  assert_choice_type(types::ue_radio_cap_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const mdt_plmn_list_l& path_switch_request_ack_ies_o::value_c::management_based_mdt_plmn_list() const
{
  assert_choice_type(types::management_based_mdt_plmn_list, type_, "Value");
  return c.get<mdt_plmn_list_l>();
}
const time_sync_assist_info_s& path_switch_request_ack_ies_o::value_c::time_sync_assist_info() const
{
  assert_choice_type(types::time_sync_assist_info, type_, "Value");
  return c.get<time_sync_assist_info_s>();
}
const five_g_pro_se_authorized_s& path_switch_request_ack_ies_o::value_c::five_g_pro_se_authorized() const
{
  assert_choice_type(types::five_g_pro_se_authorized, type_, "Value");
  return c.get<five_g_pro_se_authorized_s>();
}
const nr_ue_sidelink_aggr_max_bitrate_s&
path_switch_request_ack_ies_o::value_c::five_g_pro_se_ue_pc5_aggr_max_bit_rate() const
{
  assert_choice_type(types::five_g_pro_se_ue_pc5_aggr_max_bit_rate, type_, "Value");
  return c.get<nr_ue_sidelink_aggr_max_bitrate_s>();
}
const five_g_pro_se_pc5_qos_params_s& path_switch_request_ack_ies_o::value_c::five_g_pro_se_pc5_qos_params() const
{
  assert_choice_type(types::five_g_pro_se_pc5_qos_params, type_, "Value");
  return c.get<five_g_pro_se_pc5_qos_params_s>();
}
const mdt_plmn_mod_list_l& path_switch_request_ack_ies_o::value_c::management_based_mdt_plmn_mod_list() const
{
  assert_choice_type(types::management_based_mdt_plmn_mod_list, type_, "Value");
  return c.get<mdt_plmn_mod_list_l>();
}
void path_switch_request_ack_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::ue_security_cap:
      j.write_fieldname("UESecurityCapabilities");
      c.get<ue_security_cap_s>().to_json(j);
      break;
    case types::security_context:
      j.write_fieldname("SecurityContext");
      c.get<security_context_s>().to_json(j);
      break;
    case types::new_security_context_ind:
      j.write_str("NewSecurityContextInd", "true");
      break;
    case types::pdu_session_res_switched_list:
      j.start_array("PDUSessionResourceSwitchedList");
      for (const auto& e1 : c.get<pdu_session_res_switched_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::pdu_session_res_released_list_ps_ack:
      j.start_array("PDUSessionResourceReleasedListPSAck");
      for (const auto& e1 : c.get<pdu_session_res_released_list_ps_ack_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::allowed_nssai:
      j.start_array("AllowedNSSAI");
      for (const auto& e1 : c.get<allowed_nssai_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::core_network_assist_info_for_inactive:
      j.write_fieldname("CoreNetworkAssistanceInformationForInactive");
      c.get<core_network_assist_info_for_inactive_s>().to_json(j);
      break;
    case types::rrc_inactive_transition_report_request:
      j.write_str("RRCInactiveTransitionReportRequest", c.get<rrc_inactive_transition_report_request_e>().to_string());
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    case types::redirection_voice_fallback:
      j.write_str("RedirectionVoiceFallback", c.get<redirection_voice_fallback_e>().to_string());
      break;
    case types::cn_assisted_ran_tuning:
      j.write_fieldname("CNAssistedRANTuning");
      c.get<cn_assisted_ran_tuning_s>().to_json(j);
      break;
    case types::srvcc_operation_possible:
      j.write_str("SRVCCOperationPossible", c.get<srvcc_operation_possible_e>().to_string());
      break;
    case types::enhanced_coverage_restrict:
      j.write_str("Enhanced-CoverageRestriction", "restricted");
      break;
    case types::extended_connected_time:
      j.write_int("INTEGER (0..255)", c.get<uint16_t>());
      break;
    case types::ue_diff_info:
      j.write_fieldname("UE-DifferentiationInfo");
      c.get<ue_diff_info_s>().to_json(j);
      break;
    case types::nr_v2x_services_authorized:
      j.write_fieldname("NRV2XServicesAuthorized");
      c.get<nr_v2x_services_authorized_s>().to_json(j);
      break;
    case types::ltev2x_services_authorized:
      j.write_fieldname("LTEV2XServicesAuthorized");
      c.get<ltev2x_services_authorized_s>().to_json(j);
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      j.write_fieldname("NRUESidelinkAggregateMaximumBitrate");
      c.get<nr_ue_sidelink_aggr_max_bitrate_s>().to_json(j);
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      j.write_fieldname("LTEUESidelinkAggregateMaximumBitrate");
      c.get<lte_ue_sidelink_aggr_max_bitrate_s>().to_json(j);
      break;
    case types::pc5_qos_params:
      j.write_fieldname("PC5QoSParameters");
      c.get<pc5_qos_params_s>().to_json(j);
      break;
    case types::ce_mode_brestricted:
      j.write_str("CEmodeBrestricted", c.get<ce_mode_brestricted_e>().to_string());
      break;
    case types::ue_up_c_iot_support:
      j.write_str("UE-UP-CIoT-Support", "supported");
      break;
    case types::ue_radio_cap_id:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::management_based_mdt_plmn_list:
      j.start_array("MDTPLMNList");
      for (const auto& e1 : c.get<mdt_plmn_list_l>()) {
        j.write_str(e1.to_string());
      }
      j.end_array();
      break;
    case types::time_sync_assist_info:
      j.write_fieldname("TimeSyncAssistanceInfo");
      c.get<time_sync_assist_info_s>().to_json(j);
      break;
    case types::five_g_pro_se_authorized:
      j.write_fieldname("FiveG-ProSeAuthorized");
      c.get<five_g_pro_se_authorized_s>().to_json(j);
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      j.write_fieldname("NRUESidelinkAggregateMaximumBitrate");
      c.get<nr_ue_sidelink_aggr_max_bitrate_s>().to_json(j);
      break;
    case types::five_g_pro_se_pc5_qos_params:
      j.write_fieldname("FiveG-ProSePC5QoSParameters");
      c.get<five_g_pro_se_pc5_qos_params_s>().to_json(j);
      break;
    case types::management_based_mdt_plmn_mod_list:
      j.start_array("MDTPLMNModificationList");
      for (const auto& e1 : c.get<mdt_plmn_mod_list_l>()) {
        j.write_str(e1.to_string());
      }
      j.end_array();
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_ack_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE path_switch_request_ack_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ue_security_cap:
      HANDLE_CODE(c.get<ue_security_cap_s>().pack(bref));
      break;
    case types::security_context:
      HANDLE_CODE(c.get<security_context_s>().pack(bref));
      break;
    case types::new_security_context_ind:
      HANDLE_CODE(c.get<new_security_context_ind_e>().pack(bref));
      break;
    case types::pdu_session_res_switched_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_switched_list_l>(), 1, 256, true));
      break;
    case types::pdu_session_res_released_list_ps_ack:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_released_list_ps_ack_l>(), 1, 256, true));
      break;
    case types::allowed_nssai:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<allowed_nssai_l>(), 1, 8, true));
      break;
    case types::core_network_assist_info_for_inactive:
      HANDLE_CODE(c.get<core_network_assist_info_for_inactive_s>().pack(bref));
      break;
    case types::rrc_inactive_transition_report_request:
      HANDLE_CODE(c.get<rrc_inactive_transition_report_request_e>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    case types::redirection_voice_fallback:
      HANDLE_CODE(c.get<redirection_voice_fallback_e>().pack(bref));
      break;
    case types::cn_assisted_ran_tuning:
      HANDLE_CODE(c.get<cn_assisted_ran_tuning_s>().pack(bref));
      break;
    case types::srvcc_operation_possible:
      HANDLE_CODE(c.get<srvcc_operation_possible_e>().pack(bref));
      break;
    case types::enhanced_coverage_restrict:
      HANDLE_CODE(c.get<enhanced_coverage_restrict_e>().pack(bref));
      break;
    case types::extended_connected_time:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)0u, (uint16_t)255u, false, true));
      break;
    case types::ue_diff_info:
      HANDLE_CODE(c.get<ue_diff_info_s>().pack(bref));
      break;
    case types::nr_v2x_services_authorized:
      HANDLE_CODE(c.get<nr_v2x_services_authorized_s>().pack(bref));
      break;
    case types::ltev2x_services_authorized:
      HANDLE_CODE(c.get<ltev2x_services_authorized_s>().pack(bref));
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      HANDLE_CODE(c.get<nr_ue_sidelink_aggr_max_bitrate_s>().pack(bref));
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      HANDLE_CODE(c.get<lte_ue_sidelink_aggr_max_bitrate_s>().pack(bref));
      break;
    case types::pc5_qos_params:
      HANDLE_CODE(c.get<pc5_qos_params_s>().pack(bref));
      break;
    case types::ce_mode_brestricted:
      HANDLE_CODE(c.get<ce_mode_brestricted_e>().pack(bref));
      break;
    case types::ue_up_c_iot_support:
      HANDLE_CODE(c.get<ue_up_c_iot_support_e>().pack(bref));
      break;
    case types::ue_radio_cap_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::management_based_mdt_plmn_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<mdt_plmn_list_l>(), 1, 16, true));
      break;
    case types::time_sync_assist_info:
      HANDLE_CODE(c.get<time_sync_assist_info_s>().pack(bref));
      break;
    case types::five_g_pro_se_authorized:
      HANDLE_CODE(c.get<five_g_pro_se_authorized_s>().pack(bref));
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      HANDLE_CODE(c.get<nr_ue_sidelink_aggr_max_bitrate_s>().pack(bref));
      break;
    case types::five_g_pro_se_pc5_qos_params:
      HANDLE_CODE(c.get<five_g_pro_se_pc5_qos_params_s>().pack(bref));
      break;
    case types::management_based_mdt_plmn_mod_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<mdt_plmn_mod_list_l>(), 0, 16, true));
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_ack_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE path_switch_request_ack_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ue_security_cap:
      HANDLE_CODE(c.get<ue_security_cap_s>().unpack(bref));
      break;
    case types::security_context:
      HANDLE_CODE(c.get<security_context_s>().unpack(bref));
      break;
    case types::new_security_context_ind:
      HANDLE_CODE(c.get<new_security_context_ind_e>().unpack(bref));
      break;
    case types::pdu_session_res_switched_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_switched_list_l>(), bref, 1, 256, true));
      break;
    case types::pdu_session_res_released_list_ps_ack:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_released_list_ps_ack_l>(), bref, 1, 256, true));
      break;
    case types::allowed_nssai:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<allowed_nssai_l>(), bref, 1, 8, true));
      break;
    case types::core_network_assist_info_for_inactive:
      HANDLE_CODE(c.get<core_network_assist_info_for_inactive_s>().unpack(bref));
      break;
    case types::rrc_inactive_transition_report_request:
      HANDLE_CODE(c.get<rrc_inactive_transition_report_request_e>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    case types::redirection_voice_fallback:
      HANDLE_CODE(c.get<redirection_voice_fallback_e>().unpack(bref));
      break;
    case types::cn_assisted_ran_tuning:
      HANDLE_CODE(c.get<cn_assisted_ran_tuning_s>().unpack(bref));
      break;
    case types::srvcc_operation_possible:
      HANDLE_CODE(c.get<srvcc_operation_possible_e>().unpack(bref));
      break;
    case types::enhanced_coverage_restrict:
      HANDLE_CODE(c.get<enhanced_coverage_restrict_e>().unpack(bref));
      break;
    case types::extended_connected_time:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)0u, (uint16_t)255u, false, true));
      break;
    case types::ue_diff_info:
      HANDLE_CODE(c.get<ue_diff_info_s>().unpack(bref));
      break;
    case types::nr_v2x_services_authorized:
      HANDLE_CODE(c.get<nr_v2x_services_authorized_s>().unpack(bref));
      break;
    case types::ltev2x_services_authorized:
      HANDLE_CODE(c.get<ltev2x_services_authorized_s>().unpack(bref));
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      HANDLE_CODE(c.get<nr_ue_sidelink_aggr_max_bitrate_s>().unpack(bref));
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      HANDLE_CODE(c.get<lte_ue_sidelink_aggr_max_bitrate_s>().unpack(bref));
      break;
    case types::pc5_qos_params:
      HANDLE_CODE(c.get<pc5_qos_params_s>().unpack(bref));
      break;
    case types::ce_mode_brestricted:
      HANDLE_CODE(c.get<ce_mode_brestricted_e>().unpack(bref));
      break;
    case types::ue_up_c_iot_support:
      HANDLE_CODE(c.get<ue_up_c_iot_support_e>().unpack(bref));
      break;
    case types::ue_radio_cap_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::management_based_mdt_plmn_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<mdt_plmn_list_l>(), bref, 1, 16, true));
      break;
    case types::time_sync_assist_info:
      HANDLE_CODE(c.get<time_sync_assist_info_s>().unpack(bref));
      break;
    case types::five_g_pro_se_authorized:
      HANDLE_CODE(c.get<five_g_pro_se_authorized_s>().unpack(bref));
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      HANDLE_CODE(c.get<nr_ue_sidelink_aggr_max_bitrate_s>().unpack(bref));
      break;
    case types::five_g_pro_se_pc5_qos_params:
      HANDLE_CODE(c.get<five_g_pro_se_pc5_qos_params_s>().unpack(bref));
      break;
    case types::management_based_mdt_plmn_mod_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<mdt_plmn_mod_list_l>(), bref, 0, 16, true));
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_ack_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* path_switch_request_ack_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..1099511627775)",
                                "INTEGER (0..4294967295)",
                                "UESecurityCapabilities",
                                "SecurityContext",
                                "NewSecurityContextInd",
                                "PDUSessionResourceSwitchedList",
                                "PDUSessionResourceReleasedListPSAck",
                                "AllowedNSSAI",
                                "CoreNetworkAssistanceInformationForInactive",
                                "RRCInactiveTransitionReportRequest",
                                "CriticalityDiagnostics",
                                "RedirectionVoiceFallback",
                                "CNAssistedRANTuning",
                                "SRVCCOperationPossible",
                                "Enhanced-CoverageRestriction",
                                "INTEGER (0..255)",
                                "UE-DifferentiationInfo",
                                "NRV2XServicesAuthorized",
                                "LTEV2XServicesAuthorized",
                                "NRUESidelinkAggregateMaximumBitrate",
                                "LTEUESidelinkAggregateMaximumBitrate",
                                "PC5QoSParameters",
                                "CEmodeBrestricted",
                                "UE-UP-CIoT-Support",
                                "OCTET STRING",
                                "MDTPLMNList",
                                "TimeSyncAssistanceInfo",
                                "FiveG-ProSeAuthorized",
                                "NRUESidelinkAggregateMaximumBitrate",
                                "FiveG-ProSePC5QoSParameters",
                                "MDTPLMNModificationList"};
  return convert_enum_idx(names, 31, value, "path_switch_request_ack_ies_o::value_c::types");
}

// PathSwitchRequestFailureIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t path_switch_request_fail_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 69, 19};
  return map_enum_number(names, 4, idx, "id");
}
bool path_switch_request_fail_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 69, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e path_switch_request_fail_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::ignore;
    case 85:
      return crit_e::ignore;
    case 69:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
path_switch_request_fail_ies_o::value_c path_switch_request_fail_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 69:
      ret.set(value_c::types::pdu_session_res_released_list_ps_fail);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e path_switch_request_fail_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 69:
      return presence_e::mandatory;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void path_switch_request_fail_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::pdu_session_res_released_list_ps_fail:
      c.destroy<pdu_session_res_released_list_ps_fail_l>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void path_switch_request_fail_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::pdu_session_res_released_list_ps_fail:
      c.init<pdu_session_res_released_list_ps_fail_l>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_fail_ies_o::value_c");
  }
}
path_switch_request_fail_ies_o::value_c::value_c(const path_switch_request_fail_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::pdu_session_res_released_list_ps_fail:
      c.init(other.c.get<pdu_session_res_released_list_ps_fail_l>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_fail_ies_o::value_c");
  }
}
path_switch_request_fail_ies_o::value_c&
path_switch_request_fail_ies_o::value_c::operator=(const path_switch_request_fail_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::pdu_session_res_released_list_ps_fail:
      c.set(other.c.get<pdu_session_res_released_list_ps_fail_l>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_fail_ies_o::value_c");
  }

  return *this;
}
uint64_t& path_switch_request_fail_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& path_switch_request_fail_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
pdu_session_res_released_list_ps_fail_l&
path_switch_request_fail_ies_o::value_c::pdu_session_res_released_list_ps_fail()
{
  assert_choice_type(types::pdu_session_res_released_list_ps_fail, type_, "Value");
  return c.get<pdu_session_res_released_list_ps_fail_l>();
}
crit_diagnostics_s& path_switch_request_fail_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const uint64_t& path_switch_request_fail_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& path_switch_request_fail_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const pdu_session_res_released_list_ps_fail_l&
path_switch_request_fail_ies_o::value_c::pdu_session_res_released_list_ps_fail() const
{
  assert_choice_type(types::pdu_session_res_released_list_ps_fail, type_, "Value");
  return c.get<pdu_session_res_released_list_ps_fail_l>();
}
const crit_diagnostics_s& path_switch_request_fail_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void path_switch_request_fail_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::pdu_session_res_released_list_ps_fail:
      j.start_array("PDUSessionResourceReleasedListPSFail");
      for (const auto& e1 : c.get<pdu_session_res_released_list_ps_fail_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_fail_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE path_switch_request_fail_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_released_list_ps_fail:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_released_list_ps_fail_l>(), 1, 256, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_fail_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE path_switch_request_fail_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_released_list_ps_fail:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_released_list_ps_fail_l>(), bref, 1, 256, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_fail_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* path_switch_request_fail_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..1099511627775)",
                                "INTEGER (0..4294967295)",
                                "PDUSessionResourceReleasedListPSFail",
                                "CriticalityDiagnostics"};
  return convert_enum_idx(names, 4, value, "path_switch_request_fail_ies_o::value_c::types");
}

// PathSwitchRequestIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t path_switch_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {85, 100, 121, 119, 76, 57, 237, 333};
  return map_enum_number(names, 8, idx, "id");
}
bool path_switch_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {85, 100, 121, 119, 76, 57, 237, 333};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e path_switch_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 85:
      return crit_e::reject;
    case 100:
      return crit_e::reject;
    case 121:
      return crit_e::ignore;
    case 119:
      return crit_e::ignore;
    case 76:
      return crit_e::reject;
    case 57:
      return crit_e::ignore;
    case 237:
      return crit_e::ignore;
    case 333:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
path_switch_request_ies_o::value_c path_switch_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 100:
      ret.set(value_c::types::source_amf_ue_ngap_id);
      break;
    case 121:
      ret.set(value_c::types::user_location_info);
      break;
    case 119:
      ret.set(value_c::types::ue_security_cap);
      break;
    case 76:
      ret.set(value_c::types::pdu_session_res_to_be_switched_dl_list);
      break;
    case 57:
      ret.set(value_c::types::pdu_session_res_failed_to_setup_list_ps_req);
      break;
    case 237:
      ret.set(value_c::types::rrc_resume_cause);
      break;
    case 333:
      ret.set(value_c::types::red_cap_ind);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e path_switch_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 85:
      return presence_e::mandatory;
    case 100:
      return presence_e::mandatory;
    case 121:
      return presence_e::mandatory;
    case 119:
      return presence_e::mandatory;
    case 76:
      return presence_e::mandatory;
    case 57:
      return presence_e::optional;
    case 237:
      return presence_e::optional;
    case 333:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void path_switch_request_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::user_location_info:
      c.destroy<user_location_info_c>();
      break;
    case types::ue_security_cap:
      c.destroy<ue_security_cap_s>();
      break;
    case types::pdu_session_res_to_be_switched_dl_list:
      c.destroy<pdu_session_res_to_be_switched_dl_list_l>();
      break;
    case types::pdu_session_res_failed_to_setup_list_ps_req:
      c.destroy<pdu_session_res_failed_to_setup_list_ps_req_l>();
      break;
    default:
      break;
  }
}
void path_switch_request_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::ran_ue_ngap_id:
      break;
    case types::source_amf_ue_ngap_id:
      break;
    case types::user_location_info:
      c.init<user_location_info_c>();
      break;
    case types::ue_security_cap:
      c.init<ue_security_cap_s>();
      break;
    case types::pdu_session_res_to_be_switched_dl_list:
      c.init<pdu_session_res_to_be_switched_dl_list_l>();
      break;
    case types::pdu_session_res_failed_to_setup_list_ps_req:
      c.init<pdu_session_res_failed_to_setup_list_ps_req_l>();
      break;
    case types::rrc_resume_cause:
      break;
    case types::red_cap_ind:
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_ies_o::value_c");
  }
}
path_switch_request_ies_o::value_c::value_c(const path_switch_request_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::source_amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::user_location_info:
      c.init(other.c.get<user_location_info_c>());
      break;
    case types::ue_security_cap:
      c.init(other.c.get<ue_security_cap_s>());
      break;
    case types::pdu_session_res_to_be_switched_dl_list:
      c.init(other.c.get<pdu_session_res_to_be_switched_dl_list_l>());
      break;
    case types::pdu_session_res_failed_to_setup_list_ps_req:
      c.init(other.c.get<pdu_session_res_failed_to_setup_list_ps_req_l>());
      break;
    case types::rrc_resume_cause:
      c.init(other.c.get<rrc_establishment_cause_e>());
      break;
    case types::red_cap_ind:
      c.init(other.c.get<red_cap_ind_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_ies_o::value_c");
  }
}
path_switch_request_ies_o::value_c&
path_switch_request_ies_o::value_c::operator=(const path_switch_request_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::source_amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::user_location_info:
      c.set(other.c.get<user_location_info_c>());
      break;
    case types::ue_security_cap:
      c.set(other.c.get<ue_security_cap_s>());
      break;
    case types::pdu_session_res_to_be_switched_dl_list:
      c.set(other.c.get<pdu_session_res_to_be_switched_dl_list_l>());
      break;
    case types::pdu_session_res_failed_to_setup_list_ps_req:
      c.set(other.c.get<pdu_session_res_failed_to_setup_list_ps_req_l>());
      break;
    case types::rrc_resume_cause:
      c.set(other.c.get<rrc_establishment_cause_e>());
      break;
    case types::red_cap_ind:
      c.set(other.c.get<red_cap_ind_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_ies_o::value_c");
  }

  return *this;
}
uint64_t& path_switch_request_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& path_switch_request_ies_o::value_c::source_amf_ue_ngap_id()
{
  assert_choice_type(types::source_amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
user_location_info_c& path_switch_request_ies_o::value_c::user_location_info()
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
ue_security_cap_s& path_switch_request_ies_o::value_c::ue_security_cap()
{
  assert_choice_type(types::ue_security_cap, type_, "Value");
  return c.get<ue_security_cap_s>();
}
pdu_session_res_to_be_switched_dl_list_l& path_switch_request_ies_o::value_c::pdu_session_res_to_be_switched_dl_list()
{
  assert_choice_type(types::pdu_session_res_to_be_switched_dl_list, type_, "Value");
  return c.get<pdu_session_res_to_be_switched_dl_list_l>();
}
pdu_session_res_failed_to_setup_list_ps_req_l&
path_switch_request_ies_o::value_c::pdu_session_res_failed_to_setup_list_ps_req()
{
  assert_choice_type(types::pdu_session_res_failed_to_setup_list_ps_req, type_, "Value");
  return c.get<pdu_session_res_failed_to_setup_list_ps_req_l>();
}
rrc_establishment_cause_e& path_switch_request_ies_o::value_c::rrc_resume_cause()
{
  assert_choice_type(types::rrc_resume_cause, type_, "Value");
  return c.get<rrc_establishment_cause_e>();
}
red_cap_ind_e& path_switch_request_ies_o::value_c::red_cap_ind()
{
  assert_choice_type(types::red_cap_ind, type_, "Value");
  return c.get<red_cap_ind_e>();
}
const uint64_t& path_switch_request_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& path_switch_request_ies_o::value_c::source_amf_ue_ngap_id() const
{
  assert_choice_type(types::source_amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const user_location_info_c& path_switch_request_ies_o::value_c::user_location_info() const
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
const ue_security_cap_s& path_switch_request_ies_o::value_c::ue_security_cap() const
{
  assert_choice_type(types::ue_security_cap, type_, "Value");
  return c.get<ue_security_cap_s>();
}
const pdu_session_res_to_be_switched_dl_list_l&
path_switch_request_ies_o::value_c::pdu_session_res_to_be_switched_dl_list() const
{
  assert_choice_type(types::pdu_session_res_to_be_switched_dl_list, type_, "Value");
  return c.get<pdu_session_res_to_be_switched_dl_list_l>();
}
const pdu_session_res_failed_to_setup_list_ps_req_l&
path_switch_request_ies_o::value_c::pdu_session_res_failed_to_setup_list_ps_req() const
{
  assert_choice_type(types::pdu_session_res_failed_to_setup_list_ps_req, type_, "Value");
  return c.get<pdu_session_res_failed_to_setup_list_ps_req_l>();
}
const rrc_establishment_cause_e& path_switch_request_ies_o::value_c::rrc_resume_cause() const
{
  assert_choice_type(types::rrc_resume_cause, type_, "Value");
  return c.get<rrc_establishment_cause_e>();
}
const red_cap_ind_e& path_switch_request_ies_o::value_c::red_cap_ind() const
{
  assert_choice_type(types::red_cap_ind, type_, "Value");
  return c.get<red_cap_ind_e>();
}
void path_switch_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::source_amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::user_location_info:
      j.write_fieldname("UserLocationInformation");
      c.get<user_location_info_c>().to_json(j);
      break;
    case types::ue_security_cap:
      j.write_fieldname("UESecurityCapabilities");
      c.get<ue_security_cap_s>().to_json(j);
      break;
    case types::pdu_session_res_to_be_switched_dl_list:
      j.start_array("PDUSessionResourceToBeSwitchedDLList");
      for (const auto& e1 : c.get<pdu_session_res_to_be_switched_dl_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::pdu_session_res_failed_to_setup_list_ps_req:
      j.start_array("PDUSessionResourceFailedToSetupListPSReq");
      for (const auto& e1 : c.get<pdu_session_res_failed_to_setup_list_ps_req_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::rrc_resume_cause:
      j.write_str("RRCEstablishmentCause", c.get<rrc_establishment_cause_e>().to_string());
      break;
    case types::red_cap_ind:
      j.write_str("RedCapIndication", "redcap");
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE path_switch_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::source_amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().pack(bref));
      break;
    case types::ue_security_cap:
      HANDLE_CODE(c.get<ue_security_cap_s>().pack(bref));
      break;
    case types::pdu_session_res_to_be_switched_dl_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_to_be_switched_dl_list_l>(), 1, 256, true));
      break;
    case types::pdu_session_res_failed_to_setup_list_ps_req:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_failed_to_setup_list_ps_req_l>(), 1, 256, true));
      break;
    case types::rrc_resume_cause:
      HANDLE_CODE(c.get<rrc_establishment_cause_e>().pack(bref));
      break;
    case types::red_cap_ind:
      HANDLE_CODE(c.get<red_cap_ind_e>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE path_switch_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::source_amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().unpack(bref));
      break;
    case types::ue_security_cap:
      HANDLE_CODE(c.get<ue_security_cap_s>().unpack(bref));
      break;
    case types::pdu_session_res_to_be_switched_dl_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_to_be_switched_dl_list_l>(), bref, 1, 256, true));
      break;
    case types::pdu_session_res_failed_to_setup_list_ps_req:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_failed_to_setup_list_ps_req_l>(), bref, 1, 256, true));
      break;
    case types::rrc_resume_cause:
      HANDLE_CODE(c.get<rrc_establishment_cause_e>().unpack(bref));
      break;
    case types::red_cap_ind:
      HANDLE_CODE(c.get<red_cap_ind_e>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* path_switch_request_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..4294967295)",
                                "INTEGER (0..1099511627775)",
                                "UserLocationInformation",
                                "UESecurityCapabilities",
                                "PDUSessionResourceToBeSwitchedDLList",
                                "PDUSessionResourceFailedToSetupListPSReq",
                                "RRCEstablishmentCause",
                                "RedCapIndication"};
  return convert_enum_idx(names, 8, value, "path_switch_request_ies_o::value_c::types");
}

// Value ::= OPEN TYPE
void ngap_private_ies_empty_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.end_obj();
}
SRSASN_CODE ngap_private_ies_empty_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  return SRSASN_SUCCESS;
}
SRSASN_CODE ngap_private_ies_empty_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  return SRSASN_SUCCESS;
}

const char* ngap_private_ies_empty_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {};
  return convert_enum_idx(names, 0, value, "ngap_private_ies_empty_o::value_c::types");
}

// RANCPRelocationIndicationIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ran_cp_relocation_ind_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {85, 26, 25, 213, 211};
  return map_enum_number(names, 5, idx, "id");
}
bool ran_cp_relocation_ind_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {85, 26, 25, 213, 211};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ran_cp_relocation_ind_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 85:
      return crit_e::reject;
    case 26:
      return crit_e::reject;
    case 25:
      return crit_e::ignore;
    case 213:
      return crit_e::ignore;
    case 211:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ran_cp_relocation_ind_ies_o::value_c ran_cp_relocation_ind_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 26:
      ret.set(value_c::types::five_g_s_tmsi);
      break;
    case 25:
      ret.set(value_c::types::eutra_cgi);
      break;
    case 213:
      ret.set(value_c::types::tai);
      break;
    case 211:
      ret.set(value_c::types::ul_cp_security_info);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ran_cp_relocation_ind_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 85:
      return presence_e::mandatory;
    case 26:
      return presence_e::mandatory;
    case 25:
      return presence_e::mandatory;
    case 213:
      return presence_e::mandatory;
    case 211:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ran_cp_relocation_ind_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::five_g_s_tmsi:
      c.destroy<five_g_s_tmsi_s>();
      break;
    case types::eutra_cgi:
      c.destroy<eutra_cgi_s>();
      break;
    case types::tai:
      c.destroy<tai_s>();
      break;
    case types::ul_cp_security_info:
      c.destroy<ul_cp_security_info_s>();
      break;
    default:
      break;
  }
}
void ran_cp_relocation_ind_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::ran_ue_ngap_id:
      break;
    case types::five_g_s_tmsi:
      c.init<five_g_s_tmsi_s>();
      break;
    case types::eutra_cgi:
      c.init<eutra_cgi_s>();
      break;
    case types::tai:
      c.init<tai_s>();
      break;
    case types::ul_cp_security_info:
      c.init<ul_cp_security_info_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ran_cp_relocation_ind_ies_o::value_c");
  }
}
ran_cp_relocation_ind_ies_o::value_c::value_c(const ran_cp_relocation_ind_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::five_g_s_tmsi:
      c.init(other.c.get<five_g_s_tmsi_s>());
      break;
    case types::eutra_cgi:
      c.init(other.c.get<eutra_cgi_s>());
      break;
    case types::tai:
      c.init(other.c.get<tai_s>());
      break;
    case types::ul_cp_security_info:
      c.init(other.c.get<ul_cp_security_info_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ran_cp_relocation_ind_ies_o::value_c");
  }
}
ran_cp_relocation_ind_ies_o::value_c&
ran_cp_relocation_ind_ies_o::value_c::operator=(const ran_cp_relocation_ind_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::five_g_s_tmsi:
      c.set(other.c.get<five_g_s_tmsi_s>());
      break;
    case types::eutra_cgi:
      c.set(other.c.get<eutra_cgi_s>());
      break;
    case types::tai:
      c.set(other.c.get<tai_s>());
      break;
    case types::ul_cp_security_info:
      c.set(other.c.get<ul_cp_security_info_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ran_cp_relocation_ind_ies_o::value_c");
  }

  return *this;
}
uint64_t& ran_cp_relocation_ind_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
five_g_s_tmsi_s& ran_cp_relocation_ind_ies_o::value_c::five_g_s_tmsi()
{
  assert_choice_type(types::five_g_s_tmsi, type_, "Value");
  return c.get<five_g_s_tmsi_s>();
}
eutra_cgi_s& ran_cp_relocation_ind_ies_o::value_c::eutra_cgi()
{
  assert_choice_type(types::eutra_cgi, type_, "Value");
  return c.get<eutra_cgi_s>();
}
tai_s& ran_cp_relocation_ind_ies_o::value_c::tai()
{
  assert_choice_type(types::tai, type_, "Value");
  return c.get<tai_s>();
}
ul_cp_security_info_s& ran_cp_relocation_ind_ies_o::value_c::ul_cp_security_info()
{
  assert_choice_type(types::ul_cp_security_info, type_, "Value");
  return c.get<ul_cp_security_info_s>();
}
const uint64_t& ran_cp_relocation_ind_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const five_g_s_tmsi_s& ran_cp_relocation_ind_ies_o::value_c::five_g_s_tmsi() const
{
  assert_choice_type(types::five_g_s_tmsi, type_, "Value");
  return c.get<five_g_s_tmsi_s>();
}
const eutra_cgi_s& ran_cp_relocation_ind_ies_o::value_c::eutra_cgi() const
{
  assert_choice_type(types::eutra_cgi, type_, "Value");
  return c.get<eutra_cgi_s>();
}
const tai_s& ran_cp_relocation_ind_ies_o::value_c::tai() const
{
  assert_choice_type(types::tai, type_, "Value");
  return c.get<tai_s>();
}
const ul_cp_security_info_s& ran_cp_relocation_ind_ies_o::value_c::ul_cp_security_info() const
{
  assert_choice_type(types::ul_cp_security_info, type_, "Value");
  return c.get<ul_cp_security_info_s>();
}
void ran_cp_relocation_ind_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::five_g_s_tmsi:
      j.write_fieldname("FiveG-S-TMSI");
      c.get<five_g_s_tmsi_s>().to_json(j);
      break;
    case types::eutra_cgi:
      j.write_fieldname("EUTRA-CGI");
      c.get<eutra_cgi_s>().to_json(j);
      break;
    case types::tai:
      j.write_fieldname("TAI");
      c.get<tai_s>().to_json(j);
      break;
    case types::ul_cp_security_info:
      j.write_fieldname("UL-CP-SecurityInformation");
      c.get<ul_cp_security_info_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ran_cp_relocation_ind_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ran_cp_relocation_ind_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::five_g_s_tmsi:
      HANDLE_CODE(c.get<five_g_s_tmsi_s>().pack(bref));
      break;
    case types::eutra_cgi:
      HANDLE_CODE(c.get<eutra_cgi_s>().pack(bref));
      break;
    case types::tai:
      HANDLE_CODE(c.get<tai_s>().pack(bref));
      break;
    case types::ul_cp_security_info:
      HANDLE_CODE(c.get<ul_cp_security_info_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ran_cp_relocation_ind_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ran_cp_relocation_ind_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::five_g_s_tmsi:
      HANDLE_CODE(c.get<five_g_s_tmsi_s>().unpack(bref));
      break;
    case types::eutra_cgi:
      HANDLE_CODE(c.get<eutra_cgi_s>().unpack(bref));
      break;
    case types::tai:
      HANDLE_CODE(c.get<tai_s>().unpack(bref));
      break;
    case types::ul_cp_security_info:
      HANDLE_CODE(c.get<ul_cp_security_info_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ran_cp_relocation_ind_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ran_cp_relocation_ind_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {
      "INTEGER (0..4294967295)", "FiveG-S-TMSI", "EUTRA-CGI", "TAI", "UL-CP-SecurityInformation"};
  return convert_enum_idx(names, 5, value, "ran_cp_relocation_ind_ies_o::value_c::types");
}
uint8_t ran_cp_relocation_ind_ies_o::value_c::types_opts::to_number() const
{
  static const uint8_t numbers[] = {0};
  return map_enum_number(numbers, 1, value, "ran_cp_relocation_ind_ies_o::value_c::types");
}

// RANConfigurationUpdateAcknowledgeIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ran_cfg_upd_ack_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {19};
  return map_enum_number(names, 1, idx, "id");
}
bool ran_cfg_upd_ack_ies_o::is_id_valid(const uint32_t& id)
{
  return 19 == id;
}
crit_e ran_cfg_upd_ack_ies_o::get_crit(const uint32_t& id)
{
  if (id == 19) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
ran_cfg_upd_ack_ies_o::value_c ran_cfg_upd_ack_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  if (id != 19) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ran_cfg_upd_ack_ies_o::get_presence(const uint32_t& id)
{
  if (id == 19) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Value ::= OPEN TYPE
void ran_cfg_upd_ack_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("CriticalityDiagnostics");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE ran_cfg_upd_ack_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE ran_cfg_upd_ack_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* ran_cfg_upd_ack_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"CriticalityDiagnostics"};
  return convert_enum_idx(names, 1, value, "ran_cfg_upd_ack_ies_o::value_c::types");
}

// RANConfigurationUpdateFailureIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ran_cfg_upd_fail_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {15, 107, 19};
  return map_enum_number(names, 3, idx, "id");
}
bool ran_cfg_upd_fail_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {15, 107, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ran_cfg_upd_fail_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 15:
      return crit_e::ignore;
    case 107:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ran_cfg_upd_fail_ies_o::value_c ran_cfg_upd_fail_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 15:
      ret.set(value_c::types::cause);
      break;
    case 107:
      ret.set(value_c::types::time_to_wait);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ran_cfg_upd_fail_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 15:
      return presence_e::mandatory;
    case 107:
      return presence_e::optional;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ran_cfg_upd_fail_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::cause:
      c.destroy<cause_c>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void ran_cfg_upd_fail_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::cause:
      c.init<cause_c>();
      break;
    case types::time_to_wait:
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ran_cfg_upd_fail_ies_o::value_c");
  }
}
ran_cfg_upd_fail_ies_o::value_c::value_c(const ran_cfg_upd_fail_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::time_to_wait:
      c.init(other.c.get<time_to_wait_e>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ran_cfg_upd_fail_ies_o::value_c");
  }
}
ran_cfg_upd_fail_ies_o::value_c&
ran_cfg_upd_fail_ies_o::value_c::operator=(const ran_cfg_upd_fail_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::time_to_wait:
      c.set(other.c.get<time_to_wait_e>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ran_cfg_upd_fail_ies_o::value_c");
  }

  return *this;
}
cause_c& ran_cfg_upd_fail_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
time_to_wait_e& ran_cfg_upd_fail_ies_o::value_c::time_to_wait()
{
  assert_choice_type(types::time_to_wait, type_, "Value");
  return c.get<time_to_wait_e>();
}
crit_diagnostics_s& ran_cfg_upd_fail_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const cause_c& ran_cfg_upd_fail_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const time_to_wait_e& ran_cfg_upd_fail_ies_o::value_c::time_to_wait() const
{
  assert_choice_type(types::time_to_wait, type_, "Value");
  return c.get<time_to_wait_e>();
}
const crit_diagnostics_s& ran_cfg_upd_fail_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void ran_cfg_upd_fail_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    case types::time_to_wait:
      j.write_str("TimeToWait", c.get<time_to_wait_e>().to_string());
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ran_cfg_upd_fail_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ran_cfg_upd_fail_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    case types::time_to_wait:
      HANDLE_CODE(c.get<time_to_wait_e>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ran_cfg_upd_fail_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ran_cfg_upd_fail_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    case types::time_to_wait:
      HANDLE_CODE(c.get<time_to_wait_e>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ran_cfg_upd_fail_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ran_cfg_upd_fail_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"Cause", "TimeToWait", "CriticalityDiagnostics"};
  return convert_enum_idx(names, 3, value, "ran_cfg_upd_fail_ies_o::value_c::types");
}

// RANConfigurationUpdateIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ran_cfg_upd_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {82, 102, 21, 27, 167, 204, 273};
  return map_enum_number(names, 7, idx, "id");
}
bool ran_cfg_upd_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {82, 102, 21, 27, 167, 204, 273};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ran_cfg_upd_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 82:
      return crit_e::ignore;
    case 102:
      return crit_e::reject;
    case 21:
      return crit_e::ignore;
    case 27:
      return crit_e::ignore;
    case 167:
      return crit_e::reject;
    case 204:
      return crit_e::ignore;
    case 273:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ran_cfg_upd_ies_o::value_c ran_cfg_upd_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 82:
      ret.set(value_c::types::ran_node_name);
      break;
    case 102:
      ret.set(value_c::types::supported_ta_list);
      break;
    case 21:
      ret.set(value_c::types::default_paging_drx);
      break;
    case 27:
      ret.set(value_c::types::global_ran_node_id);
      break;
    case 167:
      ret.set(value_c::types::ngran_tnl_assoc_to_rem_list);
      break;
    case 204:
      ret.set(value_c::types::nb_iot_default_paging_drx);
      break;
    case 273:
      ret.set(value_c::types::extended_ran_node_name);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ran_cfg_upd_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 82:
      return presence_e::optional;
    case 102:
      return presence_e::optional;
    case 21:
      return presence_e::optional;
    case 27:
      return presence_e::optional;
    case 167:
      return presence_e::optional;
    case 204:
      return presence_e::optional;
    case 273:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ran_cfg_upd_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::ran_node_name:
      c.destroy<printable_string<1, 150, true, true>>();
      break;
    case types::supported_ta_list:
      c.destroy<supported_ta_list_l>();
      break;
    case types::global_ran_node_id:
      c.destroy<global_ran_node_id_c>();
      break;
    case types::ngran_tnl_assoc_to_rem_list:
      c.destroy<ngran_tnl_assoc_to_rem_list_l>();
      break;
    case types::extended_ran_node_name:
      c.destroy<extended_ran_node_name_s>();
      break;
    default:
      break;
  }
}
void ran_cfg_upd_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::ran_node_name:
      c.init<printable_string<1, 150, true, true>>();
      break;
    case types::supported_ta_list:
      c.init<supported_ta_list_l>();
      break;
    case types::default_paging_drx:
      break;
    case types::global_ran_node_id:
      c.init<global_ran_node_id_c>();
      break;
    case types::ngran_tnl_assoc_to_rem_list:
      c.init<ngran_tnl_assoc_to_rem_list_l>();
      break;
    case types::nb_iot_default_paging_drx:
      break;
    case types::extended_ran_node_name:
      c.init<extended_ran_node_name_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ran_cfg_upd_ies_o::value_c");
  }
}
ran_cfg_upd_ies_o::value_c::value_c(const ran_cfg_upd_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::ran_node_name:
      c.init(other.c.get<printable_string<1, 150, true, true>>());
      break;
    case types::supported_ta_list:
      c.init(other.c.get<supported_ta_list_l>());
      break;
    case types::default_paging_drx:
      c.init(other.c.get<paging_drx_e>());
      break;
    case types::global_ran_node_id:
      c.init(other.c.get<global_ran_node_id_c>());
      break;
    case types::ngran_tnl_assoc_to_rem_list:
      c.init(other.c.get<ngran_tnl_assoc_to_rem_list_l>());
      break;
    case types::nb_iot_default_paging_drx:
      c.init(other.c.get<nb_iot_default_paging_drx_e>());
      break;
    case types::extended_ran_node_name:
      c.init(other.c.get<extended_ran_node_name_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ran_cfg_upd_ies_o::value_c");
  }
}
ran_cfg_upd_ies_o::value_c& ran_cfg_upd_ies_o::value_c::operator=(const ran_cfg_upd_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::ran_node_name:
      c.set(other.c.get<printable_string<1, 150, true, true>>());
      break;
    case types::supported_ta_list:
      c.set(other.c.get<supported_ta_list_l>());
      break;
    case types::default_paging_drx:
      c.set(other.c.get<paging_drx_e>());
      break;
    case types::global_ran_node_id:
      c.set(other.c.get<global_ran_node_id_c>());
      break;
    case types::ngran_tnl_assoc_to_rem_list:
      c.set(other.c.get<ngran_tnl_assoc_to_rem_list_l>());
      break;
    case types::nb_iot_default_paging_drx:
      c.set(other.c.get<nb_iot_default_paging_drx_e>());
      break;
    case types::extended_ran_node_name:
      c.set(other.c.get<extended_ran_node_name_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ran_cfg_upd_ies_o::value_c");
  }

  return *this;
}
printable_string<1, 150, true, true>& ran_cfg_upd_ies_o::value_c::ran_node_name()
{
  assert_choice_type(types::ran_node_name, type_, "Value");
  return c.get<printable_string<1, 150, true, true>>();
}
supported_ta_list_l& ran_cfg_upd_ies_o::value_c::supported_ta_list()
{
  assert_choice_type(types::supported_ta_list, type_, "Value");
  return c.get<supported_ta_list_l>();
}
paging_drx_e& ran_cfg_upd_ies_o::value_c::default_paging_drx()
{
  assert_choice_type(types::default_paging_drx, type_, "Value");
  return c.get<paging_drx_e>();
}
global_ran_node_id_c& ran_cfg_upd_ies_o::value_c::global_ran_node_id()
{
  assert_choice_type(types::global_ran_node_id, type_, "Value");
  return c.get<global_ran_node_id_c>();
}
ngran_tnl_assoc_to_rem_list_l& ran_cfg_upd_ies_o::value_c::ngran_tnl_assoc_to_rem_list()
{
  assert_choice_type(types::ngran_tnl_assoc_to_rem_list, type_, "Value");
  return c.get<ngran_tnl_assoc_to_rem_list_l>();
}
nb_iot_default_paging_drx_e& ran_cfg_upd_ies_o::value_c::nb_iot_default_paging_drx()
{
  assert_choice_type(types::nb_iot_default_paging_drx, type_, "Value");
  return c.get<nb_iot_default_paging_drx_e>();
}
extended_ran_node_name_s& ran_cfg_upd_ies_o::value_c::extended_ran_node_name()
{
  assert_choice_type(types::extended_ran_node_name, type_, "Value");
  return c.get<extended_ran_node_name_s>();
}
const printable_string<1, 150, true, true>& ran_cfg_upd_ies_o::value_c::ran_node_name() const
{
  assert_choice_type(types::ran_node_name, type_, "Value");
  return c.get<printable_string<1, 150, true, true>>();
}
const supported_ta_list_l& ran_cfg_upd_ies_o::value_c::supported_ta_list() const
{
  assert_choice_type(types::supported_ta_list, type_, "Value");
  return c.get<supported_ta_list_l>();
}
const paging_drx_e& ran_cfg_upd_ies_o::value_c::default_paging_drx() const
{
  assert_choice_type(types::default_paging_drx, type_, "Value");
  return c.get<paging_drx_e>();
}
const global_ran_node_id_c& ran_cfg_upd_ies_o::value_c::global_ran_node_id() const
{
  assert_choice_type(types::global_ran_node_id, type_, "Value");
  return c.get<global_ran_node_id_c>();
}
const ngran_tnl_assoc_to_rem_list_l& ran_cfg_upd_ies_o::value_c::ngran_tnl_assoc_to_rem_list() const
{
  assert_choice_type(types::ngran_tnl_assoc_to_rem_list, type_, "Value");
  return c.get<ngran_tnl_assoc_to_rem_list_l>();
}
const nb_iot_default_paging_drx_e& ran_cfg_upd_ies_o::value_c::nb_iot_default_paging_drx() const
{
  assert_choice_type(types::nb_iot_default_paging_drx, type_, "Value");
  return c.get<nb_iot_default_paging_drx_e>();
}
const extended_ran_node_name_s& ran_cfg_upd_ies_o::value_c::extended_ran_node_name() const
{
  assert_choice_type(types::extended_ran_node_name, type_, "Value");
  return c.get<extended_ran_node_name_s>();
}
void ran_cfg_upd_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::ran_node_name:
      j.write_str("PrintableString", c.get<printable_string<1, 150, true, true>>().to_string());
      break;
    case types::supported_ta_list:
      j.start_array("SupportedTAList");
      for (const auto& e1 : c.get<supported_ta_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::default_paging_drx:
      j.write_str("PagingDRX", c.get<paging_drx_e>().to_string());
      break;
    case types::global_ran_node_id:
      j.write_fieldname("GlobalRANNodeID");
      c.get<global_ran_node_id_c>().to_json(j);
      break;
    case types::ngran_tnl_assoc_to_rem_list:
      j.start_array("NGRAN-TNLAssociationToRemoveList");
      for (const auto& e1 : c.get<ngran_tnl_assoc_to_rem_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::nb_iot_default_paging_drx:
      j.write_str("NB-IoT-DefaultPagingDRX", c.get<nb_iot_default_paging_drx_e>().to_string());
      break;
    case types::extended_ran_node_name:
      j.write_fieldname("Extended-RANNodeName");
      c.get<extended_ran_node_name_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ran_cfg_upd_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ran_cfg_upd_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ran_node_name:
      HANDLE_CODE((c.get<printable_string<1, 150, true, true>>().pack(bref)));
      break;
    case types::supported_ta_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<supported_ta_list_l>(), 1, 256, true));
      break;
    case types::default_paging_drx:
      HANDLE_CODE(c.get<paging_drx_e>().pack(bref));
      break;
    case types::global_ran_node_id:
      HANDLE_CODE(c.get<global_ran_node_id_c>().pack(bref));
      break;
    case types::ngran_tnl_assoc_to_rem_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<ngran_tnl_assoc_to_rem_list_l>(), 1, 32, true));
      break;
    case types::nb_iot_default_paging_drx:
      HANDLE_CODE(c.get<nb_iot_default_paging_drx_e>().pack(bref));
      break;
    case types::extended_ran_node_name:
      HANDLE_CODE(c.get<extended_ran_node_name_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ran_cfg_upd_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ran_cfg_upd_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ran_node_name:
      HANDLE_CODE((c.get<printable_string<1, 150, true, true>>().unpack(bref)));
      break;
    case types::supported_ta_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<supported_ta_list_l>(), bref, 1, 256, true));
      break;
    case types::default_paging_drx:
      HANDLE_CODE(c.get<paging_drx_e>().unpack(bref));
      break;
    case types::global_ran_node_id:
      HANDLE_CODE(c.get<global_ran_node_id_c>().unpack(bref));
      break;
    case types::ngran_tnl_assoc_to_rem_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<ngran_tnl_assoc_to_rem_list_l>(), bref, 1, 32, true));
      break;
    case types::nb_iot_default_paging_drx:
      HANDLE_CODE(c.get<nb_iot_default_paging_drx_e>().unpack(bref));
      break;
    case types::extended_ran_node_name:
      HANDLE_CODE(c.get<extended_ran_node_name_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ran_cfg_upd_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ran_cfg_upd_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"PrintableString",
                                "SupportedTAList",
                                "PagingDRX",
                                "GlobalRANNodeID",
                                "NGRAN-TNLAssociationToRemoveList",
                                "NB-IoT-DefaultPagingDRX",
                                "Extended-RANNodeName"};
  return convert_enum_idx(names, 7, value, "ran_cfg_upd_ies_o::value_c::types");
}

// RRCInactiveTransitionReportIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t rrc_inactive_transition_report_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 92, 121};
  return map_enum_number(names, 4, idx, "id");
}
bool rrc_inactive_transition_report_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 92, 121};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e rrc_inactive_transition_report_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 92:
      return crit_e::ignore;
    case 121:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
rrc_inactive_transition_report_ies_o::value_c rrc_inactive_transition_report_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 92:
      ret.set(value_c::types::rrc_state);
      break;
    case 121:
      ret.set(value_c::types::user_location_info);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e rrc_inactive_transition_report_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 92:
      return presence_e::mandatory;
    case 121:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void rrc_inactive_transition_report_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::user_location_info:
      c.destroy<user_location_info_c>();
      break;
    default:
      break;
  }
}
void rrc_inactive_transition_report_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::rrc_state:
      break;
    case types::user_location_info:
      c.init<user_location_info_c>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "rrc_inactive_transition_report_ies_o::value_c");
  }
}
rrc_inactive_transition_report_ies_o::value_c::value_c(const rrc_inactive_transition_report_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::rrc_state:
      c.init(other.c.get<rrc_state_e>());
      break;
    case types::user_location_info:
      c.init(other.c.get<user_location_info_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "rrc_inactive_transition_report_ies_o::value_c");
  }
}
rrc_inactive_transition_report_ies_o::value_c&
rrc_inactive_transition_report_ies_o::value_c::operator=(const rrc_inactive_transition_report_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::rrc_state:
      c.set(other.c.get<rrc_state_e>());
      break;
    case types::user_location_info:
      c.set(other.c.get<user_location_info_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "rrc_inactive_transition_report_ies_o::value_c");
  }

  return *this;
}
uint64_t& rrc_inactive_transition_report_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& rrc_inactive_transition_report_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
rrc_state_e& rrc_inactive_transition_report_ies_o::value_c::rrc_state()
{
  assert_choice_type(types::rrc_state, type_, "Value");
  return c.get<rrc_state_e>();
}
user_location_info_c& rrc_inactive_transition_report_ies_o::value_c::user_location_info()
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
const uint64_t& rrc_inactive_transition_report_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& rrc_inactive_transition_report_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const rrc_state_e& rrc_inactive_transition_report_ies_o::value_c::rrc_state() const
{
  assert_choice_type(types::rrc_state, type_, "Value");
  return c.get<rrc_state_e>();
}
const user_location_info_c& rrc_inactive_transition_report_ies_o::value_c::user_location_info() const
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
void rrc_inactive_transition_report_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::rrc_state:
      j.write_str("RRCState", c.get<rrc_state_e>().to_string());
      break;
    case types::user_location_info:
      j.write_fieldname("UserLocationInformation");
      c.get<user_location_info_c>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "rrc_inactive_transition_report_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE rrc_inactive_transition_report_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::rrc_state:
      HANDLE_CODE(c.get<rrc_state_e>().pack(bref));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "rrc_inactive_transition_report_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE rrc_inactive_transition_report_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::rrc_state:
      HANDLE_CODE(c.get<rrc_state_e>().unpack(bref));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "rrc_inactive_transition_report_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* rrc_inactive_transition_report_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {
      "INTEGER (0..1099511627775)", "INTEGER (0..4294967295)", "RRCState", "UserLocationInformation"};
  return convert_enum_idx(names, 4, value, "rrc_inactive_transition_report_ies_o::value_c::types");
}

// RerouteNASRequest-IEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t reroute_nas_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {85, 10, 42, 3, 0, 171};
  return map_enum_number(names, 6, idx, "id");
}
bool reroute_nas_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {85, 10, 42, 3, 0, 171};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e reroute_nas_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 85:
      return crit_e::reject;
    case 10:
      return crit_e::ignore;
    case 42:
      return crit_e::reject;
    case 3:
      return crit_e::reject;
    case 0:
      return crit_e::reject;
    case 171:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
reroute_nas_request_ies_o::value_c reroute_nas_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 42:
      ret.set(value_c::types::ngap_msg);
      break;
    case 3:
      ret.set(value_c::types::amf_set_id);
      break;
    case 0:
      ret.set(value_c::types::allowed_nssai);
      break;
    case 171:
      ret.set(value_c::types::source_to_target_amf_info_reroute);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e reroute_nas_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 85:
      return presence_e::mandatory;
    case 10:
      return presence_e::optional;
    case 42:
      return presence_e::mandatory;
    case 3:
      return presence_e::mandatory;
    case 0:
      return presence_e::optional;
    case 171:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void reroute_nas_request_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::ngap_msg:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::amf_set_id:
      c.destroy<fixed_bitstring<10, false, true>>();
      break;
    case types::allowed_nssai:
      c.destroy<allowed_nssai_l>();
      break;
    case types::source_to_target_amf_info_reroute:
      c.destroy<source_to_target_amf_info_reroute_s>();
      break;
    default:
      break;
  }
}
void reroute_nas_request_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::ran_ue_ngap_id:
      break;
    case types::amf_ue_ngap_id:
      break;
    case types::ngap_msg:
      c.init<unbounded_octstring<true>>();
      break;
    case types::amf_set_id:
      c.init<fixed_bitstring<10, false, true>>();
      break;
    case types::allowed_nssai:
      c.init<allowed_nssai_l>();
      break;
    case types::source_to_target_amf_info_reroute:
      c.init<source_to_target_amf_info_reroute_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "reroute_nas_request_ies_o::value_c");
  }
}
reroute_nas_request_ies_o::value_c::value_c(const reroute_nas_request_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ngap_msg:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::amf_set_id:
      c.init(other.c.get<fixed_bitstring<10, false, true>>());
      break;
    case types::allowed_nssai:
      c.init(other.c.get<allowed_nssai_l>());
      break;
    case types::source_to_target_amf_info_reroute:
      c.init(other.c.get<source_to_target_amf_info_reroute_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "reroute_nas_request_ies_o::value_c");
  }
}
reroute_nas_request_ies_o::value_c&
reroute_nas_request_ies_o::value_c::operator=(const reroute_nas_request_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ngap_msg:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::amf_set_id:
      c.set(other.c.get<fixed_bitstring<10, false, true>>());
      break;
    case types::allowed_nssai:
      c.set(other.c.get<allowed_nssai_l>());
      break;
    case types::source_to_target_amf_info_reroute:
      c.set(other.c.get<source_to_target_amf_info_reroute_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "reroute_nas_request_ies_o::value_c");
  }

  return *this;
}
uint64_t& reroute_nas_request_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& reroute_nas_request_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
unbounded_octstring<true>& reroute_nas_request_ies_o::value_c::ngap_msg()
{
  assert_choice_type(types::ngap_msg, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
fixed_bitstring<10, false, true>& reroute_nas_request_ies_o::value_c::amf_set_id()
{
  assert_choice_type(types::amf_set_id, type_, "Value");
  return c.get<fixed_bitstring<10, false, true>>();
}
allowed_nssai_l& reroute_nas_request_ies_o::value_c::allowed_nssai()
{
  assert_choice_type(types::allowed_nssai, type_, "Value");
  return c.get<allowed_nssai_l>();
}
source_to_target_amf_info_reroute_s& reroute_nas_request_ies_o::value_c::source_to_target_amf_info_reroute()
{
  assert_choice_type(types::source_to_target_amf_info_reroute, type_, "Value");
  return c.get<source_to_target_amf_info_reroute_s>();
}
const uint64_t& reroute_nas_request_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& reroute_nas_request_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const unbounded_octstring<true>& reroute_nas_request_ies_o::value_c::ngap_msg() const
{
  assert_choice_type(types::ngap_msg, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const fixed_bitstring<10, false, true>& reroute_nas_request_ies_o::value_c::amf_set_id() const
{
  assert_choice_type(types::amf_set_id, type_, "Value");
  return c.get<fixed_bitstring<10, false, true>>();
}
const allowed_nssai_l& reroute_nas_request_ies_o::value_c::allowed_nssai() const
{
  assert_choice_type(types::allowed_nssai, type_, "Value");
  return c.get<allowed_nssai_l>();
}
const source_to_target_amf_info_reroute_s& reroute_nas_request_ies_o::value_c::source_to_target_amf_info_reroute() const
{
  assert_choice_type(types::source_to_target_amf_info_reroute, type_, "Value");
  return c.get<source_to_target_amf_info_reroute_s>();
}
void reroute_nas_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ngap_msg:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::amf_set_id:
      j.write_str("BIT STRING", c.get<fixed_bitstring<10, false, true>>().to_string());
      break;
    case types::allowed_nssai:
      j.start_array("AllowedNSSAI");
      for (const auto& e1 : c.get<allowed_nssai_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::source_to_target_amf_info_reroute:
      j.write_fieldname("SourceToTarget-AMFInformationReroute");
      c.get<source_to_target_amf_info_reroute_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "reroute_nas_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE reroute_nas_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ngap_msg:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::amf_set_id:
      HANDLE_CODE((c.get<fixed_bitstring<10, false, true>>().pack(bref)));
      break;
    case types::allowed_nssai:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<allowed_nssai_l>(), 1, 8, true));
      break;
    case types::source_to_target_amf_info_reroute:
      HANDLE_CODE(c.get<source_to_target_amf_info_reroute_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "reroute_nas_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE reroute_nas_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ngap_msg:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::amf_set_id:
      HANDLE_CODE((c.get<fixed_bitstring<10, false, true>>().unpack(bref)));
      break;
    case types::allowed_nssai:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<allowed_nssai_l>(), bref, 1, 8, true));
      break;
    case types::source_to_target_amf_info_reroute:
      HANDLE_CODE(c.get<source_to_target_amf_info_reroute_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "reroute_nas_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* reroute_nas_request_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..4294967295)",
                                "INTEGER (0..1099511627775)",
                                "OCTET STRING",
                                "BIT STRING",
                                "AllowedNSSAI",
                                "SourceToTarget-AMFInformationReroute"};
  return convert_enum_idx(names, 6, value, "reroute_nas_request_ies_o::value_c::types");
}

// RetrieveUEInformationIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t retrieve_ue_info_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {26};
  return map_enum_number(names, 1, idx, "id");
}
bool retrieve_ue_info_ies_o::is_id_valid(const uint32_t& id)
{
  return 26 == id;
}
crit_e retrieve_ue_info_ies_o::get_crit(const uint32_t& id)
{
  if (id == 26) {
    return crit_e::reject;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
retrieve_ue_info_ies_o::value_c retrieve_ue_info_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  if (id != 26) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e retrieve_ue_info_ies_o::get_presence(const uint32_t& id)
{
  if (id == 26) {
    return presence_e::mandatory;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Value ::= OPEN TYPE
void retrieve_ue_info_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("FiveG-S-TMSI");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE retrieve_ue_info_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE retrieve_ue_info_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* retrieve_ue_info_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"FiveG-S-TMSI"};
  return convert_enum_idx(names, 1, value, "retrieve_ue_info_ies_o::value_c::types");
}

// SecondaryRATDataUsageReportIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t secondary_rat_data_usage_report_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 142, 143, 121};
  return map_enum_number(names, 5, idx, "id");
}
bool secondary_rat_data_usage_report_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 142, 143, 121};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e secondary_rat_data_usage_report_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::ignore;
    case 85:
      return crit_e::ignore;
    case 142:
      return crit_e::ignore;
    case 143:
      return crit_e::ignore;
    case 121:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
secondary_rat_data_usage_report_ies_o::value_c secondary_rat_data_usage_report_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 142:
      ret.set(value_c::types::pdu_session_res_secondary_rat_usage_list);
      break;
    case 143:
      ret.set(value_c::types::ho_flag);
      break;
    case 121:
      ret.set(value_c::types::user_location_info);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e secondary_rat_data_usage_report_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 142:
      return presence_e::mandatory;
    case 143:
      return presence_e::optional;
    case 121:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void secondary_rat_data_usage_report_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::pdu_session_res_secondary_rat_usage_list:
      c.destroy<pdu_session_res_secondary_rat_usage_list_l>();
      break;
    case types::user_location_info:
      c.destroy<user_location_info_c>();
      break;
    default:
      break;
  }
}
void secondary_rat_data_usage_report_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::pdu_session_res_secondary_rat_usage_list:
      c.init<pdu_session_res_secondary_rat_usage_list_l>();
      break;
    case types::ho_flag:
      break;
    case types::user_location_info:
      c.init<user_location_info_c>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "secondary_rat_data_usage_report_ies_o::value_c");
  }
}
secondary_rat_data_usage_report_ies_o::value_c::value_c(const secondary_rat_data_usage_report_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::pdu_session_res_secondary_rat_usage_list:
      c.init(other.c.get<pdu_session_res_secondary_rat_usage_list_l>());
      break;
    case types::ho_flag:
      c.init(other.c.get<ho_flag_e>());
      break;
    case types::user_location_info:
      c.init(other.c.get<user_location_info_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "secondary_rat_data_usage_report_ies_o::value_c");
  }
}
secondary_rat_data_usage_report_ies_o::value_c&
secondary_rat_data_usage_report_ies_o::value_c::operator=(const secondary_rat_data_usage_report_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::pdu_session_res_secondary_rat_usage_list:
      c.set(other.c.get<pdu_session_res_secondary_rat_usage_list_l>());
      break;
    case types::ho_flag:
      c.set(other.c.get<ho_flag_e>());
      break;
    case types::user_location_info:
      c.set(other.c.get<user_location_info_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "secondary_rat_data_usage_report_ies_o::value_c");
  }

  return *this;
}
uint64_t& secondary_rat_data_usage_report_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& secondary_rat_data_usage_report_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
pdu_session_res_secondary_rat_usage_list_l&
secondary_rat_data_usage_report_ies_o::value_c::pdu_session_res_secondary_rat_usage_list()
{
  assert_choice_type(types::pdu_session_res_secondary_rat_usage_list, type_, "Value");
  return c.get<pdu_session_res_secondary_rat_usage_list_l>();
}
ho_flag_e& secondary_rat_data_usage_report_ies_o::value_c::ho_flag()
{
  assert_choice_type(types::ho_flag, type_, "Value");
  return c.get<ho_flag_e>();
}
user_location_info_c& secondary_rat_data_usage_report_ies_o::value_c::user_location_info()
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
const uint64_t& secondary_rat_data_usage_report_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& secondary_rat_data_usage_report_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const pdu_session_res_secondary_rat_usage_list_l&
secondary_rat_data_usage_report_ies_o::value_c::pdu_session_res_secondary_rat_usage_list() const
{
  assert_choice_type(types::pdu_session_res_secondary_rat_usage_list, type_, "Value");
  return c.get<pdu_session_res_secondary_rat_usage_list_l>();
}
const ho_flag_e& secondary_rat_data_usage_report_ies_o::value_c::ho_flag() const
{
  assert_choice_type(types::ho_flag, type_, "Value");
  return c.get<ho_flag_e>();
}
const user_location_info_c& secondary_rat_data_usage_report_ies_o::value_c::user_location_info() const
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
void secondary_rat_data_usage_report_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::pdu_session_res_secondary_rat_usage_list:
      j.start_array("PDUSessionResourceSecondaryRATUsageList");
      for (const auto& e1 : c.get<pdu_session_res_secondary_rat_usage_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::ho_flag:
      j.write_str("HandoverFlag", "handover-preparation");
      break;
    case types::user_location_info:
      j.write_fieldname("UserLocationInformation");
      c.get<user_location_info_c>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "secondary_rat_data_usage_report_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE secondary_rat_data_usage_report_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_secondary_rat_usage_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_secondary_rat_usage_list_l>(), 1, 256, true));
      break;
    case types::ho_flag:
      HANDLE_CODE(c.get<ho_flag_e>().pack(bref));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "secondary_rat_data_usage_report_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE secondary_rat_data_usage_report_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_secondary_rat_usage_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_secondary_rat_usage_list_l>(), bref, 1, 256, true));
      break;
    case types::ho_flag:
      HANDLE_CODE(c.get<ho_flag_e>().unpack(bref));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "secondary_rat_data_usage_report_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* secondary_rat_data_usage_report_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..1099511627775)",
                                "INTEGER (0..4294967295)",
                                "PDUSessionResourceSecondaryRATUsageList",
                                "HandoverFlag",
                                "UserLocationInformation"};
  return convert_enum_idx(names, 5, value, "secondary_rat_data_usage_report_ies_o::value_c::types");
}

// TraceFailureIndicationIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t trace_fail_ind_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 44, 15};
  return map_enum_number(names, 4, idx, "id");
}
bool trace_fail_ind_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 44, 15};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e trace_fail_ind_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 44:
      return crit_e::ignore;
    case 15:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
trace_fail_ind_ies_o::value_c trace_fail_ind_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 44:
      ret.set(value_c::types::ngran_trace_id);
      break;
    case 15:
      ret.set(value_c::types::cause);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e trace_fail_ind_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 44:
      return presence_e::mandatory;
    case 15:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void trace_fail_ind_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::ngran_trace_id:
      c.destroy<fixed_octstring<8, true>>();
      break;
    case types::cause:
      c.destroy<cause_c>();
      break;
    default:
      break;
  }
}
void trace_fail_ind_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::ngran_trace_id:
      c.init<fixed_octstring<8, true>>();
      break;
    case types::cause:
      c.init<cause_c>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "trace_fail_ind_ies_o::value_c");
  }
}
trace_fail_ind_ies_o::value_c::value_c(const trace_fail_ind_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ngran_trace_id:
      c.init(other.c.get<fixed_octstring<8, true>>());
      break;
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "trace_fail_ind_ies_o::value_c");
  }
}
trace_fail_ind_ies_o::value_c& trace_fail_ind_ies_o::value_c::operator=(const trace_fail_ind_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ngran_trace_id:
      c.set(other.c.get<fixed_octstring<8, true>>());
      break;
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "trace_fail_ind_ies_o::value_c");
  }

  return *this;
}
uint64_t& trace_fail_ind_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& trace_fail_ind_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
fixed_octstring<8, true>& trace_fail_ind_ies_o::value_c::ngran_trace_id()
{
  assert_choice_type(types::ngran_trace_id, type_, "Value");
  return c.get<fixed_octstring<8, true>>();
}
cause_c& trace_fail_ind_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const uint64_t& trace_fail_ind_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& trace_fail_ind_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const fixed_octstring<8, true>& trace_fail_ind_ies_o::value_c::ngran_trace_id() const
{
  assert_choice_type(types::ngran_trace_id, type_, "Value");
  return c.get<fixed_octstring<8, true>>();
}
const cause_c& trace_fail_ind_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
void trace_fail_ind_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::ngran_trace_id:
      j.write_str("OCTET STRING", c.get<fixed_octstring<8, true>>().to_string());
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "trace_fail_ind_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE trace_fail_ind_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ngran_trace_id:
      HANDLE_CODE((c.get<fixed_octstring<8, true>>().pack(bref)));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "trace_fail_ind_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE trace_fail_ind_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ngran_trace_id:
      HANDLE_CODE((c.get<fixed_octstring<8, true>>().unpack(bref)));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "trace_fail_ind_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* trace_fail_ind_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..1099511627775)", "INTEGER (0..4294967295)", "OCTET STRING", "Cause"};
  return convert_enum_idx(names, 4, value, "trace_fail_ind_ies_o::value_c::types");
}

// TraceStartIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t trace_start_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 108};
  return map_enum_number(names, 3, idx, "id");
}
bool trace_start_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 108};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e trace_start_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 108:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
trace_start_ies_o::value_c trace_start_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 108:
      ret.set(value_c::types::trace_activation);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e trace_start_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 108:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void trace_start_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::trace_activation:
      c.destroy<trace_activation_s>();
      break;
    default:
      break;
  }
}
void trace_start_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::trace_activation:
      c.init<trace_activation_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "trace_start_ies_o::value_c");
  }
}
trace_start_ies_o::value_c::value_c(const trace_start_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::trace_activation:
      c.init(other.c.get<trace_activation_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "trace_start_ies_o::value_c");
  }
}
trace_start_ies_o::value_c& trace_start_ies_o::value_c::operator=(const trace_start_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::trace_activation:
      c.set(other.c.get<trace_activation_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "trace_start_ies_o::value_c");
  }

  return *this;
}
uint64_t& trace_start_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& trace_start_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
trace_activation_s& trace_start_ies_o::value_c::trace_activation()
{
  assert_choice_type(types::trace_activation, type_, "Value");
  return c.get<trace_activation_s>();
}
const uint64_t& trace_start_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& trace_start_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const trace_activation_s& trace_start_ies_o::value_c::trace_activation() const
{
  assert_choice_type(types::trace_activation, type_, "Value");
  return c.get<trace_activation_s>();
}
void trace_start_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::trace_activation:
      j.write_fieldname("TraceActivation");
      c.get<trace_activation_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "trace_start_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE trace_start_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::trace_activation:
      HANDLE_CODE(c.get<trace_activation_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "trace_start_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE trace_start_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::trace_activation:
      HANDLE_CODE(c.get<trace_activation_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "trace_start_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* trace_start_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..1099511627775)", "INTEGER (0..4294967295)", "TraceActivation"};
  return convert_enum_idx(names, 3, value, "trace_start_ies_o::value_c::types");
}

// UEContextModificationFailureIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ue_context_mod_fail_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 15, 19};
  return map_enum_number(names, 4, idx, "id");
}
bool ue_context_mod_fail_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 15, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ue_context_mod_fail_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::ignore;
    case 85:
      return crit_e::ignore;
    case 15:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ue_context_mod_fail_ies_o::value_c ue_context_mod_fail_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 15:
      ret.set(value_c::types::cause);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ue_context_mod_fail_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 15:
      return presence_e::mandatory;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ue_context_mod_fail_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::cause:
      c.destroy<cause_c>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void ue_context_mod_fail_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::cause:
      c.init<cause_c>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_fail_ies_o::value_c");
  }
}
ue_context_mod_fail_ies_o::value_c::value_c(const ue_context_mod_fail_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_fail_ies_o::value_c");
  }
}
ue_context_mod_fail_ies_o::value_c&
ue_context_mod_fail_ies_o::value_c::operator=(const ue_context_mod_fail_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_fail_ies_o::value_c");
  }

  return *this;
}
uint64_t& ue_context_mod_fail_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ue_context_mod_fail_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
cause_c& ue_context_mod_fail_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
crit_diagnostics_s& ue_context_mod_fail_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const uint64_t& ue_context_mod_fail_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ue_context_mod_fail_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const cause_c& ue_context_mod_fail_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const crit_diagnostics_s& ue_context_mod_fail_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void ue_context_mod_fail_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_fail_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_context_mod_fail_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_fail_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_mod_fail_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_fail_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ue_context_mod_fail_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {
      "INTEGER (0..1099511627775)", "INTEGER (0..4294967295)", "Cause", "CriticalityDiagnostics"};
  return convert_enum_idx(names, 4, value, "ue_context_mod_fail_ies_o::value_c::types");
}

// UEContextModificationRequestIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ue_context_mod_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10,  85,  83,  94,  31,  110, 119, 18,  24,  40,  91,  162, 165, 177, 199,
                                   216, 215, 218, 217, 219, 264, 238, 326, 328, 329, 335, 359, 345, 346, 347};
  return map_enum_number(names, 30, idx, "id");
}
bool ue_context_mod_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10,  85,  83,  94,  31,  110, 119, 18,  24,  40,  91,  162, 165, 177, 199,
                                   216, 215, 218, 217, 219, 264, 238, 326, 328, 329, 335, 359, 345, 346, 347};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ue_context_mod_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 83:
      return crit_e::ignore;
    case 94:
      return crit_e::reject;
    case 31:
      return crit_e::ignore;
    case 110:
      return crit_e::ignore;
    case 119:
      return crit_e::reject;
    case 18:
      return crit_e::ignore;
    case 24:
      return crit_e::reject;
    case 40:
      return crit_e::reject;
    case 91:
      return crit_e::ignore;
    case 162:
      return crit_e::reject;
    case 165:
      return crit_e::ignore;
    case 177:
      return crit_e::ignore;
    case 199:
      return crit_e::ignore;
    case 216:
      return crit_e::ignore;
    case 215:
      return crit_e::ignore;
    case 218:
      return crit_e::ignore;
    case 217:
      return crit_e::ignore;
    case 219:
      return crit_e::ignore;
    case 264:
      return crit_e::reject;
    case 238:
      return crit_e::ignore;
    case 326:
      return crit_e::ignore;
    case 328:
      return crit_e::ignore;
    case 329:
      return crit_e::ignore;
    case 335:
      return crit_e::ignore;
    case 359:
      return crit_e::ignore;
    case 345:
      return crit_e::ignore;
    case 346:
      return crit_e::ignore;
    case 347:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ue_context_mod_request_ies_o::value_c ue_context_mod_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 83:
      ret.set(value_c::types::ran_paging_prio);
      break;
    case 94:
      ret.set(value_c::types::security_key);
      break;
    case 31:
      ret.set(value_c::types::idx_to_rfsp);
      break;
    case 110:
      ret.set(value_c::types::ue_aggr_max_bit_rate);
      break;
    case 119:
      ret.set(value_c::types::ue_security_cap);
      break;
    case 18:
      ret.set(value_c::types::core_network_assist_info_for_inactive);
      break;
    case 24:
      ret.set(value_c::types::emergency_fallback_ind);
      break;
    case 40:
      ret.set(value_c::types::new_amf_ue_ngap_id);
      break;
    case 91:
      ret.set(value_c::types::rrc_inactive_transition_report_request);
      break;
    case 162:
      ret.set(value_c::types::new_guami);
      break;
    case 165:
      ret.set(value_c::types::cn_assisted_ran_tuning);
      break;
    case 177:
      ret.set(value_c::types::srvcc_operation_possible);
      break;
    case 199:
      ret.set(value_c::types::iab_authorized);
      break;
    case 216:
      ret.set(value_c::types::nr_v2x_services_authorized);
      break;
    case 215:
      ret.set(value_c::types::ltev2x_services_authorized);
      break;
    case 218:
      ret.set(value_c::types::nr_ue_sidelink_aggr_max_bitrate);
      break;
    case 217:
      ret.set(value_c::types::lte_ue_sidelink_aggr_max_bitrate);
      break;
    case 219:
      ret.set(value_c::types::pc5_qos_params);
      break;
    case 264:
      ret.set(value_c::types::ue_radio_cap_id);
      break;
    case 238:
      ret.set(value_c::types::rg_level_wireline_access_characteristics);
      break;
    case 326:
      ret.set(value_c::types::time_sync_assist_info);
      break;
    case 328:
      ret.set(value_c::types::q_mcc_onfig_info);
      break;
    case 329:
      ret.set(value_c::types::qmc_deactivation);
      break;
    case 335:
      ret.set(value_c::types::ue_slice_max_bit_rate_list);
      break;
    case 359:
      ret.set(value_c::types::management_based_mdt_plmn_mod_list);
      break;
    case 345:
      ret.set(value_c::types::five_g_pro_se_authorized);
      break;
    case 346:
      ret.set(value_c::types::five_g_pro_se_ue_pc5_aggr_max_bit_rate);
      break;
    case 347:
      ret.set(value_c::types::five_g_pro_se_pc5_qos_params);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ue_context_mod_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 83:
      return presence_e::optional;
    case 94:
      return presence_e::optional;
    case 31:
      return presence_e::optional;
    case 110:
      return presence_e::optional;
    case 119:
      return presence_e::optional;
    case 18:
      return presence_e::optional;
    case 24:
      return presence_e::optional;
    case 40:
      return presence_e::optional;
    case 91:
      return presence_e::optional;
    case 162:
      return presence_e::optional;
    case 165:
      return presence_e::optional;
    case 177:
      return presence_e::optional;
    case 199:
      return presence_e::optional;
    case 216:
      return presence_e::optional;
    case 215:
      return presence_e::optional;
    case 218:
      return presence_e::optional;
    case 217:
      return presence_e::optional;
    case 219:
      return presence_e::optional;
    case 264:
      return presence_e::optional;
    case 238:
      return presence_e::optional;
    case 326:
      return presence_e::optional;
    case 328:
      return presence_e::optional;
    case 329:
      return presence_e::optional;
    case 335:
      return presence_e::optional;
    case 359:
      return presence_e::optional;
    case 345:
      return presence_e::optional;
    case 346:
      return presence_e::optional;
    case 347:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ue_context_mod_request_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::security_key:
      c.destroy<fixed_bitstring<256, false, true>>();
      break;
    case types::ue_aggr_max_bit_rate:
      c.destroy<ue_aggr_max_bit_rate_s>();
      break;
    case types::ue_security_cap:
      c.destroy<ue_security_cap_s>();
      break;
    case types::core_network_assist_info_for_inactive:
      c.destroy<core_network_assist_info_for_inactive_s>();
      break;
    case types::emergency_fallback_ind:
      c.destroy<emergency_fallback_ind_s>();
      break;
    case types::new_guami:
      c.destroy<guami_s>();
      break;
    case types::cn_assisted_ran_tuning:
      c.destroy<cn_assisted_ran_tuning_s>();
      break;
    case types::nr_v2x_services_authorized:
      c.destroy<nr_v2x_services_authorized_s>();
      break;
    case types::ltev2x_services_authorized:
      c.destroy<ltev2x_services_authorized_s>();
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      c.destroy<nr_ue_sidelink_aggr_max_bitrate_s>();
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      c.destroy<lte_ue_sidelink_aggr_max_bitrate_s>();
      break;
    case types::pc5_qos_params:
      c.destroy<pc5_qos_params_s>();
      break;
    case types::ue_radio_cap_id:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::rg_level_wireline_access_characteristics:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::time_sync_assist_info:
      c.destroy<time_sync_assist_info_s>();
      break;
    case types::q_mcc_onfig_info:
      c.destroy<q_mcc_onfig_info_s>();
      break;
    case types::qmc_deactivation:
      c.destroy<qmc_deactivation_s>();
      break;
    case types::ue_slice_max_bit_rate_list:
      c.destroy<ue_slice_max_bit_rate_list_l>();
      break;
    case types::management_based_mdt_plmn_mod_list:
      c.destroy<mdt_plmn_mod_list_l>();
      break;
    case types::five_g_pro_se_authorized:
      c.destroy<five_g_pro_se_authorized_s>();
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      c.destroy<nr_ue_sidelink_aggr_max_bitrate_s>();
      break;
    case types::five_g_pro_se_pc5_qos_params:
      c.destroy<five_g_pro_se_pc5_qos_params_s>();
      break;
    default:
      break;
  }
}
void ue_context_mod_request_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::ran_paging_prio:
      break;
    case types::security_key:
      c.init<fixed_bitstring<256, false, true>>();
      break;
    case types::idx_to_rfsp:
      break;
    case types::ue_aggr_max_bit_rate:
      c.init<ue_aggr_max_bit_rate_s>();
      break;
    case types::ue_security_cap:
      c.init<ue_security_cap_s>();
      break;
    case types::core_network_assist_info_for_inactive:
      c.init<core_network_assist_info_for_inactive_s>();
      break;
    case types::emergency_fallback_ind:
      c.init<emergency_fallback_ind_s>();
      break;
    case types::new_amf_ue_ngap_id:
      break;
    case types::rrc_inactive_transition_report_request:
      break;
    case types::new_guami:
      c.init<guami_s>();
      break;
    case types::cn_assisted_ran_tuning:
      c.init<cn_assisted_ran_tuning_s>();
      break;
    case types::srvcc_operation_possible:
      break;
    case types::iab_authorized:
      break;
    case types::nr_v2x_services_authorized:
      c.init<nr_v2x_services_authorized_s>();
      break;
    case types::ltev2x_services_authorized:
      c.init<ltev2x_services_authorized_s>();
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      c.init<nr_ue_sidelink_aggr_max_bitrate_s>();
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      c.init<lte_ue_sidelink_aggr_max_bitrate_s>();
      break;
    case types::pc5_qos_params:
      c.init<pc5_qos_params_s>();
      break;
    case types::ue_radio_cap_id:
      c.init<unbounded_octstring<true>>();
      break;
    case types::rg_level_wireline_access_characteristics:
      c.init<unbounded_octstring<true>>();
      break;
    case types::time_sync_assist_info:
      c.init<time_sync_assist_info_s>();
      break;
    case types::q_mcc_onfig_info:
      c.init<q_mcc_onfig_info_s>();
      break;
    case types::qmc_deactivation:
      c.init<qmc_deactivation_s>();
      break;
    case types::ue_slice_max_bit_rate_list:
      c.init<ue_slice_max_bit_rate_list_l>();
      break;
    case types::management_based_mdt_plmn_mod_list:
      c.init<mdt_plmn_mod_list_l>();
      break;
    case types::five_g_pro_se_authorized:
      c.init<five_g_pro_se_authorized_s>();
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      c.init<nr_ue_sidelink_aggr_max_bitrate_s>();
      break;
    case types::five_g_pro_se_pc5_qos_params:
      c.init<five_g_pro_se_pc5_qos_params_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_request_ies_o::value_c");
  }
}
ue_context_mod_request_ies_o::value_c::value_c(const ue_context_mod_request_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_paging_prio:
      c.init(other.c.get<uint16_t>());
      break;
    case types::security_key:
      c.init(other.c.get<fixed_bitstring<256, false, true>>());
      break;
    case types::idx_to_rfsp:
      c.init(other.c.get<uint16_t>());
      break;
    case types::ue_aggr_max_bit_rate:
      c.init(other.c.get<ue_aggr_max_bit_rate_s>());
      break;
    case types::ue_security_cap:
      c.init(other.c.get<ue_security_cap_s>());
      break;
    case types::core_network_assist_info_for_inactive:
      c.init(other.c.get<core_network_assist_info_for_inactive_s>());
      break;
    case types::emergency_fallback_ind:
      c.init(other.c.get<emergency_fallback_ind_s>());
      break;
    case types::new_amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::rrc_inactive_transition_report_request:
      c.init(other.c.get<rrc_inactive_transition_report_request_e>());
      break;
    case types::new_guami:
      c.init(other.c.get<guami_s>());
      break;
    case types::cn_assisted_ran_tuning:
      c.init(other.c.get<cn_assisted_ran_tuning_s>());
      break;
    case types::srvcc_operation_possible:
      c.init(other.c.get<srvcc_operation_possible_e>());
      break;
    case types::iab_authorized:
      c.init(other.c.get<iab_authorized_e>());
      break;
    case types::nr_v2x_services_authorized:
      c.init(other.c.get<nr_v2x_services_authorized_s>());
      break;
    case types::ltev2x_services_authorized:
      c.init(other.c.get<ltev2x_services_authorized_s>());
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      c.init(other.c.get<nr_ue_sidelink_aggr_max_bitrate_s>());
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      c.init(other.c.get<lte_ue_sidelink_aggr_max_bitrate_s>());
      break;
    case types::pc5_qos_params:
      c.init(other.c.get<pc5_qos_params_s>());
      break;
    case types::ue_radio_cap_id:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::rg_level_wireline_access_characteristics:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::time_sync_assist_info:
      c.init(other.c.get<time_sync_assist_info_s>());
      break;
    case types::q_mcc_onfig_info:
      c.init(other.c.get<q_mcc_onfig_info_s>());
      break;
    case types::qmc_deactivation:
      c.init(other.c.get<qmc_deactivation_s>());
      break;
    case types::ue_slice_max_bit_rate_list:
      c.init(other.c.get<ue_slice_max_bit_rate_list_l>());
      break;
    case types::management_based_mdt_plmn_mod_list:
      c.init(other.c.get<mdt_plmn_mod_list_l>());
      break;
    case types::five_g_pro_se_authorized:
      c.init(other.c.get<five_g_pro_se_authorized_s>());
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      c.init(other.c.get<nr_ue_sidelink_aggr_max_bitrate_s>());
      break;
    case types::five_g_pro_se_pc5_qos_params:
      c.init(other.c.get<five_g_pro_se_pc5_qos_params_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_request_ies_o::value_c");
  }
}
ue_context_mod_request_ies_o::value_c&
ue_context_mod_request_ies_o::value_c::operator=(const ue_context_mod_request_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_paging_prio:
      c.set(other.c.get<uint16_t>());
      break;
    case types::security_key:
      c.set(other.c.get<fixed_bitstring<256, false, true>>());
      break;
    case types::idx_to_rfsp:
      c.set(other.c.get<uint16_t>());
      break;
    case types::ue_aggr_max_bit_rate:
      c.set(other.c.get<ue_aggr_max_bit_rate_s>());
      break;
    case types::ue_security_cap:
      c.set(other.c.get<ue_security_cap_s>());
      break;
    case types::core_network_assist_info_for_inactive:
      c.set(other.c.get<core_network_assist_info_for_inactive_s>());
      break;
    case types::emergency_fallback_ind:
      c.set(other.c.get<emergency_fallback_ind_s>());
      break;
    case types::new_amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::rrc_inactive_transition_report_request:
      c.set(other.c.get<rrc_inactive_transition_report_request_e>());
      break;
    case types::new_guami:
      c.set(other.c.get<guami_s>());
      break;
    case types::cn_assisted_ran_tuning:
      c.set(other.c.get<cn_assisted_ran_tuning_s>());
      break;
    case types::srvcc_operation_possible:
      c.set(other.c.get<srvcc_operation_possible_e>());
      break;
    case types::iab_authorized:
      c.set(other.c.get<iab_authorized_e>());
      break;
    case types::nr_v2x_services_authorized:
      c.set(other.c.get<nr_v2x_services_authorized_s>());
      break;
    case types::ltev2x_services_authorized:
      c.set(other.c.get<ltev2x_services_authorized_s>());
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      c.set(other.c.get<nr_ue_sidelink_aggr_max_bitrate_s>());
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      c.set(other.c.get<lte_ue_sidelink_aggr_max_bitrate_s>());
      break;
    case types::pc5_qos_params:
      c.set(other.c.get<pc5_qos_params_s>());
      break;
    case types::ue_radio_cap_id:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::rg_level_wireline_access_characteristics:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::time_sync_assist_info:
      c.set(other.c.get<time_sync_assist_info_s>());
      break;
    case types::q_mcc_onfig_info:
      c.set(other.c.get<q_mcc_onfig_info_s>());
      break;
    case types::qmc_deactivation:
      c.set(other.c.get<qmc_deactivation_s>());
      break;
    case types::ue_slice_max_bit_rate_list:
      c.set(other.c.get<ue_slice_max_bit_rate_list_l>());
      break;
    case types::management_based_mdt_plmn_mod_list:
      c.set(other.c.get<mdt_plmn_mod_list_l>());
      break;
    case types::five_g_pro_se_authorized:
      c.set(other.c.get<five_g_pro_se_authorized_s>());
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      c.set(other.c.get<nr_ue_sidelink_aggr_max_bitrate_s>());
      break;
    case types::five_g_pro_se_pc5_qos_params:
      c.set(other.c.get<five_g_pro_se_pc5_qos_params_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_request_ies_o::value_c");
  }

  return *this;
}
uint64_t& ue_context_mod_request_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ue_context_mod_request_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint16_t& ue_context_mod_request_ies_o::value_c::ran_paging_prio()
{
  assert_choice_type(types::ran_paging_prio, type_, "Value");
  return c.get<uint16_t>();
}
fixed_bitstring<256, false, true>& ue_context_mod_request_ies_o::value_c::security_key()
{
  assert_choice_type(types::security_key, type_, "Value");
  return c.get<fixed_bitstring<256, false, true>>();
}
uint16_t& ue_context_mod_request_ies_o::value_c::idx_to_rfsp()
{
  assert_choice_type(types::idx_to_rfsp, type_, "Value");
  return c.get<uint16_t>();
}
ue_aggr_max_bit_rate_s& ue_context_mod_request_ies_o::value_c::ue_aggr_max_bit_rate()
{
  assert_choice_type(types::ue_aggr_max_bit_rate, type_, "Value");
  return c.get<ue_aggr_max_bit_rate_s>();
}
ue_security_cap_s& ue_context_mod_request_ies_o::value_c::ue_security_cap()
{
  assert_choice_type(types::ue_security_cap, type_, "Value");
  return c.get<ue_security_cap_s>();
}
core_network_assist_info_for_inactive_s& ue_context_mod_request_ies_o::value_c::core_network_assist_info_for_inactive()
{
  assert_choice_type(types::core_network_assist_info_for_inactive, type_, "Value");
  return c.get<core_network_assist_info_for_inactive_s>();
}
emergency_fallback_ind_s& ue_context_mod_request_ies_o::value_c::emergency_fallback_ind()
{
  assert_choice_type(types::emergency_fallback_ind, type_, "Value");
  return c.get<emergency_fallback_ind_s>();
}
uint64_t& ue_context_mod_request_ies_o::value_c::new_amf_ue_ngap_id()
{
  assert_choice_type(types::new_amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
rrc_inactive_transition_report_request_e&
ue_context_mod_request_ies_o::value_c::rrc_inactive_transition_report_request()
{
  assert_choice_type(types::rrc_inactive_transition_report_request, type_, "Value");
  return c.get<rrc_inactive_transition_report_request_e>();
}
guami_s& ue_context_mod_request_ies_o::value_c::new_guami()
{
  assert_choice_type(types::new_guami, type_, "Value");
  return c.get<guami_s>();
}
cn_assisted_ran_tuning_s& ue_context_mod_request_ies_o::value_c::cn_assisted_ran_tuning()
{
  assert_choice_type(types::cn_assisted_ran_tuning, type_, "Value");
  return c.get<cn_assisted_ran_tuning_s>();
}
srvcc_operation_possible_e& ue_context_mod_request_ies_o::value_c::srvcc_operation_possible()
{
  assert_choice_type(types::srvcc_operation_possible, type_, "Value");
  return c.get<srvcc_operation_possible_e>();
}
iab_authorized_e& ue_context_mod_request_ies_o::value_c::iab_authorized()
{
  assert_choice_type(types::iab_authorized, type_, "Value");
  return c.get<iab_authorized_e>();
}
nr_v2x_services_authorized_s& ue_context_mod_request_ies_o::value_c::nr_v2x_services_authorized()
{
  assert_choice_type(types::nr_v2x_services_authorized, type_, "Value");
  return c.get<nr_v2x_services_authorized_s>();
}
ltev2x_services_authorized_s& ue_context_mod_request_ies_o::value_c::ltev2x_services_authorized()
{
  assert_choice_type(types::ltev2x_services_authorized, type_, "Value");
  return c.get<ltev2x_services_authorized_s>();
}
nr_ue_sidelink_aggr_max_bitrate_s& ue_context_mod_request_ies_o::value_c::nr_ue_sidelink_aggr_max_bitrate()
{
  assert_choice_type(types::nr_ue_sidelink_aggr_max_bitrate, type_, "Value");
  return c.get<nr_ue_sidelink_aggr_max_bitrate_s>();
}
lte_ue_sidelink_aggr_max_bitrate_s& ue_context_mod_request_ies_o::value_c::lte_ue_sidelink_aggr_max_bitrate()
{
  assert_choice_type(types::lte_ue_sidelink_aggr_max_bitrate, type_, "Value");
  return c.get<lte_ue_sidelink_aggr_max_bitrate_s>();
}
pc5_qos_params_s& ue_context_mod_request_ies_o::value_c::pc5_qos_params()
{
  assert_choice_type(types::pc5_qos_params, type_, "Value");
  return c.get<pc5_qos_params_s>();
}
unbounded_octstring<true>& ue_context_mod_request_ies_o::value_c::ue_radio_cap_id()
{
  assert_choice_type(types::ue_radio_cap_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
unbounded_octstring<true>& ue_context_mod_request_ies_o::value_c::rg_level_wireline_access_characteristics()
{
  assert_choice_type(types::rg_level_wireline_access_characteristics, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
time_sync_assist_info_s& ue_context_mod_request_ies_o::value_c::time_sync_assist_info()
{
  assert_choice_type(types::time_sync_assist_info, type_, "Value");
  return c.get<time_sync_assist_info_s>();
}
q_mcc_onfig_info_s& ue_context_mod_request_ies_o::value_c::q_mcc_onfig_info()
{
  assert_choice_type(types::q_mcc_onfig_info, type_, "Value");
  return c.get<q_mcc_onfig_info_s>();
}
qmc_deactivation_s& ue_context_mod_request_ies_o::value_c::qmc_deactivation()
{
  assert_choice_type(types::qmc_deactivation, type_, "Value");
  return c.get<qmc_deactivation_s>();
}
ue_slice_max_bit_rate_list_l& ue_context_mod_request_ies_o::value_c::ue_slice_max_bit_rate_list()
{
  assert_choice_type(types::ue_slice_max_bit_rate_list, type_, "Value");
  return c.get<ue_slice_max_bit_rate_list_l>();
}
mdt_plmn_mod_list_l& ue_context_mod_request_ies_o::value_c::management_based_mdt_plmn_mod_list()
{
  assert_choice_type(types::management_based_mdt_plmn_mod_list, type_, "Value");
  return c.get<mdt_plmn_mod_list_l>();
}
five_g_pro_se_authorized_s& ue_context_mod_request_ies_o::value_c::five_g_pro_se_authorized()
{
  assert_choice_type(types::five_g_pro_se_authorized, type_, "Value");
  return c.get<five_g_pro_se_authorized_s>();
}
nr_ue_sidelink_aggr_max_bitrate_s& ue_context_mod_request_ies_o::value_c::five_g_pro_se_ue_pc5_aggr_max_bit_rate()
{
  assert_choice_type(types::five_g_pro_se_ue_pc5_aggr_max_bit_rate, type_, "Value");
  return c.get<nr_ue_sidelink_aggr_max_bitrate_s>();
}
five_g_pro_se_pc5_qos_params_s& ue_context_mod_request_ies_o::value_c::five_g_pro_se_pc5_qos_params()
{
  assert_choice_type(types::five_g_pro_se_pc5_qos_params, type_, "Value");
  return c.get<five_g_pro_se_pc5_qos_params_s>();
}
const uint64_t& ue_context_mod_request_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ue_context_mod_request_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint16_t& ue_context_mod_request_ies_o::value_c::ran_paging_prio() const
{
  assert_choice_type(types::ran_paging_prio, type_, "Value");
  return c.get<uint16_t>();
}
const fixed_bitstring<256, false, true>& ue_context_mod_request_ies_o::value_c::security_key() const
{
  assert_choice_type(types::security_key, type_, "Value");
  return c.get<fixed_bitstring<256, false, true>>();
}
const uint16_t& ue_context_mod_request_ies_o::value_c::idx_to_rfsp() const
{
  assert_choice_type(types::idx_to_rfsp, type_, "Value");
  return c.get<uint16_t>();
}
const ue_aggr_max_bit_rate_s& ue_context_mod_request_ies_o::value_c::ue_aggr_max_bit_rate() const
{
  assert_choice_type(types::ue_aggr_max_bit_rate, type_, "Value");
  return c.get<ue_aggr_max_bit_rate_s>();
}
const ue_security_cap_s& ue_context_mod_request_ies_o::value_c::ue_security_cap() const
{
  assert_choice_type(types::ue_security_cap, type_, "Value");
  return c.get<ue_security_cap_s>();
}
const core_network_assist_info_for_inactive_s&
ue_context_mod_request_ies_o::value_c::core_network_assist_info_for_inactive() const
{
  assert_choice_type(types::core_network_assist_info_for_inactive, type_, "Value");
  return c.get<core_network_assist_info_for_inactive_s>();
}
const emergency_fallback_ind_s& ue_context_mod_request_ies_o::value_c::emergency_fallback_ind() const
{
  assert_choice_type(types::emergency_fallback_ind, type_, "Value");
  return c.get<emergency_fallback_ind_s>();
}
const uint64_t& ue_context_mod_request_ies_o::value_c::new_amf_ue_ngap_id() const
{
  assert_choice_type(types::new_amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const rrc_inactive_transition_report_request_e&
ue_context_mod_request_ies_o::value_c::rrc_inactive_transition_report_request() const
{
  assert_choice_type(types::rrc_inactive_transition_report_request, type_, "Value");
  return c.get<rrc_inactive_transition_report_request_e>();
}
const guami_s& ue_context_mod_request_ies_o::value_c::new_guami() const
{
  assert_choice_type(types::new_guami, type_, "Value");
  return c.get<guami_s>();
}
const cn_assisted_ran_tuning_s& ue_context_mod_request_ies_o::value_c::cn_assisted_ran_tuning() const
{
  assert_choice_type(types::cn_assisted_ran_tuning, type_, "Value");
  return c.get<cn_assisted_ran_tuning_s>();
}
const srvcc_operation_possible_e& ue_context_mod_request_ies_o::value_c::srvcc_operation_possible() const
{
  assert_choice_type(types::srvcc_operation_possible, type_, "Value");
  return c.get<srvcc_operation_possible_e>();
}
const iab_authorized_e& ue_context_mod_request_ies_o::value_c::iab_authorized() const
{
  assert_choice_type(types::iab_authorized, type_, "Value");
  return c.get<iab_authorized_e>();
}
const nr_v2x_services_authorized_s& ue_context_mod_request_ies_o::value_c::nr_v2x_services_authorized() const
{
  assert_choice_type(types::nr_v2x_services_authorized, type_, "Value");
  return c.get<nr_v2x_services_authorized_s>();
}
const ltev2x_services_authorized_s& ue_context_mod_request_ies_o::value_c::ltev2x_services_authorized() const
{
  assert_choice_type(types::ltev2x_services_authorized, type_, "Value");
  return c.get<ltev2x_services_authorized_s>();
}
const nr_ue_sidelink_aggr_max_bitrate_s& ue_context_mod_request_ies_o::value_c::nr_ue_sidelink_aggr_max_bitrate() const
{
  assert_choice_type(types::nr_ue_sidelink_aggr_max_bitrate, type_, "Value");
  return c.get<nr_ue_sidelink_aggr_max_bitrate_s>();
}
const lte_ue_sidelink_aggr_max_bitrate_s&
ue_context_mod_request_ies_o::value_c::lte_ue_sidelink_aggr_max_bitrate() const
{
  assert_choice_type(types::lte_ue_sidelink_aggr_max_bitrate, type_, "Value");
  return c.get<lte_ue_sidelink_aggr_max_bitrate_s>();
}
const pc5_qos_params_s& ue_context_mod_request_ies_o::value_c::pc5_qos_params() const
{
  assert_choice_type(types::pc5_qos_params, type_, "Value");
  return c.get<pc5_qos_params_s>();
}
const unbounded_octstring<true>& ue_context_mod_request_ies_o::value_c::ue_radio_cap_id() const
{
  assert_choice_type(types::ue_radio_cap_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const unbounded_octstring<true>& ue_context_mod_request_ies_o::value_c::rg_level_wireline_access_characteristics() const
{
  assert_choice_type(types::rg_level_wireline_access_characteristics, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const time_sync_assist_info_s& ue_context_mod_request_ies_o::value_c::time_sync_assist_info() const
{
  assert_choice_type(types::time_sync_assist_info, type_, "Value");
  return c.get<time_sync_assist_info_s>();
}
const q_mcc_onfig_info_s& ue_context_mod_request_ies_o::value_c::q_mcc_onfig_info() const
{
  assert_choice_type(types::q_mcc_onfig_info, type_, "Value");
  return c.get<q_mcc_onfig_info_s>();
}
const qmc_deactivation_s& ue_context_mod_request_ies_o::value_c::qmc_deactivation() const
{
  assert_choice_type(types::qmc_deactivation, type_, "Value");
  return c.get<qmc_deactivation_s>();
}
const ue_slice_max_bit_rate_list_l& ue_context_mod_request_ies_o::value_c::ue_slice_max_bit_rate_list() const
{
  assert_choice_type(types::ue_slice_max_bit_rate_list, type_, "Value");
  return c.get<ue_slice_max_bit_rate_list_l>();
}
const mdt_plmn_mod_list_l& ue_context_mod_request_ies_o::value_c::management_based_mdt_plmn_mod_list() const
{
  assert_choice_type(types::management_based_mdt_plmn_mod_list, type_, "Value");
  return c.get<mdt_plmn_mod_list_l>();
}
const five_g_pro_se_authorized_s& ue_context_mod_request_ies_o::value_c::five_g_pro_se_authorized() const
{
  assert_choice_type(types::five_g_pro_se_authorized, type_, "Value");
  return c.get<five_g_pro_se_authorized_s>();
}
const nr_ue_sidelink_aggr_max_bitrate_s&
ue_context_mod_request_ies_o::value_c::five_g_pro_se_ue_pc5_aggr_max_bit_rate() const
{
  assert_choice_type(types::five_g_pro_se_ue_pc5_aggr_max_bit_rate, type_, "Value");
  return c.get<nr_ue_sidelink_aggr_max_bitrate_s>();
}
const five_g_pro_se_pc5_qos_params_s& ue_context_mod_request_ies_o::value_c::five_g_pro_se_pc5_qos_params() const
{
  assert_choice_type(types::five_g_pro_se_pc5_qos_params, type_, "Value");
  return c.get<five_g_pro_se_pc5_qos_params_s>();
}
void ue_context_mod_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::ran_paging_prio:
      j.write_int("INTEGER (1..256)", c.get<uint16_t>());
      break;
    case types::security_key:
      j.write_str("BIT STRING", c.get<fixed_bitstring<256, false, true>>().to_string());
      break;
    case types::idx_to_rfsp:
      j.write_int("INTEGER (1..256,...)", c.get<uint16_t>());
      break;
    case types::ue_aggr_max_bit_rate:
      j.write_fieldname("UEAggregateMaximumBitRate");
      c.get<ue_aggr_max_bit_rate_s>().to_json(j);
      break;
    case types::ue_security_cap:
      j.write_fieldname("UESecurityCapabilities");
      c.get<ue_security_cap_s>().to_json(j);
      break;
    case types::core_network_assist_info_for_inactive:
      j.write_fieldname("CoreNetworkAssistanceInformationForInactive");
      c.get<core_network_assist_info_for_inactive_s>().to_json(j);
      break;
    case types::emergency_fallback_ind:
      j.write_fieldname("EmergencyFallbackIndicator");
      c.get<emergency_fallback_ind_s>().to_json(j);
      break;
    case types::new_amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::rrc_inactive_transition_report_request:
      j.write_str("RRCInactiveTransitionReportRequest", c.get<rrc_inactive_transition_report_request_e>().to_string());
      break;
    case types::new_guami:
      j.write_fieldname("GUAMI");
      c.get<guami_s>().to_json(j);
      break;
    case types::cn_assisted_ran_tuning:
      j.write_fieldname("CNAssistedRANTuning");
      c.get<cn_assisted_ran_tuning_s>().to_json(j);
      break;
    case types::srvcc_operation_possible:
      j.write_str("SRVCCOperationPossible", c.get<srvcc_operation_possible_e>().to_string());
      break;
    case types::iab_authorized:
      j.write_str("IAB-Authorized", c.get<iab_authorized_e>().to_string());
      break;
    case types::nr_v2x_services_authorized:
      j.write_fieldname("NRV2XServicesAuthorized");
      c.get<nr_v2x_services_authorized_s>().to_json(j);
      break;
    case types::ltev2x_services_authorized:
      j.write_fieldname("LTEV2XServicesAuthorized");
      c.get<ltev2x_services_authorized_s>().to_json(j);
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      j.write_fieldname("NRUESidelinkAggregateMaximumBitrate");
      c.get<nr_ue_sidelink_aggr_max_bitrate_s>().to_json(j);
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      j.write_fieldname("LTEUESidelinkAggregateMaximumBitrate");
      c.get<lte_ue_sidelink_aggr_max_bitrate_s>().to_json(j);
      break;
    case types::pc5_qos_params:
      j.write_fieldname("PC5QoSParameters");
      c.get<pc5_qos_params_s>().to_json(j);
      break;
    case types::ue_radio_cap_id:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::rg_level_wireline_access_characteristics:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::time_sync_assist_info:
      j.write_fieldname("TimeSyncAssistanceInfo");
      c.get<time_sync_assist_info_s>().to_json(j);
      break;
    case types::q_mcc_onfig_info:
      j.write_fieldname("QMCConfigInfo");
      c.get<q_mcc_onfig_info_s>().to_json(j);
      break;
    case types::qmc_deactivation:
      j.write_fieldname("QMCDeactivation");
      c.get<qmc_deactivation_s>().to_json(j);
      break;
    case types::ue_slice_max_bit_rate_list:
      j.start_array("UESliceMaximumBitRateList");
      for (const auto& e1 : c.get<ue_slice_max_bit_rate_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::management_based_mdt_plmn_mod_list:
      j.start_array("MDTPLMNModificationList");
      for (const auto& e1 : c.get<mdt_plmn_mod_list_l>()) {
        j.write_str(e1.to_string());
      }
      j.end_array();
      break;
    case types::five_g_pro_se_authorized:
      j.write_fieldname("FiveG-ProSeAuthorized");
      c.get<five_g_pro_se_authorized_s>().to_json(j);
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      j.write_fieldname("NRUESidelinkAggregateMaximumBitrate");
      c.get<nr_ue_sidelink_aggr_max_bitrate_s>().to_json(j);
      break;
    case types::five_g_pro_se_pc5_qos_params:
      j.write_fieldname("FiveG-ProSePC5QoSParameters");
      c.get<five_g_pro_se_pc5_qos_params_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_context_mod_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ran_paging_prio:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)1u, (uint16_t)256u, false, true));
      break;
    case types::security_key:
      HANDLE_CODE((c.get<fixed_bitstring<256, false, true>>().pack(bref)));
      break;
    case types::idx_to_rfsp:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)1u, (uint16_t)256u, true, true));
      break;
    case types::ue_aggr_max_bit_rate:
      HANDLE_CODE(c.get<ue_aggr_max_bit_rate_s>().pack(bref));
      break;
    case types::ue_security_cap:
      HANDLE_CODE(c.get<ue_security_cap_s>().pack(bref));
      break;
    case types::core_network_assist_info_for_inactive:
      HANDLE_CODE(c.get<core_network_assist_info_for_inactive_s>().pack(bref));
      break;
    case types::emergency_fallback_ind:
      HANDLE_CODE(c.get<emergency_fallback_ind_s>().pack(bref));
      break;
    case types::new_amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::rrc_inactive_transition_report_request:
      HANDLE_CODE(c.get<rrc_inactive_transition_report_request_e>().pack(bref));
      break;
    case types::new_guami:
      HANDLE_CODE(c.get<guami_s>().pack(bref));
      break;
    case types::cn_assisted_ran_tuning:
      HANDLE_CODE(c.get<cn_assisted_ran_tuning_s>().pack(bref));
      break;
    case types::srvcc_operation_possible:
      HANDLE_CODE(c.get<srvcc_operation_possible_e>().pack(bref));
      break;
    case types::iab_authorized:
      HANDLE_CODE(c.get<iab_authorized_e>().pack(bref));
      break;
    case types::nr_v2x_services_authorized:
      HANDLE_CODE(c.get<nr_v2x_services_authorized_s>().pack(bref));
      break;
    case types::ltev2x_services_authorized:
      HANDLE_CODE(c.get<ltev2x_services_authorized_s>().pack(bref));
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      HANDLE_CODE(c.get<nr_ue_sidelink_aggr_max_bitrate_s>().pack(bref));
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      HANDLE_CODE(c.get<lte_ue_sidelink_aggr_max_bitrate_s>().pack(bref));
      break;
    case types::pc5_qos_params:
      HANDLE_CODE(c.get<pc5_qos_params_s>().pack(bref));
      break;
    case types::ue_radio_cap_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::rg_level_wireline_access_characteristics:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::time_sync_assist_info:
      HANDLE_CODE(c.get<time_sync_assist_info_s>().pack(bref));
      break;
    case types::q_mcc_onfig_info:
      HANDLE_CODE(c.get<q_mcc_onfig_info_s>().pack(bref));
      break;
    case types::qmc_deactivation:
      HANDLE_CODE(c.get<qmc_deactivation_s>().pack(bref));
      break;
    case types::ue_slice_max_bit_rate_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<ue_slice_max_bit_rate_list_l>(), 1, 8, true));
      break;
    case types::management_based_mdt_plmn_mod_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<mdt_plmn_mod_list_l>(), 0, 16, true));
      break;
    case types::five_g_pro_se_authorized:
      HANDLE_CODE(c.get<five_g_pro_se_authorized_s>().pack(bref));
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      HANDLE_CODE(c.get<nr_ue_sidelink_aggr_max_bitrate_s>().pack(bref));
      break;
    case types::five_g_pro_se_pc5_qos_params:
      HANDLE_CODE(c.get<five_g_pro_se_pc5_qos_params_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_mod_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ran_paging_prio:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)1u, (uint16_t)256u, false, true));
      break;
    case types::security_key:
      HANDLE_CODE((c.get<fixed_bitstring<256, false, true>>().unpack(bref)));
      break;
    case types::idx_to_rfsp:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)1u, (uint16_t)256u, true, true));
      break;
    case types::ue_aggr_max_bit_rate:
      HANDLE_CODE(c.get<ue_aggr_max_bit_rate_s>().unpack(bref));
      break;
    case types::ue_security_cap:
      HANDLE_CODE(c.get<ue_security_cap_s>().unpack(bref));
      break;
    case types::core_network_assist_info_for_inactive:
      HANDLE_CODE(c.get<core_network_assist_info_for_inactive_s>().unpack(bref));
      break;
    case types::emergency_fallback_ind:
      HANDLE_CODE(c.get<emergency_fallback_ind_s>().unpack(bref));
      break;
    case types::new_amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::rrc_inactive_transition_report_request:
      HANDLE_CODE(c.get<rrc_inactive_transition_report_request_e>().unpack(bref));
      break;
    case types::new_guami:
      HANDLE_CODE(c.get<guami_s>().unpack(bref));
      break;
    case types::cn_assisted_ran_tuning:
      HANDLE_CODE(c.get<cn_assisted_ran_tuning_s>().unpack(bref));
      break;
    case types::srvcc_operation_possible:
      HANDLE_CODE(c.get<srvcc_operation_possible_e>().unpack(bref));
      break;
    case types::iab_authorized:
      HANDLE_CODE(c.get<iab_authorized_e>().unpack(bref));
      break;
    case types::nr_v2x_services_authorized:
      HANDLE_CODE(c.get<nr_v2x_services_authorized_s>().unpack(bref));
      break;
    case types::ltev2x_services_authorized:
      HANDLE_CODE(c.get<ltev2x_services_authorized_s>().unpack(bref));
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      HANDLE_CODE(c.get<nr_ue_sidelink_aggr_max_bitrate_s>().unpack(bref));
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      HANDLE_CODE(c.get<lte_ue_sidelink_aggr_max_bitrate_s>().unpack(bref));
      break;
    case types::pc5_qos_params:
      HANDLE_CODE(c.get<pc5_qos_params_s>().unpack(bref));
      break;
    case types::ue_radio_cap_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::rg_level_wireline_access_characteristics:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::time_sync_assist_info:
      HANDLE_CODE(c.get<time_sync_assist_info_s>().unpack(bref));
      break;
    case types::q_mcc_onfig_info:
      HANDLE_CODE(c.get<q_mcc_onfig_info_s>().unpack(bref));
      break;
    case types::qmc_deactivation:
      HANDLE_CODE(c.get<qmc_deactivation_s>().unpack(bref));
      break;
    case types::ue_slice_max_bit_rate_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<ue_slice_max_bit_rate_list_l>(), bref, 1, 8, true));
      break;
    case types::management_based_mdt_plmn_mod_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<mdt_plmn_mod_list_l>(), bref, 0, 16, true));
      break;
    case types::five_g_pro_se_authorized:
      HANDLE_CODE(c.get<five_g_pro_se_authorized_s>().unpack(bref));
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      HANDLE_CODE(c.get<nr_ue_sidelink_aggr_max_bitrate_s>().unpack(bref));
      break;
    case types::five_g_pro_se_pc5_qos_params:
      HANDLE_CODE(c.get<five_g_pro_se_pc5_qos_params_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ue_context_mod_request_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..1099511627775)",
                                "INTEGER (0..4294967295)",
                                "INTEGER (1..256)",
                                "BIT STRING",
                                "INTEGER (1..256,...)",
                                "UEAggregateMaximumBitRate",
                                "UESecurityCapabilities",
                                "CoreNetworkAssistanceInformationForInactive",
                                "EmergencyFallbackIndicator",
                                "INTEGER (0..1099511627775)",
                                "RRCInactiveTransitionReportRequest",
                                "GUAMI",
                                "CNAssistedRANTuning",
                                "SRVCCOperationPossible",
                                "IAB-Authorized",
                                "NRV2XServicesAuthorized",
                                "LTEV2XServicesAuthorized",
                                "NRUESidelinkAggregateMaximumBitrate",
                                "LTEUESidelinkAggregateMaximumBitrate",
                                "PC5QoSParameters",
                                "OCTET STRING",
                                "OCTET STRING",
                                "TimeSyncAssistanceInfo",
                                "QMCConfigInfo",
                                "QMCDeactivation",
                                "UESliceMaximumBitRateList",
                                "MDTPLMNModificationList",
                                "FiveG-ProSeAuthorized",
                                "NRUESidelinkAggregateMaximumBitrate",
                                "FiveG-ProSePC5QoSParameters"};
  return convert_enum_idx(names, 30, value, "ue_context_mod_request_ies_o::value_c::types");
}

// UEContextModificationResponseIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ue_context_mod_resp_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 92, 121, 19};
  return map_enum_number(names, 5, idx, "id");
}
bool ue_context_mod_resp_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 92, 121, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ue_context_mod_resp_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::ignore;
    case 85:
      return crit_e::ignore;
    case 92:
      return crit_e::ignore;
    case 121:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ue_context_mod_resp_ies_o::value_c ue_context_mod_resp_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 92:
      ret.set(value_c::types::rrc_state);
      break;
    case 121:
      ret.set(value_c::types::user_location_info);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ue_context_mod_resp_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 92:
      return presence_e::optional;
    case 121:
      return presence_e::optional;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ue_context_mod_resp_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::user_location_info:
      c.destroy<user_location_info_c>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void ue_context_mod_resp_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::rrc_state:
      break;
    case types::user_location_info:
      c.init<user_location_info_c>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_resp_ies_o::value_c");
  }
}
ue_context_mod_resp_ies_o::value_c::value_c(const ue_context_mod_resp_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::rrc_state:
      c.init(other.c.get<rrc_state_e>());
      break;
    case types::user_location_info:
      c.init(other.c.get<user_location_info_c>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_resp_ies_o::value_c");
  }
}
ue_context_mod_resp_ies_o::value_c&
ue_context_mod_resp_ies_o::value_c::operator=(const ue_context_mod_resp_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::rrc_state:
      c.set(other.c.get<rrc_state_e>());
      break;
    case types::user_location_info:
      c.set(other.c.get<user_location_info_c>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_resp_ies_o::value_c");
  }

  return *this;
}
uint64_t& ue_context_mod_resp_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ue_context_mod_resp_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
rrc_state_e& ue_context_mod_resp_ies_o::value_c::rrc_state()
{
  assert_choice_type(types::rrc_state, type_, "Value");
  return c.get<rrc_state_e>();
}
user_location_info_c& ue_context_mod_resp_ies_o::value_c::user_location_info()
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
crit_diagnostics_s& ue_context_mod_resp_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const uint64_t& ue_context_mod_resp_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ue_context_mod_resp_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const rrc_state_e& ue_context_mod_resp_ies_o::value_c::rrc_state() const
{
  assert_choice_type(types::rrc_state, type_, "Value");
  return c.get<rrc_state_e>();
}
const user_location_info_c& ue_context_mod_resp_ies_o::value_c::user_location_info() const
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
const crit_diagnostics_s& ue_context_mod_resp_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void ue_context_mod_resp_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::rrc_state:
      j.write_str("RRCState", c.get<rrc_state_e>().to_string());
      break;
    case types::user_location_info:
      j.write_fieldname("UserLocationInformation");
      c.get<user_location_info_c>().to_json(j);
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_resp_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_context_mod_resp_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::rrc_state:
      HANDLE_CODE(c.get<rrc_state_e>().pack(bref));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_resp_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_mod_resp_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::rrc_state:
      HANDLE_CODE(c.get<rrc_state_e>().unpack(bref));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_resp_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ue_context_mod_resp_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..1099511627775)",
                                "INTEGER (0..4294967295)",
                                "RRCState",
                                "UserLocationInformation",
                                "CriticalityDiagnostics"};
  return convert_enum_idx(names, 5, value, "ue_context_mod_resp_ies_o::value_c::types");
}

// UEContextReleaseCommand-IEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ue_context_release_cmd_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {114, 15};
  return map_enum_number(names, 2, idx, "id");
}
bool ue_context_release_cmd_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {114, 15};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ue_context_release_cmd_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 114:
      return crit_e::reject;
    case 15:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ue_context_release_cmd_ies_o::value_c ue_context_release_cmd_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 114:
      ret.set(value_c::types::ue_ngap_ids);
      break;
    case 15:
      ret.set(value_c::types::cause);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ue_context_release_cmd_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 114:
      return presence_e::mandatory;
    case 15:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ue_context_release_cmd_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::ue_ngap_ids:
      c.destroy<ue_ngap_ids_c>();
      break;
    case types::cause:
      c.destroy<cause_c>();
      break;
    default:
      break;
  }
}
void ue_context_release_cmd_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::ue_ngap_ids:
      c.init<ue_ngap_ids_c>();
      break;
    case types::cause:
      c.init<cause_c>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_release_cmd_ies_o::value_c");
  }
}
ue_context_release_cmd_ies_o::value_c::value_c(const ue_context_release_cmd_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::ue_ngap_ids:
      c.init(other.c.get<ue_ngap_ids_c>());
      break;
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_release_cmd_ies_o::value_c");
  }
}
ue_context_release_cmd_ies_o::value_c&
ue_context_release_cmd_ies_o::value_c::operator=(const ue_context_release_cmd_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::ue_ngap_ids:
      c.set(other.c.get<ue_ngap_ids_c>());
      break;
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_release_cmd_ies_o::value_c");
  }

  return *this;
}
ue_ngap_ids_c& ue_context_release_cmd_ies_o::value_c::ue_ngap_ids()
{
  assert_choice_type(types::ue_ngap_ids, type_, "Value");
  return c.get<ue_ngap_ids_c>();
}
cause_c& ue_context_release_cmd_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const ue_ngap_ids_c& ue_context_release_cmd_ies_o::value_c::ue_ngap_ids() const
{
  assert_choice_type(types::ue_ngap_ids, type_, "Value");
  return c.get<ue_ngap_ids_c>();
}
const cause_c& ue_context_release_cmd_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
void ue_context_release_cmd_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::ue_ngap_ids:
      j.write_fieldname("UE-NGAP-IDs");
      c.get<ue_ngap_ids_c>().to_json(j);
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_release_cmd_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_context_release_cmd_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ue_ngap_ids:
      HANDLE_CODE(c.get<ue_ngap_ids_c>().pack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_release_cmd_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_release_cmd_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ue_ngap_ids:
      HANDLE_CODE(c.get<ue_ngap_ids_c>().unpack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_release_cmd_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ue_context_release_cmd_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"UE-NGAP-IDs", "Cause"};
  return convert_enum_idx(names, 2, value, "ue_context_release_cmd_ies_o::value_c::types");
}

// UEContextReleaseComplete-IEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ue_context_release_complete_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 121, 32, 60, 19, 207};
  return map_enum_number(names, 7, idx, "id");
}
bool ue_context_release_complete_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 121, 32, 60, 19, 207};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ue_context_release_complete_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::ignore;
    case 85:
      return crit_e::ignore;
    case 121:
      return crit_e::ignore;
    case 32:
      return crit_e::ignore;
    case 60:
      return crit_e::reject;
    case 19:
      return crit_e::ignore;
    case 207:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ue_context_release_complete_ies_o::value_c ue_context_release_complete_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 121:
      ret.set(value_c::types::user_location_info);
      break;
    case 32:
      ret.set(value_c::types::info_on_recommended_cells_and_ran_nodes_for_paging);
      break;
    case 60:
      ret.set(value_c::types::pdu_session_res_list_cxt_rel_cpl);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    case 207:
      ret.set(value_c::types::paging_assis_datafor_c_ecapab_ue);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ue_context_release_complete_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 121:
      return presence_e::optional;
    case 32:
      return presence_e::optional;
    case 60:
      return presence_e::optional;
    case 19:
      return presence_e::optional;
    case 207:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ue_context_release_complete_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::user_location_info:
      c.destroy<user_location_info_c>();
      break;
    case types::info_on_recommended_cells_and_ran_nodes_for_paging:
      c.destroy<info_on_recommended_cells_and_ran_nodes_for_paging_s>();
      break;
    case types::pdu_session_res_list_cxt_rel_cpl:
      c.destroy<pdu_session_res_list_cxt_rel_cpl_l>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    case types::paging_assis_datafor_c_ecapab_ue:
      c.destroy<paging_assis_datafor_c_ecapab_ue_s>();
      break;
    default:
      break;
  }
}
void ue_context_release_complete_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::user_location_info:
      c.init<user_location_info_c>();
      break;
    case types::info_on_recommended_cells_and_ran_nodes_for_paging:
      c.init<info_on_recommended_cells_and_ran_nodes_for_paging_s>();
      break;
    case types::pdu_session_res_list_cxt_rel_cpl:
      c.init<pdu_session_res_list_cxt_rel_cpl_l>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::paging_assis_datafor_c_ecapab_ue:
      c.init<paging_assis_datafor_c_ecapab_ue_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_release_complete_ies_o::value_c");
  }
}
ue_context_release_complete_ies_o::value_c::value_c(const ue_context_release_complete_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::user_location_info:
      c.init(other.c.get<user_location_info_c>());
      break;
    case types::info_on_recommended_cells_and_ran_nodes_for_paging:
      c.init(other.c.get<info_on_recommended_cells_and_ran_nodes_for_paging_s>());
      break;
    case types::pdu_session_res_list_cxt_rel_cpl:
      c.init(other.c.get<pdu_session_res_list_cxt_rel_cpl_l>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::paging_assis_datafor_c_ecapab_ue:
      c.init(other.c.get<paging_assis_datafor_c_ecapab_ue_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_release_complete_ies_o::value_c");
  }
}
ue_context_release_complete_ies_o::value_c&
ue_context_release_complete_ies_o::value_c::operator=(const ue_context_release_complete_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::user_location_info:
      c.set(other.c.get<user_location_info_c>());
      break;
    case types::info_on_recommended_cells_and_ran_nodes_for_paging:
      c.set(other.c.get<info_on_recommended_cells_and_ran_nodes_for_paging_s>());
      break;
    case types::pdu_session_res_list_cxt_rel_cpl:
      c.set(other.c.get<pdu_session_res_list_cxt_rel_cpl_l>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::paging_assis_datafor_c_ecapab_ue:
      c.set(other.c.get<paging_assis_datafor_c_ecapab_ue_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_release_complete_ies_o::value_c");
  }

  return *this;
}
uint64_t& ue_context_release_complete_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ue_context_release_complete_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
user_location_info_c& ue_context_release_complete_ies_o::value_c::user_location_info()
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
info_on_recommended_cells_and_ran_nodes_for_paging_s&
ue_context_release_complete_ies_o::value_c::info_on_recommended_cells_and_ran_nodes_for_paging()
{
  assert_choice_type(types::info_on_recommended_cells_and_ran_nodes_for_paging, type_, "Value");
  return c.get<info_on_recommended_cells_and_ran_nodes_for_paging_s>();
}
pdu_session_res_list_cxt_rel_cpl_l& ue_context_release_complete_ies_o::value_c::pdu_session_res_list_cxt_rel_cpl()
{
  assert_choice_type(types::pdu_session_res_list_cxt_rel_cpl, type_, "Value");
  return c.get<pdu_session_res_list_cxt_rel_cpl_l>();
}
crit_diagnostics_s& ue_context_release_complete_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
paging_assis_datafor_c_ecapab_ue_s& ue_context_release_complete_ies_o::value_c::paging_assis_datafor_c_ecapab_ue()
{
  assert_choice_type(types::paging_assis_datafor_c_ecapab_ue, type_, "Value");
  return c.get<paging_assis_datafor_c_ecapab_ue_s>();
}
const uint64_t& ue_context_release_complete_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ue_context_release_complete_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const user_location_info_c& ue_context_release_complete_ies_o::value_c::user_location_info() const
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
const info_on_recommended_cells_and_ran_nodes_for_paging_s&
ue_context_release_complete_ies_o::value_c::info_on_recommended_cells_and_ran_nodes_for_paging() const
{
  assert_choice_type(types::info_on_recommended_cells_and_ran_nodes_for_paging, type_, "Value");
  return c.get<info_on_recommended_cells_and_ran_nodes_for_paging_s>();
}
const pdu_session_res_list_cxt_rel_cpl_l&
ue_context_release_complete_ies_o::value_c::pdu_session_res_list_cxt_rel_cpl() const
{
  assert_choice_type(types::pdu_session_res_list_cxt_rel_cpl, type_, "Value");
  return c.get<pdu_session_res_list_cxt_rel_cpl_l>();
}
const crit_diagnostics_s& ue_context_release_complete_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const paging_assis_datafor_c_ecapab_ue_s&
ue_context_release_complete_ies_o::value_c::paging_assis_datafor_c_ecapab_ue() const
{
  assert_choice_type(types::paging_assis_datafor_c_ecapab_ue, type_, "Value");
  return c.get<paging_assis_datafor_c_ecapab_ue_s>();
}
void ue_context_release_complete_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::user_location_info:
      j.write_fieldname("UserLocationInformation");
      c.get<user_location_info_c>().to_json(j);
      break;
    case types::info_on_recommended_cells_and_ran_nodes_for_paging:
      j.write_fieldname("InfoOnRecommendedCellsAndRANNodesForPaging");
      c.get<info_on_recommended_cells_and_ran_nodes_for_paging_s>().to_json(j);
      break;
    case types::pdu_session_res_list_cxt_rel_cpl:
      j.start_array("PDUSessionResourceListCxtRelCpl");
      for (const auto& e1 : c.get<pdu_session_res_list_cxt_rel_cpl_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    case types::paging_assis_datafor_c_ecapab_ue:
      j.write_fieldname("PagingAssisDataforCEcapabUE");
      c.get<paging_assis_datafor_c_ecapab_ue_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_release_complete_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_context_release_complete_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().pack(bref));
      break;
    case types::info_on_recommended_cells_and_ran_nodes_for_paging:
      HANDLE_CODE(c.get<info_on_recommended_cells_and_ran_nodes_for_paging_s>().pack(bref));
      break;
    case types::pdu_session_res_list_cxt_rel_cpl:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_list_cxt_rel_cpl_l>(), 1, 256, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    case types::paging_assis_datafor_c_ecapab_ue:
      HANDLE_CODE(c.get<paging_assis_datafor_c_ecapab_ue_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_release_complete_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_release_complete_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().unpack(bref));
      break;
    case types::info_on_recommended_cells_and_ran_nodes_for_paging:
      HANDLE_CODE(c.get<info_on_recommended_cells_and_ran_nodes_for_paging_s>().unpack(bref));
      break;
    case types::pdu_session_res_list_cxt_rel_cpl:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_list_cxt_rel_cpl_l>(), bref, 1, 256, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    case types::paging_assis_datafor_c_ecapab_ue:
      HANDLE_CODE(c.get<paging_assis_datafor_c_ecapab_ue_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_release_complete_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ue_context_release_complete_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..1099511627775)",
                                "INTEGER (0..4294967295)",
                                "UserLocationInformation",
                                "InfoOnRecommendedCellsAndRANNodesForPaging",
                                "PDUSessionResourceListCxtRelCpl",
                                "CriticalityDiagnostics",
                                "PagingAssisDataforCEcapabUE"};
  return convert_enum_idx(names, 7, value, "ue_context_release_complete_ies_o::value_c::types");
}

// UEContextReleaseRequest-IEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ue_context_release_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 133, 15};
  return map_enum_number(names, 4, idx, "id");
}
bool ue_context_release_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 133, 15};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ue_context_release_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 133:
      return crit_e::reject;
    case 15:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ue_context_release_request_ies_o::value_c ue_context_release_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 133:
      ret.set(value_c::types::pdu_session_res_list_cxt_rel_req);
      break;
    case 15:
      ret.set(value_c::types::cause);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ue_context_release_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 133:
      return presence_e::optional;
    case 15:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ue_context_release_request_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::pdu_session_res_list_cxt_rel_req:
      c.destroy<pdu_session_res_list_cxt_rel_req_l>();
      break;
    case types::cause:
      c.destroy<cause_c>();
      break;
    default:
      break;
  }
}
void ue_context_release_request_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::pdu_session_res_list_cxt_rel_req:
      c.init<pdu_session_res_list_cxt_rel_req_l>();
      break;
    case types::cause:
      c.init<cause_c>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_release_request_ies_o::value_c");
  }
}
ue_context_release_request_ies_o::value_c::value_c(const ue_context_release_request_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::pdu_session_res_list_cxt_rel_req:
      c.init(other.c.get<pdu_session_res_list_cxt_rel_req_l>());
      break;
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_release_request_ies_o::value_c");
  }
}
ue_context_release_request_ies_o::value_c&
ue_context_release_request_ies_o::value_c::operator=(const ue_context_release_request_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::pdu_session_res_list_cxt_rel_req:
      c.set(other.c.get<pdu_session_res_list_cxt_rel_req_l>());
      break;
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_release_request_ies_o::value_c");
  }

  return *this;
}
uint64_t& ue_context_release_request_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ue_context_release_request_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
pdu_session_res_list_cxt_rel_req_l& ue_context_release_request_ies_o::value_c::pdu_session_res_list_cxt_rel_req()
{
  assert_choice_type(types::pdu_session_res_list_cxt_rel_req, type_, "Value");
  return c.get<pdu_session_res_list_cxt_rel_req_l>();
}
cause_c& ue_context_release_request_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const uint64_t& ue_context_release_request_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ue_context_release_request_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const pdu_session_res_list_cxt_rel_req_l&
ue_context_release_request_ies_o::value_c::pdu_session_res_list_cxt_rel_req() const
{
  assert_choice_type(types::pdu_session_res_list_cxt_rel_req, type_, "Value");
  return c.get<pdu_session_res_list_cxt_rel_req_l>();
}
const cause_c& ue_context_release_request_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
void ue_context_release_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::pdu_session_res_list_cxt_rel_req:
      j.start_array("PDUSessionResourceListCxtRelReq");
      for (const auto& e1 : c.get<pdu_session_res_list_cxt_rel_req_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_release_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_context_release_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_list_cxt_rel_req:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_list_cxt_rel_req_l>(), 1, 256, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_release_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_release_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_list_cxt_rel_req:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_list_cxt_rel_req_l>(), bref, 1, 256, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_release_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ue_context_release_request_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {
      "INTEGER (0..1099511627775)", "INTEGER (0..4294967295)", "PDUSessionResourceListCxtRelReq", "Cause"};
  return convert_enum_idx(names, 4, value, "ue_context_release_request_ies_o::value_c::types");
}

// UEContextResumeFailureIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ue_context_resume_fail_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 15, 19};
  return map_enum_number(names, 4, idx, "id");
}
bool ue_context_resume_fail_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 15, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ue_context_resume_fail_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::ignore;
    case 85:
      return crit_e::ignore;
    case 15:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ue_context_resume_fail_ies_o::value_c ue_context_resume_fail_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 15:
      ret.set(value_c::types::cause);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ue_context_resume_fail_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 15:
      return presence_e::mandatory;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ue_context_resume_fail_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::cause:
      c.destroy<cause_c>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void ue_context_resume_fail_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::cause:
      c.init<cause_c>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_resume_fail_ies_o::value_c");
  }
}
ue_context_resume_fail_ies_o::value_c::value_c(const ue_context_resume_fail_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_resume_fail_ies_o::value_c");
  }
}
ue_context_resume_fail_ies_o::value_c&
ue_context_resume_fail_ies_o::value_c::operator=(const ue_context_resume_fail_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_resume_fail_ies_o::value_c");
  }

  return *this;
}
uint64_t& ue_context_resume_fail_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ue_context_resume_fail_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
cause_c& ue_context_resume_fail_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
crit_diagnostics_s& ue_context_resume_fail_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const uint64_t& ue_context_resume_fail_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ue_context_resume_fail_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const cause_c& ue_context_resume_fail_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const crit_diagnostics_s& ue_context_resume_fail_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void ue_context_resume_fail_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_resume_fail_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_context_resume_fail_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_resume_fail_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_resume_fail_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_resume_fail_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ue_context_resume_fail_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {
      "INTEGER (0..1099511627775)", "INTEGER (0..4294967295)", "Cause", "CriticalityDiagnostics"};
  return convert_enum_idx(names, 4, value, "ue_context_resume_fail_ies_o::value_c::types");
}

// UEContextResumeRequestIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ue_context_resume_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 237, 232, 229, 235, 32, 207};
  return map_enum_number(names, 8, idx, "id");
}
bool ue_context_resume_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 237, 232, 229, 235, 32, 207};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ue_context_resume_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 237:
      return crit_e::ignore;
    case 232:
      return crit_e::reject;
    case 229:
      return crit_e::reject;
    case 235:
      return crit_e::ignore;
    case 32:
      return crit_e::ignore;
    case 207:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ue_context_resume_request_ies_o::value_c ue_context_resume_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 237:
      ret.set(value_c::types::rrc_resume_cause);
      break;
    case 232:
      ret.set(value_c::types::pdu_session_res_resume_list_res_req);
      break;
    case 229:
      ret.set(value_c::types::pdu_session_res_failed_to_resume_list_res_req);
      break;
    case 235:
      ret.set(value_c::types::suspend_request_ind);
      break;
    case 32:
      ret.set(value_c::types::info_on_recommended_cells_and_ran_nodes_for_paging);
      break;
    case 207:
      ret.set(value_c::types::paging_assis_datafor_c_ecapab_ue);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ue_context_resume_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 237:
      return presence_e::mandatory;
    case 232:
      return presence_e::optional;
    case 229:
      return presence_e::optional;
    case 235:
      return presence_e::optional;
    case 32:
      return presence_e::optional;
    case 207:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ue_context_resume_request_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::pdu_session_res_resume_list_res_req:
      c.destroy<pdu_session_res_resume_list_res_req_l>();
      break;
    case types::pdu_session_res_failed_to_resume_list_res_req:
      c.destroy<pdu_session_res_failed_to_resume_list_res_req_l>();
      break;
    case types::info_on_recommended_cells_and_ran_nodes_for_paging:
      c.destroy<info_on_recommended_cells_and_ran_nodes_for_paging_s>();
      break;
    case types::paging_assis_datafor_c_ecapab_ue:
      c.destroy<paging_assis_datafor_c_ecapab_ue_s>();
      break;
    default:
      break;
  }
}
void ue_context_resume_request_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::rrc_resume_cause:
      break;
    case types::pdu_session_res_resume_list_res_req:
      c.init<pdu_session_res_resume_list_res_req_l>();
      break;
    case types::pdu_session_res_failed_to_resume_list_res_req:
      c.init<pdu_session_res_failed_to_resume_list_res_req_l>();
      break;
    case types::suspend_request_ind:
      break;
    case types::info_on_recommended_cells_and_ran_nodes_for_paging:
      c.init<info_on_recommended_cells_and_ran_nodes_for_paging_s>();
      break;
    case types::paging_assis_datafor_c_ecapab_ue:
      c.init<paging_assis_datafor_c_ecapab_ue_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_resume_request_ies_o::value_c");
  }
}
ue_context_resume_request_ies_o::value_c::value_c(const ue_context_resume_request_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::rrc_resume_cause:
      c.init(other.c.get<rrc_establishment_cause_e>());
      break;
    case types::pdu_session_res_resume_list_res_req:
      c.init(other.c.get<pdu_session_res_resume_list_res_req_l>());
      break;
    case types::pdu_session_res_failed_to_resume_list_res_req:
      c.init(other.c.get<pdu_session_res_failed_to_resume_list_res_req_l>());
      break;
    case types::suspend_request_ind:
      c.init(other.c.get<suspend_request_ind_e>());
      break;
    case types::info_on_recommended_cells_and_ran_nodes_for_paging:
      c.init(other.c.get<info_on_recommended_cells_and_ran_nodes_for_paging_s>());
      break;
    case types::paging_assis_datafor_c_ecapab_ue:
      c.init(other.c.get<paging_assis_datafor_c_ecapab_ue_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_resume_request_ies_o::value_c");
  }
}
ue_context_resume_request_ies_o::value_c&
ue_context_resume_request_ies_o::value_c::operator=(const ue_context_resume_request_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::rrc_resume_cause:
      c.set(other.c.get<rrc_establishment_cause_e>());
      break;
    case types::pdu_session_res_resume_list_res_req:
      c.set(other.c.get<pdu_session_res_resume_list_res_req_l>());
      break;
    case types::pdu_session_res_failed_to_resume_list_res_req:
      c.set(other.c.get<pdu_session_res_failed_to_resume_list_res_req_l>());
      break;
    case types::suspend_request_ind:
      c.set(other.c.get<suspend_request_ind_e>());
      break;
    case types::info_on_recommended_cells_and_ran_nodes_for_paging:
      c.set(other.c.get<info_on_recommended_cells_and_ran_nodes_for_paging_s>());
      break;
    case types::paging_assis_datafor_c_ecapab_ue:
      c.set(other.c.get<paging_assis_datafor_c_ecapab_ue_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_resume_request_ies_o::value_c");
  }

  return *this;
}
uint64_t& ue_context_resume_request_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ue_context_resume_request_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
rrc_establishment_cause_e& ue_context_resume_request_ies_o::value_c::rrc_resume_cause()
{
  assert_choice_type(types::rrc_resume_cause, type_, "Value");
  return c.get<rrc_establishment_cause_e>();
}
pdu_session_res_resume_list_res_req_l& ue_context_resume_request_ies_o::value_c::pdu_session_res_resume_list_res_req()
{
  assert_choice_type(types::pdu_session_res_resume_list_res_req, type_, "Value");
  return c.get<pdu_session_res_resume_list_res_req_l>();
}
pdu_session_res_failed_to_resume_list_res_req_l&
ue_context_resume_request_ies_o::value_c::pdu_session_res_failed_to_resume_list_res_req()
{
  assert_choice_type(types::pdu_session_res_failed_to_resume_list_res_req, type_, "Value");
  return c.get<pdu_session_res_failed_to_resume_list_res_req_l>();
}
suspend_request_ind_e& ue_context_resume_request_ies_o::value_c::suspend_request_ind()
{
  assert_choice_type(types::suspend_request_ind, type_, "Value");
  return c.get<suspend_request_ind_e>();
}
info_on_recommended_cells_and_ran_nodes_for_paging_s&
ue_context_resume_request_ies_o::value_c::info_on_recommended_cells_and_ran_nodes_for_paging()
{
  assert_choice_type(types::info_on_recommended_cells_and_ran_nodes_for_paging, type_, "Value");
  return c.get<info_on_recommended_cells_and_ran_nodes_for_paging_s>();
}
paging_assis_datafor_c_ecapab_ue_s& ue_context_resume_request_ies_o::value_c::paging_assis_datafor_c_ecapab_ue()
{
  assert_choice_type(types::paging_assis_datafor_c_ecapab_ue, type_, "Value");
  return c.get<paging_assis_datafor_c_ecapab_ue_s>();
}
const uint64_t& ue_context_resume_request_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ue_context_resume_request_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const rrc_establishment_cause_e& ue_context_resume_request_ies_o::value_c::rrc_resume_cause() const
{
  assert_choice_type(types::rrc_resume_cause, type_, "Value");
  return c.get<rrc_establishment_cause_e>();
}
const pdu_session_res_resume_list_res_req_l&
ue_context_resume_request_ies_o::value_c::pdu_session_res_resume_list_res_req() const
{
  assert_choice_type(types::pdu_session_res_resume_list_res_req, type_, "Value");
  return c.get<pdu_session_res_resume_list_res_req_l>();
}
const pdu_session_res_failed_to_resume_list_res_req_l&
ue_context_resume_request_ies_o::value_c::pdu_session_res_failed_to_resume_list_res_req() const
{
  assert_choice_type(types::pdu_session_res_failed_to_resume_list_res_req, type_, "Value");
  return c.get<pdu_session_res_failed_to_resume_list_res_req_l>();
}
const suspend_request_ind_e& ue_context_resume_request_ies_o::value_c::suspend_request_ind() const
{
  assert_choice_type(types::suspend_request_ind, type_, "Value");
  return c.get<suspend_request_ind_e>();
}
const info_on_recommended_cells_and_ran_nodes_for_paging_s&
ue_context_resume_request_ies_o::value_c::info_on_recommended_cells_and_ran_nodes_for_paging() const
{
  assert_choice_type(types::info_on_recommended_cells_and_ran_nodes_for_paging, type_, "Value");
  return c.get<info_on_recommended_cells_and_ran_nodes_for_paging_s>();
}
const paging_assis_datafor_c_ecapab_ue_s&
ue_context_resume_request_ies_o::value_c::paging_assis_datafor_c_ecapab_ue() const
{
  assert_choice_type(types::paging_assis_datafor_c_ecapab_ue, type_, "Value");
  return c.get<paging_assis_datafor_c_ecapab_ue_s>();
}
void ue_context_resume_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::rrc_resume_cause:
      j.write_str("RRCEstablishmentCause", c.get<rrc_establishment_cause_e>().to_string());
      break;
    case types::pdu_session_res_resume_list_res_req:
      j.start_array("PDUSessionResourceResumeListRESReq");
      for (const auto& e1 : c.get<pdu_session_res_resume_list_res_req_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::pdu_session_res_failed_to_resume_list_res_req:
      j.start_array("PDUSessionResourceFailedToResumeListRESReq");
      for (const auto& e1 : c.get<pdu_session_res_failed_to_resume_list_res_req_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::suspend_request_ind:
      j.write_str("Suspend-Request-Indication", "suspend-requested");
      break;
    case types::info_on_recommended_cells_and_ran_nodes_for_paging:
      j.write_fieldname("InfoOnRecommendedCellsAndRANNodesForPaging");
      c.get<info_on_recommended_cells_and_ran_nodes_for_paging_s>().to_json(j);
      break;
    case types::paging_assis_datafor_c_ecapab_ue:
      j.write_fieldname("PagingAssisDataforCEcapabUE");
      c.get<paging_assis_datafor_c_ecapab_ue_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_resume_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_context_resume_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::rrc_resume_cause:
      HANDLE_CODE(c.get<rrc_establishment_cause_e>().pack(bref));
      break;
    case types::pdu_session_res_resume_list_res_req:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_resume_list_res_req_l>(), 1, 256, true));
      break;
    case types::pdu_session_res_failed_to_resume_list_res_req:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_failed_to_resume_list_res_req_l>(), 1, 256, true));
      break;
    case types::suspend_request_ind:
      HANDLE_CODE(c.get<suspend_request_ind_e>().pack(bref));
      break;
    case types::info_on_recommended_cells_and_ran_nodes_for_paging:
      HANDLE_CODE(c.get<info_on_recommended_cells_and_ran_nodes_for_paging_s>().pack(bref));
      break;
    case types::paging_assis_datafor_c_ecapab_ue:
      HANDLE_CODE(c.get<paging_assis_datafor_c_ecapab_ue_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_resume_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_resume_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::rrc_resume_cause:
      HANDLE_CODE(c.get<rrc_establishment_cause_e>().unpack(bref));
      break;
    case types::pdu_session_res_resume_list_res_req:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_resume_list_res_req_l>(), bref, 1, 256, true));
      break;
    case types::pdu_session_res_failed_to_resume_list_res_req:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_failed_to_resume_list_res_req_l>(), bref, 1, 256, true));
      break;
    case types::suspend_request_ind:
      HANDLE_CODE(c.get<suspend_request_ind_e>().unpack(bref));
      break;
    case types::info_on_recommended_cells_and_ran_nodes_for_paging:
      HANDLE_CODE(c.get<info_on_recommended_cells_and_ran_nodes_for_paging_s>().unpack(bref));
      break;
    case types::paging_assis_datafor_c_ecapab_ue:
      HANDLE_CODE(c.get<paging_assis_datafor_c_ecapab_ue_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_resume_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ue_context_resume_request_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..1099511627775)",
                                "INTEGER (0..4294967295)",
                                "RRCEstablishmentCause",
                                "PDUSessionResourceResumeListRESReq",
                                "PDUSessionResourceFailedToResumeListRESReq",
                                "Suspend-Request-Indication",
                                "InfoOnRecommendedCellsAndRANNodesForPaging",
                                "PagingAssisDataforCEcapabUE"};
  return convert_enum_idx(names, 8, value, "ue_context_resume_request_ies_o::value_c::types");
}

// UEContextResumeResponseIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ue_context_resume_resp_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 233, 230, 93, 236, 206, 19};
  return map_enum_number(names, 8, idx, "id");
}
bool ue_context_resume_resp_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 233, 230, 93, 236, 206, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ue_context_resume_resp_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::ignore;
    case 85:
      return crit_e::ignore;
    case 233:
      return crit_e::reject;
    case 230:
      return crit_e::reject;
    case 93:
      return crit_e::reject;
    case 236:
      return crit_e::ignore;
    case 206:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ue_context_resume_resp_ies_o::value_c ue_context_resume_resp_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 233:
      ret.set(value_c::types::pdu_session_res_resume_list_res_res);
      break;
    case 230:
      ret.set(value_c::types::pdu_session_res_failed_to_resume_list_res_res);
      break;
    case 93:
      ret.set(value_c::types::security_context);
      break;
    case 236:
      ret.set(value_c::types::suspend_resp_ind);
      break;
    case 206:
      ret.set(value_c::types::extended_connected_time);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ue_context_resume_resp_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 233:
      return presence_e::optional;
    case 230:
      return presence_e::optional;
    case 93:
      return presence_e::optional;
    case 236:
      return presence_e::optional;
    case 206:
      return presence_e::optional;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ue_context_resume_resp_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::pdu_session_res_resume_list_res_res:
      c.destroy<pdu_session_res_resume_list_res_res_l>();
      break;
    case types::pdu_session_res_failed_to_resume_list_res_res:
      c.destroy<pdu_session_res_failed_to_resume_list_res_res_l>();
      break;
    case types::security_context:
      c.destroy<security_context_s>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void ue_context_resume_resp_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::pdu_session_res_resume_list_res_res:
      c.init<pdu_session_res_resume_list_res_res_l>();
      break;
    case types::pdu_session_res_failed_to_resume_list_res_res:
      c.init<pdu_session_res_failed_to_resume_list_res_res_l>();
      break;
    case types::security_context:
      c.init<security_context_s>();
      break;
    case types::suspend_resp_ind:
      break;
    case types::extended_connected_time:
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_resume_resp_ies_o::value_c");
  }
}
ue_context_resume_resp_ies_o::value_c::value_c(const ue_context_resume_resp_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::pdu_session_res_resume_list_res_res:
      c.init(other.c.get<pdu_session_res_resume_list_res_res_l>());
      break;
    case types::pdu_session_res_failed_to_resume_list_res_res:
      c.init(other.c.get<pdu_session_res_failed_to_resume_list_res_res_l>());
      break;
    case types::security_context:
      c.init(other.c.get<security_context_s>());
      break;
    case types::suspend_resp_ind:
      c.init(other.c.get<suspend_resp_ind_e>());
      break;
    case types::extended_connected_time:
      c.init(other.c.get<uint16_t>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_resume_resp_ies_o::value_c");
  }
}
ue_context_resume_resp_ies_o::value_c&
ue_context_resume_resp_ies_o::value_c::operator=(const ue_context_resume_resp_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::pdu_session_res_resume_list_res_res:
      c.set(other.c.get<pdu_session_res_resume_list_res_res_l>());
      break;
    case types::pdu_session_res_failed_to_resume_list_res_res:
      c.set(other.c.get<pdu_session_res_failed_to_resume_list_res_res_l>());
      break;
    case types::security_context:
      c.set(other.c.get<security_context_s>());
      break;
    case types::suspend_resp_ind:
      c.set(other.c.get<suspend_resp_ind_e>());
      break;
    case types::extended_connected_time:
      c.set(other.c.get<uint16_t>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_resume_resp_ies_o::value_c");
  }

  return *this;
}
uint64_t& ue_context_resume_resp_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ue_context_resume_resp_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
pdu_session_res_resume_list_res_res_l& ue_context_resume_resp_ies_o::value_c::pdu_session_res_resume_list_res_res()
{
  assert_choice_type(types::pdu_session_res_resume_list_res_res, type_, "Value");
  return c.get<pdu_session_res_resume_list_res_res_l>();
}
pdu_session_res_failed_to_resume_list_res_res_l&
ue_context_resume_resp_ies_o::value_c::pdu_session_res_failed_to_resume_list_res_res()
{
  assert_choice_type(types::pdu_session_res_failed_to_resume_list_res_res, type_, "Value");
  return c.get<pdu_session_res_failed_to_resume_list_res_res_l>();
}
security_context_s& ue_context_resume_resp_ies_o::value_c::security_context()
{
  assert_choice_type(types::security_context, type_, "Value");
  return c.get<security_context_s>();
}
suspend_resp_ind_e& ue_context_resume_resp_ies_o::value_c::suspend_resp_ind()
{
  assert_choice_type(types::suspend_resp_ind, type_, "Value");
  return c.get<suspend_resp_ind_e>();
}
uint16_t& ue_context_resume_resp_ies_o::value_c::extended_connected_time()
{
  assert_choice_type(types::extended_connected_time, type_, "Value");
  return c.get<uint16_t>();
}
crit_diagnostics_s& ue_context_resume_resp_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const uint64_t& ue_context_resume_resp_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ue_context_resume_resp_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const pdu_session_res_resume_list_res_res_l&
ue_context_resume_resp_ies_o::value_c::pdu_session_res_resume_list_res_res() const
{
  assert_choice_type(types::pdu_session_res_resume_list_res_res, type_, "Value");
  return c.get<pdu_session_res_resume_list_res_res_l>();
}
const pdu_session_res_failed_to_resume_list_res_res_l&
ue_context_resume_resp_ies_o::value_c::pdu_session_res_failed_to_resume_list_res_res() const
{
  assert_choice_type(types::pdu_session_res_failed_to_resume_list_res_res, type_, "Value");
  return c.get<pdu_session_res_failed_to_resume_list_res_res_l>();
}
const security_context_s& ue_context_resume_resp_ies_o::value_c::security_context() const
{
  assert_choice_type(types::security_context, type_, "Value");
  return c.get<security_context_s>();
}
const suspend_resp_ind_e& ue_context_resume_resp_ies_o::value_c::suspend_resp_ind() const
{
  assert_choice_type(types::suspend_resp_ind, type_, "Value");
  return c.get<suspend_resp_ind_e>();
}
const uint16_t& ue_context_resume_resp_ies_o::value_c::extended_connected_time() const
{
  assert_choice_type(types::extended_connected_time, type_, "Value");
  return c.get<uint16_t>();
}
const crit_diagnostics_s& ue_context_resume_resp_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void ue_context_resume_resp_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::pdu_session_res_resume_list_res_res:
      j.start_array("PDUSessionResourceResumeListRESRes");
      for (const auto& e1 : c.get<pdu_session_res_resume_list_res_res_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::pdu_session_res_failed_to_resume_list_res_res:
      j.start_array("PDUSessionResourceFailedToResumeListRESRes");
      for (const auto& e1 : c.get<pdu_session_res_failed_to_resume_list_res_res_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::security_context:
      j.write_fieldname("SecurityContext");
      c.get<security_context_s>().to_json(j);
      break;
    case types::suspend_resp_ind:
      j.write_str("Suspend-Response-Indication", "suspend-indicated");
      break;
    case types::extended_connected_time:
      j.write_int("INTEGER (0..255)", c.get<uint16_t>());
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_resume_resp_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_context_resume_resp_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_resume_list_res_res:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_resume_list_res_res_l>(), 1, 256, true));
      break;
    case types::pdu_session_res_failed_to_resume_list_res_res:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_failed_to_resume_list_res_res_l>(), 1, 256, true));
      break;
    case types::security_context:
      HANDLE_CODE(c.get<security_context_s>().pack(bref));
      break;
    case types::suspend_resp_ind:
      HANDLE_CODE(c.get<suspend_resp_ind_e>().pack(bref));
      break;
    case types::extended_connected_time:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)0u, (uint16_t)255u, false, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_resume_resp_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_resume_resp_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_resume_list_res_res:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_resume_list_res_res_l>(), bref, 1, 256, true));
      break;
    case types::pdu_session_res_failed_to_resume_list_res_res:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_failed_to_resume_list_res_res_l>(), bref, 1, 256, true));
      break;
    case types::security_context:
      HANDLE_CODE(c.get<security_context_s>().unpack(bref));
      break;
    case types::suspend_resp_ind:
      HANDLE_CODE(c.get<suspend_resp_ind_e>().unpack(bref));
      break;
    case types::extended_connected_time:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)0u, (uint16_t)255u, false, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_resume_resp_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ue_context_resume_resp_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..1099511627775)",
                                "INTEGER (0..4294967295)",
                                "PDUSessionResourceResumeListRESRes",
                                "PDUSessionResourceFailedToResumeListRESRes",
                                "SecurityContext",
                                "Suspend-Response-Indication",
                                "INTEGER (0..255)",
                                "CriticalityDiagnostics"};
  return convert_enum_idx(names, 8, value, "ue_context_resume_resp_ies_o::value_c::types");
}

// UEContextSuspendFailureIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ue_context_suspend_fail_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 15, 19};
  return map_enum_number(names, 4, idx, "id");
}
bool ue_context_suspend_fail_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 15, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ue_context_suspend_fail_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::ignore;
    case 85:
      return crit_e::ignore;
    case 15:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ue_context_suspend_fail_ies_o::value_c ue_context_suspend_fail_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 15:
      ret.set(value_c::types::cause);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ue_context_suspend_fail_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 15:
      return presence_e::mandatory;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ue_context_suspend_fail_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::cause:
      c.destroy<cause_c>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void ue_context_suspend_fail_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::cause:
      c.init<cause_c>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_suspend_fail_ies_o::value_c");
  }
}
ue_context_suspend_fail_ies_o::value_c::value_c(const ue_context_suspend_fail_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_suspend_fail_ies_o::value_c");
  }
}
ue_context_suspend_fail_ies_o::value_c&
ue_context_suspend_fail_ies_o::value_c::operator=(const ue_context_suspend_fail_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_suspend_fail_ies_o::value_c");
  }

  return *this;
}
uint64_t& ue_context_suspend_fail_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ue_context_suspend_fail_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
cause_c& ue_context_suspend_fail_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
crit_diagnostics_s& ue_context_suspend_fail_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const uint64_t& ue_context_suspend_fail_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ue_context_suspend_fail_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const cause_c& ue_context_suspend_fail_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const crit_diagnostics_s& ue_context_suspend_fail_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void ue_context_suspend_fail_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_suspend_fail_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_context_suspend_fail_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_suspend_fail_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_suspend_fail_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_suspend_fail_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ue_context_suspend_fail_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {
      "INTEGER (0..1099511627775)", "INTEGER (0..4294967295)", "Cause", "CriticalityDiagnostics"};
  return convert_enum_idx(names, 4, value, "ue_context_suspend_fail_ies_o::value_c::types");
}

// UEContextSuspendRequestIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ue_context_suspend_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 32, 207, 231};
  return map_enum_number(names, 5, idx, "id");
}
bool ue_context_suspend_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 32, 207, 231};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ue_context_suspend_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 32:
      return crit_e::ignore;
    case 207:
      return crit_e::ignore;
    case 231:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ue_context_suspend_request_ies_o::value_c ue_context_suspend_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 32:
      ret.set(value_c::types::info_on_recommended_cells_and_ran_nodes_for_paging);
      break;
    case 207:
      ret.set(value_c::types::paging_assis_datafor_c_ecapab_ue);
      break;
    case 231:
      ret.set(value_c::types::pdu_session_res_suspend_list_sus_req);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ue_context_suspend_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 32:
      return presence_e::optional;
    case 207:
      return presence_e::optional;
    case 231:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ue_context_suspend_request_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::info_on_recommended_cells_and_ran_nodes_for_paging:
      c.destroy<info_on_recommended_cells_and_ran_nodes_for_paging_s>();
      break;
    case types::paging_assis_datafor_c_ecapab_ue:
      c.destroy<paging_assis_datafor_c_ecapab_ue_s>();
      break;
    case types::pdu_session_res_suspend_list_sus_req:
      c.destroy<pdu_session_res_suspend_list_sus_req_l>();
      break;
    default:
      break;
  }
}
void ue_context_suspend_request_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::info_on_recommended_cells_and_ran_nodes_for_paging:
      c.init<info_on_recommended_cells_and_ran_nodes_for_paging_s>();
      break;
    case types::paging_assis_datafor_c_ecapab_ue:
      c.init<paging_assis_datafor_c_ecapab_ue_s>();
      break;
    case types::pdu_session_res_suspend_list_sus_req:
      c.init<pdu_session_res_suspend_list_sus_req_l>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_suspend_request_ies_o::value_c");
  }
}
ue_context_suspend_request_ies_o::value_c::value_c(const ue_context_suspend_request_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::info_on_recommended_cells_and_ran_nodes_for_paging:
      c.init(other.c.get<info_on_recommended_cells_and_ran_nodes_for_paging_s>());
      break;
    case types::paging_assis_datafor_c_ecapab_ue:
      c.init(other.c.get<paging_assis_datafor_c_ecapab_ue_s>());
      break;
    case types::pdu_session_res_suspend_list_sus_req:
      c.init(other.c.get<pdu_session_res_suspend_list_sus_req_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_suspend_request_ies_o::value_c");
  }
}
ue_context_suspend_request_ies_o::value_c&
ue_context_suspend_request_ies_o::value_c::operator=(const ue_context_suspend_request_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::info_on_recommended_cells_and_ran_nodes_for_paging:
      c.set(other.c.get<info_on_recommended_cells_and_ran_nodes_for_paging_s>());
      break;
    case types::paging_assis_datafor_c_ecapab_ue:
      c.set(other.c.get<paging_assis_datafor_c_ecapab_ue_s>());
      break;
    case types::pdu_session_res_suspend_list_sus_req:
      c.set(other.c.get<pdu_session_res_suspend_list_sus_req_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_suspend_request_ies_o::value_c");
  }

  return *this;
}
uint64_t& ue_context_suspend_request_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ue_context_suspend_request_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
info_on_recommended_cells_and_ran_nodes_for_paging_s&
ue_context_suspend_request_ies_o::value_c::info_on_recommended_cells_and_ran_nodes_for_paging()
{
  assert_choice_type(types::info_on_recommended_cells_and_ran_nodes_for_paging, type_, "Value");
  return c.get<info_on_recommended_cells_and_ran_nodes_for_paging_s>();
}
paging_assis_datafor_c_ecapab_ue_s& ue_context_suspend_request_ies_o::value_c::paging_assis_datafor_c_ecapab_ue()
{
  assert_choice_type(types::paging_assis_datafor_c_ecapab_ue, type_, "Value");
  return c.get<paging_assis_datafor_c_ecapab_ue_s>();
}
pdu_session_res_suspend_list_sus_req_l&
ue_context_suspend_request_ies_o::value_c::pdu_session_res_suspend_list_sus_req()
{
  assert_choice_type(types::pdu_session_res_suspend_list_sus_req, type_, "Value");
  return c.get<pdu_session_res_suspend_list_sus_req_l>();
}
const uint64_t& ue_context_suspend_request_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ue_context_suspend_request_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const info_on_recommended_cells_and_ran_nodes_for_paging_s&
ue_context_suspend_request_ies_o::value_c::info_on_recommended_cells_and_ran_nodes_for_paging() const
{
  assert_choice_type(types::info_on_recommended_cells_and_ran_nodes_for_paging, type_, "Value");
  return c.get<info_on_recommended_cells_and_ran_nodes_for_paging_s>();
}
const paging_assis_datafor_c_ecapab_ue_s&
ue_context_suspend_request_ies_o::value_c::paging_assis_datafor_c_ecapab_ue() const
{
  assert_choice_type(types::paging_assis_datafor_c_ecapab_ue, type_, "Value");
  return c.get<paging_assis_datafor_c_ecapab_ue_s>();
}
const pdu_session_res_suspend_list_sus_req_l&
ue_context_suspend_request_ies_o::value_c::pdu_session_res_suspend_list_sus_req() const
{
  assert_choice_type(types::pdu_session_res_suspend_list_sus_req, type_, "Value");
  return c.get<pdu_session_res_suspend_list_sus_req_l>();
}
void ue_context_suspend_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::info_on_recommended_cells_and_ran_nodes_for_paging:
      j.write_fieldname("InfoOnRecommendedCellsAndRANNodesForPaging");
      c.get<info_on_recommended_cells_and_ran_nodes_for_paging_s>().to_json(j);
      break;
    case types::paging_assis_datafor_c_ecapab_ue:
      j.write_fieldname("PagingAssisDataforCEcapabUE");
      c.get<paging_assis_datafor_c_ecapab_ue_s>().to_json(j);
      break;
    case types::pdu_session_res_suspend_list_sus_req:
      j.start_array("PDUSessionResourceSuspendListSUSReq");
      for (const auto& e1 : c.get<pdu_session_res_suspend_list_sus_req_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_suspend_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_context_suspend_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::info_on_recommended_cells_and_ran_nodes_for_paging:
      HANDLE_CODE(c.get<info_on_recommended_cells_and_ran_nodes_for_paging_s>().pack(bref));
      break;
    case types::paging_assis_datafor_c_ecapab_ue:
      HANDLE_CODE(c.get<paging_assis_datafor_c_ecapab_ue_s>().pack(bref));
      break;
    case types::pdu_session_res_suspend_list_sus_req:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_suspend_list_sus_req_l>(), 1, 256, true));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_suspend_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_suspend_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::info_on_recommended_cells_and_ran_nodes_for_paging:
      HANDLE_CODE(c.get<info_on_recommended_cells_and_ran_nodes_for_paging_s>().unpack(bref));
      break;
    case types::paging_assis_datafor_c_ecapab_ue:
      HANDLE_CODE(c.get<paging_assis_datafor_c_ecapab_ue_s>().unpack(bref));
      break;
    case types::pdu_session_res_suspend_list_sus_req:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_suspend_list_sus_req_l>(), bref, 1, 256, true));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_suspend_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ue_context_suspend_request_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..1099511627775)",
                                "INTEGER (0..4294967295)",
                                "InfoOnRecommendedCellsAndRANNodesForPaging",
                                "PagingAssisDataforCEcapabUE",
                                "PDUSessionResourceSuspendListSUSReq"};
  return convert_enum_idx(names, 5, value, "ue_context_suspend_request_ies_o::value_c::types");
}

// UEContextSuspendResponseIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ue_context_suspend_resp_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 93, 19};
  return map_enum_number(names, 4, idx, "id");
}
bool ue_context_suspend_resp_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 93, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ue_context_suspend_resp_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::ignore;
    case 85:
      return crit_e::ignore;
    case 93:
      return crit_e::reject;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ue_context_suspend_resp_ies_o::value_c ue_context_suspend_resp_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 93:
      ret.set(value_c::types::security_context);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ue_context_suspend_resp_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 93:
      return presence_e::optional;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ue_context_suspend_resp_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::security_context:
      c.destroy<security_context_s>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void ue_context_suspend_resp_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::security_context:
      c.init<security_context_s>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_suspend_resp_ies_o::value_c");
  }
}
ue_context_suspend_resp_ies_o::value_c::value_c(const ue_context_suspend_resp_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::security_context:
      c.init(other.c.get<security_context_s>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_suspend_resp_ies_o::value_c");
  }
}
ue_context_suspend_resp_ies_o::value_c&
ue_context_suspend_resp_ies_o::value_c::operator=(const ue_context_suspend_resp_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::security_context:
      c.set(other.c.get<security_context_s>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_suspend_resp_ies_o::value_c");
  }

  return *this;
}
uint64_t& ue_context_suspend_resp_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ue_context_suspend_resp_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
security_context_s& ue_context_suspend_resp_ies_o::value_c::security_context()
{
  assert_choice_type(types::security_context, type_, "Value");
  return c.get<security_context_s>();
}
crit_diagnostics_s& ue_context_suspend_resp_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const uint64_t& ue_context_suspend_resp_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ue_context_suspend_resp_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const security_context_s& ue_context_suspend_resp_ies_o::value_c::security_context() const
{
  assert_choice_type(types::security_context, type_, "Value");
  return c.get<security_context_s>();
}
const crit_diagnostics_s& ue_context_suspend_resp_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void ue_context_suspend_resp_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::security_context:
      j.write_fieldname("SecurityContext");
      c.get<security_context_s>().to_json(j);
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_suspend_resp_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_context_suspend_resp_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::security_context:
      HANDLE_CODE(c.get<security_context_s>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_suspend_resp_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_suspend_resp_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::security_context:
      HANDLE_CODE(c.get<security_context_s>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_suspend_resp_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ue_context_suspend_resp_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {
      "INTEGER (0..1099511627775)", "INTEGER (0..4294967295)", "SecurityContext", "CriticalityDiagnostics"};
  return convert_enum_idx(names, 4, value, "ue_context_suspend_resp_ies_o::value_c::types");
}

// UEInformationTransferIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ue_info_transfer_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {26, 210, 117, 148, 0, 209, 34};
  return map_enum_number(names, 7, idx, "id");
}
bool ue_info_transfer_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {26, 210, 117, 148, 0, 209, 34};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ue_info_transfer_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 26:
      return crit_e::reject;
    case 210:
      return crit_e::ignore;
    case 117:
      return crit_e::ignore;
    case 148:
      return crit_e::ignore;
    case 0:
      return crit_e::ignore;
    case 209:
      return crit_e::ignore;
    case 34:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ue_info_transfer_ies_o::value_c ue_info_transfer_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 26:
      ret.set(value_c::types::five_g_s_tmsi);
      break;
    case 210:
      ret.set(value_c::types::nb_iot_ue_prio);
      break;
    case 117:
      ret.set(value_c::types::ue_radio_cap);
      break;
    case 148:
      ret.set(value_c::types::s_nssai);
      break;
    case 0:
      ret.set(value_c::types::allowed_nssai);
      break;
    case 209:
      ret.set(value_c::types::ue_diff_info);
      break;
    case 34:
      ret.set(value_c::types::masked_imeisv);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ue_info_transfer_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 26:
      return presence_e::mandatory;
    case 210:
      return presence_e::optional;
    case 117:
      return presence_e::optional;
    case 148:
      return presence_e::optional;
    case 0:
      return presence_e::optional;
    case 209:
      return presence_e::optional;
    case 34:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ue_info_transfer_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::five_g_s_tmsi:
      c.destroy<five_g_s_tmsi_s>();
      break;
    case types::ue_radio_cap:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::s_nssai:
      c.destroy<s_nssai_s>();
      break;
    case types::allowed_nssai:
      c.destroy<allowed_nssai_l>();
      break;
    case types::ue_diff_info:
      c.destroy<ue_diff_info_s>();
      break;
    case types::masked_imeisv:
      c.destroy<fixed_bitstring<64, false, true>>();
      break;
    default:
      break;
  }
}
void ue_info_transfer_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::five_g_s_tmsi:
      c.init<five_g_s_tmsi_s>();
      break;
    case types::nb_iot_ue_prio:
      break;
    case types::ue_radio_cap:
      c.init<unbounded_octstring<true>>();
      break;
    case types::s_nssai:
      c.init<s_nssai_s>();
      break;
    case types::allowed_nssai:
      c.init<allowed_nssai_l>();
      break;
    case types::ue_diff_info:
      c.init<ue_diff_info_s>();
      break;
    case types::masked_imeisv:
      c.init<fixed_bitstring<64, false, true>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_info_transfer_ies_o::value_c");
  }
}
ue_info_transfer_ies_o::value_c::value_c(const ue_info_transfer_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::five_g_s_tmsi:
      c.init(other.c.get<five_g_s_tmsi_s>());
      break;
    case types::nb_iot_ue_prio:
      c.init(other.c.get<uint16_t>());
      break;
    case types::ue_radio_cap:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::s_nssai:
      c.init(other.c.get<s_nssai_s>());
      break;
    case types::allowed_nssai:
      c.init(other.c.get<allowed_nssai_l>());
      break;
    case types::ue_diff_info:
      c.init(other.c.get<ue_diff_info_s>());
      break;
    case types::masked_imeisv:
      c.init(other.c.get<fixed_bitstring<64, false, true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_info_transfer_ies_o::value_c");
  }
}
ue_info_transfer_ies_o::value_c&
ue_info_transfer_ies_o::value_c::operator=(const ue_info_transfer_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::five_g_s_tmsi:
      c.set(other.c.get<five_g_s_tmsi_s>());
      break;
    case types::nb_iot_ue_prio:
      c.set(other.c.get<uint16_t>());
      break;
    case types::ue_radio_cap:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::s_nssai:
      c.set(other.c.get<s_nssai_s>());
      break;
    case types::allowed_nssai:
      c.set(other.c.get<allowed_nssai_l>());
      break;
    case types::ue_diff_info:
      c.set(other.c.get<ue_diff_info_s>());
      break;
    case types::masked_imeisv:
      c.set(other.c.get<fixed_bitstring<64, false, true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_info_transfer_ies_o::value_c");
  }

  return *this;
}
five_g_s_tmsi_s& ue_info_transfer_ies_o::value_c::five_g_s_tmsi()
{
  assert_choice_type(types::five_g_s_tmsi, type_, "Value");
  return c.get<five_g_s_tmsi_s>();
}
uint16_t& ue_info_transfer_ies_o::value_c::nb_iot_ue_prio()
{
  assert_choice_type(types::nb_iot_ue_prio, type_, "Value");
  return c.get<uint16_t>();
}
unbounded_octstring<true>& ue_info_transfer_ies_o::value_c::ue_radio_cap()
{
  assert_choice_type(types::ue_radio_cap, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
s_nssai_s& ue_info_transfer_ies_o::value_c::s_nssai()
{
  assert_choice_type(types::s_nssai, type_, "Value");
  return c.get<s_nssai_s>();
}
allowed_nssai_l& ue_info_transfer_ies_o::value_c::allowed_nssai()
{
  assert_choice_type(types::allowed_nssai, type_, "Value");
  return c.get<allowed_nssai_l>();
}
ue_diff_info_s& ue_info_transfer_ies_o::value_c::ue_diff_info()
{
  assert_choice_type(types::ue_diff_info, type_, "Value");
  return c.get<ue_diff_info_s>();
}
fixed_bitstring<64, false, true>& ue_info_transfer_ies_o::value_c::masked_imeisv()
{
  assert_choice_type(types::masked_imeisv, type_, "Value");
  return c.get<fixed_bitstring<64, false, true>>();
}
const five_g_s_tmsi_s& ue_info_transfer_ies_o::value_c::five_g_s_tmsi() const
{
  assert_choice_type(types::five_g_s_tmsi, type_, "Value");
  return c.get<five_g_s_tmsi_s>();
}
const uint16_t& ue_info_transfer_ies_o::value_c::nb_iot_ue_prio() const
{
  assert_choice_type(types::nb_iot_ue_prio, type_, "Value");
  return c.get<uint16_t>();
}
const unbounded_octstring<true>& ue_info_transfer_ies_o::value_c::ue_radio_cap() const
{
  assert_choice_type(types::ue_radio_cap, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const s_nssai_s& ue_info_transfer_ies_o::value_c::s_nssai() const
{
  assert_choice_type(types::s_nssai, type_, "Value");
  return c.get<s_nssai_s>();
}
const allowed_nssai_l& ue_info_transfer_ies_o::value_c::allowed_nssai() const
{
  assert_choice_type(types::allowed_nssai, type_, "Value");
  return c.get<allowed_nssai_l>();
}
const ue_diff_info_s& ue_info_transfer_ies_o::value_c::ue_diff_info() const
{
  assert_choice_type(types::ue_diff_info, type_, "Value");
  return c.get<ue_diff_info_s>();
}
const fixed_bitstring<64, false, true>& ue_info_transfer_ies_o::value_c::masked_imeisv() const
{
  assert_choice_type(types::masked_imeisv, type_, "Value");
  return c.get<fixed_bitstring<64, false, true>>();
}
void ue_info_transfer_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::five_g_s_tmsi:
      j.write_fieldname("FiveG-S-TMSI");
      c.get<five_g_s_tmsi_s>().to_json(j);
      break;
    case types::nb_iot_ue_prio:
      j.write_int("INTEGER (0..255,...)", c.get<uint16_t>());
      break;
    case types::ue_radio_cap:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::s_nssai:
      j.write_fieldname("S-NSSAI");
      c.get<s_nssai_s>().to_json(j);
      break;
    case types::allowed_nssai:
      j.start_array("AllowedNSSAI");
      for (const auto& e1 : c.get<allowed_nssai_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::ue_diff_info:
      j.write_fieldname("UE-DifferentiationInfo");
      c.get<ue_diff_info_s>().to_json(j);
      break;
    case types::masked_imeisv:
      j.write_str("BIT STRING", c.get<fixed_bitstring<64, false, true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "ue_info_transfer_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_info_transfer_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::five_g_s_tmsi:
      HANDLE_CODE(c.get<five_g_s_tmsi_s>().pack(bref));
      break;
    case types::nb_iot_ue_prio:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)0u, (uint16_t)255u, true, true));
      break;
    case types::ue_radio_cap:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::s_nssai:
      HANDLE_CODE(c.get<s_nssai_s>().pack(bref));
      break;
    case types::allowed_nssai:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<allowed_nssai_l>(), 1, 8, true));
      break;
    case types::ue_diff_info:
      HANDLE_CODE(c.get<ue_diff_info_s>().pack(bref));
      break;
    case types::masked_imeisv:
      HANDLE_CODE((c.get<fixed_bitstring<64, false, true>>().pack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "ue_info_transfer_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_info_transfer_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::five_g_s_tmsi:
      HANDLE_CODE(c.get<five_g_s_tmsi_s>().unpack(bref));
      break;
    case types::nb_iot_ue_prio:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)0u, (uint16_t)255u, true, true));
      break;
    case types::ue_radio_cap:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::s_nssai:
      HANDLE_CODE(c.get<s_nssai_s>().unpack(bref));
      break;
    case types::allowed_nssai:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<allowed_nssai_l>(), bref, 1, 8, true));
      break;
    case types::ue_diff_info:
      HANDLE_CODE(c.get<ue_diff_info_s>().unpack(bref));
      break;
    case types::masked_imeisv:
      HANDLE_CODE((c.get<fixed_bitstring<64, false, true>>().unpack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "ue_info_transfer_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ue_info_transfer_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"FiveG-S-TMSI",
                                "INTEGER (0..255,...)",
                                "OCTET STRING",
                                "S-NSSAI",
                                "AllowedNSSAI",
                                "UE-DifferentiationInfo",
                                "BIT STRING"};
  return convert_enum_idx(names, 7, value, "ue_info_transfer_ies_o::value_c::types");
}
uint8_t ue_info_transfer_ies_o::value_c::types_opts::to_number() const
{
  if (value == nb_iot_ue_prio) {
    return 0;
  }
  invalid_enum_number(value, "ue_info_transfer_ies_o::value_c::types");
  return 0;
}

// UERadioCapabilityCheckRequestIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ue_radio_cap_check_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 117, 264};
  return map_enum_number(names, 4, idx, "id");
}
bool ue_radio_cap_check_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 117, 264};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ue_radio_cap_check_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 117:
      return crit_e::ignore;
    case 264:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ue_radio_cap_check_request_ies_o::value_c ue_radio_cap_check_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 117:
      ret.set(value_c::types::ue_radio_cap);
      break;
    case 264:
      ret.set(value_c::types::ue_radio_cap_id);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ue_radio_cap_check_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 117:
      return presence_e::optional;
    case 264:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ue_radio_cap_check_request_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::ue_radio_cap:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::ue_radio_cap_id:
      c.destroy<unbounded_octstring<true>>();
      break;
    default:
      break;
  }
}
void ue_radio_cap_check_request_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::ue_radio_cap:
      c.init<unbounded_octstring<true>>();
      break;
    case types::ue_radio_cap_id:
      c.init<unbounded_octstring<true>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_check_request_ies_o::value_c");
  }
}
ue_radio_cap_check_request_ies_o::value_c::value_c(const ue_radio_cap_check_request_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ue_radio_cap:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::ue_radio_cap_id:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_check_request_ies_o::value_c");
  }
}
ue_radio_cap_check_request_ies_o::value_c&
ue_radio_cap_check_request_ies_o::value_c::operator=(const ue_radio_cap_check_request_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ue_radio_cap:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::ue_radio_cap_id:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_check_request_ies_o::value_c");
  }

  return *this;
}
uint64_t& ue_radio_cap_check_request_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ue_radio_cap_check_request_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
unbounded_octstring<true>& ue_radio_cap_check_request_ies_o::value_c::ue_radio_cap()
{
  assert_choice_type(types::ue_radio_cap, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
unbounded_octstring<true>& ue_radio_cap_check_request_ies_o::value_c::ue_radio_cap_id()
{
  assert_choice_type(types::ue_radio_cap_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const uint64_t& ue_radio_cap_check_request_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ue_radio_cap_check_request_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const unbounded_octstring<true>& ue_radio_cap_check_request_ies_o::value_c::ue_radio_cap() const
{
  assert_choice_type(types::ue_radio_cap, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const unbounded_octstring<true>& ue_radio_cap_check_request_ies_o::value_c::ue_radio_cap_id() const
{
  assert_choice_type(types::ue_radio_cap_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
void ue_radio_cap_check_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::ue_radio_cap:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::ue_radio_cap_id:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_check_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_radio_cap_check_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ue_radio_cap:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::ue_radio_cap_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_check_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_radio_cap_check_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ue_radio_cap:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::ue_radio_cap_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_check_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ue_radio_cap_check_request_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {
      "INTEGER (0..1099511627775)", "INTEGER (0..4294967295)", "OCTET STRING", "OCTET STRING"};
  return convert_enum_idx(names, 4, value, "ue_radio_cap_check_request_ies_o::value_c::types");
}

// UERadioCapabilityCheckResponseIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ue_radio_cap_check_resp_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 30, 19};
  return map_enum_number(names, 4, idx, "id");
}
bool ue_radio_cap_check_resp_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 30, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ue_radio_cap_check_resp_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::ignore;
    case 85:
      return crit_e::ignore;
    case 30:
      return crit_e::reject;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ue_radio_cap_check_resp_ies_o::value_c ue_radio_cap_check_resp_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 30:
      ret.set(value_c::types::ims_voice_support_ind);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ue_radio_cap_check_resp_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 30:
      return presence_e::mandatory;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ue_radio_cap_check_resp_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void ue_radio_cap_check_resp_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::ims_voice_support_ind:
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_check_resp_ies_o::value_c");
  }
}
ue_radio_cap_check_resp_ies_o::value_c::value_c(const ue_radio_cap_check_resp_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ims_voice_support_ind:
      c.init(other.c.get<ims_voice_support_ind_e>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_check_resp_ies_o::value_c");
  }
}
ue_radio_cap_check_resp_ies_o::value_c&
ue_radio_cap_check_resp_ies_o::value_c::operator=(const ue_radio_cap_check_resp_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ims_voice_support_ind:
      c.set(other.c.get<ims_voice_support_ind_e>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_check_resp_ies_o::value_c");
  }

  return *this;
}
uint64_t& ue_radio_cap_check_resp_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ue_radio_cap_check_resp_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
ims_voice_support_ind_e& ue_radio_cap_check_resp_ies_o::value_c::ims_voice_support_ind()
{
  assert_choice_type(types::ims_voice_support_ind, type_, "Value");
  return c.get<ims_voice_support_ind_e>();
}
crit_diagnostics_s& ue_radio_cap_check_resp_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const uint64_t& ue_radio_cap_check_resp_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ue_radio_cap_check_resp_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const ims_voice_support_ind_e& ue_radio_cap_check_resp_ies_o::value_c::ims_voice_support_ind() const
{
  assert_choice_type(types::ims_voice_support_ind, type_, "Value");
  return c.get<ims_voice_support_ind_e>();
}
const crit_diagnostics_s& ue_radio_cap_check_resp_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void ue_radio_cap_check_resp_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::ims_voice_support_ind:
      j.write_str("IMSVoiceSupportIndicator", c.get<ims_voice_support_ind_e>().to_string());
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_check_resp_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_radio_cap_check_resp_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ims_voice_support_ind:
      HANDLE_CODE(c.get<ims_voice_support_ind_e>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_check_resp_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_radio_cap_check_resp_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ims_voice_support_ind:
      HANDLE_CODE(c.get<ims_voice_support_ind_e>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_check_resp_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ue_radio_cap_check_resp_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {
      "INTEGER (0..1099511627775)", "INTEGER (0..4294967295)", "IMSVoiceSupportIndicator", "CriticalityDiagnostics"};
  return convert_enum_idx(names, 4, value, "ue_radio_cap_check_resp_ies_o::value_c::types");
}

// UERadioCapabilityIDMappingRequestIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ue_radio_cap_id_map_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {264};
  return map_enum_number(names, 1, idx, "id");
}
bool ue_radio_cap_id_map_request_ies_o::is_id_valid(const uint32_t& id)
{
  return 264 == id;
}
crit_e ue_radio_cap_id_map_request_ies_o::get_crit(const uint32_t& id)
{
  if (id == 264) {
    return crit_e::reject;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
ue_radio_cap_id_map_request_ies_o::value_c ue_radio_cap_id_map_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  if (id != 264) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ue_radio_cap_id_map_request_ies_o::get_presence(const uint32_t& id)
{
  if (id == 264) {
    return presence_e::mandatory;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Value ::= OPEN TYPE
void ue_radio_cap_id_map_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("OCTET STRING", c.to_string());
  j.end_obj();
}
SRSASN_CODE ue_radio_cap_id_map_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_radio_cap_id_map_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* ue_radio_cap_id_map_request_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"OCTET STRING"};
  return convert_enum_idx(names, 1, value, "ue_radio_cap_id_map_request_ies_o::value_c::types");
}

// UERadioCapabilityIDMappingResponseIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ue_radio_cap_id_map_resp_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {264, 117, 19};
  return map_enum_number(names, 3, idx, "id");
}
bool ue_radio_cap_id_map_resp_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {264, 117, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ue_radio_cap_id_map_resp_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 264:
      return crit_e::reject;
    case 117:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ue_radio_cap_id_map_resp_ies_o::value_c ue_radio_cap_id_map_resp_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 264:
      ret.set(value_c::types::ue_radio_cap_id);
      break;
    case 117:
      ret.set(value_c::types::ue_radio_cap);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ue_radio_cap_id_map_resp_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 264:
      return presence_e::mandatory;
    case 117:
      return presence_e::mandatory;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ue_radio_cap_id_map_resp_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::ue_radio_cap_id:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::ue_radio_cap:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void ue_radio_cap_id_map_resp_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::ue_radio_cap_id:
      c.init<unbounded_octstring<true>>();
      break;
    case types::ue_radio_cap:
      c.init<unbounded_octstring<true>>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_id_map_resp_ies_o::value_c");
  }
}
ue_radio_cap_id_map_resp_ies_o::value_c::value_c(const ue_radio_cap_id_map_resp_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::ue_radio_cap_id:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::ue_radio_cap:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_id_map_resp_ies_o::value_c");
  }
}
ue_radio_cap_id_map_resp_ies_o::value_c&
ue_radio_cap_id_map_resp_ies_o::value_c::operator=(const ue_radio_cap_id_map_resp_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::ue_radio_cap_id:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::ue_radio_cap:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_id_map_resp_ies_o::value_c");
  }

  return *this;
}
unbounded_octstring<true>& ue_radio_cap_id_map_resp_ies_o::value_c::ue_radio_cap_id()
{
  assert_choice_type(types::ue_radio_cap_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
unbounded_octstring<true>& ue_radio_cap_id_map_resp_ies_o::value_c::ue_radio_cap()
{
  assert_choice_type(types::ue_radio_cap, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
crit_diagnostics_s& ue_radio_cap_id_map_resp_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const unbounded_octstring<true>& ue_radio_cap_id_map_resp_ies_o::value_c::ue_radio_cap_id() const
{
  assert_choice_type(types::ue_radio_cap_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const unbounded_octstring<true>& ue_radio_cap_id_map_resp_ies_o::value_c::ue_radio_cap() const
{
  assert_choice_type(types::ue_radio_cap, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const crit_diagnostics_s& ue_radio_cap_id_map_resp_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void ue_radio_cap_id_map_resp_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::ue_radio_cap_id:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::ue_radio_cap:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_id_map_resp_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_radio_cap_id_map_resp_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ue_radio_cap_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::ue_radio_cap:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_id_map_resp_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_radio_cap_id_map_resp_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ue_radio_cap_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::ue_radio_cap:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_id_map_resp_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ue_radio_cap_id_map_resp_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"OCTET STRING", "OCTET STRING", "CriticalityDiagnostics"};
  return convert_enum_idx(names, 3, value, "ue_radio_cap_id_map_resp_ies_o::value_c::types");
}

// UERadioCapabilityInfoIndicationIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ue_radio_cap_info_ind_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 117, 118, 265};
  return map_enum_number(names, 5, idx, "id");
}
bool ue_radio_cap_info_ind_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 117, 118, 265};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ue_radio_cap_info_ind_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 117:
      return crit_e::ignore;
    case 118:
      return crit_e::ignore;
    case 265:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ue_radio_cap_info_ind_ies_o::value_c ue_radio_cap_info_ind_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 117:
      ret.set(value_c::types::ue_radio_cap);
      break;
    case 118:
      ret.set(value_c::types::ue_radio_cap_for_paging);
      break;
    case 265:
      ret.set(value_c::types::ue_radio_cap_eutra_format);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ue_radio_cap_info_ind_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 117:
      return presence_e::mandatory;
    case 118:
      return presence_e::optional;
    case 265:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ue_radio_cap_info_ind_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::ue_radio_cap:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::ue_radio_cap_for_paging:
      c.destroy<ue_radio_cap_for_paging_s>();
      break;
    case types::ue_radio_cap_eutra_format:
      c.destroy<unbounded_octstring<true>>();
      break;
    default:
      break;
  }
}
void ue_radio_cap_info_ind_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::ue_radio_cap:
      c.init<unbounded_octstring<true>>();
      break;
    case types::ue_radio_cap_for_paging:
      c.init<ue_radio_cap_for_paging_s>();
      break;
    case types::ue_radio_cap_eutra_format:
      c.init<unbounded_octstring<true>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_info_ind_ies_o::value_c");
  }
}
ue_radio_cap_info_ind_ies_o::value_c::value_c(const ue_radio_cap_info_ind_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ue_radio_cap:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::ue_radio_cap_for_paging:
      c.init(other.c.get<ue_radio_cap_for_paging_s>());
      break;
    case types::ue_radio_cap_eutra_format:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_info_ind_ies_o::value_c");
  }
}
ue_radio_cap_info_ind_ies_o::value_c&
ue_radio_cap_info_ind_ies_o::value_c::operator=(const ue_radio_cap_info_ind_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ue_radio_cap:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::ue_radio_cap_for_paging:
      c.set(other.c.get<ue_radio_cap_for_paging_s>());
      break;
    case types::ue_radio_cap_eutra_format:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_info_ind_ies_o::value_c");
  }

  return *this;
}
uint64_t& ue_radio_cap_info_ind_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ue_radio_cap_info_ind_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
unbounded_octstring<true>& ue_radio_cap_info_ind_ies_o::value_c::ue_radio_cap()
{
  assert_choice_type(types::ue_radio_cap, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
ue_radio_cap_for_paging_s& ue_radio_cap_info_ind_ies_o::value_c::ue_radio_cap_for_paging()
{
  assert_choice_type(types::ue_radio_cap_for_paging, type_, "Value");
  return c.get<ue_radio_cap_for_paging_s>();
}
unbounded_octstring<true>& ue_radio_cap_info_ind_ies_o::value_c::ue_radio_cap_eutra_format()
{
  assert_choice_type(types::ue_radio_cap_eutra_format, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const uint64_t& ue_radio_cap_info_ind_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ue_radio_cap_info_ind_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const unbounded_octstring<true>& ue_radio_cap_info_ind_ies_o::value_c::ue_radio_cap() const
{
  assert_choice_type(types::ue_radio_cap, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const ue_radio_cap_for_paging_s& ue_radio_cap_info_ind_ies_o::value_c::ue_radio_cap_for_paging() const
{
  assert_choice_type(types::ue_radio_cap_for_paging, type_, "Value");
  return c.get<ue_radio_cap_for_paging_s>();
}
const unbounded_octstring<true>& ue_radio_cap_info_ind_ies_o::value_c::ue_radio_cap_eutra_format() const
{
  assert_choice_type(types::ue_radio_cap_eutra_format, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
void ue_radio_cap_info_ind_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::ue_radio_cap:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::ue_radio_cap_for_paging:
      j.write_fieldname("UERadioCapabilityForPaging");
      c.get<ue_radio_cap_for_paging_s>().to_json(j);
      break;
    case types::ue_radio_cap_eutra_format:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_info_ind_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_radio_cap_info_ind_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ue_radio_cap:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::ue_radio_cap_for_paging:
      HANDLE_CODE(c.get<ue_radio_cap_for_paging_s>().pack(bref));
      break;
    case types::ue_radio_cap_eutra_format:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_info_ind_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_radio_cap_info_ind_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ue_radio_cap:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::ue_radio_cap_for_paging:
      HANDLE_CODE(c.get<ue_radio_cap_for_paging_s>().unpack(bref));
      break;
    case types::ue_radio_cap_eutra_format:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_info_ind_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ue_radio_cap_info_ind_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..1099511627775)",
                                "INTEGER (0..4294967295)",
                                "OCTET STRING",
                                "UERadioCapabilityForPaging",
                                "OCTET STRING"};
  return convert_enum_idx(names, 5, value, "ue_radio_cap_info_ind_ies_o::value_c::types");
}

// UETNLABindingReleaseRequestIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ue_tnla_binding_release_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85};
  return map_enum_number(names, 2, idx, "id");
}
bool ue_tnla_binding_release_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ue_tnla_binding_release_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ue_tnla_binding_release_request_ies_o::value_c ue_tnla_binding_release_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ue_tnla_binding_release_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ue_tnla_binding_release_request_ies_o::value_c::destroy_() {}
void ue_tnla_binding_release_request_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
}
ue_tnla_binding_release_request_ies_o::value_c::value_c(const ue_tnla_binding_release_request_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_tnla_binding_release_request_ies_o::value_c");
  }
}
ue_tnla_binding_release_request_ies_o::value_c&
ue_tnla_binding_release_request_ies_o::value_c::operator=(const ue_tnla_binding_release_request_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_tnla_binding_release_request_ies_o::value_c");
  }

  return *this;
}
uint64_t& ue_tnla_binding_release_request_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ue_tnla_binding_release_request_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ue_tnla_binding_release_request_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ue_tnla_binding_release_request_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
void ue_tnla_binding_release_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    default:
      log_invalid_choice_id(type_, "ue_tnla_binding_release_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_tnla_binding_release_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    default:
      log_invalid_choice_id(type_, "ue_tnla_binding_release_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_tnla_binding_release_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    default:
      log_invalid_choice_id(type_, "ue_tnla_binding_release_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ue_tnla_binding_release_request_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..1099511627775)", "INTEGER (0..4294967295)"};
  return convert_enum_idx(names, 2, value, "ue_tnla_binding_release_request_ies_o::value_c::types");
}

// UplinkNASTransport-IEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ul_nas_transport_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 38, 121, 239, 246, 247};
  return map_enum_number(names, 7, idx, "id");
}
bool ul_nas_transport_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 38, 121, 239, 246, 247};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ul_nas_transport_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 38:
      return crit_e::reject;
    case 121:
      return crit_e::ignore;
    case 239:
      return crit_e::reject;
    case 246:
      return crit_e::reject;
    case 247:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ul_nas_transport_ies_o::value_c ul_nas_transport_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 38:
      ret.set(value_c::types::nas_pdu);
      break;
    case 121:
      ret.set(value_c::types::user_location_info);
      break;
    case 239:
      ret.set(value_c::types::w_agf_id_info);
      break;
    case 246:
      ret.set(value_c::types::tngf_id_info);
      break;
    case 247:
      ret.set(value_c::types::twif_id_info);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ul_nas_transport_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 38:
      return presence_e::mandatory;
    case 121:
      return presence_e::mandatory;
    case 239:
      return presence_e::optional;
    case 246:
      return presence_e::optional;
    case 247:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ul_nas_transport_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::nas_pdu:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::user_location_info:
      c.destroy<user_location_info_c>();
      break;
    case types::w_agf_id_info:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::tngf_id_info:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::twif_id_info:
      c.destroy<unbounded_octstring<true>>();
      break;
    default:
      break;
  }
}
void ul_nas_transport_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::nas_pdu:
      c.init<unbounded_octstring<true>>();
      break;
    case types::user_location_info:
      c.init<user_location_info_c>();
      break;
    case types::w_agf_id_info:
      c.init<unbounded_octstring<true>>();
      break;
    case types::tngf_id_info:
      c.init<unbounded_octstring<true>>();
      break;
    case types::twif_id_info:
      c.init<unbounded_octstring<true>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ul_nas_transport_ies_o::value_c");
  }
}
ul_nas_transport_ies_o::value_c::value_c(const ul_nas_transport_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::nas_pdu:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::user_location_info:
      c.init(other.c.get<user_location_info_c>());
      break;
    case types::w_agf_id_info:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::tngf_id_info:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::twif_id_info:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ul_nas_transport_ies_o::value_c");
  }
}
ul_nas_transport_ies_o::value_c&
ul_nas_transport_ies_o::value_c::operator=(const ul_nas_transport_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::nas_pdu:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::user_location_info:
      c.set(other.c.get<user_location_info_c>());
      break;
    case types::w_agf_id_info:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::tngf_id_info:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::twif_id_info:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ul_nas_transport_ies_o::value_c");
  }

  return *this;
}
uint64_t& ul_nas_transport_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ul_nas_transport_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
unbounded_octstring<true>& ul_nas_transport_ies_o::value_c::nas_pdu()
{
  assert_choice_type(types::nas_pdu, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
user_location_info_c& ul_nas_transport_ies_o::value_c::user_location_info()
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
unbounded_octstring<true>& ul_nas_transport_ies_o::value_c::w_agf_id_info()
{
  assert_choice_type(types::w_agf_id_info, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
unbounded_octstring<true>& ul_nas_transport_ies_o::value_c::tngf_id_info()
{
  assert_choice_type(types::tngf_id_info, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
unbounded_octstring<true>& ul_nas_transport_ies_o::value_c::twif_id_info()
{
  assert_choice_type(types::twif_id_info, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const uint64_t& ul_nas_transport_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ul_nas_transport_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const unbounded_octstring<true>& ul_nas_transport_ies_o::value_c::nas_pdu() const
{
  assert_choice_type(types::nas_pdu, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const user_location_info_c& ul_nas_transport_ies_o::value_c::user_location_info() const
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
const unbounded_octstring<true>& ul_nas_transport_ies_o::value_c::w_agf_id_info() const
{
  assert_choice_type(types::w_agf_id_info, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const unbounded_octstring<true>& ul_nas_transport_ies_o::value_c::tngf_id_info() const
{
  assert_choice_type(types::tngf_id_info, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const unbounded_octstring<true>& ul_nas_transport_ies_o::value_c::twif_id_info() const
{
  assert_choice_type(types::twif_id_info, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
void ul_nas_transport_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::nas_pdu:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::user_location_info:
      j.write_fieldname("UserLocationInformation");
      c.get<user_location_info_c>().to_json(j);
      break;
    case types::w_agf_id_info:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::tngf_id_info:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::twif_id_info:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "ul_nas_transport_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ul_nas_transport_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::nas_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().pack(bref));
      break;
    case types::w_agf_id_info:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::tngf_id_info:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::twif_id_info:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ul_nas_transport_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ul_nas_transport_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::nas_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().unpack(bref));
      break;
    case types::w_agf_id_info:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::tngf_id_info:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::twif_id_info:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ul_nas_transport_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ul_nas_transport_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..1099511627775)",
                                "INTEGER (0..4294967295)",
                                "OCTET STRING",
                                "UserLocationInformation",
                                "OCTET STRING",
                                "OCTET STRING",
                                "OCTET STRING"};
  return convert_enum_idx(names, 7, value, "ul_nas_transport_ies_o::value_c::types");
}

// UplinkNonUEAssociatedNRPPaTransportIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ul_non_ue_associated_nrppa_transport_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {89, 46};
  return map_enum_number(names, 2, idx, "id");
}
bool ul_non_ue_associated_nrppa_transport_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {89, 46};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ul_non_ue_associated_nrppa_transport_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 89:
      return crit_e::reject;
    case 46:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ul_non_ue_associated_nrppa_transport_ies_o::value_c
ul_non_ue_associated_nrppa_transport_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 89:
      ret.set(value_c::types::routing_id);
      break;
    case 46:
      ret.set(value_c::types::nrppa_pdu);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ul_non_ue_associated_nrppa_transport_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 89:
      return presence_e::mandatory;
    case 46:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ul_non_ue_associated_nrppa_transport_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::routing_id:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::nrppa_pdu:
      c.destroy<unbounded_octstring<true>>();
      break;
    default:
      break;
  }
}
void ul_non_ue_associated_nrppa_transport_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::routing_id:
      c.init<unbounded_octstring<true>>();
      break;
    case types::nrppa_pdu:
      c.init<unbounded_octstring<true>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ul_non_ue_associated_nrppa_transport_ies_o::value_c");
  }
}
ul_non_ue_associated_nrppa_transport_ies_o::value_c::value_c(
    const ul_non_ue_associated_nrppa_transport_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::routing_id:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nrppa_pdu:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ul_non_ue_associated_nrppa_transport_ies_o::value_c");
  }
}
ul_non_ue_associated_nrppa_transport_ies_o::value_c& ul_non_ue_associated_nrppa_transport_ies_o::value_c::operator=(
    const ul_non_ue_associated_nrppa_transport_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::routing_id:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nrppa_pdu:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ul_non_ue_associated_nrppa_transport_ies_o::value_c");
  }

  return *this;
}
unbounded_octstring<true>& ul_non_ue_associated_nrppa_transport_ies_o::value_c::routing_id()
{
  assert_choice_type(types::routing_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
unbounded_octstring<true>& ul_non_ue_associated_nrppa_transport_ies_o::value_c::nrppa_pdu()
{
  assert_choice_type(types::nrppa_pdu, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const unbounded_octstring<true>& ul_non_ue_associated_nrppa_transport_ies_o::value_c::routing_id() const
{
  assert_choice_type(types::routing_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const unbounded_octstring<true>& ul_non_ue_associated_nrppa_transport_ies_o::value_c::nrppa_pdu() const
{
  assert_choice_type(types::nrppa_pdu, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
void ul_non_ue_associated_nrppa_transport_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::routing_id:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::nrppa_pdu:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "ul_non_ue_associated_nrppa_transport_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ul_non_ue_associated_nrppa_transport_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::routing_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::nrppa_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ul_non_ue_associated_nrppa_transport_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ul_non_ue_associated_nrppa_transport_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::routing_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::nrppa_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ul_non_ue_associated_nrppa_transport_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ul_non_ue_associated_nrppa_transport_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"OCTET STRING", "OCTET STRING"};
  return convert_enum_idx(names, 2, value, "ul_non_ue_associated_nrppa_transport_ies_o::value_c::types");
}

// UplinkRANConfigurationTransferIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ul_ran_cfg_transfer_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {99, 158, 251};
  return map_enum_number(names, 3, idx, "id");
}
bool ul_ran_cfg_transfer_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {99, 158, 251};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ul_ran_cfg_transfer_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 99:
      return crit_e::ignore;
    case 158:
      return crit_e::ignore;
    case 251:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ul_ran_cfg_transfer_ies_o::value_c ul_ran_cfg_transfer_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 99:
      ret.set(value_c::types::son_cfg_transfer_ul);
      break;
    case 158:
      ret.set(value_c::types::endc_son_cfg_transfer_ul);
      break;
    case 251:
      ret.set(value_c::types::intersys_son_cfg_transfer_ul);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ul_ran_cfg_transfer_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 99:
      return presence_e::optional;
    case 158:
      return presence_e::optional;
    case 251:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ul_ran_cfg_transfer_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::son_cfg_transfer_ul:
      c.destroy<son_cfg_transfer_s>();
      break;
    case types::endc_son_cfg_transfer_ul:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::intersys_son_cfg_transfer_ul:
      c.destroy<intersys_son_cfg_transfer_s>();
      break;
    default:
      break;
  }
}
void ul_ran_cfg_transfer_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::son_cfg_transfer_ul:
      c.init<son_cfg_transfer_s>();
      break;
    case types::endc_son_cfg_transfer_ul:
      c.init<unbounded_octstring<true>>();
      break;
    case types::intersys_son_cfg_transfer_ul:
      c.init<intersys_son_cfg_transfer_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ul_ran_cfg_transfer_ies_o::value_c");
  }
}
ul_ran_cfg_transfer_ies_o::value_c::value_c(const ul_ran_cfg_transfer_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::son_cfg_transfer_ul:
      c.init(other.c.get<son_cfg_transfer_s>());
      break;
    case types::endc_son_cfg_transfer_ul:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::intersys_son_cfg_transfer_ul:
      c.init(other.c.get<intersys_son_cfg_transfer_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ul_ran_cfg_transfer_ies_o::value_c");
  }
}
ul_ran_cfg_transfer_ies_o::value_c&
ul_ran_cfg_transfer_ies_o::value_c::operator=(const ul_ran_cfg_transfer_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::son_cfg_transfer_ul:
      c.set(other.c.get<son_cfg_transfer_s>());
      break;
    case types::endc_son_cfg_transfer_ul:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::intersys_son_cfg_transfer_ul:
      c.set(other.c.get<intersys_son_cfg_transfer_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ul_ran_cfg_transfer_ies_o::value_c");
  }

  return *this;
}
son_cfg_transfer_s& ul_ran_cfg_transfer_ies_o::value_c::son_cfg_transfer_ul()
{
  assert_choice_type(types::son_cfg_transfer_ul, type_, "Value");
  return c.get<son_cfg_transfer_s>();
}
unbounded_octstring<true>& ul_ran_cfg_transfer_ies_o::value_c::endc_son_cfg_transfer_ul()
{
  assert_choice_type(types::endc_son_cfg_transfer_ul, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
intersys_son_cfg_transfer_s& ul_ran_cfg_transfer_ies_o::value_c::intersys_son_cfg_transfer_ul()
{
  assert_choice_type(types::intersys_son_cfg_transfer_ul, type_, "Value");
  return c.get<intersys_son_cfg_transfer_s>();
}
const son_cfg_transfer_s& ul_ran_cfg_transfer_ies_o::value_c::son_cfg_transfer_ul() const
{
  assert_choice_type(types::son_cfg_transfer_ul, type_, "Value");
  return c.get<son_cfg_transfer_s>();
}
const unbounded_octstring<true>& ul_ran_cfg_transfer_ies_o::value_c::endc_son_cfg_transfer_ul() const
{
  assert_choice_type(types::endc_son_cfg_transfer_ul, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const intersys_son_cfg_transfer_s& ul_ran_cfg_transfer_ies_o::value_c::intersys_son_cfg_transfer_ul() const
{
  assert_choice_type(types::intersys_son_cfg_transfer_ul, type_, "Value");
  return c.get<intersys_son_cfg_transfer_s>();
}
void ul_ran_cfg_transfer_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::son_cfg_transfer_ul:
      j.write_fieldname("SONConfigurationTransfer");
      c.get<son_cfg_transfer_s>().to_json(j);
      break;
    case types::endc_son_cfg_transfer_ul:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::intersys_son_cfg_transfer_ul:
      j.write_fieldname("IntersystemSONConfigurationTransfer");
      c.get<intersys_son_cfg_transfer_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ul_ran_cfg_transfer_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ul_ran_cfg_transfer_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::son_cfg_transfer_ul:
      HANDLE_CODE(c.get<son_cfg_transfer_s>().pack(bref));
      break;
    case types::endc_son_cfg_transfer_ul:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::intersys_son_cfg_transfer_ul:
      HANDLE_CODE(c.get<intersys_son_cfg_transfer_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ul_ran_cfg_transfer_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ul_ran_cfg_transfer_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::son_cfg_transfer_ul:
      HANDLE_CODE(c.get<son_cfg_transfer_s>().unpack(bref));
      break;
    case types::endc_son_cfg_transfer_ul:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::intersys_son_cfg_transfer_ul:
      HANDLE_CODE(c.get<intersys_son_cfg_transfer_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ul_ran_cfg_transfer_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ul_ran_cfg_transfer_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"SONConfigurationTransfer", "OCTET STRING", "IntersystemSONConfigurationTransfer"};
  return convert_enum_idx(names, 3, value, "ul_ran_cfg_transfer_ies_o::value_c::types");
}

// UplinkRANEarlyStatusTransferIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ul_ran_early_status_transfer_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 268};
  return map_enum_number(names, 3, idx, "id");
}
bool ul_ran_early_status_transfer_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 268};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ul_ran_early_status_transfer_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 268:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ul_ran_early_status_transfer_ies_o::value_c ul_ran_early_status_transfer_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 268:
      ret.set(value_c::types::early_status_transfer_transparent_container);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ul_ran_early_status_transfer_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 268:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ul_ran_early_status_transfer_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::early_status_transfer_transparent_container:
      c.destroy<early_status_transfer_transparent_container_s>();
      break;
    default:
      break;
  }
}
void ul_ran_early_status_transfer_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::early_status_transfer_transparent_container:
      c.init<early_status_transfer_transparent_container_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ul_ran_early_status_transfer_ies_o::value_c");
  }
}
ul_ran_early_status_transfer_ies_o::value_c::value_c(const ul_ran_early_status_transfer_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::early_status_transfer_transparent_container:
      c.init(other.c.get<early_status_transfer_transparent_container_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ul_ran_early_status_transfer_ies_o::value_c");
  }
}
ul_ran_early_status_transfer_ies_o::value_c&
ul_ran_early_status_transfer_ies_o::value_c::operator=(const ul_ran_early_status_transfer_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::early_status_transfer_transparent_container:
      c.set(other.c.get<early_status_transfer_transparent_container_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ul_ran_early_status_transfer_ies_o::value_c");
  }

  return *this;
}
uint64_t& ul_ran_early_status_transfer_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ul_ran_early_status_transfer_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
early_status_transfer_transparent_container_s&
ul_ran_early_status_transfer_ies_o::value_c::early_status_transfer_transparent_container()
{
  assert_choice_type(types::early_status_transfer_transparent_container, type_, "Value");
  return c.get<early_status_transfer_transparent_container_s>();
}
const uint64_t& ul_ran_early_status_transfer_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ul_ran_early_status_transfer_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const early_status_transfer_transparent_container_s&
ul_ran_early_status_transfer_ies_o::value_c::early_status_transfer_transparent_container() const
{
  assert_choice_type(types::early_status_transfer_transparent_container, type_, "Value");
  return c.get<early_status_transfer_transparent_container_s>();
}
void ul_ran_early_status_transfer_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::early_status_transfer_transparent_container:
      j.write_fieldname("EarlyStatusTransfer-TransparentContainer");
      c.get<early_status_transfer_transparent_container_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ul_ran_early_status_transfer_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ul_ran_early_status_transfer_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::early_status_transfer_transparent_container:
      HANDLE_CODE(c.get<early_status_transfer_transparent_container_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ul_ran_early_status_transfer_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ul_ran_early_status_transfer_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::early_status_transfer_transparent_container:
      HANDLE_CODE(c.get<early_status_transfer_transparent_container_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ul_ran_early_status_transfer_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ul_ran_early_status_transfer_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {
      "INTEGER (0..1099511627775)", "INTEGER (0..4294967295)", "EarlyStatusTransfer-TransparentContainer"};
  return convert_enum_idx(names, 3, value, "ul_ran_early_status_transfer_ies_o::value_c::types");
}

// UplinkRANStatusTransferIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ul_ran_status_transfer_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 84};
  return map_enum_number(names, 3, idx, "id");
}
bool ul_ran_status_transfer_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 84};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ul_ran_status_transfer_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 84:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ul_ran_status_transfer_ies_o::value_c ul_ran_status_transfer_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 84:
      ret.set(value_c::types::ran_status_transfer_transparent_container);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ul_ran_status_transfer_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 84:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ul_ran_status_transfer_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::ran_status_transfer_transparent_container:
      c.destroy<ran_status_transfer_transparent_container_s>();
      break;
    default:
      break;
  }
}
void ul_ran_status_transfer_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::ran_status_transfer_transparent_container:
      c.init<ran_status_transfer_transparent_container_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ul_ran_status_transfer_ies_o::value_c");
  }
}
ul_ran_status_transfer_ies_o::value_c::value_c(const ul_ran_status_transfer_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_status_transfer_transparent_container:
      c.init(other.c.get<ran_status_transfer_transparent_container_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ul_ran_status_transfer_ies_o::value_c");
  }
}
ul_ran_status_transfer_ies_o::value_c&
ul_ran_status_transfer_ies_o::value_c::operator=(const ul_ran_status_transfer_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_status_transfer_transparent_container:
      c.set(other.c.get<ran_status_transfer_transparent_container_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ul_ran_status_transfer_ies_o::value_c");
  }

  return *this;
}
uint64_t& ul_ran_status_transfer_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ul_ran_status_transfer_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
ran_status_transfer_transparent_container_s&
ul_ran_status_transfer_ies_o::value_c::ran_status_transfer_transparent_container()
{
  assert_choice_type(types::ran_status_transfer_transparent_container, type_, "Value");
  return c.get<ran_status_transfer_transparent_container_s>();
}
const uint64_t& ul_ran_status_transfer_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ul_ran_status_transfer_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const ran_status_transfer_transparent_container_s&
ul_ran_status_transfer_ies_o::value_c::ran_status_transfer_transparent_container() const
{
  assert_choice_type(types::ran_status_transfer_transparent_container, type_, "Value");
  return c.get<ran_status_transfer_transparent_container_s>();
}
void ul_ran_status_transfer_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::ran_status_transfer_transparent_container:
      j.write_fieldname("RANStatusTransfer-TransparentContainer");
      c.get<ran_status_transfer_transparent_container_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ul_ran_status_transfer_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ul_ran_status_transfer_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ran_status_transfer_transparent_container:
      HANDLE_CODE(c.get<ran_status_transfer_transparent_container_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ul_ran_status_transfer_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ul_ran_status_transfer_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ran_status_transfer_transparent_container:
      HANDLE_CODE(c.get<ran_status_transfer_transparent_container_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ul_ran_status_transfer_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ul_ran_status_transfer_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {
      "INTEGER (0..1099511627775)", "INTEGER (0..4294967295)", "RANStatusTransfer-TransparentContainer"};
  return convert_enum_idx(names, 3, value, "ul_ran_status_transfer_ies_o::value_c::types");
}

// UplinkRIMInformationTransferIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ul_rim_info_transfer_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {175};
  return map_enum_number(names, 1, idx, "id");
}
bool ul_rim_info_transfer_ies_o::is_id_valid(const uint32_t& id)
{
  return 175 == id;
}
crit_e ul_rim_info_transfer_ies_o::get_crit(const uint32_t& id)
{
  if (id == 175) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
ul_rim_info_transfer_ies_o::value_c ul_rim_info_transfer_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  if (id != 175) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ul_rim_info_transfer_ies_o::get_presence(const uint32_t& id)
{
  if (id == 175) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Value ::= OPEN TYPE
void ul_rim_info_transfer_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("RIMInformationTransfer");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE ul_rim_info_transfer_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE ul_rim_info_transfer_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* ul_rim_info_transfer_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"RIMInformationTransfer"};
  return convert_enum_idx(names, 1, value, "ul_rim_info_transfer_ies_o::value_c::types");
}

// UplinkUEAssociatedNRPPaTransportIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ul_ue_associated_nrppa_transport_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 89, 46};
  return map_enum_number(names, 4, idx, "id");
}
bool ul_ue_associated_nrppa_transport_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 89, 46};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ul_ue_associated_nrppa_transport_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 89:
      return crit_e::reject;
    case 46:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ul_ue_associated_nrppa_transport_ies_o::value_c ul_ue_associated_nrppa_transport_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 89:
      ret.set(value_c::types::routing_id);
      break;
    case 46:
      ret.set(value_c::types::nrppa_pdu);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ul_ue_associated_nrppa_transport_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 89:
      return presence_e::mandatory;
    case 46:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ul_ue_associated_nrppa_transport_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::routing_id:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::nrppa_pdu:
      c.destroy<unbounded_octstring<true>>();
      break;
    default:
      break;
  }
}
void ul_ue_associated_nrppa_transport_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::routing_id:
      c.init<unbounded_octstring<true>>();
      break;
    case types::nrppa_pdu:
      c.init<unbounded_octstring<true>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ul_ue_associated_nrppa_transport_ies_o::value_c");
  }
}
ul_ue_associated_nrppa_transport_ies_o::value_c::value_c(const ul_ue_associated_nrppa_transport_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::routing_id:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nrppa_pdu:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ul_ue_associated_nrppa_transport_ies_o::value_c");
  }
}
ul_ue_associated_nrppa_transport_ies_o::value_c&
ul_ue_associated_nrppa_transport_ies_o::value_c::operator=(const ul_ue_associated_nrppa_transport_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::routing_id:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nrppa_pdu:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ul_ue_associated_nrppa_transport_ies_o::value_c");
  }

  return *this;
}
uint64_t& ul_ue_associated_nrppa_transport_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ul_ue_associated_nrppa_transport_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
unbounded_octstring<true>& ul_ue_associated_nrppa_transport_ies_o::value_c::routing_id()
{
  assert_choice_type(types::routing_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
unbounded_octstring<true>& ul_ue_associated_nrppa_transport_ies_o::value_c::nrppa_pdu()
{
  assert_choice_type(types::nrppa_pdu, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const uint64_t& ul_ue_associated_nrppa_transport_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ul_ue_associated_nrppa_transport_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const unbounded_octstring<true>& ul_ue_associated_nrppa_transport_ies_o::value_c::routing_id() const
{
  assert_choice_type(types::routing_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const unbounded_octstring<true>& ul_ue_associated_nrppa_transport_ies_o::value_c::nrppa_pdu() const
{
  assert_choice_type(types::nrppa_pdu, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
void ul_ue_associated_nrppa_transport_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::routing_id:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::nrppa_pdu:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "ul_ue_associated_nrppa_transport_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ul_ue_associated_nrppa_transport_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::routing_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::nrppa_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ul_ue_associated_nrppa_transport_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ul_ue_associated_nrppa_transport_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::routing_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::nrppa_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ul_ue_associated_nrppa_transport_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ul_ue_associated_nrppa_transport_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {
      "INTEGER (0..1099511627775)", "INTEGER (0..4294967295)", "OCTET STRING", "OCTET STRING"};
  return convert_enum_idx(names, 4, value, "ul_ue_associated_nrppa_transport_ies_o::value_c::types");
}

// WriteReplaceWarningRequestIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t write_replace_warning_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {35, 95, 122, 87, 47, 125, 124, 20, 123, 17, 141};
  return map_enum_number(names, 11, idx, "id");
}
bool write_replace_warning_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {35, 95, 122, 87, 47, 125, 124, 20, 123, 17, 141};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e write_replace_warning_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 35:
      return crit_e::reject;
    case 95:
      return crit_e::reject;
    case 122:
      return crit_e::ignore;
    case 87:
      return crit_e::reject;
    case 47:
      return crit_e::reject;
    case 125:
      return crit_e::ignore;
    case 124:
      return crit_e::ignore;
    case 20:
      return crit_e::ignore;
    case 123:
      return crit_e::ignore;
    case 17:
      return crit_e::reject;
    case 141:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
write_replace_warning_request_ies_o::value_c write_replace_warning_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 35:
      ret.set(value_c::types::msg_id);
      break;
    case 95:
      ret.set(value_c::types::serial_num);
      break;
    case 122:
      ret.set(value_c::types::warning_area_list);
      break;
    case 87:
      ret.set(value_c::types::repeat_period);
      break;
    case 47:
      ret.set(value_c::types::nof_broadcasts_requested);
      break;
    case 125:
      ret.set(value_c::types::warning_type);
      break;
    case 124:
      ret.set(value_c::types::warning_security_info);
      break;
    case 20:
      ret.set(value_c::types::data_coding_scheme);
      break;
    case 123:
      ret.set(value_c::types::warning_msg_contents);
      break;
    case 17:
      ret.set(value_c::types::concurrent_warning_msg_ind);
      break;
    case 141:
      ret.set(value_c::types::warning_area_coordinates);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e write_replace_warning_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 35:
      return presence_e::mandatory;
    case 95:
      return presence_e::mandatory;
    case 122:
      return presence_e::optional;
    case 87:
      return presence_e::mandatory;
    case 47:
      return presence_e::mandatory;
    case 125:
      return presence_e::optional;
    case 124:
      return presence_e::optional;
    case 20:
      return presence_e::optional;
    case 123:
      return presence_e::optional;
    case 17:
      return presence_e::optional;
    case 141:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void write_replace_warning_request_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::msg_id:
      c.destroy<fixed_bitstring<16, false, true>>();
      break;
    case types::serial_num:
      c.destroy<fixed_bitstring<16, false, true>>();
      break;
    case types::warning_area_list:
      c.destroy<warning_area_list_c>();
      break;
    case types::warning_type:
      c.destroy<fixed_octstring<2, true>>();
      break;
    case types::warning_security_info:
      c.destroy<fixed_octstring<50, true>>();
      break;
    case types::data_coding_scheme:
      c.destroy<fixed_bitstring<8, false, true>>();
      break;
    case types::warning_msg_contents:
      c.destroy<bounded_octstring<1, 9600, true>>();
      break;
    case types::warning_area_coordinates:
      c.destroy<bounded_octstring<1, 1024, true>>();
      break;
    default:
      break;
  }
}
void write_replace_warning_request_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::msg_id:
      c.init<fixed_bitstring<16, false, true>>();
      break;
    case types::serial_num:
      c.init<fixed_bitstring<16, false, true>>();
      break;
    case types::warning_area_list:
      c.init<warning_area_list_c>();
      break;
    case types::repeat_period:
      break;
    case types::nof_broadcasts_requested:
      break;
    case types::warning_type:
      c.init<fixed_octstring<2, true>>();
      break;
    case types::warning_security_info:
      c.init<fixed_octstring<50, true>>();
      break;
    case types::data_coding_scheme:
      c.init<fixed_bitstring<8, false, true>>();
      break;
    case types::warning_msg_contents:
      c.init<bounded_octstring<1, 9600, true>>();
      break;
    case types::concurrent_warning_msg_ind:
      break;
    case types::warning_area_coordinates:
      c.init<bounded_octstring<1, 1024, true>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "write_replace_warning_request_ies_o::value_c");
  }
}
write_replace_warning_request_ies_o::value_c::value_c(const write_replace_warning_request_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::msg_id:
      c.init(other.c.get<fixed_bitstring<16, false, true>>());
      break;
    case types::serial_num:
      c.init(other.c.get<fixed_bitstring<16, false, true>>());
      break;
    case types::warning_area_list:
      c.init(other.c.get<warning_area_list_c>());
      break;
    case types::repeat_period:
      c.init(other.c.get<uint32_t>());
      break;
    case types::nof_broadcasts_requested:
      c.init(other.c.get<uint32_t>());
      break;
    case types::warning_type:
      c.init(other.c.get<fixed_octstring<2, true>>());
      break;
    case types::warning_security_info:
      c.init(other.c.get<fixed_octstring<50, true>>());
      break;
    case types::data_coding_scheme:
      c.init(other.c.get<fixed_bitstring<8, false, true>>());
      break;
    case types::warning_msg_contents:
      c.init(other.c.get<bounded_octstring<1, 9600, true>>());
      break;
    case types::concurrent_warning_msg_ind:
      c.init(other.c.get<concurrent_warning_msg_ind_e>());
      break;
    case types::warning_area_coordinates:
      c.init(other.c.get<bounded_octstring<1, 1024, true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "write_replace_warning_request_ies_o::value_c");
  }
}
write_replace_warning_request_ies_o::value_c&
write_replace_warning_request_ies_o::value_c::operator=(const write_replace_warning_request_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::msg_id:
      c.set(other.c.get<fixed_bitstring<16, false, true>>());
      break;
    case types::serial_num:
      c.set(other.c.get<fixed_bitstring<16, false, true>>());
      break;
    case types::warning_area_list:
      c.set(other.c.get<warning_area_list_c>());
      break;
    case types::repeat_period:
      c.set(other.c.get<uint32_t>());
      break;
    case types::nof_broadcasts_requested:
      c.set(other.c.get<uint32_t>());
      break;
    case types::warning_type:
      c.set(other.c.get<fixed_octstring<2, true>>());
      break;
    case types::warning_security_info:
      c.set(other.c.get<fixed_octstring<50, true>>());
      break;
    case types::data_coding_scheme:
      c.set(other.c.get<fixed_bitstring<8, false, true>>());
      break;
    case types::warning_msg_contents:
      c.set(other.c.get<bounded_octstring<1, 9600, true>>());
      break;
    case types::concurrent_warning_msg_ind:
      c.set(other.c.get<concurrent_warning_msg_ind_e>());
      break;
    case types::warning_area_coordinates:
      c.set(other.c.get<bounded_octstring<1, 1024, true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "write_replace_warning_request_ies_o::value_c");
  }

  return *this;
}
fixed_bitstring<16, false, true>& write_replace_warning_request_ies_o::value_c::msg_id()
{
  assert_choice_type(types::msg_id, type_, "Value");
  return c.get<fixed_bitstring<16, false, true>>();
}
fixed_bitstring<16, false, true>& write_replace_warning_request_ies_o::value_c::serial_num()
{
  assert_choice_type(types::serial_num, type_, "Value");
  return c.get<fixed_bitstring<16, false, true>>();
}
warning_area_list_c& write_replace_warning_request_ies_o::value_c::warning_area_list()
{
  assert_choice_type(types::warning_area_list, type_, "Value");
  return c.get<warning_area_list_c>();
}
uint32_t& write_replace_warning_request_ies_o::value_c::repeat_period()
{
  assert_choice_type(types::repeat_period, type_, "Value");
  return c.get<uint32_t>();
}
uint32_t& write_replace_warning_request_ies_o::value_c::nof_broadcasts_requested()
{
  assert_choice_type(types::nof_broadcasts_requested, type_, "Value");
  return c.get<uint32_t>();
}
fixed_octstring<2, true>& write_replace_warning_request_ies_o::value_c::warning_type()
{
  assert_choice_type(types::warning_type, type_, "Value");
  return c.get<fixed_octstring<2, true>>();
}
fixed_octstring<50, true>& write_replace_warning_request_ies_o::value_c::warning_security_info()
{
  assert_choice_type(types::warning_security_info, type_, "Value");
  return c.get<fixed_octstring<50, true>>();
}
fixed_bitstring<8, false, true>& write_replace_warning_request_ies_o::value_c::data_coding_scheme()
{
  assert_choice_type(types::data_coding_scheme, type_, "Value");
  return c.get<fixed_bitstring<8, false, true>>();
}
bounded_octstring<1, 9600, true>& write_replace_warning_request_ies_o::value_c::warning_msg_contents()
{
  assert_choice_type(types::warning_msg_contents, type_, "Value");
  return c.get<bounded_octstring<1, 9600, true>>();
}
concurrent_warning_msg_ind_e& write_replace_warning_request_ies_o::value_c::concurrent_warning_msg_ind()
{
  assert_choice_type(types::concurrent_warning_msg_ind, type_, "Value");
  return c.get<concurrent_warning_msg_ind_e>();
}
bounded_octstring<1, 1024, true>& write_replace_warning_request_ies_o::value_c::warning_area_coordinates()
{
  assert_choice_type(types::warning_area_coordinates, type_, "Value");
  return c.get<bounded_octstring<1, 1024, true>>();
}
const fixed_bitstring<16, false, true>& write_replace_warning_request_ies_o::value_c::msg_id() const
{
  assert_choice_type(types::msg_id, type_, "Value");
  return c.get<fixed_bitstring<16, false, true>>();
}
const fixed_bitstring<16, false, true>& write_replace_warning_request_ies_o::value_c::serial_num() const
{
  assert_choice_type(types::serial_num, type_, "Value");
  return c.get<fixed_bitstring<16, false, true>>();
}
const warning_area_list_c& write_replace_warning_request_ies_o::value_c::warning_area_list() const
{
  assert_choice_type(types::warning_area_list, type_, "Value");
  return c.get<warning_area_list_c>();
}
const uint32_t& write_replace_warning_request_ies_o::value_c::repeat_period() const
{
  assert_choice_type(types::repeat_period, type_, "Value");
  return c.get<uint32_t>();
}
const uint32_t& write_replace_warning_request_ies_o::value_c::nof_broadcasts_requested() const
{
  assert_choice_type(types::nof_broadcasts_requested, type_, "Value");
  return c.get<uint32_t>();
}
const fixed_octstring<2, true>& write_replace_warning_request_ies_o::value_c::warning_type() const
{
  assert_choice_type(types::warning_type, type_, "Value");
  return c.get<fixed_octstring<2, true>>();
}
const fixed_octstring<50, true>& write_replace_warning_request_ies_o::value_c::warning_security_info() const
{
  assert_choice_type(types::warning_security_info, type_, "Value");
  return c.get<fixed_octstring<50, true>>();
}
const fixed_bitstring<8, false, true>& write_replace_warning_request_ies_o::value_c::data_coding_scheme() const
{
  assert_choice_type(types::data_coding_scheme, type_, "Value");
  return c.get<fixed_bitstring<8, false, true>>();
}
const bounded_octstring<1, 9600, true>& write_replace_warning_request_ies_o::value_c::warning_msg_contents() const
{
  assert_choice_type(types::warning_msg_contents, type_, "Value");
  return c.get<bounded_octstring<1, 9600, true>>();
}
const concurrent_warning_msg_ind_e& write_replace_warning_request_ies_o::value_c::concurrent_warning_msg_ind() const
{
  assert_choice_type(types::concurrent_warning_msg_ind, type_, "Value");
  return c.get<concurrent_warning_msg_ind_e>();
}
const bounded_octstring<1, 1024, true>& write_replace_warning_request_ies_o::value_c::warning_area_coordinates() const
{
  assert_choice_type(types::warning_area_coordinates, type_, "Value");
  return c.get<bounded_octstring<1, 1024, true>>();
}
void write_replace_warning_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::msg_id:
      j.write_str("BIT STRING", c.get<fixed_bitstring<16, false, true>>().to_string());
      break;
    case types::serial_num:
      j.write_str("BIT STRING", c.get<fixed_bitstring<16, false, true>>().to_string());
      break;
    case types::warning_area_list:
      j.write_fieldname("WarningAreaList");
      c.get<warning_area_list_c>().to_json(j);
      break;
    case types::repeat_period:
      j.write_int("INTEGER (0..131071)", c.get<uint32_t>());
      break;
    case types::nof_broadcasts_requested:
      j.write_int("INTEGER (0..65535)", c.get<uint32_t>());
      break;
    case types::warning_type:
      j.write_str("OCTET STRING", c.get<fixed_octstring<2, true>>().to_string());
      break;
    case types::warning_security_info:
      j.write_str("OCTET STRING", c.get<fixed_octstring<50, true>>().to_string());
      break;
    case types::data_coding_scheme:
      j.write_str("BIT STRING", c.get<fixed_bitstring<8, false, true>>().to_string());
      break;
    case types::warning_msg_contents:
      j.write_str("OCTET STRING", c.get<bounded_octstring<1, 9600, true>>().to_string());
      break;
    case types::concurrent_warning_msg_ind:
      j.write_str("ConcurrentWarningMessageInd", "true");
      break;
    case types::warning_area_coordinates:
      j.write_str("OCTET STRING", c.get<bounded_octstring<1, 1024, true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "write_replace_warning_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE write_replace_warning_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::msg_id:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true>>().pack(bref)));
      break;
    case types::serial_num:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true>>().pack(bref)));
      break;
    case types::warning_area_list:
      HANDLE_CODE(c.get<warning_area_list_c>().pack(bref));
      break;
    case types::repeat_period:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)131071u, false, true));
      break;
    case types::nof_broadcasts_requested:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)65535u, false, true));
      break;
    case types::warning_type:
      HANDLE_CODE((c.get<fixed_octstring<2, true>>().pack(bref)));
      break;
    case types::warning_security_info:
      HANDLE_CODE((c.get<fixed_octstring<50, true>>().pack(bref)));
      break;
    case types::data_coding_scheme:
      HANDLE_CODE((c.get<fixed_bitstring<8, false, true>>().pack(bref)));
      break;
    case types::warning_msg_contents:
      HANDLE_CODE((c.get<bounded_octstring<1, 9600, true>>().pack(bref)));
      break;
    case types::concurrent_warning_msg_ind:
      HANDLE_CODE(c.get<concurrent_warning_msg_ind_e>().pack(bref));
      break;
    case types::warning_area_coordinates:
      HANDLE_CODE((c.get<bounded_octstring<1, 1024, true>>().pack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "write_replace_warning_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE write_replace_warning_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::msg_id:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true>>().unpack(bref)));
      break;
    case types::serial_num:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true>>().unpack(bref)));
      break;
    case types::warning_area_list:
      HANDLE_CODE(c.get<warning_area_list_c>().unpack(bref));
      break;
    case types::repeat_period:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)131071u, false, true));
      break;
    case types::nof_broadcasts_requested:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)65535u, false, true));
      break;
    case types::warning_type:
      HANDLE_CODE((c.get<fixed_octstring<2, true>>().unpack(bref)));
      break;
    case types::warning_security_info:
      HANDLE_CODE((c.get<fixed_octstring<50, true>>().unpack(bref)));
      break;
    case types::data_coding_scheme:
      HANDLE_CODE((c.get<fixed_bitstring<8, false, true>>().unpack(bref)));
      break;
    case types::warning_msg_contents:
      HANDLE_CODE((c.get<bounded_octstring<1, 9600, true>>().unpack(bref)));
      break;
    case types::concurrent_warning_msg_ind:
      HANDLE_CODE(c.get<concurrent_warning_msg_ind_e>().unpack(bref));
      break;
    case types::warning_area_coordinates:
      HANDLE_CODE((c.get<bounded_octstring<1, 1024, true>>().unpack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "write_replace_warning_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* write_replace_warning_request_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"BIT STRING",
                                "BIT STRING",
                                "WarningAreaList",
                                "INTEGER (0..131071)",
                                "INTEGER (0..65535)",
                                "OCTET STRING",
                                "OCTET STRING",
                                "BIT STRING",
                                "OCTET STRING",
                                "ConcurrentWarningMessageInd",
                                "OCTET STRING"};
  return convert_enum_idx(names, 11, value, "write_replace_warning_request_ies_o::value_c::types");
}

// WriteReplaceWarningResponseIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t write_replace_warning_resp_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {35, 95, 13, 19};
  return map_enum_number(names, 4, idx, "id");
}
bool write_replace_warning_resp_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {35, 95, 13, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e write_replace_warning_resp_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 35:
      return crit_e::reject;
    case 95:
      return crit_e::reject;
    case 13:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
write_replace_warning_resp_ies_o::value_c write_replace_warning_resp_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 35:
      ret.set(value_c::types::msg_id);
      break;
    case 95:
      ret.set(value_c::types::serial_num);
      break;
    case 13:
      ret.set(value_c::types::broadcast_completed_area_list);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e write_replace_warning_resp_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 35:
      return presence_e::mandatory;
    case 95:
      return presence_e::mandatory;
    case 13:
      return presence_e::optional;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void write_replace_warning_resp_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::msg_id:
      c.destroy<fixed_bitstring<16, false, true>>();
      break;
    case types::serial_num:
      c.destroy<fixed_bitstring<16, false, true>>();
      break;
    case types::broadcast_completed_area_list:
      c.destroy<broadcast_completed_area_list_c>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void write_replace_warning_resp_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::msg_id:
      c.init<fixed_bitstring<16, false, true>>();
      break;
    case types::serial_num:
      c.init<fixed_bitstring<16, false, true>>();
      break;
    case types::broadcast_completed_area_list:
      c.init<broadcast_completed_area_list_c>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "write_replace_warning_resp_ies_o::value_c");
  }
}
write_replace_warning_resp_ies_o::value_c::value_c(const write_replace_warning_resp_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::msg_id:
      c.init(other.c.get<fixed_bitstring<16, false, true>>());
      break;
    case types::serial_num:
      c.init(other.c.get<fixed_bitstring<16, false, true>>());
      break;
    case types::broadcast_completed_area_list:
      c.init(other.c.get<broadcast_completed_area_list_c>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "write_replace_warning_resp_ies_o::value_c");
  }
}
write_replace_warning_resp_ies_o::value_c&
write_replace_warning_resp_ies_o::value_c::operator=(const write_replace_warning_resp_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::msg_id:
      c.set(other.c.get<fixed_bitstring<16, false, true>>());
      break;
    case types::serial_num:
      c.set(other.c.get<fixed_bitstring<16, false, true>>());
      break;
    case types::broadcast_completed_area_list:
      c.set(other.c.get<broadcast_completed_area_list_c>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "write_replace_warning_resp_ies_o::value_c");
  }

  return *this;
}
fixed_bitstring<16, false, true>& write_replace_warning_resp_ies_o::value_c::msg_id()
{
  assert_choice_type(types::msg_id, type_, "Value");
  return c.get<fixed_bitstring<16, false, true>>();
}
fixed_bitstring<16, false, true>& write_replace_warning_resp_ies_o::value_c::serial_num()
{
  assert_choice_type(types::serial_num, type_, "Value");
  return c.get<fixed_bitstring<16, false, true>>();
}
broadcast_completed_area_list_c& write_replace_warning_resp_ies_o::value_c::broadcast_completed_area_list()
{
  assert_choice_type(types::broadcast_completed_area_list, type_, "Value");
  return c.get<broadcast_completed_area_list_c>();
}
crit_diagnostics_s& write_replace_warning_resp_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const fixed_bitstring<16, false, true>& write_replace_warning_resp_ies_o::value_c::msg_id() const
{
  assert_choice_type(types::msg_id, type_, "Value");
  return c.get<fixed_bitstring<16, false, true>>();
}
const fixed_bitstring<16, false, true>& write_replace_warning_resp_ies_o::value_c::serial_num() const
{
  assert_choice_type(types::serial_num, type_, "Value");
  return c.get<fixed_bitstring<16, false, true>>();
}
const broadcast_completed_area_list_c& write_replace_warning_resp_ies_o::value_c::broadcast_completed_area_list() const
{
  assert_choice_type(types::broadcast_completed_area_list, type_, "Value");
  return c.get<broadcast_completed_area_list_c>();
}
const crit_diagnostics_s& write_replace_warning_resp_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void write_replace_warning_resp_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::msg_id:
      j.write_str("BIT STRING", c.get<fixed_bitstring<16, false, true>>().to_string());
      break;
    case types::serial_num:
      j.write_str("BIT STRING", c.get<fixed_bitstring<16, false, true>>().to_string());
      break;
    case types::broadcast_completed_area_list:
      j.write_fieldname("BroadcastCompletedAreaList");
      c.get<broadcast_completed_area_list_c>().to_json(j);
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "write_replace_warning_resp_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE write_replace_warning_resp_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::msg_id:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true>>().pack(bref)));
      break;
    case types::serial_num:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true>>().pack(bref)));
      break;
    case types::broadcast_completed_area_list:
      HANDLE_CODE(c.get<broadcast_completed_area_list_c>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "write_replace_warning_resp_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE write_replace_warning_resp_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::msg_id:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true>>().unpack(bref)));
      break;
    case types::serial_num:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true>>().unpack(bref)));
      break;
    case types::broadcast_completed_area_list:
      HANDLE_CODE(c.get<broadcast_completed_area_list_c>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "write_replace_warning_resp_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* write_replace_warning_resp_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"BIT STRING", "BIT STRING", "BroadcastCompletedAreaList", "CriticalityDiagnostics"};
  return convert_enum_idx(names, 4, value, "write_replace_warning_resp_ies_o::value_c::types");
}

template struct asn1::protocol_ie_field_s<location_report_ies_o>;

location_report_ies_container::location_report_ies_container() :
  amf_ue_ngap_id(10, crit_e::reject),
  ran_ue_ngap_id(85, crit_e::reject),
  user_location_info(121, crit_e::ignore),
  ue_presence_in_area_of_interest_list(116, crit_e::ignore),
  location_report_request_type(33, crit_e::ignore)
{
}
SRSASN_CODE location_report_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 4;
  nof_ies += ue_presence_in_area_of_interest_list_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  HANDLE_CODE(user_location_info.pack(bref));
  if (ue_presence_in_area_of_interest_list_present) {
    HANDLE_CODE(ue_presence_in_area_of_interest_list.pack(bref));
  }
  HANDLE_CODE(location_report_request_type.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE location_report_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 4;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 121: {
        nof_mandatory_ies--;
        user_location_info.id = id;
        HANDLE_CODE(user_location_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(user_location_info.value.unpack(bref));
        break;
      }
      case 116: {
        ue_presence_in_area_of_interest_list_present = true;
        ue_presence_in_area_of_interest_list.id      = id;
        HANDLE_CODE(ue_presence_in_area_of_interest_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_presence_in_area_of_interest_list.value.unpack(bref));
        break;
      }
      case 33: {
        nof_mandatory_ies--;
        location_report_request_type.id = id;
        HANDLE_CODE(location_report_request_type.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(location_report_request_type.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void location_report_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  user_location_info.to_json(j);
  if (ue_presence_in_area_of_interest_list_present) {
    j.write_fieldname("");
    ue_presence_in_area_of_interest_list.to_json(j);
  }
  j.write_fieldname("");
  location_report_request_type.to_json(j);
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<location_report_ctrl_ies_o>;

location_report_ctrl_ies_container::location_report_ctrl_ies_container() :
  amf_ue_ngap_id(10, crit_e::reject),
  ran_ue_ngap_id(85, crit_e::reject),
  location_report_request_type(33, crit_e::ignore)
{
}
SRSASN_CODE location_report_ctrl_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  HANDLE_CODE(location_report_request_type.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE location_report_ctrl_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 33: {
        nof_mandatory_ies--;
        location_report_request_type.id = id;
        HANDLE_CODE(location_report_request_type.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(location_report_request_type.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void location_report_ctrl_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  location_report_request_type.to_json(j);
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<location_report_fail_ind_ies_o>;

location_report_fail_ind_ies_container::location_report_fail_ind_ies_container() :
  amf_ue_ngap_id(10, crit_e::reject), ran_ue_ngap_id(85, crit_e::reject), cause(15, crit_e::ignore)
{
}
SRSASN_CODE location_report_fail_ind_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  HANDLE_CODE(cause.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE location_report_fail_ind_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 15: {
        nof_mandatory_ies--;
        cause.id = id;
        HANDLE_CODE(cause.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void location_report_fail_ind_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  cause.to_json(j);
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<multicast_group_paging_ies_o>;

multicast_group_paging_ies_container::multicast_group_paging_ies_container() :
  mbs_session_id(299, crit_e::ignore),
  mbs_service_area(298, crit_e::ignore),
  multicast_group_paging_area_list(307, crit_e::ignore)
{
}
SRSASN_CODE multicast_group_paging_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += mbs_service_area_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mbs_session_id.pack(bref));
  if (mbs_service_area_present) {
    HANDLE_CODE(mbs_service_area.pack(bref));
  }
  HANDLE_CODE(multicast_group_paging_area_list.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_group_paging_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        mbs_session_id.id = id;
        HANDLE_CODE(mbs_session_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.value.unpack(bref));
        break;
      }
      case 298: {
        mbs_service_area_present = true;
        mbs_service_area.id      = id;
        HANDLE_CODE(mbs_service_area.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_service_area.value.unpack(bref));
        break;
      }
      case 307: {
        nof_mandatory_ies--;
        multicast_group_paging_area_list.id = id;
        HANDLE_CODE(multicast_group_paging_area_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(multicast_group_paging_area_list.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void multicast_group_paging_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mbs_session_id.to_json(j);
  if (mbs_service_area_present) {
    j.write_fieldname("");
    mbs_service_area.to_json(j);
  }
  j.write_fieldname("");
  multicast_group_paging_area_list.to_json(j);
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<multicast_session_activation_fail_ies_o>;

multicast_session_activation_fail_ies_container::multicast_session_activation_fail_ies_container() :
  mbs_session_id(299, crit_e::reject), cause(15, crit_e::ignore), crit_diagnostics(19, crit_e::ignore)
{
}
SRSASN_CODE multicast_session_activation_fail_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mbs_session_id.pack(bref));
  HANDLE_CODE(cause.pack(bref));
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_session_activation_fail_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        mbs_session_id.id = id;
        HANDLE_CODE(mbs_session_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.value.unpack(bref));
        break;
      }
      case 15: {
        nof_mandatory_ies--;
        cause.id = id;
        HANDLE_CODE(cause.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.value.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        crit_diagnostics.id      = id;
        HANDLE_CODE(crit_diagnostics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void multicast_session_activation_fail_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mbs_session_id.to_json(j);
  j.write_fieldname("");
  cause.to_json(j);
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<multicast_session_activation_request_ies_o>;

multicast_session_activation_request_ies_container::multicast_session_activation_request_ies_container() :
  mbs_session_id(299, crit_e::reject), multicast_session_activation_request_transfer(304, crit_e::reject)
{
}
SRSASN_CODE multicast_session_activation_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mbs_session_id.pack(bref));
  HANDLE_CODE(multicast_session_activation_request_transfer.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_session_activation_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        mbs_session_id.id = id;
        HANDLE_CODE(mbs_session_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.value.unpack(bref));
        break;
      }
      case 304: {
        nof_mandatory_ies--;
        multicast_session_activation_request_transfer.id = id;
        HANDLE_CODE(multicast_session_activation_request_transfer.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(multicast_session_activation_request_transfer.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void multicast_session_activation_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mbs_session_id.to_json(j);
  j.write_fieldname("");
  multicast_session_activation_request_transfer.to_json(j);
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<multicast_session_activation_resp_ies_o>;

multicast_session_activation_resp_ies_container::multicast_session_activation_resp_ies_container() :
  mbs_session_id(299, crit_e::reject), crit_diagnostics(19, crit_e::ignore)
{
}
SRSASN_CODE multicast_session_activation_resp_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 1;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mbs_session_id.pack(bref));
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_session_activation_resp_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 1;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        mbs_session_id.id = id;
        HANDLE_CODE(mbs_session_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.value.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        crit_diagnostics.id      = id;
        HANDLE_CODE(crit_diagnostics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void multicast_session_activation_resp_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mbs_session_id.to_json(j);
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<multicast_session_deactivation_request_ies_o>;

multicast_session_deactivation_request_ies_container::multicast_session_deactivation_request_ies_container() :
  mbs_session_id(299, crit_e::reject), multicast_session_deactivation_request_transfer(305, crit_e::reject)
{
}
SRSASN_CODE multicast_session_deactivation_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mbs_session_id.pack(bref));
  HANDLE_CODE(multicast_session_deactivation_request_transfer.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_session_deactivation_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        mbs_session_id.id = id;
        HANDLE_CODE(mbs_session_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.value.unpack(bref));
        break;
      }
      case 305: {
        nof_mandatory_ies--;
        multicast_session_deactivation_request_transfer.id = id;
        HANDLE_CODE(multicast_session_deactivation_request_transfer.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(multicast_session_deactivation_request_transfer.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void multicast_session_deactivation_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mbs_session_id.to_json(j);
  j.write_fieldname("");
  multicast_session_deactivation_request_transfer.to_json(j);
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<multicast_session_deactivation_resp_ies_o>;

multicast_session_deactivation_resp_ies_container::multicast_session_deactivation_resp_ies_container() :
  mbs_session_id(299, crit_e::reject), crit_diagnostics(19, crit_e::ignore)
{
}
SRSASN_CODE multicast_session_deactivation_resp_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 1;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mbs_session_id.pack(bref));
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_session_deactivation_resp_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 1;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        mbs_session_id.id = id;
        HANDLE_CODE(mbs_session_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.value.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        crit_diagnostics.id      = id;
        HANDLE_CODE(crit_diagnostics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void multicast_session_deactivation_resp_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mbs_session_id.to_json(j);
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<multicast_session_upd_fail_ies_o>;

multicast_session_upd_fail_ies_container::multicast_session_upd_fail_ies_container() :
  mbs_session_id(299, crit_e::reject),
  mbs_area_session_id(295, crit_e::reject),
  cause(15, crit_e::ignore),
  crit_diagnostics(19, crit_e::ignore)
{
}
SRSASN_CODE multicast_session_upd_fail_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += mbs_area_session_id_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mbs_session_id.pack(bref));
  if (mbs_area_session_id_present) {
    HANDLE_CODE(mbs_area_session_id.pack(bref));
  }
  HANDLE_CODE(cause.pack(bref));
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_session_upd_fail_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        mbs_session_id.id = id;
        HANDLE_CODE(mbs_session_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.value.unpack(bref));
        break;
      }
      case 295: {
        mbs_area_session_id_present = true;
        mbs_area_session_id.id      = id;
        HANDLE_CODE(mbs_area_session_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_area_session_id.value.unpack(bref));
        break;
      }
      case 15: {
        nof_mandatory_ies--;
        cause.id = id;
        HANDLE_CODE(cause.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.value.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        crit_diagnostics.id      = id;
        HANDLE_CODE(crit_diagnostics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void multicast_session_upd_fail_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mbs_session_id.to_json(j);
  if (mbs_area_session_id_present) {
    j.write_fieldname("");
    mbs_area_session_id.to_json(j);
  }
  j.write_fieldname("");
  cause.to_json(j);
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<multicast_session_upd_request_ies_o>;

multicast_session_upd_request_ies_container::multicast_session_upd_request_ies_container() :
  mbs_session_id(299, crit_e::reject),
  mbs_area_session_id(295, crit_e::reject),
  multicast_session_upd_request_transfer(306, crit_e::reject)
{
}
SRSASN_CODE multicast_session_upd_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += mbs_area_session_id_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mbs_session_id.pack(bref));
  if (mbs_area_session_id_present) {
    HANDLE_CODE(mbs_area_session_id.pack(bref));
  }
  HANDLE_CODE(multicast_session_upd_request_transfer.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_session_upd_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        mbs_session_id.id = id;
        HANDLE_CODE(mbs_session_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.value.unpack(bref));
        break;
      }
      case 295: {
        mbs_area_session_id_present = true;
        mbs_area_session_id.id      = id;
        HANDLE_CODE(mbs_area_session_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_area_session_id.value.unpack(bref));
        break;
      }
      case 306: {
        nof_mandatory_ies--;
        multicast_session_upd_request_transfer.id = id;
        HANDLE_CODE(multicast_session_upd_request_transfer.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(multicast_session_upd_request_transfer.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void multicast_session_upd_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mbs_session_id.to_json(j);
  if (mbs_area_session_id_present) {
    j.write_fieldname("");
    mbs_area_session_id.to_json(j);
  }
  j.write_fieldname("");
  multicast_session_upd_request_transfer.to_json(j);
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<multicast_session_upd_resp_ies_o>;

multicast_session_upd_resp_ies_container::multicast_session_upd_resp_ies_container() :
  mbs_session_id(299, crit_e::reject), mbs_area_session_id(295, crit_e::reject), crit_diagnostics(19, crit_e::ignore)
{
}
SRSASN_CODE multicast_session_upd_resp_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 1;
  nof_ies += mbs_area_session_id_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mbs_session_id.pack(bref));
  if (mbs_area_session_id_present) {
    HANDLE_CODE(mbs_area_session_id.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_session_upd_resp_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 1;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        mbs_session_id.id = id;
        HANDLE_CODE(mbs_session_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.value.unpack(bref));
        break;
      }
      case 295: {
        mbs_area_session_id_present = true;
        mbs_area_session_id.id      = id;
        HANDLE_CODE(mbs_area_session_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_area_session_id.value.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        crit_diagnostics.id      = id;
        HANDLE_CODE(crit_diagnostics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void multicast_session_upd_resp_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mbs_session_id.to_json(j);
  if (mbs_area_session_id_present) {
    j.write_fieldname("");
    mbs_area_session_id.to_json(j);
  }
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<nas_non_delivery_ind_ies_o>;

nas_non_delivery_ind_ies_container::nas_non_delivery_ind_ies_container() :
  amf_ue_ngap_id(10, crit_e::reject),
  ran_ue_ngap_id(85, crit_e::reject),
  nas_pdu(38, crit_e::ignore),
  cause(15, crit_e::ignore)
{
}
SRSASN_CODE nas_non_delivery_ind_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 4;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  HANDLE_CODE(nas_pdu.pack(bref));
  HANDLE_CODE(cause.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE nas_non_delivery_ind_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 4;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 38: {
        nof_mandatory_ies--;
        nas_pdu.id = id;
        HANDLE_CODE(nas_pdu.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nas_pdu.value.unpack(bref));
        break;
      }
      case 15: {
        nof_mandatory_ies--;
        cause.id = id;
        HANDLE_CODE(cause.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void nas_non_delivery_ind_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  nas_pdu.to_json(j);
  j.write_fieldname("");
  cause.to_json(j);
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<ng_reset_ies_o>;

ng_reset_ies_container::ng_reset_ies_container() : cause(15, crit_e::ignore), reset_type(88, crit_e::reject) {}
SRSASN_CODE ng_reset_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(cause.pack(bref));
  HANDLE_CODE(reset_type.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE ng_reset_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 15: {
        nof_mandatory_ies--;
        cause.id = id;
        HANDLE_CODE(cause.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.value.unpack(bref));
        break;
      }
      case 88: {
        nof_mandatory_ies--;
        reset_type.id = id;
        HANDLE_CODE(reset_type.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(reset_type.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ng_reset_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  cause.to_json(j);
  j.write_fieldname("");
  reset_type.to_json(j);
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<ng_reset_ack_ies_o>;

ng_reset_ack_ies_container::ng_reset_ack_ies_container() :
  ue_associated_lc_ng_conn_list(111, crit_e::ignore), crit_diagnostics(19, crit_e::ignore)
{
}
SRSASN_CODE ng_reset_ack_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += ue_associated_lc_ng_conn_list_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  if (ue_associated_lc_ng_conn_list_present) {
    HANDLE_CODE(ue_associated_lc_ng_conn_list.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ng_reset_ack_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 111: {
        ue_associated_lc_ng_conn_list_present = true;
        ue_associated_lc_ng_conn_list.id      = id;
        HANDLE_CODE(ue_associated_lc_ng_conn_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_associated_lc_ng_conn_list.value.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        crit_diagnostics.id      = id;
        HANDLE_CODE(crit_diagnostics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void ng_reset_ack_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (ue_associated_lc_ng_conn_list_present) {
    j.write_fieldname("");
    ue_associated_lc_ng_conn_list.to_json(j);
  }
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<ng_setup_fail_ies_o>;

ng_setup_fail_ies_container::ng_setup_fail_ies_container() :
  cause(15, crit_e::ignore), time_to_wait(107, crit_e::ignore), crit_diagnostics(19, crit_e::ignore)
{
}
SRSASN_CODE ng_setup_fail_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 1;
  nof_ies += time_to_wait_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(cause.pack(bref));
  if (time_to_wait_present) {
    HANDLE_CODE(time_to_wait.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ng_setup_fail_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 1;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 15: {
        nof_mandatory_ies--;
        cause.id = id;
        HANDLE_CODE(cause.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.value.unpack(bref));
        break;
      }
      case 107: {
        time_to_wait_present = true;
        time_to_wait.id      = id;
        HANDLE_CODE(time_to_wait.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(time_to_wait.value.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        crit_diagnostics.id      = id;
        HANDLE_CODE(crit_diagnostics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ng_setup_fail_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  cause.to_json(j);
  if (time_to_wait_present) {
    j.write_fieldname("");
    time_to_wait.to_json(j);
  }
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<ng_setup_request_ies_o>;

ng_setup_request_ies_container::ng_setup_request_ies_container() :
  global_ran_node_id(27, crit_e::reject),
  ran_node_name(82, crit_e::ignore),
  supported_ta_list(102, crit_e::reject),
  default_paging_drx(21, crit_e::ignore),
  ue_retention_info(147, crit_e::ignore),
  nb_iot_default_paging_drx(204, crit_e::ignore),
  extended_ran_node_name(273, crit_e::ignore)
{
}
SRSASN_CODE ng_setup_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += ran_node_name_present ? 1 : 0;
  nof_ies += ue_retention_info_present ? 1 : 0;
  nof_ies += nb_iot_default_paging_drx_present ? 1 : 0;
  nof_ies += extended_ran_node_name_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(global_ran_node_id.pack(bref));
  if (ran_node_name_present) {
    HANDLE_CODE(ran_node_name.pack(bref));
  }
  HANDLE_CODE(supported_ta_list.pack(bref));
  HANDLE_CODE(default_paging_drx.pack(bref));
  if (ue_retention_info_present) {
    HANDLE_CODE(ue_retention_info.pack(bref));
  }
  if (nb_iot_default_paging_drx_present) {
    HANDLE_CODE(nb_iot_default_paging_drx.pack(bref));
  }
  if (extended_ran_node_name_present) {
    HANDLE_CODE(extended_ran_node_name.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ng_setup_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 27: {
        nof_mandatory_ies--;
        global_ran_node_id.id = id;
        HANDLE_CODE(global_ran_node_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(global_ran_node_id.value.unpack(bref));
        break;
      }
      case 82: {
        ran_node_name_present = true;
        ran_node_name.id      = id;
        HANDLE_CODE(ran_node_name.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_node_name.value.unpack(bref));
        break;
      }
      case 102: {
        nof_mandatory_ies--;
        supported_ta_list.id = id;
        HANDLE_CODE(supported_ta_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(supported_ta_list.value.unpack(bref));
        break;
      }
      case 21: {
        nof_mandatory_ies--;
        default_paging_drx.id = id;
        HANDLE_CODE(default_paging_drx.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(default_paging_drx.value.unpack(bref));
        break;
      }
      case 147: {
        ue_retention_info_present = true;
        ue_retention_info.id      = id;
        HANDLE_CODE(ue_retention_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_retention_info.value.unpack(bref));
        break;
      }
      case 204: {
        nb_iot_default_paging_drx_present = true;
        nb_iot_default_paging_drx.id      = id;
        HANDLE_CODE(nb_iot_default_paging_drx.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nb_iot_default_paging_drx.value.unpack(bref));
        break;
      }
      case 273: {
        extended_ran_node_name_present = true;
        extended_ran_node_name.id      = id;
        HANDLE_CODE(extended_ran_node_name.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(extended_ran_node_name.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ng_setup_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  global_ran_node_id.to_json(j);
  if (ran_node_name_present) {
    j.write_fieldname("");
    ran_node_name.to_json(j);
  }
  j.write_fieldname("");
  supported_ta_list.to_json(j);
  j.write_fieldname("");
  default_paging_drx.to_json(j);
  if (ue_retention_info_present) {
    j.write_fieldname("");
    ue_retention_info.to_json(j);
  }
  if (nb_iot_default_paging_drx_present) {
    j.write_fieldname("");
    nb_iot_default_paging_drx.to_json(j);
  }
  if (extended_ran_node_name_present) {
    j.write_fieldname("");
    extended_ran_node_name.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<ng_setup_resp_ies_o>;

ng_setup_resp_ies_container::ng_setup_resp_ies_container() :
  amf_name(1, crit_e::reject),
  served_guami_list(96, crit_e::reject),
  relative_amf_capacity(86, crit_e::ignore),
  plmn_support_list(80, crit_e::reject),
  crit_diagnostics(19, crit_e::ignore),
  ue_retention_info(147, crit_e::ignore),
  iab_supported(200, crit_e::ignore),
  extended_amf_name(274, crit_e::ignore)
{
}
SRSASN_CODE ng_setup_resp_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 4;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  nof_ies += ue_retention_info_present ? 1 : 0;
  nof_ies += iab_supported_present ? 1 : 0;
  nof_ies += extended_amf_name_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_name.pack(bref));
  HANDLE_CODE(served_guami_list.pack(bref));
  HANDLE_CODE(relative_amf_capacity.pack(bref));
  HANDLE_CODE(plmn_support_list.pack(bref));
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }
  if (ue_retention_info_present) {
    HANDLE_CODE(ue_retention_info.pack(bref));
  }
  if (iab_supported_present) {
    HANDLE_CODE(iab_supported.pack(bref));
  }
  if (extended_amf_name_present) {
    HANDLE_CODE(extended_amf_name.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ng_setup_resp_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 4;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 1: {
        nof_mandatory_ies--;
        amf_name.id = id;
        HANDLE_CODE(amf_name.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_name.value.unpack(bref));
        break;
      }
      case 96: {
        nof_mandatory_ies--;
        served_guami_list.id = id;
        HANDLE_CODE(served_guami_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(served_guami_list.value.unpack(bref));
        break;
      }
      case 86: {
        nof_mandatory_ies--;
        relative_amf_capacity.id = id;
        HANDLE_CODE(relative_amf_capacity.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(relative_amf_capacity.value.unpack(bref));
        break;
      }
      case 80: {
        nof_mandatory_ies--;
        plmn_support_list.id = id;
        HANDLE_CODE(plmn_support_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(plmn_support_list.value.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        crit_diagnostics.id      = id;
        HANDLE_CODE(crit_diagnostics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.value.unpack(bref));
        break;
      }
      case 147: {
        ue_retention_info_present = true;
        ue_retention_info.id      = id;
        HANDLE_CODE(ue_retention_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_retention_info.value.unpack(bref));
        break;
      }
      case 200: {
        iab_supported_present = true;
        iab_supported.id      = id;
        HANDLE_CODE(iab_supported.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(iab_supported.value.unpack(bref));
        break;
      }
      case 274: {
        extended_amf_name_present = true;
        extended_amf_name.id      = id;
        HANDLE_CODE(extended_amf_name.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(extended_amf_name.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ng_setup_resp_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_name.to_json(j);
  j.write_fieldname("");
  served_guami_list.to_json(j);
  j.write_fieldname("");
  relative_amf_capacity.to_json(j);
  j.write_fieldname("");
  plmn_support_list.to_json(j);
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  if (ue_retention_info_present) {
    j.write_fieldname("");
    ue_retention_info.to_json(j);
  }
  if (iab_supported_present) {
    j.write_fieldname("");
    iab_supported.to_json(j);
  }
  if (extended_amf_name_present) {
    j.write_fieldname("");
    extended_amf_name.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<overload_start_ies_o>;

overload_start_ies_container::overload_start_ies_container() :
  amf_overload_resp(2, crit_e::reject),
  amf_traffic_load_reduction_ind(9, crit_e::ignore),
  overload_start_nssai_list(49, crit_e::ignore)
{
}
SRSASN_CODE overload_start_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += amf_overload_resp_present ? 1 : 0;
  nof_ies += amf_traffic_load_reduction_ind_present ? 1 : 0;
  nof_ies += overload_start_nssai_list_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  if (amf_overload_resp_present) {
    HANDLE_CODE(amf_overload_resp.pack(bref));
  }
  if (amf_traffic_load_reduction_ind_present) {
    HANDLE_CODE(amf_traffic_load_reduction_ind.pack(bref));
  }
  if (overload_start_nssai_list_present) {
    HANDLE_CODE(overload_start_nssai_list.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE overload_start_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 2: {
        amf_overload_resp_present = true;
        amf_overload_resp.id      = id;
        HANDLE_CODE(amf_overload_resp.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_overload_resp.value.unpack(bref));
        break;
      }
      case 9: {
        amf_traffic_load_reduction_ind_present = true;
        amf_traffic_load_reduction_ind.id      = id;
        HANDLE_CODE(amf_traffic_load_reduction_ind.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_traffic_load_reduction_ind.value.unpack(bref));
        break;
      }
      case 49: {
        overload_start_nssai_list_present = true;
        overload_start_nssai_list.id      = id;
        HANDLE_CODE(overload_start_nssai_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(overload_start_nssai_list.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void overload_start_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (amf_overload_resp_present) {
    j.write_fieldname("");
    amf_overload_resp.to_json(j);
  }
  if (amf_traffic_load_reduction_ind_present) {
    j.write_fieldname("");
    amf_traffic_load_reduction_ind.to_json(j);
  }
  if (overload_start_nssai_list_present) {
    j.write_fieldname("");
    overload_start_nssai_list.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<pdu_session_res_modify_confirm_ies_o>;

pdu_session_res_modify_confirm_ies_container::pdu_session_res_modify_confirm_ies_container() :
  amf_ue_ngap_id(10, crit_e::ignore),
  ran_ue_ngap_id(85, crit_e::ignore),
  pdu_session_res_modify_list_mod_cfm(62, crit_e::ignore),
  pdu_session_res_failed_to_modify_list_mod_cfm(131, crit_e::ignore),
  crit_diagnostics(19, crit_e::ignore)
{
}
SRSASN_CODE pdu_session_res_modify_confirm_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += pdu_session_res_modify_list_mod_cfm_present ? 1 : 0;
  nof_ies += pdu_session_res_failed_to_modify_list_mod_cfm_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  if (pdu_session_res_modify_list_mod_cfm_present) {
    HANDLE_CODE(pdu_session_res_modify_list_mod_cfm.pack(bref));
  }
  if (pdu_session_res_failed_to_modify_list_mod_cfm_present) {
    HANDLE_CODE(pdu_session_res_failed_to_modify_list_mod_cfm.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_modify_confirm_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 62: {
        pdu_session_res_modify_list_mod_cfm_present = true;
        pdu_session_res_modify_list_mod_cfm.id      = id;
        HANDLE_CODE(pdu_session_res_modify_list_mod_cfm.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pdu_session_res_modify_list_mod_cfm.value.unpack(bref));
        break;
      }
      case 131: {
        pdu_session_res_failed_to_modify_list_mod_cfm_present = true;
        pdu_session_res_failed_to_modify_list_mod_cfm.id      = id;
        HANDLE_CODE(pdu_session_res_failed_to_modify_list_mod_cfm.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pdu_session_res_failed_to_modify_list_mod_cfm.value.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        crit_diagnostics.id      = id;
        HANDLE_CODE(crit_diagnostics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void pdu_session_res_modify_confirm_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  if (pdu_session_res_modify_list_mod_cfm_present) {
    j.write_fieldname("");
    pdu_session_res_modify_list_mod_cfm.to_json(j);
  }
  if (pdu_session_res_failed_to_modify_list_mod_cfm_present) {
    j.write_fieldname("");
    pdu_session_res_failed_to_modify_list_mod_cfm.to_json(j);
  }
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<pdu_session_res_modify_ind_ies_o>;

pdu_session_res_modify_ind_ies_container::pdu_session_res_modify_ind_ies_container() :
  amf_ue_ngap_id(10, crit_e::reject),
  ran_ue_ngap_id(85, crit_e::reject),
  pdu_session_res_modify_list_mod_ind(63, crit_e::reject),
  user_location_info(121, crit_e::ignore)
{
}
SRSASN_CODE pdu_session_res_modify_ind_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += user_location_info_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  HANDLE_CODE(pdu_session_res_modify_list_mod_ind.pack(bref));
  if (user_location_info_present) {
    HANDLE_CODE(user_location_info.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_modify_ind_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 63: {
        nof_mandatory_ies--;
        pdu_session_res_modify_list_mod_ind.id = id;
        HANDLE_CODE(pdu_session_res_modify_list_mod_ind.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pdu_session_res_modify_list_mod_ind.value.unpack(bref));
        break;
      }
      case 121: {
        user_location_info_present = true;
        user_location_info.id      = id;
        HANDLE_CODE(user_location_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(user_location_info.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void pdu_session_res_modify_ind_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  pdu_session_res_modify_list_mod_ind.to_json(j);
  if (user_location_info_present) {
    j.write_fieldname("");
    user_location_info.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<pdu_session_res_modify_request_ies_o>;

pdu_session_res_modify_request_ies_container::pdu_session_res_modify_request_ies_container() :
  amf_ue_ngap_id(10, crit_e::reject),
  ran_ue_ngap_id(85, crit_e::reject),
  ran_paging_prio(83, crit_e::ignore),
  pdu_session_res_modify_list_mod_req(64, crit_e::reject)
{
}
SRSASN_CODE pdu_session_res_modify_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += ran_paging_prio_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  if (ran_paging_prio_present) {
    HANDLE_CODE(ran_paging_prio.pack(bref));
  }
  HANDLE_CODE(pdu_session_res_modify_list_mod_req.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_modify_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 83: {
        ran_paging_prio_present = true;
        ran_paging_prio.id      = id;
        HANDLE_CODE(ran_paging_prio.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_paging_prio.value.unpack(bref));
        break;
      }
      case 64: {
        nof_mandatory_ies--;
        pdu_session_res_modify_list_mod_req.id = id;
        HANDLE_CODE(pdu_session_res_modify_list_mod_req.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pdu_session_res_modify_list_mod_req.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void pdu_session_res_modify_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  if (ran_paging_prio_present) {
    j.write_fieldname("");
    ran_paging_prio.to_json(j);
  }
  j.write_fieldname("");
  pdu_session_res_modify_list_mod_req.to_json(j);
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<pdu_session_res_modify_resp_ies_o>;

pdu_session_res_modify_resp_ies_container::pdu_session_res_modify_resp_ies_container() :
  amf_ue_ngap_id(10, crit_e::ignore),
  ran_ue_ngap_id(85, crit_e::ignore),
  pdu_session_res_modify_list_mod_res(65, crit_e::ignore),
  pdu_session_res_failed_to_modify_list_mod_res(54, crit_e::ignore),
  user_location_info(121, crit_e::ignore),
  crit_diagnostics(19, crit_e::ignore)
{
}
SRSASN_CODE pdu_session_res_modify_resp_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += pdu_session_res_modify_list_mod_res_present ? 1 : 0;
  nof_ies += pdu_session_res_failed_to_modify_list_mod_res_present ? 1 : 0;
  nof_ies += user_location_info_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  if (pdu_session_res_modify_list_mod_res_present) {
    HANDLE_CODE(pdu_session_res_modify_list_mod_res.pack(bref));
  }
  if (pdu_session_res_failed_to_modify_list_mod_res_present) {
    HANDLE_CODE(pdu_session_res_failed_to_modify_list_mod_res.pack(bref));
  }
  if (user_location_info_present) {
    HANDLE_CODE(user_location_info.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_modify_resp_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 65: {
        pdu_session_res_modify_list_mod_res_present = true;
        pdu_session_res_modify_list_mod_res.id      = id;
        HANDLE_CODE(pdu_session_res_modify_list_mod_res.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pdu_session_res_modify_list_mod_res.value.unpack(bref));
        break;
      }
      case 54: {
        pdu_session_res_failed_to_modify_list_mod_res_present = true;
        pdu_session_res_failed_to_modify_list_mod_res.id      = id;
        HANDLE_CODE(pdu_session_res_failed_to_modify_list_mod_res.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pdu_session_res_failed_to_modify_list_mod_res.value.unpack(bref));
        break;
      }
      case 121: {
        user_location_info_present = true;
        user_location_info.id      = id;
        HANDLE_CODE(user_location_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(user_location_info.value.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        crit_diagnostics.id      = id;
        HANDLE_CODE(crit_diagnostics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void pdu_session_res_modify_resp_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  if (pdu_session_res_modify_list_mod_res_present) {
    j.write_fieldname("");
    pdu_session_res_modify_list_mod_res.to_json(j);
  }
  if (pdu_session_res_failed_to_modify_list_mod_res_present) {
    j.write_fieldname("");
    pdu_session_res_failed_to_modify_list_mod_res.to_json(j);
  }
  if (user_location_info_present) {
    j.write_fieldname("");
    user_location_info.to_json(j);
  }
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<pdu_session_res_notify_ies_o>;

pdu_session_res_notify_ies_container::pdu_session_res_notify_ies_container() :
  amf_ue_ngap_id(10, crit_e::reject),
  ran_ue_ngap_id(85, crit_e::reject),
  pdu_session_res_notify_list(66, crit_e::reject),
  pdu_session_res_released_list_not(67, crit_e::ignore),
  user_location_info(121, crit_e::ignore)
{
}
SRSASN_CODE pdu_session_res_notify_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += pdu_session_res_notify_list_present ? 1 : 0;
  nof_ies += pdu_session_res_released_list_not_present ? 1 : 0;
  nof_ies += user_location_info_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  if (pdu_session_res_notify_list_present) {
    HANDLE_CODE(pdu_session_res_notify_list.pack(bref));
  }
  if (pdu_session_res_released_list_not_present) {
    HANDLE_CODE(pdu_session_res_released_list_not.pack(bref));
  }
  if (user_location_info_present) {
    HANDLE_CODE(user_location_info.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_notify_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 66: {
        pdu_session_res_notify_list_present = true;
        pdu_session_res_notify_list.id      = id;
        HANDLE_CODE(pdu_session_res_notify_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pdu_session_res_notify_list.value.unpack(bref));
        break;
      }
      case 67: {
        pdu_session_res_released_list_not_present = true;
        pdu_session_res_released_list_not.id      = id;
        HANDLE_CODE(pdu_session_res_released_list_not.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pdu_session_res_released_list_not.value.unpack(bref));
        break;
      }
      case 121: {
        user_location_info_present = true;
        user_location_info.id      = id;
        HANDLE_CODE(user_location_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(user_location_info.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void pdu_session_res_notify_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  if (pdu_session_res_notify_list_present) {
    j.write_fieldname("");
    pdu_session_res_notify_list.to_json(j);
  }
  if (pdu_session_res_released_list_not_present) {
    j.write_fieldname("");
    pdu_session_res_released_list_not.to_json(j);
  }
  if (user_location_info_present) {
    j.write_fieldname("");
    user_location_info.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<pdu_session_res_release_cmd_ies_o>;

pdu_session_res_release_cmd_ies_container::pdu_session_res_release_cmd_ies_container() :
  amf_ue_ngap_id(10, crit_e::reject),
  ran_ue_ngap_id(85, crit_e::reject),
  ran_paging_prio(83, crit_e::ignore),
  nas_pdu(38, crit_e::ignore),
  pdu_session_res_to_release_list_rel_cmd(79, crit_e::reject)
{
}
SRSASN_CODE pdu_session_res_release_cmd_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += ran_paging_prio_present ? 1 : 0;
  nof_ies += nas_pdu_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  if (ran_paging_prio_present) {
    HANDLE_CODE(ran_paging_prio.pack(bref));
  }
  if (nas_pdu_present) {
    HANDLE_CODE(nas_pdu.pack(bref));
  }
  HANDLE_CODE(pdu_session_res_to_release_list_rel_cmd.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_release_cmd_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 83: {
        ran_paging_prio_present = true;
        ran_paging_prio.id      = id;
        HANDLE_CODE(ran_paging_prio.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_paging_prio.value.unpack(bref));
        break;
      }
      case 38: {
        nas_pdu_present = true;
        nas_pdu.id      = id;
        HANDLE_CODE(nas_pdu.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nas_pdu.value.unpack(bref));
        break;
      }
      case 79: {
        nof_mandatory_ies--;
        pdu_session_res_to_release_list_rel_cmd.id = id;
        HANDLE_CODE(pdu_session_res_to_release_list_rel_cmd.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pdu_session_res_to_release_list_rel_cmd.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void pdu_session_res_release_cmd_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  if (ran_paging_prio_present) {
    j.write_fieldname("");
    ran_paging_prio.to_json(j);
  }
  if (nas_pdu_present) {
    j.write_fieldname("");
    nas_pdu.to_json(j);
  }
  j.write_fieldname("");
  pdu_session_res_to_release_list_rel_cmd.to_json(j);
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<pdu_session_res_release_resp_ies_o>;

pdu_session_res_release_resp_ies_container::pdu_session_res_release_resp_ies_container() :
  amf_ue_ngap_id(10, crit_e::ignore),
  ran_ue_ngap_id(85, crit_e::ignore),
  pdu_session_res_released_list_rel_res(70, crit_e::ignore),
  user_location_info(121, crit_e::ignore),
  crit_diagnostics(19, crit_e::ignore)
{
}
SRSASN_CODE pdu_session_res_release_resp_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += user_location_info_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  HANDLE_CODE(pdu_session_res_released_list_rel_res.pack(bref));
  if (user_location_info_present) {
    HANDLE_CODE(user_location_info.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_release_resp_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 70: {
        nof_mandatory_ies--;
        pdu_session_res_released_list_rel_res.id = id;
        HANDLE_CODE(pdu_session_res_released_list_rel_res.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pdu_session_res_released_list_rel_res.value.unpack(bref));
        break;
      }
      case 121: {
        user_location_info_present = true;
        user_location_info.id      = id;
        HANDLE_CODE(user_location_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(user_location_info.value.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        crit_diagnostics.id      = id;
        HANDLE_CODE(crit_diagnostics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void pdu_session_res_release_resp_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  pdu_session_res_released_list_rel_res.to_json(j);
  if (user_location_info_present) {
    j.write_fieldname("");
    user_location_info.to_json(j);
  }
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<pdu_session_res_setup_request_ies_o>;

pdu_session_res_setup_request_ies_container::pdu_session_res_setup_request_ies_container() :
  amf_ue_ngap_id(10, crit_e::reject),
  ran_ue_ngap_id(85, crit_e::reject),
  ran_paging_prio(83, crit_e::ignore),
  nas_pdu(38, crit_e::reject),
  pdu_session_res_setup_list_su_req(74, crit_e::reject),
  ue_aggr_max_bit_rate(110, crit_e::ignore),
  ue_slice_max_bit_rate_list(335, crit_e::ignore)
{
}
SRSASN_CODE pdu_session_res_setup_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += ran_paging_prio_present ? 1 : 0;
  nof_ies += nas_pdu_present ? 1 : 0;
  nof_ies += ue_aggr_max_bit_rate_present ? 1 : 0;
  nof_ies += ue_slice_max_bit_rate_list_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  if (ran_paging_prio_present) {
    HANDLE_CODE(ran_paging_prio.pack(bref));
  }
  if (nas_pdu_present) {
    HANDLE_CODE(nas_pdu.pack(bref));
  }
  HANDLE_CODE(pdu_session_res_setup_list_su_req.pack(bref));
  if (ue_aggr_max_bit_rate_present) {
    HANDLE_CODE(ue_aggr_max_bit_rate.pack(bref));
  }
  if (ue_slice_max_bit_rate_list_present) {
    HANDLE_CODE(ue_slice_max_bit_rate_list.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_setup_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 83: {
        ran_paging_prio_present = true;
        ran_paging_prio.id      = id;
        HANDLE_CODE(ran_paging_prio.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_paging_prio.value.unpack(bref));
        break;
      }
      case 38: {
        nas_pdu_present = true;
        nas_pdu.id      = id;
        HANDLE_CODE(nas_pdu.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nas_pdu.value.unpack(bref));
        break;
      }
      case 74: {
        nof_mandatory_ies--;
        pdu_session_res_setup_list_su_req.id = id;
        HANDLE_CODE(pdu_session_res_setup_list_su_req.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pdu_session_res_setup_list_su_req.value.unpack(bref));
        break;
      }
      case 110: {
        ue_aggr_max_bit_rate_present = true;
        ue_aggr_max_bit_rate.id      = id;
        HANDLE_CODE(ue_aggr_max_bit_rate.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_aggr_max_bit_rate.value.unpack(bref));
        break;
      }
      case 335: {
        ue_slice_max_bit_rate_list_present = true;
        ue_slice_max_bit_rate_list.id      = id;
        HANDLE_CODE(ue_slice_max_bit_rate_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_slice_max_bit_rate_list.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void pdu_session_res_setup_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  if (ran_paging_prio_present) {
    j.write_fieldname("");
    ran_paging_prio.to_json(j);
  }
  if (nas_pdu_present) {
    j.write_fieldname("");
    nas_pdu.to_json(j);
  }
  j.write_fieldname("");
  pdu_session_res_setup_list_su_req.to_json(j);
  if (ue_aggr_max_bit_rate_present) {
    j.write_fieldname("");
    ue_aggr_max_bit_rate.to_json(j);
  }
  if (ue_slice_max_bit_rate_list_present) {
    j.write_fieldname("");
    ue_slice_max_bit_rate_list.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<pdu_session_res_setup_resp_ies_o>;

pdu_session_res_setup_resp_ies_container::pdu_session_res_setup_resp_ies_container() :
  amf_ue_ngap_id(10, crit_e::ignore),
  ran_ue_ngap_id(85, crit_e::ignore),
  pdu_session_res_setup_list_su_res(75, crit_e::ignore),
  pdu_session_res_failed_to_setup_list_su_res(58, crit_e::ignore),
  crit_diagnostics(19, crit_e::ignore),
  user_location_info(121, crit_e::ignore)
{
}
SRSASN_CODE pdu_session_res_setup_resp_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += pdu_session_res_setup_list_su_res_present ? 1 : 0;
  nof_ies += pdu_session_res_failed_to_setup_list_su_res_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  nof_ies += user_location_info_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  if (pdu_session_res_setup_list_su_res_present) {
    HANDLE_CODE(pdu_session_res_setup_list_su_res.pack(bref));
  }
  if (pdu_session_res_failed_to_setup_list_su_res_present) {
    HANDLE_CODE(pdu_session_res_failed_to_setup_list_su_res.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }
  if (user_location_info_present) {
    HANDLE_CODE(user_location_info.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_setup_resp_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 75: {
        pdu_session_res_setup_list_su_res_present = true;
        pdu_session_res_setup_list_su_res.id      = id;
        HANDLE_CODE(pdu_session_res_setup_list_su_res.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pdu_session_res_setup_list_su_res.value.unpack(bref));
        break;
      }
      case 58: {
        pdu_session_res_failed_to_setup_list_su_res_present = true;
        pdu_session_res_failed_to_setup_list_su_res.id      = id;
        HANDLE_CODE(pdu_session_res_failed_to_setup_list_su_res.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pdu_session_res_failed_to_setup_list_su_res.value.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        crit_diagnostics.id      = id;
        HANDLE_CODE(crit_diagnostics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.value.unpack(bref));
        break;
      }
      case 121: {
        user_location_info_present = true;
        user_location_info.id      = id;
        HANDLE_CODE(user_location_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(user_location_info.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void pdu_session_res_setup_resp_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  if (pdu_session_res_setup_list_su_res_present) {
    j.write_fieldname("");
    pdu_session_res_setup_list_su_res.to_json(j);
  }
  if (pdu_session_res_failed_to_setup_list_su_res_present) {
    j.write_fieldname("");
    pdu_session_res_failed_to_setup_list_su_res.to_json(j);
  }
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  if (user_location_info_present) {
    j.write_fieldname("");
    user_location_info.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<pws_cancel_request_ies_o>;

pws_cancel_request_ies_container::pws_cancel_request_ies_container() :
  msg_id(35, crit_e::reject),
  serial_num(95, crit_e::reject),
  warning_area_list(122, crit_e::ignore),
  cancel_all_warning_msgs(14, crit_e::reject)
{
}
SRSASN_CODE pws_cancel_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += warning_area_list_present ? 1 : 0;
  nof_ies += cancel_all_warning_msgs_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(msg_id.pack(bref));
  HANDLE_CODE(serial_num.pack(bref));
  if (warning_area_list_present) {
    HANDLE_CODE(warning_area_list.pack(bref));
  }
  if (cancel_all_warning_msgs_present) {
    HANDLE_CODE(cancel_all_warning_msgs.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pws_cancel_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 35: {
        nof_mandatory_ies--;
        msg_id.id = id;
        HANDLE_CODE(msg_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(msg_id.value.unpack(bref));
        break;
      }
      case 95: {
        nof_mandatory_ies--;
        serial_num.id = id;
        HANDLE_CODE(serial_num.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(serial_num.value.unpack(bref));
        break;
      }
      case 122: {
        warning_area_list_present = true;
        warning_area_list.id      = id;
        HANDLE_CODE(warning_area_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(warning_area_list.value.unpack(bref));
        break;
      }
      case 14: {
        cancel_all_warning_msgs_present = true;
        cancel_all_warning_msgs.id      = id;
        HANDLE_CODE(cancel_all_warning_msgs.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cancel_all_warning_msgs.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void pws_cancel_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  msg_id.to_json(j);
  j.write_fieldname("");
  serial_num.to_json(j);
  if (warning_area_list_present) {
    j.write_fieldname("");
    warning_area_list.to_json(j);
  }
  if (cancel_all_warning_msgs_present) {
    j.write_fieldname("");
    cancel_all_warning_msgs.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<pws_cancel_resp_ies_o>;

pws_cancel_resp_ies_container::pws_cancel_resp_ies_container() :
  msg_id(35, crit_e::reject),
  serial_num(95, crit_e::reject),
  broadcast_cancelled_area_list(12, crit_e::ignore),
  crit_diagnostics(19, crit_e::ignore)
{
}
SRSASN_CODE pws_cancel_resp_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += broadcast_cancelled_area_list_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(msg_id.pack(bref));
  HANDLE_CODE(serial_num.pack(bref));
  if (broadcast_cancelled_area_list_present) {
    HANDLE_CODE(broadcast_cancelled_area_list.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pws_cancel_resp_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 35: {
        nof_mandatory_ies--;
        msg_id.id = id;
        HANDLE_CODE(msg_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(msg_id.value.unpack(bref));
        break;
      }
      case 95: {
        nof_mandatory_ies--;
        serial_num.id = id;
        HANDLE_CODE(serial_num.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(serial_num.value.unpack(bref));
        break;
      }
      case 12: {
        broadcast_cancelled_area_list_present = true;
        broadcast_cancelled_area_list.id      = id;
        HANDLE_CODE(broadcast_cancelled_area_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(broadcast_cancelled_area_list.value.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        crit_diagnostics.id      = id;
        HANDLE_CODE(crit_diagnostics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void pws_cancel_resp_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  msg_id.to_json(j);
  j.write_fieldname("");
  serial_num.to_json(j);
  if (broadcast_cancelled_area_list_present) {
    j.write_fieldname("");
    broadcast_cancelled_area_list.to_json(j);
  }
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<pws_fail_ind_ies_o>;

pws_fail_ind_ies_container::pws_fail_ind_ies_container() :
  pws_failed_cell_id_list(81, crit_e::reject), global_ran_node_id(27, crit_e::reject)
{
}
SRSASN_CODE pws_fail_ind_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(pws_failed_cell_id_list.pack(bref));
  HANDLE_CODE(global_ran_node_id.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE pws_fail_ind_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 81: {
        nof_mandatory_ies--;
        pws_failed_cell_id_list.id = id;
        HANDLE_CODE(pws_failed_cell_id_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pws_failed_cell_id_list.value.unpack(bref));
        break;
      }
      case 27: {
        nof_mandatory_ies--;
        global_ran_node_id.id = id;
        HANDLE_CODE(global_ran_node_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(global_ran_node_id.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void pws_fail_ind_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  pws_failed_cell_id_list.to_json(j);
  j.write_fieldname("");
  global_ran_node_id.to_json(j);
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<pws_restart_ind_ies_o>;

pws_restart_ind_ies_container::pws_restart_ind_ies_container() :
  cell_id_list_for_restart(16, crit_e::reject),
  global_ran_node_id(27, crit_e::reject),
  tai_list_for_restart(104, crit_e::reject),
  emergency_area_id_list_for_restart(23, crit_e::reject)
{
}
SRSASN_CODE pws_restart_ind_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += emergency_area_id_list_for_restart_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(cell_id_list_for_restart.pack(bref));
  HANDLE_CODE(global_ran_node_id.pack(bref));
  HANDLE_CODE(tai_list_for_restart.pack(bref));
  if (emergency_area_id_list_for_restart_present) {
    HANDLE_CODE(emergency_area_id_list_for_restart.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pws_restart_ind_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 16: {
        nof_mandatory_ies--;
        cell_id_list_for_restart.id = id;
        HANDLE_CODE(cell_id_list_for_restart.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cell_id_list_for_restart.value.unpack(bref));
        break;
      }
      case 27: {
        nof_mandatory_ies--;
        global_ran_node_id.id = id;
        HANDLE_CODE(global_ran_node_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(global_ran_node_id.value.unpack(bref));
        break;
      }
      case 104: {
        nof_mandatory_ies--;
        tai_list_for_restart.id = id;
        HANDLE_CODE(tai_list_for_restart.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(tai_list_for_restart.value.unpack(bref));
        break;
      }
      case 23: {
        emergency_area_id_list_for_restart_present = true;
        emergency_area_id_list_for_restart.id      = id;
        HANDLE_CODE(emergency_area_id_list_for_restart.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(emergency_area_id_list_for_restart.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void pws_restart_ind_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  cell_id_list_for_restart.to_json(j);
  j.write_fieldname("");
  global_ran_node_id.to_json(j);
  j.write_fieldname("");
  tai_list_for_restart.to_json(j);
  if (emergency_area_id_list_for_restart_present) {
    j.write_fieldname("");
    emergency_area_id_list_for_restart.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<paging_ies_o>;

paging_ies_container::paging_ies_container() :
  ue_paging_id(115, crit_e::ignore),
  paging_drx(50, crit_e::ignore),
  tai_list_for_paging(103, crit_e::ignore),
  paging_prio(52, crit_e::ignore),
  ue_radio_cap_for_paging(118, crit_e::ignore),
  paging_origin(51, crit_e::ignore),
  assist_data_for_paging(11, crit_e::ignore),
  nb_iot_paging_e_drx_info(203, crit_e::ignore),
  nb_iot_paging_drx(202, crit_e::ignore),
  enhanced_coverage_restrict(205, crit_e::ignore),
  wus_assist_info(208, crit_e::ignore),
  eutra_paginge_drx_info(223, crit_e::ignore),
  ce_mode_brestricted(222, crit_e::ignore),
  nr_paginge_drx_info(332, crit_e::ignore),
  paging_cause(342, crit_e::ignore),
  pe_ip_sassist_info(344, crit_e::ignore)
{
}
SRSASN_CODE paging_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += paging_drx_present ? 1 : 0;
  nof_ies += paging_prio_present ? 1 : 0;
  nof_ies += ue_radio_cap_for_paging_present ? 1 : 0;
  nof_ies += paging_origin_present ? 1 : 0;
  nof_ies += assist_data_for_paging_present ? 1 : 0;
  nof_ies += nb_iot_paging_e_drx_info_present ? 1 : 0;
  nof_ies += nb_iot_paging_drx_present ? 1 : 0;
  nof_ies += enhanced_coverage_restrict_present ? 1 : 0;
  nof_ies += wus_assist_info_present ? 1 : 0;
  nof_ies += eutra_paginge_drx_info_present ? 1 : 0;
  nof_ies += ce_mode_brestricted_present ? 1 : 0;
  nof_ies += nr_paginge_drx_info_present ? 1 : 0;
  nof_ies += paging_cause_present ? 1 : 0;
  nof_ies += pe_ip_sassist_info_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(ue_paging_id.pack(bref));
  if (paging_drx_present) {
    HANDLE_CODE(paging_drx.pack(bref));
  }
  HANDLE_CODE(tai_list_for_paging.pack(bref));
  if (paging_prio_present) {
    HANDLE_CODE(paging_prio.pack(bref));
  }
  if (ue_radio_cap_for_paging_present) {
    HANDLE_CODE(ue_radio_cap_for_paging.pack(bref));
  }
  if (paging_origin_present) {
    HANDLE_CODE(paging_origin.pack(bref));
  }
  if (assist_data_for_paging_present) {
    HANDLE_CODE(assist_data_for_paging.pack(bref));
  }
  if (nb_iot_paging_e_drx_info_present) {
    HANDLE_CODE(nb_iot_paging_e_drx_info.pack(bref));
  }
  if (nb_iot_paging_drx_present) {
    HANDLE_CODE(nb_iot_paging_drx.pack(bref));
  }
  if (enhanced_coverage_restrict_present) {
    HANDLE_CODE(enhanced_coverage_restrict.pack(bref));
  }
  if (wus_assist_info_present) {
    HANDLE_CODE(wus_assist_info.pack(bref));
  }
  if (eutra_paginge_drx_info_present) {
    HANDLE_CODE(eutra_paginge_drx_info.pack(bref));
  }
  if (ce_mode_brestricted_present) {
    HANDLE_CODE(ce_mode_brestricted.pack(bref));
  }
  if (nr_paginge_drx_info_present) {
    HANDLE_CODE(nr_paginge_drx_info.pack(bref));
  }
  if (paging_cause_present) {
    HANDLE_CODE(paging_cause.pack(bref));
  }
  if (pe_ip_sassist_info_present) {
    HANDLE_CODE(pe_ip_sassist_info.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE paging_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 115: {
        nof_mandatory_ies--;
        ue_paging_id.id = id;
        HANDLE_CODE(ue_paging_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_paging_id.value.unpack(bref));
        break;
      }
      case 50: {
        paging_drx_present = true;
        paging_drx.id      = id;
        HANDLE_CODE(paging_drx.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(paging_drx.value.unpack(bref));
        break;
      }
      case 103: {
        nof_mandatory_ies--;
        tai_list_for_paging.id = id;
        HANDLE_CODE(tai_list_for_paging.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(tai_list_for_paging.value.unpack(bref));
        break;
      }
      case 52: {
        paging_prio_present = true;
        paging_prio.id      = id;
        HANDLE_CODE(paging_prio.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(paging_prio.value.unpack(bref));
        break;
      }
      case 118: {
        ue_radio_cap_for_paging_present = true;
        ue_radio_cap_for_paging.id      = id;
        HANDLE_CODE(ue_radio_cap_for_paging.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_radio_cap_for_paging.value.unpack(bref));
        break;
      }
      case 51: {
        paging_origin_present = true;
        paging_origin.id      = id;
        HANDLE_CODE(paging_origin.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(paging_origin.value.unpack(bref));
        break;
      }
      case 11: {
        assist_data_for_paging_present = true;
        assist_data_for_paging.id      = id;
        HANDLE_CODE(assist_data_for_paging.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(assist_data_for_paging.value.unpack(bref));
        break;
      }
      case 203: {
        nb_iot_paging_e_drx_info_present = true;
        nb_iot_paging_e_drx_info.id      = id;
        HANDLE_CODE(nb_iot_paging_e_drx_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nb_iot_paging_e_drx_info.value.unpack(bref));
        break;
      }
      case 202: {
        nb_iot_paging_drx_present = true;
        nb_iot_paging_drx.id      = id;
        HANDLE_CODE(nb_iot_paging_drx.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nb_iot_paging_drx.value.unpack(bref));
        break;
      }
      case 205: {
        enhanced_coverage_restrict_present = true;
        enhanced_coverage_restrict.id      = id;
        HANDLE_CODE(enhanced_coverage_restrict.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(enhanced_coverage_restrict.value.unpack(bref));
        break;
      }
      case 208: {
        wus_assist_info_present = true;
        wus_assist_info.id      = id;
        HANDLE_CODE(wus_assist_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(wus_assist_info.value.unpack(bref));
        break;
      }
      case 223: {
        eutra_paginge_drx_info_present = true;
        eutra_paginge_drx_info.id      = id;
        HANDLE_CODE(eutra_paginge_drx_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(eutra_paginge_drx_info.value.unpack(bref));
        break;
      }
      case 222: {
        ce_mode_brestricted_present = true;
        ce_mode_brestricted.id      = id;
        HANDLE_CODE(ce_mode_brestricted.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ce_mode_brestricted.value.unpack(bref));
        break;
      }
      case 332: {
        nr_paginge_drx_info_present = true;
        nr_paginge_drx_info.id      = id;
        HANDLE_CODE(nr_paginge_drx_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nr_paginge_drx_info.value.unpack(bref));
        break;
      }
      case 342: {
        paging_cause_present = true;
        paging_cause.id      = id;
        HANDLE_CODE(paging_cause.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(paging_cause.value.unpack(bref));
        break;
      }
      case 344: {
        pe_ip_sassist_info_present = true;
        pe_ip_sassist_info.id      = id;
        HANDLE_CODE(pe_ip_sassist_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pe_ip_sassist_info.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void paging_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  ue_paging_id.to_json(j);
  if (paging_drx_present) {
    j.write_fieldname("");
    paging_drx.to_json(j);
  }
  j.write_fieldname("");
  tai_list_for_paging.to_json(j);
  if (paging_prio_present) {
    j.write_fieldname("");
    paging_prio.to_json(j);
  }
  if (ue_radio_cap_for_paging_present) {
    j.write_fieldname("");
    ue_radio_cap_for_paging.to_json(j);
  }
  if (paging_origin_present) {
    j.write_fieldname("");
    paging_origin.to_json(j);
  }
  if (assist_data_for_paging_present) {
    j.write_fieldname("");
    assist_data_for_paging.to_json(j);
  }
  if (nb_iot_paging_e_drx_info_present) {
    j.write_fieldname("");
    nb_iot_paging_e_drx_info.to_json(j);
  }
  if (nb_iot_paging_drx_present) {
    j.write_fieldname("");
    nb_iot_paging_drx.to_json(j);
  }
  if (enhanced_coverage_restrict_present) {
    j.write_fieldname("");
    enhanced_coverage_restrict.to_json(j);
  }
  if (wus_assist_info_present) {
    j.write_fieldname("");
    wus_assist_info.to_json(j);
  }
  if (eutra_paginge_drx_info_present) {
    j.write_fieldname("");
    eutra_paginge_drx_info.to_json(j);
  }
  if (ce_mode_brestricted_present) {
    j.write_fieldname("");
    ce_mode_brestricted.to_json(j);
  }
  if (nr_paginge_drx_info_present) {
    j.write_fieldname("");
    nr_paginge_drx_info.to_json(j);
  }
  if (paging_cause_present) {
    j.write_fieldname("");
    paging_cause.to_json(j);
  }
  if (pe_ip_sassist_info_present) {
    j.write_fieldname("");
    pe_ip_sassist_info.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<path_switch_request_ies_o>;

path_switch_request_ies_container::path_switch_request_ies_container() :
  ran_ue_ngap_id(85, crit_e::reject),
  source_amf_ue_ngap_id(100, crit_e::reject),
  user_location_info(121, crit_e::ignore),
  ue_security_cap(119, crit_e::ignore),
  pdu_session_res_to_be_switched_dl_list(76, crit_e::reject),
  pdu_session_res_failed_to_setup_list_ps_req(57, crit_e::ignore),
  rrc_resume_cause(237, crit_e::ignore),
  red_cap_ind(333, crit_e::ignore)
{
}
SRSASN_CODE path_switch_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 5;
  nof_ies += pdu_session_res_failed_to_setup_list_ps_req_present ? 1 : 0;
  nof_ies += rrc_resume_cause_present ? 1 : 0;
  nof_ies += red_cap_ind_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  HANDLE_CODE(source_amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(user_location_info.pack(bref));
  HANDLE_CODE(ue_security_cap.pack(bref));
  HANDLE_CODE(pdu_session_res_to_be_switched_dl_list.pack(bref));
  if (pdu_session_res_failed_to_setup_list_ps_req_present) {
    HANDLE_CODE(pdu_session_res_failed_to_setup_list_ps_req.pack(bref));
  }
  if (rrc_resume_cause_present) {
    HANDLE_CODE(rrc_resume_cause.pack(bref));
  }
  if (red_cap_ind_present) {
    HANDLE_CODE(red_cap_ind.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE path_switch_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 5;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 100: {
        nof_mandatory_ies--;
        source_amf_ue_ngap_id.id = id;
        HANDLE_CODE(source_amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(source_amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 121: {
        nof_mandatory_ies--;
        user_location_info.id = id;
        HANDLE_CODE(user_location_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(user_location_info.value.unpack(bref));
        break;
      }
      case 119: {
        nof_mandatory_ies--;
        ue_security_cap.id = id;
        HANDLE_CODE(ue_security_cap.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_security_cap.value.unpack(bref));
        break;
      }
      case 76: {
        nof_mandatory_ies--;
        pdu_session_res_to_be_switched_dl_list.id = id;
        HANDLE_CODE(pdu_session_res_to_be_switched_dl_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pdu_session_res_to_be_switched_dl_list.value.unpack(bref));
        break;
      }
      case 57: {
        pdu_session_res_failed_to_setup_list_ps_req_present = true;
        pdu_session_res_failed_to_setup_list_ps_req.id      = id;
        HANDLE_CODE(pdu_session_res_failed_to_setup_list_ps_req.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pdu_session_res_failed_to_setup_list_ps_req.value.unpack(bref));
        break;
      }
      case 237: {
        rrc_resume_cause_present = true;
        rrc_resume_cause.id      = id;
        HANDLE_CODE(rrc_resume_cause.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(rrc_resume_cause.value.unpack(bref));
        break;
      }
      case 333: {
        red_cap_ind_present = true;
        red_cap_ind.id      = id;
        HANDLE_CODE(red_cap_ind.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(red_cap_ind.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void path_switch_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  source_amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  user_location_info.to_json(j);
  j.write_fieldname("");
  ue_security_cap.to_json(j);
  j.write_fieldname("");
  pdu_session_res_to_be_switched_dl_list.to_json(j);
  if (pdu_session_res_failed_to_setup_list_ps_req_present) {
    j.write_fieldname("");
    pdu_session_res_failed_to_setup_list_ps_req.to_json(j);
  }
  if (rrc_resume_cause_present) {
    j.write_fieldname("");
    rrc_resume_cause.to_json(j);
  }
  if (red_cap_ind_present) {
    j.write_fieldname("");
    red_cap_ind.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<path_switch_request_ack_ies_o>;

path_switch_request_ack_ies_container::path_switch_request_ack_ies_container() :
  amf_ue_ngap_id(10, crit_e::ignore),
  ran_ue_ngap_id(85, crit_e::ignore),
  ue_security_cap(119, crit_e::reject),
  security_context(93, crit_e::reject),
  new_security_context_ind(41, crit_e::reject),
  pdu_session_res_switched_list(77, crit_e::ignore),
  pdu_session_res_released_list_ps_ack(68, crit_e::ignore),
  allowed_nssai(0, crit_e::reject),
  core_network_assist_info_for_inactive(18, crit_e::ignore),
  rrc_inactive_transition_report_request(91, crit_e::ignore),
  crit_diagnostics(19, crit_e::ignore),
  redirection_voice_fallback(146, crit_e::ignore),
  cn_assisted_ran_tuning(165, crit_e::ignore),
  srvcc_operation_possible(177, crit_e::ignore),
  enhanced_coverage_restrict(205, crit_e::ignore),
  extended_connected_time(206, crit_e::ignore),
  ue_diff_info(209, crit_e::ignore),
  nr_v2x_services_authorized(216, crit_e::ignore),
  ltev2x_services_authorized(215, crit_e::ignore),
  nr_ue_sidelink_aggr_max_bitrate(218, crit_e::ignore),
  lte_ue_sidelink_aggr_max_bitrate(217, crit_e::ignore),
  pc5_qos_params(219, crit_e::ignore),
  ce_mode_brestricted(222, crit_e::ignore),
  ue_up_c_iot_support(234, crit_e::ignore),
  ue_radio_cap_id(264, crit_e::reject),
  management_based_mdt_plmn_list(254, crit_e::ignore),
  time_sync_assist_info(326, crit_e::ignore),
  five_g_pro_se_authorized(345, crit_e::ignore),
  five_g_pro_se_ue_pc5_aggr_max_bit_rate(346, crit_e::ignore),
  five_g_pro_se_pc5_qos_params(347, crit_e::ignore),
  management_based_mdt_plmn_mod_list(359, crit_e::ignore)
{
}
SRSASN_CODE path_switch_request_ack_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 5;
  nof_ies += ue_security_cap_present ? 1 : 0;
  nof_ies += new_security_context_ind_present ? 1 : 0;
  nof_ies += pdu_session_res_released_list_ps_ack_present ? 1 : 0;
  nof_ies += core_network_assist_info_for_inactive_present ? 1 : 0;
  nof_ies += rrc_inactive_transition_report_request_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  nof_ies += redirection_voice_fallback_present ? 1 : 0;
  nof_ies += cn_assisted_ran_tuning_present ? 1 : 0;
  nof_ies += srvcc_operation_possible_present ? 1 : 0;
  nof_ies += enhanced_coverage_restrict_present ? 1 : 0;
  nof_ies += extended_connected_time_present ? 1 : 0;
  nof_ies += ue_diff_info_present ? 1 : 0;
  nof_ies += nr_v2x_services_authorized_present ? 1 : 0;
  nof_ies += ltev2x_services_authorized_present ? 1 : 0;
  nof_ies += nr_ue_sidelink_aggr_max_bitrate_present ? 1 : 0;
  nof_ies += lte_ue_sidelink_aggr_max_bitrate_present ? 1 : 0;
  nof_ies += pc5_qos_params_present ? 1 : 0;
  nof_ies += ce_mode_brestricted_present ? 1 : 0;
  nof_ies += ue_up_c_iot_support_present ? 1 : 0;
  nof_ies += ue_radio_cap_id_present ? 1 : 0;
  nof_ies += management_based_mdt_plmn_list_present ? 1 : 0;
  nof_ies += time_sync_assist_info_present ? 1 : 0;
  nof_ies += five_g_pro_se_authorized_present ? 1 : 0;
  nof_ies += five_g_pro_se_ue_pc5_aggr_max_bit_rate_present ? 1 : 0;
  nof_ies += five_g_pro_se_pc5_qos_params_present ? 1 : 0;
  nof_ies += management_based_mdt_plmn_mod_list_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  if (ue_security_cap_present) {
    HANDLE_CODE(ue_security_cap.pack(bref));
  }
  HANDLE_CODE(security_context.pack(bref));
  if (new_security_context_ind_present) {
    HANDLE_CODE(new_security_context_ind.pack(bref));
  }
  HANDLE_CODE(pdu_session_res_switched_list.pack(bref));
  if (pdu_session_res_released_list_ps_ack_present) {
    HANDLE_CODE(pdu_session_res_released_list_ps_ack.pack(bref));
  }
  HANDLE_CODE(allowed_nssai.pack(bref));
  if (core_network_assist_info_for_inactive_present) {
    HANDLE_CODE(core_network_assist_info_for_inactive.pack(bref));
  }
  if (rrc_inactive_transition_report_request_present) {
    HANDLE_CODE(rrc_inactive_transition_report_request.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }
  if (redirection_voice_fallback_present) {
    HANDLE_CODE(redirection_voice_fallback.pack(bref));
  }
  if (cn_assisted_ran_tuning_present) {
    HANDLE_CODE(cn_assisted_ran_tuning.pack(bref));
  }
  if (srvcc_operation_possible_present) {
    HANDLE_CODE(srvcc_operation_possible.pack(bref));
  }
  if (enhanced_coverage_restrict_present) {
    HANDLE_CODE(enhanced_coverage_restrict.pack(bref));
  }
  if (extended_connected_time_present) {
    HANDLE_CODE(extended_connected_time.pack(bref));
  }
  if (ue_diff_info_present) {
    HANDLE_CODE(ue_diff_info.pack(bref));
  }
  if (nr_v2x_services_authorized_present) {
    HANDLE_CODE(nr_v2x_services_authorized.pack(bref));
  }
  if (ltev2x_services_authorized_present) {
    HANDLE_CODE(ltev2x_services_authorized.pack(bref));
  }
  if (nr_ue_sidelink_aggr_max_bitrate_present) {
    HANDLE_CODE(nr_ue_sidelink_aggr_max_bitrate.pack(bref));
  }
  if (lte_ue_sidelink_aggr_max_bitrate_present) {
    HANDLE_CODE(lte_ue_sidelink_aggr_max_bitrate.pack(bref));
  }
  if (pc5_qos_params_present) {
    HANDLE_CODE(pc5_qos_params.pack(bref));
  }
  if (ce_mode_brestricted_present) {
    HANDLE_CODE(ce_mode_brestricted.pack(bref));
  }
  if (ue_up_c_iot_support_present) {
    HANDLE_CODE(ue_up_c_iot_support.pack(bref));
  }
  if (ue_radio_cap_id_present) {
    HANDLE_CODE(ue_radio_cap_id.pack(bref));
  }
  if (management_based_mdt_plmn_list_present) {
    HANDLE_CODE(management_based_mdt_plmn_list.pack(bref));
  }
  if (time_sync_assist_info_present) {
    HANDLE_CODE(time_sync_assist_info.pack(bref));
  }
  if (five_g_pro_se_authorized_present) {
    HANDLE_CODE(five_g_pro_se_authorized.pack(bref));
  }
  if (five_g_pro_se_ue_pc5_aggr_max_bit_rate_present) {
    HANDLE_CODE(five_g_pro_se_ue_pc5_aggr_max_bit_rate.pack(bref));
  }
  if (five_g_pro_se_pc5_qos_params_present) {
    HANDLE_CODE(five_g_pro_se_pc5_qos_params.pack(bref));
  }
  if (management_based_mdt_plmn_mod_list_present) {
    HANDLE_CODE(management_based_mdt_plmn_mod_list.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE path_switch_request_ack_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 5;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 119: {
        ue_security_cap_present = true;
        ue_security_cap.id      = id;
        HANDLE_CODE(ue_security_cap.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_security_cap.value.unpack(bref));
        break;
      }
      case 93: {
        nof_mandatory_ies--;
        security_context.id = id;
        HANDLE_CODE(security_context.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(security_context.value.unpack(bref));
        break;
      }
      case 41: {
        new_security_context_ind_present = true;
        new_security_context_ind.id      = id;
        HANDLE_CODE(new_security_context_ind.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(new_security_context_ind.value.unpack(bref));
        break;
      }
      case 77: {
        nof_mandatory_ies--;
        pdu_session_res_switched_list.id = id;
        HANDLE_CODE(pdu_session_res_switched_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pdu_session_res_switched_list.value.unpack(bref));
        break;
      }
      case 68: {
        pdu_session_res_released_list_ps_ack_present = true;
        pdu_session_res_released_list_ps_ack.id      = id;
        HANDLE_CODE(pdu_session_res_released_list_ps_ack.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pdu_session_res_released_list_ps_ack.value.unpack(bref));
        break;
      }
      case 0: {
        nof_mandatory_ies--;
        allowed_nssai.id = id;
        HANDLE_CODE(allowed_nssai.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(allowed_nssai.value.unpack(bref));
        break;
      }
      case 18: {
        core_network_assist_info_for_inactive_present = true;
        core_network_assist_info_for_inactive.id      = id;
        HANDLE_CODE(core_network_assist_info_for_inactive.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(core_network_assist_info_for_inactive.value.unpack(bref));
        break;
      }
      case 91: {
        rrc_inactive_transition_report_request_present = true;
        rrc_inactive_transition_report_request.id      = id;
        HANDLE_CODE(rrc_inactive_transition_report_request.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(rrc_inactive_transition_report_request.value.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        crit_diagnostics.id      = id;
        HANDLE_CODE(crit_diagnostics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.value.unpack(bref));
        break;
      }
      case 146: {
        redirection_voice_fallback_present = true;
        redirection_voice_fallback.id      = id;
        HANDLE_CODE(redirection_voice_fallback.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(redirection_voice_fallback.value.unpack(bref));
        break;
      }
      case 165: {
        cn_assisted_ran_tuning_present = true;
        cn_assisted_ran_tuning.id      = id;
        HANDLE_CODE(cn_assisted_ran_tuning.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cn_assisted_ran_tuning.value.unpack(bref));
        break;
      }
      case 177: {
        srvcc_operation_possible_present = true;
        srvcc_operation_possible.id      = id;
        HANDLE_CODE(srvcc_operation_possible.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(srvcc_operation_possible.value.unpack(bref));
        break;
      }
      case 205: {
        enhanced_coverage_restrict_present = true;
        enhanced_coverage_restrict.id      = id;
        HANDLE_CODE(enhanced_coverage_restrict.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(enhanced_coverage_restrict.value.unpack(bref));
        break;
      }
      case 206: {
        extended_connected_time_present = true;
        extended_connected_time.id      = id;
        HANDLE_CODE(extended_connected_time.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(extended_connected_time.value.unpack(bref));
        break;
      }
      case 209: {
        ue_diff_info_present = true;
        ue_diff_info.id      = id;
        HANDLE_CODE(ue_diff_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_diff_info.value.unpack(bref));
        break;
      }
      case 216: {
        nr_v2x_services_authorized_present = true;
        nr_v2x_services_authorized.id      = id;
        HANDLE_CODE(nr_v2x_services_authorized.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nr_v2x_services_authorized.value.unpack(bref));
        break;
      }
      case 215: {
        ltev2x_services_authorized_present = true;
        ltev2x_services_authorized.id      = id;
        HANDLE_CODE(ltev2x_services_authorized.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ltev2x_services_authorized.value.unpack(bref));
        break;
      }
      case 218: {
        nr_ue_sidelink_aggr_max_bitrate_present = true;
        nr_ue_sidelink_aggr_max_bitrate.id      = id;
        HANDLE_CODE(nr_ue_sidelink_aggr_max_bitrate.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nr_ue_sidelink_aggr_max_bitrate.value.unpack(bref));
        break;
      }
      case 217: {
        lte_ue_sidelink_aggr_max_bitrate_present = true;
        lte_ue_sidelink_aggr_max_bitrate.id      = id;
        HANDLE_CODE(lte_ue_sidelink_aggr_max_bitrate.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(lte_ue_sidelink_aggr_max_bitrate.value.unpack(bref));
        break;
      }
      case 219: {
        pc5_qos_params_present = true;
        pc5_qos_params.id      = id;
        HANDLE_CODE(pc5_qos_params.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pc5_qos_params.value.unpack(bref));
        break;
      }
      case 222: {
        ce_mode_brestricted_present = true;
        ce_mode_brestricted.id      = id;
        HANDLE_CODE(ce_mode_brestricted.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ce_mode_brestricted.value.unpack(bref));
        break;
      }
      case 234: {
        ue_up_c_iot_support_present = true;
        ue_up_c_iot_support.id      = id;
        HANDLE_CODE(ue_up_c_iot_support.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_up_c_iot_support.value.unpack(bref));
        break;
      }
      case 264: {
        ue_radio_cap_id_present = true;
        ue_radio_cap_id.id      = id;
        HANDLE_CODE(ue_radio_cap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_radio_cap_id.value.unpack(bref));
        break;
      }
      case 254: {
        management_based_mdt_plmn_list_present = true;
        management_based_mdt_plmn_list.id      = id;
        HANDLE_CODE(management_based_mdt_plmn_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(management_based_mdt_plmn_list.value.unpack(bref));
        break;
      }
      case 326: {
        time_sync_assist_info_present = true;
        time_sync_assist_info.id      = id;
        HANDLE_CODE(time_sync_assist_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(time_sync_assist_info.value.unpack(bref));
        break;
      }
      case 345: {
        five_g_pro_se_authorized_present = true;
        five_g_pro_se_authorized.id      = id;
        HANDLE_CODE(five_g_pro_se_authorized.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(five_g_pro_se_authorized.value.unpack(bref));
        break;
      }
      case 346: {
        five_g_pro_se_ue_pc5_aggr_max_bit_rate_present = true;
        five_g_pro_se_ue_pc5_aggr_max_bit_rate.id      = id;
        HANDLE_CODE(five_g_pro_se_ue_pc5_aggr_max_bit_rate.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(five_g_pro_se_ue_pc5_aggr_max_bit_rate.value.unpack(bref));
        break;
      }
      case 347: {
        five_g_pro_se_pc5_qos_params_present = true;
        five_g_pro_se_pc5_qos_params.id      = id;
        HANDLE_CODE(five_g_pro_se_pc5_qos_params.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(five_g_pro_se_pc5_qos_params.value.unpack(bref));
        break;
      }
      case 359: {
        management_based_mdt_plmn_mod_list_present = true;
        management_based_mdt_plmn_mod_list.id      = id;
        HANDLE_CODE(management_based_mdt_plmn_mod_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(management_based_mdt_plmn_mod_list.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void path_switch_request_ack_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  if (ue_security_cap_present) {
    j.write_fieldname("");
    ue_security_cap.to_json(j);
  }
  j.write_fieldname("");
  security_context.to_json(j);
  if (new_security_context_ind_present) {
    j.write_fieldname("");
    new_security_context_ind.to_json(j);
  }
  j.write_fieldname("");
  pdu_session_res_switched_list.to_json(j);
  if (pdu_session_res_released_list_ps_ack_present) {
    j.write_fieldname("");
    pdu_session_res_released_list_ps_ack.to_json(j);
  }
  j.write_fieldname("");
  allowed_nssai.to_json(j);
  if (core_network_assist_info_for_inactive_present) {
    j.write_fieldname("");
    core_network_assist_info_for_inactive.to_json(j);
  }
  if (rrc_inactive_transition_report_request_present) {
    j.write_fieldname("");
    rrc_inactive_transition_report_request.to_json(j);
  }
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  if (redirection_voice_fallback_present) {
    j.write_fieldname("");
    redirection_voice_fallback.to_json(j);
  }
  if (cn_assisted_ran_tuning_present) {
    j.write_fieldname("");
    cn_assisted_ran_tuning.to_json(j);
  }
  if (srvcc_operation_possible_present) {
    j.write_fieldname("");
    srvcc_operation_possible.to_json(j);
  }
  if (enhanced_coverage_restrict_present) {
    j.write_fieldname("");
    enhanced_coverage_restrict.to_json(j);
  }
  if (extended_connected_time_present) {
    j.write_fieldname("");
    extended_connected_time.to_json(j);
  }
  if (ue_diff_info_present) {
    j.write_fieldname("");
    ue_diff_info.to_json(j);
  }
  if (nr_v2x_services_authorized_present) {
    j.write_fieldname("");
    nr_v2x_services_authorized.to_json(j);
  }
  if (ltev2x_services_authorized_present) {
    j.write_fieldname("");
    ltev2x_services_authorized.to_json(j);
  }
  if (nr_ue_sidelink_aggr_max_bitrate_present) {
    j.write_fieldname("");
    nr_ue_sidelink_aggr_max_bitrate.to_json(j);
  }
  if (lte_ue_sidelink_aggr_max_bitrate_present) {
    j.write_fieldname("");
    lte_ue_sidelink_aggr_max_bitrate.to_json(j);
  }
  if (pc5_qos_params_present) {
    j.write_fieldname("");
    pc5_qos_params.to_json(j);
  }
  if (ce_mode_brestricted_present) {
    j.write_fieldname("");
    ce_mode_brestricted.to_json(j);
  }
  if (ue_up_c_iot_support_present) {
    j.write_fieldname("");
    ue_up_c_iot_support.to_json(j);
  }
  if (ue_radio_cap_id_present) {
    j.write_fieldname("");
    ue_radio_cap_id.to_json(j);
  }
  if (management_based_mdt_plmn_list_present) {
    j.write_fieldname("");
    management_based_mdt_plmn_list.to_json(j);
  }
  if (time_sync_assist_info_present) {
    j.write_fieldname("");
    time_sync_assist_info.to_json(j);
  }
  if (five_g_pro_se_authorized_present) {
    j.write_fieldname("");
    five_g_pro_se_authorized.to_json(j);
  }
  if (five_g_pro_se_ue_pc5_aggr_max_bit_rate_present) {
    j.write_fieldname("");
    five_g_pro_se_ue_pc5_aggr_max_bit_rate.to_json(j);
  }
  if (five_g_pro_se_pc5_qos_params_present) {
    j.write_fieldname("");
    five_g_pro_se_pc5_qos_params.to_json(j);
  }
  if (management_based_mdt_plmn_mod_list_present) {
    j.write_fieldname("");
    management_based_mdt_plmn_mod_list.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<path_switch_request_fail_ies_o>;

path_switch_request_fail_ies_container::path_switch_request_fail_ies_container() :
  amf_ue_ngap_id(10, crit_e::ignore),
  ran_ue_ngap_id(85, crit_e::ignore),
  pdu_session_res_released_list_ps_fail(69, crit_e::ignore),
  crit_diagnostics(19, crit_e::ignore)
{
}
SRSASN_CODE path_switch_request_fail_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  HANDLE_CODE(pdu_session_res_released_list_ps_fail.pack(bref));
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE path_switch_request_fail_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 69: {
        nof_mandatory_ies--;
        pdu_session_res_released_list_ps_fail.id = id;
        HANDLE_CODE(pdu_session_res_released_list_ps_fail.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pdu_session_res_released_list_ps_fail.value.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        crit_diagnostics.id      = id;
        HANDLE_CODE(crit_diagnostics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void path_switch_request_fail_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  pdu_session_res_released_list_ps_fail.to_json(j);
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

template <class valueT_>
private_ie_container_item_s<valueT_>::private_ie_container_item_s(private_ie_id_c id_, crit_e crit_) :
  id(id_), crit(crit_)

{
}
template <class valueT_>
SRSASN_CODE private_ie_container_item_s<valueT_>::pack(bit_ref& bref) const
{
  HANDLE_CODE(id.pack(bref));
  HANDLE_CODE(crit.pack(bref));
  {
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(value.pack(bref));
  }
  return SRSASN_SUCCESS;
}
template <class valueT_>
SRSASN_CODE private_ie_container_item_s<valueT_>::unpack(cbit_ref& bref)
{
  HANDLE_CODE(id.unpack(bref));
  HANDLE_CODE(crit.unpack(bref));
  {
    varlength_field_unpack_guard varlen_scope(bref, true);
    HANDLE_CODE(value.unpack(bref));
  }
  return SRSASN_SUCCESS;
}
template <class valueT_>
void private_ie_container_item_s<valueT_>::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("id");
  id.to_json(j);
  j.write_str("criticality", crit.to_string());
  j.end_obj();
}

SRSASN_CODE private_ie_container_empty_l::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  return SRSASN_SUCCESS;
}
SRSASN_CODE private_ie_container_empty_l::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);
  if (nof_ies > 0) {
    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void private_ie_container_empty_l::to_json(json_writer& j) const
{
  j.start_obj();
  j.end_obj();
}

// PrivateMessage ::= SEQUENCE
SRSASN_CODE private_msg_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(private_ies.pack(bref));

  bref.align_bytes_zero();

  return SRSASN_SUCCESS;
}
SRSASN_CODE private_msg_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(private_ies.unpack(bref));

  bref.align_bytes();

  return SRSASN_SUCCESS;
}
void private_msg_s::to_json(json_writer& j) const
{
  j.start_array();
  j.start_obj();
  j.start_obj("PrivateMessage");
  j.write_fieldname("privateIEs");
  private_ies.to_json(j);
  j.end_obj();
  j.end_obj();
  j.end_array();
}

template struct asn1::protocol_ie_field_s<ran_cp_relocation_ind_ies_o>;

ran_cp_relocation_ind_ies_container::ran_cp_relocation_ind_ies_container() :
  ran_ue_ngap_id(85, crit_e::reject),
  five_g_s_tmsi(26, crit_e::reject),
  eutra_cgi(25, crit_e::ignore),
  tai(213, crit_e::ignore),
  ul_cp_security_info(211, crit_e::reject)
{
}
SRSASN_CODE ran_cp_relocation_ind_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 5;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  HANDLE_CODE(five_g_s_tmsi.pack(bref));
  HANDLE_CODE(eutra_cgi.pack(bref));
  HANDLE_CODE(tai.pack(bref));
  HANDLE_CODE(ul_cp_security_info.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE ran_cp_relocation_ind_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 5;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 26: {
        nof_mandatory_ies--;
        five_g_s_tmsi.id = id;
        HANDLE_CODE(five_g_s_tmsi.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(five_g_s_tmsi.value.unpack(bref));
        break;
      }
      case 25: {
        nof_mandatory_ies--;
        eutra_cgi.id = id;
        HANDLE_CODE(eutra_cgi.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(eutra_cgi.value.unpack(bref));
        break;
      }
      case 213: {
        nof_mandatory_ies--;
        tai.id = id;
        HANDLE_CODE(tai.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(tai.value.unpack(bref));
        break;
      }
      case 211: {
        nof_mandatory_ies--;
        ul_cp_security_info.id = id;
        HANDLE_CODE(ul_cp_security_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ul_cp_security_info.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ran_cp_relocation_ind_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  five_g_s_tmsi.to_json(j);
  j.write_fieldname("");
  eutra_cgi.to_json(j);
  j.write_fieldname("");
  tai.to_json(j);
  j.write_fieldname("");
  ul_cp_security_info.to_json(j);
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<ran_cfg_upd_ies_o>;

ran_cfg_upd_ies_container::ran_cfg_upd_ies_container() :
  ran_node_name(82, crit_e::ignore),
  supported_ta_list(102, crit_e::reject),
  default_paging_drx(21, crit_e::ignore),
  global_ran_node_id(27, crit_e::ignore),
  ngran_tnl_assoc_to_rem_list(167, crit_e::reject),
  nb_iot_default_paging_drx(204, crit_e::ignore),
  extended_ran_node_name(273, crit_e::ignore)
{
}
SRSASN_CODE ran_cfg_upd_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += ran_node_name_present ? 1 : 0;
  nof_ies += supported_ta_list_present ? 1 : 0;
  nof_ies += default_paging_drx_present ? 1 : 0;
  nof_ies += global_ran_node_id_present ? 1 : 0;
  nof_ies += ngran_tnl_assoc_to_rem_list_present ? 1 : 0;
  nof_ies += nb_iot_default_paging_drx_present ? 1 : 0;
  nof_ies += extended_ran_node_name_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  if (ran_node_name_present) {
    HANDLE_CODE(ran_node_name.pack(bref));
  }
  if (supported_ta_list_present) {
    HANDLE_CODE(supported_ta_list.pack(bref));
  }
  if (default_paging_drx_present) {
    HANDLE_CODE(default_paging_drx.pack(bref));
  }
  if (global_ran_node_id_present) {
    HANDLE_CODE(global_ran_node_id.pack(bref));
  }
  if (ngran_tnl_assoc_to_rem_list_present) {
    HANDLE_CODE(ngran_tnl_assoc_to_rem_list.pack(bref));
  }
  if (nb_iot_default_paging_drx_present) {
    HANDLE_CODE(nb_iot_default_paging_drx.pack(bref));
  }
  if (extended_ran_node_name_present) {
    HANDLE_CODE(extended_ran_node_name.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ran_cfg_upd_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 82: {
        ran_node_name_present = true;
        ran_node_name.id      = id;
        HANDLE_CODE(ran_node_name.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_node_name.value.unpack(bref));
        break;
      }
      case 102: {
        supported_ta_list_present = true;
        supported_ta_list.id      = id;
        HANDLE_CODE(supported_ta_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(supported_ta_list.value.unpack(bref));
        break;
      }
      case 21: {
        default_paging_drx_present = true;
        default_paging_drx.id      = id;
        HANDLE_CODE(default_paging_drx.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(default_paging_drx.value.unpack(bref));
        break;
      }
      case 27: {
        global_ran_node_id_present = true;
        global_ran_node_id.id      = id;
        HANDLE_CODE(global_ran_node_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(global_ran_node_id.value.unpack(bref));
        break;
      }
      case 167: {
        ngran_tnl_assoc_to_rem_list_present = true;
        ngran_tnl_assoc_to_rem_list.id      = id;
        HANDLE_CODE(ngran_tnl_assoc_to_rem_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ngran_tnl_assoc_to_rem_list.value.unpack(bref));
        break;
      }
      case 204: {
        nb_iot_default_paging_drx_present = true;
        nb_iot_default_paging_drx.id      = id;
        HANDLE_CODE(nb_iot_default_paging_drx.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nb_iot_default_paging_drx.value.unpack(bref));
        break;
      }
      case 273: {
        extended_ran_node_name_present = true;
        extended_ran_node_name.id      = id;
        HANDLE_CODE(extended_ran_node_name.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(extended_ran_node_name.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void ran_cfg_upd_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (ran_node_name_present) {
    j.write_fieldname("");
    ran_node_name.to_json(j);
  }
  if (supported_ta_list_present) {
    j.write_fieldname("");
    supported_ta_list.to_json(j);
  }
  if (default_paging_drx_present) {
    j.write_fieldname("");
    default_paging_drx.to_json(j);
  }
  if (global_ran_node_id_present) {
    j.write_fieldname("");
    global_ran_node_id.to_json(j);
  }
  if (ngran_tnl_assoc_to_rem_list_present) {
    j.write_fieldname("");
    ngran_tnl_assoc_to_rem_list.to_json(j);
  }
  if (nb_iot_default_paging_drx_present) {
    j.write_fieldname("");
    nb_iot_default_paging_drx.to_json(j);
  }
  if (extended_ran_node_name_present) {
    j.write_fieldname("");
    extended_ran_node_name.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<ran_cfg_upd_fail_ies_o>;

ran_cfg_upd_fail_ies_container::ran_cfg_upd_fail_ies_container() :
  cause(15, crit_e::ignore), time_to_wait(107, crit_e::ignore), crit_diagnostics(19, crit_e::ignore)
{
}
SRSASN_CODE ran_cfg_upd_fail_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 1;
  nof_ies += time_to_wait_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(cause.pack(bref));
  if (time_to_wait_present) {
    HANDLE_CODE(time_to_wait.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ran_cfg_upd_fail_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 1;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 15: {
        nof_mandatory_ies--;
        cause.id = id;
        HANDLE_CODE(cause.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.value.unpack(bref));
        break;
      }
      case 107: {
        time_to_wait_present = true;
        time_to_wait.id      = id;
        HANDLE_CODE(time_to_wait.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(time_to_wait.value.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        crit_diagnostics.id      = id;
        HANDLE_CODE(crit_diagnostics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ran_cfg_upd_fail_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  cause.to_json(j);
  if (time_to_wait_present) {
    j.write_fieldname("");
    time_to_wait.to_json(j);
  }
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<rrc_inactive_transition_report_ies_o>;

rrc_inactive_transition_report_ies_container::rrc_inactive_transition_report_ies_container() :
  amf_ue_ngap_id(10, crit_e::reject),
  ran_ue_ngap_id(85, crit_e::reject),
  rrc_state(92, crit_e::ignore),
  user_location_info(121, crit_e::ignore)
{
}
SRSASN_CODE rrc_inactive_transition_report_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 4;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  HANDLE_CODE(rrc_state.pack(bref));
  HANDLE_CODE(user_location_info.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE rrc_inactive_transition_report_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 4;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 92: {
        nof_mandatory_ies--;
        rrc_state.id = id;
        HANDLE_CODE(rrc_state.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(rrc_state.value.unpack(bref));
        break;
      }
      case 121: {
        nof_mandatory_ies--;
        user_location_info.id = id;
        HANDLE_CODE(user_location_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(user_location_info.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void rrc_inactive_transition_report_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  rrc_state.to_json(j);
  j.write_fieldname("");
  user_location_info.to_json(j);
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<reroute_nas_request_ies_o>;

reroute_nas_request_ies_container::reroute_nas_request_ies_container() :
  ran_ue_ngap_id(85, crit_e::reject),
  amf_ue_ngap_id(10, crit_e::ignore),
  ngap_msg(42, crit_e::reject),
  amf_set_id(3, crit_e::reject),
  allowed_nssai(0, crit_e::reject),
  source_to_target_amf_info_reroute(171, crit_e::ignore)
{
}
SRSASN_CODE reroute_nas_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += amf_ue_ngap_id_present ? 1 : 0;
  nof_ies += allowed_nssai_present ? 1 : 0;
  nof_ies += source_to_target_amf_info_reroute_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  if (amf_ue_ngap_id_present) {
    HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  }
  HANDLE_CODE(ngap_msg.pack(bref));
  HANDLE_CODE(amf_set_id.pack(bref));
  if (allowed_nssai_present) {
    HANDLE_CODE(allowed_nssai.pack(bref));
  }
  if (source_to_target_amf_info_reroute_present) {
    HANDLE_CODE(source_to_target_amf_info_reroute.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE reroute_nas_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 10: {
        amf_ue_ngap_id_present = true;
        amf_ue_ngap_id.id      = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 42: {
        nof_mandatory_ies--;
        ngap_msg.id = id;
        HANDLE_CODE(ngap_msg.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ngap_msg.value.unpack(bref));
        break;
      }
      case 3: {
        nof_mandatory_ies--;
        amf_set_id.id = id;
        HANDLE_CODE(amf_set_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_set_id.value.unpack(bref));
        break;
      }
      case 0: {
        allowed_nssai_present = true;
        allowed_nssai.id      = id;
        HANDLE_CODE(allowed_nssai.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(allowed_nssai.value.unpack(bref));
        break;
      }
      case 171: {
        source_to_target_amf_info_reroute_present = true;
        source_to_target_amf_info_reroute.id      = id;
        HANDLE_CODE(source_to_target_amf_info_reroute.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(source_to_target_amf_info_reroute.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void reroute_nas_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  if (amf_ue_ngap_id_present) {
    j.write_fieldname("");
    amf_ue_ngap_id.to_json(j);
  }
  j.write_fieldname("");
  ngap_msg.to_json(j);
  j.write_fieldname("");
  amf_set_id.to_json(j);
  if (allowed_nssai_present) {
    j.write_fieldname("");
    allowed_nssai.to_json(j);
  }
  if (source_to_target_amf_info_reroute_present) {
    j.write_fieldname("");
    source_to_target_amf_info_reroute.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<secondary_rat_data_usage_report_ies_o>;

secondary_rat_data_usage_report_ies_container::secondary_rat_data_usage_report_ies_container() :
  amf_ue_ngap_id(10, crit_e::ignore),
  ran_ue_ngap_id(85, crit_e::ignore),
  pdu_session_res_secondary_rat_usage_list(142, crit_e::ignore),
  ho_flag(143, crit_e::ignore),
  user_location_info(121, crit_e::ignore)
{
}
SRSASN_CODE secondary_rat_data_usage_report_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += ho_flag_present ? 1 : 0;
  nof_ies += user_location_info_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  HANDLE_CODE(pdu_session_res_secondary_rat_usage_list.pack(bref));
  if (ho_flag_present) {
    HANDLE_CODE(ho_flag.pack(bref));
  }
  if (user_location_info_present) {
    HANDLE_CODE(user_location_info.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE secondary_rat_data_usage_report_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 142: {
        nof_mandatory_ies--;
        pdu_session_res_secondary_rat_usage_list.id = id;
        HANDLE_CODE(pdu_session_res_secondary_rat_usage_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pdu_session_res_secondary_rat_usage_list.value.unpack(bref));
        break;
      }
      case 143: {
        ho_flag_present = true;
        ho_flag.id      = id;
        HANDLE_CODE(ho_flag.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ho_flag.value.unpack(bref));
        break;
      }
      case 121: {
        user_location_info_present = true;
        user_location_info.id      = id;
        HANDLE_CODE(user_location_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(user_location_info.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void secondary_rat_data_usage_report_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  pdu_session_res_secondary_rat_usage_list.to_json(j);
  if (ho_flag_present) {
    j.write_fieldname("");
    ho_flag.to_json(j);
  }
  if (user_location_info_present) {
    j.write_fieldname("");
    user_location_info.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<trace_fail_ind_ies_o>;

trace_fail_ind_ies_container::trace_fail_ind_ies_container() :
  amf_ue_ngap_id(10, crit_e::reject),
  ran_ue_ngap_id(85, crit_e::reject),
  ngran_trace_id(44, crit_e::ignore),
  cause(15, crit_e::ignore)
{
}
SRSASN_CODE trace_fail_ind_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 4;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  HANDLE_CODE(ngran_trace_id.pack(bref));
  HANDLE_CODE(cause.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE trace_fail_ind_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 4;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 44: {
        nof_mandatory_ies--;
        ngran_trace_id.id = id;
        HANDLE_CODE(ngran_trace_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ngran_trace_id.value.unpack(bref));
        break;
      }
      case 15: {
        nof_mandatory_ies--;
        cause.id = id;
        HANDLE_CODE(cause.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void trace_fail_ind_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ngran_trace_id.to_json(j);
  j.write_fieldname("");
  cause.to_json(j);
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<trace_start_ies_o>;

trace_start_ies_container::trace_start_ies_container() :
  amf_ue_ngap_id(10, crit_e::reject), ran_ue_ngap_id(85, crit_e::reject), trace_activation(108, crit_e::ignore)
{
}
SRSASN_CODE trace_start_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  HANDLE_CODE(trace_activation.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE trace_start_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 108: {
        nof_mandatory_ies--;
        trace_activation.id = id;
        HANDLE_CODE(trace_activation.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(trace_activation.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void trace_start_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  trace_activation.to_json(j);
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<ue_context_mod_fail_ies_o>;

ue_context_mod_fail_ies_container::ue_context_mod_fail_ies_container() :
  amf_ue_ngap_id(10, crit_e::ignore),
  ran_ue_ngap_id(85, crit_e::ignore),
  cause(15, crit_e::ignore),
  crit_diagnostics(19, crit_e::ignore)
{
}
SRSASN_CODE ue_context_mod_fail_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  HANDLE_CODE(cause.pack(bref));
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_mod_fail_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 15: {
        nof_mandatory_ies--;
        cause.id = id;
        HANDLE_CODE(cause.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.value.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        crit_diagnostics.id      = id;
        HANDLE_CODE(crit_diagnostics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ue_context_mod_fail_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  cause.to_json(j);
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<ue_context_mod_request_ies_o>;

ue_context_mod_request_ies_container::ue_context_mod_request_ies_container() :
  amf_ue_ngap_id(10, crit_e::reject),
  ran_ue_ngap_id(85, crit_e::reject),
  ran_paging_prio(83, crit_e::ignore),
  security_key(94, crit_e::reject),
  idx_to_rfsp(31, crit_e::ignore),
  ue_aggr_max_bit_rate(110, crit_e::ignore),
  ue_security_cap(119, crit_e::reject),
  core_network_assist_info_for_inactive(18, crit_e::ignore),
  emergency_fallback_ind(24, crit_e::reject),
  new_amf_ue_ngap_id(40, crit_e::reject),
  rrc_inactive_transition_report_request(91, crit_e::ignore),
  new_guami(162, crit_e::reject),
  cn_assisted_ran_tuning(165, crit_e::ignore),
  srvcc_operation_possible(177, crit_e::ignore),
  iab_authorized(199, crit_e::ignore),
  nr_v2x_services_authorized(216, crit_e::ignore),
  ltev2x_services_authorized(215, crit_e::ignore),
  nr_ue_sidelink_aggr_max_bitrate(218, crit_e::ignore),
  lte_ue_sidelink_aggr_max_bitrate(217, crit_e::ignore),
  pc5_qos_params(219, crit_e::ignore),
  ue_radio_cap_id(264, crit_e::reject),
  rg_level_wireline_access_characteristics(238, crit_e::ignore),
  time_sync_assist_info(326, crit_e::ignore),
  q_mcc_onfig_info(328, crit_e::ignore),
  qmc_deactivation(329, crit_e::ignore),
  ue_slice_max_bit_rate_list(335, crit_e::ignore),
  management_based_mdt_plmn_mod_list(359, crit_e::ignore),
  five_g_pro_se_authorized(345, crit_e::ignore),
  five_g_pro_se_ue_pc5_aggr_max_bit_rate(346, crit_e::ignore),
  five_g_pro_se_pc5_qos_params(347, crit_e::ignore)
{
}
SRSASN_CODE ue_context_mod_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += ran_paging_prio_present ? 1 : 0;
  nof_ies += security_key_present ? 1 : 0;
  nof_ies += idx_to_rfsp_present ? 1 : 0;
  nof_ies += ue_aggr_max_bit_rate_present ? 1 : 0;
  nof_ies += ue_security_cap_present ? 1 : 0;
  nof_ies += core_network_assist_info_for_inactive_present ? 1 : 0;
  nof_ies += emergency_fallback_ind_present ? 1 : 0;
  nof_ies += new_amf_ue_ngap_id_present ? 1 : 0;
  nof_ies += rrc_inactive_transition_report_request_present ? 1 : 0;
  nof_ies += new_guami_present ? 1 : 0;
  nof_ies += cn_assisted_ran_tuning_present ? 1 : 0;
  nof_ies += srvcc_operation_possible_present ? 1 : 0;
  nof_ies += iab_authorized_present ? 1 : 0;
  nof_ies += nr_v2x_services_authorized_present ? 1 : 0;
  nof_ies += ltev2x_services_authorized_present ? 1 : 0;
  nof_ies += nr_ue_sidelink_aggr_max_bitrate_present ? 1 : 0;
  nof_ies += lte_ue_sidelink_aggr_max_bitrate_present ? 1 : 0;
  nof_ies += pc5_qos_params_present ? 1 : 0;
  nof_ies += ue_radio_cap_id_present ? 1 : 0;
  nof_ies += rg_level_wireline_access_characteristics_present ? 1 : 0;
  nof_ies += time_sync_assist_info_present ? 1 : 0;
  nof_ies += q_mcc_onfig_info_present ? 1 : 0;
  nof_ies += qmc_deactivation_present ? 1 : 0;
  nof_ies += ue_slice_max_bit_rate_list_present ? 1 : 0;
  nof_ies += management_based_mdt_plmn_mod_list_present ? 1 : 0;
  nof_ies += five_g_pro_se_authorized_present ? 1 : 0;
  nof_ies += five_g_pro_se_ue_pc5_aggr_max_bit_rate_present ? 1 : 0;
  nof_ies += five_g_pro_se_pc5_qos_params_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  if (ran_paging_prio_present) {
    HANDLE_CODE(ran_paging_prio.pack(bref));
  }
  if (security_key_present) {
    HANDLE_CODE(security_key.pack(bref));
  }
  if (idx_to_rfsp_present) {
    HANDLE_CODE(idx_to_rfsp.pack(bref));
  }
  if (ue_aggr_max_bit_rate_present) {
    HANDLE_CODE(ue_aggr_max_bit_rate.pack(bref));
  }
  if (ue_security_cap_present) {
    HANDLE_CODE(ue_security_cap.pack(bref));
  }
  if (core_network_assist_info_for_inactive_present) {
    HANDLE_CODE(core_network_assist_info_for_inactive.pack(bref));
  }
  if (emergency_fallback_ind_present) {
    HANDLE_CODE(emergency_fallback_ind.pack(bref));
  }
  if (new_amf_ue_ngap_id_present) {
    HANDLE_CODE(new_amf_ue_ngap_id.pack(bref));
  }
  if (rrc_inactive_transition_report_request_present) {
    HANDLE_CODE(rrc_inactive_transition_report_request.pack(bref));
  }
  if (new_guami_present) {
    HANDLE_CODE(new_guami.pack(bref));
  }
  if (cn_assisted_ran_tuning_present) {
    HANDLE_CODE(cn_assisted_ran_tuning.pack(bref));
  }
  if (srvcc_operation_possible_present) {
    HANDLE_CODE(srvcc_operation_possible.pack(bref));
  }
  if (iab_authorized_present) {
    HANDLE_CODE(iab_authorized.pack(bref));
  }
  if (nr_v2x_services_authorized_present) {
    HANDLE_CODE(nr_v2x_services_authorized.pack(bref));
  }
  if (ltev2x_services_authorized_present) {
    HANDLE_CODE(ltev2x_services_authorized.pack(bref));
  }
  if (nr_ue_sidelink_aggr_max_bitrate_present) {
    HANDLE_CODE(nr_ue_sidelink_aggr_max_bitrate.pack(bref));
  }
  if (lte_ue_sidelink_aggr_max_bitrate_present) {
    HANDLE_CODE(lte_ue_sidelink_aggr_max_bitrate.pack(bref));
  }
  if (pc5_qos_params_present) {
    HANDLE_CODE(pc5_qos_params.pack(bref));
  }
  if (ue_radio_cap_id_present) {
    HANDLE_CODE(ue_radio_cap_id.pack(bref));
  }
  if (rg_level_wireline_access_characteristics_present) {
    HANDLE_CODE(rg_level_wireline_access_characteristics.pack(bref));
  }
  if (time_sync_assist_info_present) {
    HANDLE_CODE(time_sync_assist_info.pack(bref));
  }
  if (q_mcc_onfig_info_present) {
    HANDLE_CODE(q_mcc_onfig_info.pack(bref));
  }
  if (qmc_deactivation_present) {
    HANDLE_CODE(qmc_deactivation.pack(bref));
  }
  if (ue_slice_max_bit_rate_list_present) {
    HANDLE_CODE(ue_slice_max_bit_rate_list.pack(bref));
  }
  if (management_based_mdt_plmn_mod_list_present) {
    HANDLE_CODE(management_based_mdt_plmn_mod_list.pack(bref));
  }
  if (five_g_pro_se_authorized_present) {
    HANDLE_CODE(five_g_pro_se_authorized.pack(bref));
  }
  if (five_g_pro_se_ue_pc5_aggr_max_bit_rate_present) {
    HANDLE_CODE(five_g_pro_se_ue_pc5_aggr_max_bit_rate.pack(bref));
  }
  if (five_g_pro_se_pc5_qos_params_present) {
    HANDLE_CODE(five_g_pro_se_pc5_qos_params.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_mod_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 83: {
        ran_paging_prio_present = true;
        ran_paging_prio.id      = id;
        HANDLE_CODE(ran_paging_prio.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_paging_prio.value.unpack(bref));
        break;
      }
      case 94: {
        security_key_present = true;
        security_key.id      = id;
        HANDLE_CODE(security_key.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(security_key.value.unpack(bref));
        break;
      }
      case 31: {
        idx_to_rfsp_present = true;
        idx_to_rfsp.id      = id;
        HANDLE_CODE(idx_to_rfsp.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(idx_to_rfsp.value.unpack(bref));
        break;
      }
      case 110: {
        ue_aggr_max_bit_rate_present = true;
        ue_aggr_max_bit_rate.id      = id;
        HANDLE_CODE(ue_aggr_max_bit_rate.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_aggr_max_bit_rate.value.unpack(bref));
        break;
      }
      case 119: {
        ue_security_cap_present = true;
        ue_security_cap.id      = id;
        HANDLE_CODE(ue_security_cap.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_security_cap.value.unpack(bref));
        break;
      }
      case 18: {
        core_network_assist_info_for_inactive_present = true;
        core_network_assist_info_for_inactive.id      = id;
        HANDLE_CODE(core_network_assist_info_for_inactive.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(core_network_assist_info_for_inactive.value.unpack(bref));
        break;
      }
      case 24: {
        emergency_fallback_ind_present = true;
        emergency_fallback_ind.id      = id;
        HANDLE_CODE(emergency_fallback_ind.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(emergency_fallback_ind.value.unpack(bref));
        break;
      }
      case 40: {
        new_amf_ue_ngap_id_present = true;
        new_amf_ue_ngap_id.id      = id;
        HANDLE_CODE(new_amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(new_amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 91: {
        rrc_inactive_transition_report_request_present = true;
        rrc_inactive_transition_report_request.id      = id;
        HANDLE_CODE(rrc_inactive_transition_report_request.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(rrc_inactive_transition_report_request.value.unpack(bref));
        break;
      }
      case 162: {
        new_guami_present = true;
        new_guami.id      = id;
        HANDLE_CODE(new_guami.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(new_guami.value.unpack(bref));
        break;
      }
      case 165: {
        cn_assisted_ran_tuning_present = true;
        cn_assisted_ran_tuning.id      = id;
        HANDLE_CODE(cn_assisted_ran_tuning.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cn_assisted_ran_tuning.value.unpack(bref));
        break;
      }
      case 177: {
        srvcc_operation_possible_present = true;
        srvcc_operation_possible.id      = id;
        HANDLE_CODE(srvcc_operation_possible.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(srvcc_operation_possible.value.unpack(bref));
        break;
      }
      case 199: {
        iab_authorized_present = true;
        iab_authorized.id      = id;
        HANDLE_CODE(iab_authorized.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(iab_authorized.value.unpack(bref));
        break;
      }
      case 216: {
        nr_v2x_services_authorized_present = true;
        nr_v2x_services_authorized.id      = id;
        HANDLE_CODE(nr_v2x_services_authorized.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nr_v2x_services_authorized.value.unpack(bref));
        break;
      }
      case 215: {
        ltev2x_services_authorized_present = true;
        ltev2x_services_authorized.id      = id;
        HANDLE_CODE(ltev2x_services_authorized.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ltev2x_services_authorized.value.unpack(bref));
        break;
      }
      case 218: {
        nr_ue_sidelink_aggr_max_bitrate_present = true;
        nr_ue_sidelink_aggr_max_bitrate.id      = id;
        HANDLE_CODE(nr_ue_sidelink_aggr_max_bitrate.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nr_ue_sidelink_aggr_max_bitrate.value.unpack(bref));
        break;
      }
      case 217: {
        lte_ue_sidelink_aggr_max_bitrate_present = true;
        lte_ue_sidelink_aggr_max_bitrate.id      = id;
        HANDLE_CODE(lte_ue_sidelink_aggr_max_bitrate.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(lte_ue_sidelink_aggr_max_bitrate.value.unpack(bref));
        break;
      }
      case 219: {
        pc5_qos_params_present = true;
        pc5_qos_params.id      = id;
        HANDLE_CODE(pc5_qos_params.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pc5_qos_params.value.unpack(bref));
        break;
      }
      case 264: {
        ue_radio_cap_id_present = true;
        ue_radio_cap_id.id      = id;
        HANDLE_CODE(ue_radio_cap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_radio_cap_id.value.unpack(bref));
        break;
      }
      case 238: {
        rg_level_wireline_access_characteristics_present = true;
        rg_level_wireline_access_characteristics.id      = id;
        HANDLE_CODE(rg_level_wireline_access_characteristics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(rg_level_wireline_access_characteristics.value.unpack(bref));
        break;
      }
      case 326: {
        time_sync_assist_info_present = true;
        time_sync_assist_info.id      = id;
        HANDLE_CODE(time_sync_assist_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(time_sync_assist_info.value.unpack(bref));
        break;
      }
      case 328: {
        q_mcc_onfig_info_present = true;
        q_mcc_onfig_info.id      = id;
        HANDLE_CODE(q_mcc_onfig_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(q_mcc_onfig_info.value.unpack(bref));
        break;
      }
      case 329: {
        qmc_deactivation_present = true;
        qmc_deactivation.id      = id;
        HANDLE_CODE(qmc_deactivation.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(qmc_deactivation.value.unpack(bref));
        break;
      }
      case 335: {
        ue_slice_max_bit_rate_list_present = true;
        ue_slice_max_bit_rate_list.id      = id;
        HANDLE_CODE(ue_slice_max_bit_rate_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_slice_max_bit_rate_list.value.unpack(bref));
        break;
      }
      case 359: {
        management_based_mdt_plmn_mod_list_present = true;
        management_based_mdt_plmn_mod_list.id      = id;
        HANDLE_CODE(management_based_mdt_plmn_mod_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(management_based_mdt_plmn_mod_list.value.unpack(bref));
        break;
      }
      case 345: {
        five_g_pro_se_authorized_present = true;
        five_g_pro_se_authorized.id      = id;
        HANDLE_CODE(five_g_pro_se_authorized.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(five_g_pro_se_authorized.value.unpack(bref));
        break;
      }
      case 346: {
        five_g_pro_se_ue_pc5_aggr_max_bit_rate_present = true;
        five_g_pro_se_ue_pc5_aggr_max_bit_rate.id      = id;
        HANDLE_CODE(five_g_pro_se_ue_pc5_aggr_max_bit_rate.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(five_g_pro_se_ue_pc5_aggr_max_bit_rate.value.unpack(bref));
        break;
      }
      case 347: {
        five_g_pro_se_pc5_qos_params_present = true;
        five_g_pro_se_pc5_qos_params.id      = id;
        HANDLE_CODE(five_g_pro_se_pc5_qos_params.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(five_g_pro_se_pc5_qos_params.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ue_context_mod_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  if (ran_paging_prio_present) {
    j.write_fieldname("");
    ran_paging_prio.to_json(j);
  }
  if (security_key_present) {
    j.write_fieldname("");
    security_key.to_json(j);
  }
  if (idx_to_rfsp_present) {
    j.write_fieldname("");
    idx_to_rfsp.to_json(j);
  }
  if (ue_aggr_max_bit_rate_present) {
    j.write_fieldname("");
    ue_aggr_max_bit_rate.to_json(j);
  }
  if (ue_security_cap_present) {
    j.write_fieldname("");
    ue_security_cap.to_json(j);
  }
  if (core_network_assist_info_for_inactive_present) {
    j.write_fieldname("");
    core_network_assist_info_for_inactive.to_json(j);
  }
  if (emergency_fallback_ind_present) {
    j.write_fieldname("");
    emergency_fallback_ind.to_json(j);
  }
  if (new_amf_ue_ngap_id_present) {
    j.write_fieldname("");
    new_amf_ue_ngap_id.to_json(j);
  }
  if (rrc_inactive_transition_report_request_present) {
    j.write_fieldname("");
    rrc_inactive_transition_report_request.to_json(j);
  }
  if (new_guami_present) {
    j.write_fieldname("");
    new_guami.to_json(j);
  }
  if (cn_assisted_ran_tuning_present) {
    j.write_fieldname("");
    cn_assisted_ran_tuning.to_json(j);
  }
  if (srvcc_operation_possible_present) {
    j.write_fieldname("");
    srvcc_operation_possible.to_json(j);
  }
  if (iab_authorized_present) {
    j.write_fieldname("");
    iab_authorized.to_json(j);
  }
  if (nr_v2x_services_authorized_present) {
    j.write_fieldname("");
    nr_v2x_services_authorized.to_json(j);
  }
  if (ltev2x_services_authorized_present) {
    j.write_fieldname("");
    ltev2x_services_authorized.to_json(j);
  }
  if (nr_ue_sidelink_aggr_max_bitrate_present) {
    j.write_fieldname("");
    nr_ue_sidelink_aggr_max_bitrate.to_json(j);
  }
  if (lte_ue_sidelink_aggr_max_bitrate_present) {
    j.write_fieldname("");
    lte_ue_sidelink_aggr_max_bitrate.to_json(j);
  }
  if (pc5_qos_params_present) {
    j.write_fieldname("");
    pc5_qos_params.to_json(j);
  }
  if (ue_radio_cap_id_present) {
    j.write_fieldname("");
    ue_radio_cap_id.to_json(j);
  }
  if (rg_level_wireline_access_characteristics_present) {
    j.write_fieldname("");
    rg_level_wireline_access_characteristics.to_json(j);
  }
  if (time_sync_assist_info_present) {
    j.write_fieldname("");
    time_sync_assist_info.to_json(j);
  }
  if (q_mcc_onfig_info_present) {
    j.write_fieldname("");
    q_mcc_onfig_info.to_json(j);
  }
  if (qmc_deactivation_present) {
    j.write_fieldname("");
    qmc_deactivation.to_json(j);
  }
  if (ue_slice_max_bit_rate_list_present) {
    j.write_fieldname("");
    ue_slice_max_bit_rate_list.to_json(j);
  }
  if (management_based_mdt_plmn_mod_list_present) {
    j.write_fieldname("");
    management_based_mdt_plmn_mod_list.to_json(j);
  }
  if (five_g_pro_se_authorized_present) {
    j.write_fieldname("");
    five_g_pro_se_authorized.to_json(j);
  }
  if (five_g_pro_se_ue_pc5_aggr_max_bit_rate_present) {
    j.write_fieldname("");
    five_g_pro_se_ue_pc5_aggr_max_bit_rate.to_json(j);
  }
  if (five_g_pro_se_pc5_qos_params_present) {
    j.write_fieldname("");
    five_g_pro_se_pc5_qos_params.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<ue_context_mod_resp_ies_o>;

ue_context_mod_resp_ies_container::ue_context_mod_resp_ies_container() :
  amf_ue_ngap_id(10, crit_e::ignore),
  ran_ue_ngap_id(85, crit_e::ignore),
  rrc_state(92, crit_e::ignore),
  user_location_info(121, crit_e::ignore),
  crit_diagnostics(19, crit_e::ignore)
{
}
SRSASN_CODE ue_context_mod_resp_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += rrc_state_present ? 1 : 0;
  nof_ies += user_location_info_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  if (rrc_state_present) {
    HANDLE_CODE(rrc_state.pack(bref));
  }
  if (user_location_info_present) {
    HANDLE_CODE(user_location_info.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_mod_resp_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 92: {
        rrc_state_present = true;
        rrc_state.id      = id;
        HANDLE_CODE(rrc_state.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(rrc_state.value.unpack(bref));
        break;
      }
      case 121: {
        user_location_info_present = true;
        user_location_info.id      = id;
        HANDLE_CODE(user_location_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(user_location_info.value.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        crit_diagnostics.id      = id;
        HANDLE_CODE(crit_diagnostics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ue_context_mod_resp_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  if (rrc_state_present) {
    j.write_fieldname("");
    rrc_state.to_json(j);
  }
  if (user_location_info_present) {
    j.write_fieldname("");
    user_location_info.to_json(j);
  }
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<ue_context_release_cmd_ies_o>;

ue_context_release_cmd_ies_container::ue_context_release_cmd_ies_container() :
  ue_ngap_ids(114, crit_e::reject), cause(15, crit_e::ignore)
{
}
SRSASN_CODE ue_context_release_cmd_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(ue_ngap_ids.pack(bref));
  HANDLE_CODE(cause.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_release_cmd_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 114: {
        nof_mandatory_ies--;
        ue_ngap_ids.id = id;
        HANDLE_CODE(ue_ngap_ids.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_ngap_ids.value.unpack(bref));
        break;
      }
      case 15: {
        nof_mandatory_ies--;
        cause.id = id;
        HANDLE_CODE(cause.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ue_context_release_cmd_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  ue_ngap_ids.to_json(j);
  j.write_fieldname("");
  cause.to_json(j);
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<ue_context_release_complete_ies_o>;

ue_context_release_complete_ies_container::ue_context_release_complete_ies_container() :
  amf_ue_ngap_id(10, crit_e::ignore),
  ran_ue_ngap_id(85, crit_e::ignore),
  user_location_info(121, crit_e::ignore),
  info_on_recommended_cells_and_ran_nodes_for_paging(32, crit_e::ignore),
  pdu_session_res_list_cxt_rel_cpl(60, crit_e::reject),
  crit_diagnostics(19, crit_e::ignore),
  paging_assis_datafor_c_ecapab_ue(207, crit_e::ignore)
{
}
SRSASN_CODE ue_context_release_complete_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += user_location_info_present ? 1 : 0;
  nof_ies += info_on_recommended_cells_and_ran_nodes_for_paging_present ? 1 : 0;
  nof_ies += pdu_session_res_list_cxt_rel_cpl_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  nof_ies += paging_assis_datafor_c_ecapab_ue_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  if (user_location_info_present) {
    HANDLE_CODE(user_location_info.pack(bref));
  }
  if (info_on_recommended_cells_and_ran_nodes_for_paging_present) {
    HANDLE_CODE(info_on_recommended_cells_and_ran_nodes_for_paging.pack(bref));
  }
  if (pdu_session_res_list_cxt_rel_cpl_present) {
    HANDLE_CODE(pdu_session_res_list_cxt_rel_cpl.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }
  if (paging_assis_datafor_c_ecapab_ue_present) {
    HANDLE_CODE(paging_assis_datafor_c_ecapab_ue.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_release_complete_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 121: {
        user_location_info_present = true;
        user_location_info.id      = id;
        HANDLE_CODE(user_location_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(user_location_info.value.unpack(bref));
        break;
      }
      case 32: {
        info_on_recommended_cells_and_ran_nodes_for_paging_present = true;
        info_on_recommended_cells_and_ran_nodes_for_paging.id      = id;
        HANDLE_CODE(info_on_recommended_cells_and_ran_nodes_for_paging.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(info_on_recommended_cells_and_ran_nodes_for_paging.value.unpack(bref));
        break;
      }
      case 60: {
        pdu_session_res_list_cxt_rel_cpl_present = true;
        pdu_session_res_list_cxt_rel_cpl.id      = id;
        HANDLE_CODE(pdu_session_res_list_cxt_rel_cpl.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pdu_session_res_list_cxt_rel_cpl.value.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        crit_diagnostics.id      = id;
        HANDLE_CODE(crit_diagnostics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.value.unpack(bref));
        break;
      }
      case 207: {
        paging_assis_datafor_c_ecapab_ue_present = true;
        paging_assis_datafor_c_ecapab_ue.id      = id;
        HANDLE_CODE(paging_assis_datafor_c_ecapab_ue.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(paging_assis_datafor_c_ecapab_ue.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ue_context_release_complete_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  if (user_location_info_present) {
    j.write_fieldname("");
    user_location_info.to_json(j);
  }
  if (info_on_recommended_cells_and_ran_nodes_for_paging_present) {
    j.write_fieldname("");
    info_on_recommended_cells_and_ran_nodes_for_paging.to_json(j);
  }
  if (pdu_session_res_list_cxt_rel_cpl_present) {
    j.write_fieldname("");
    pdu_session_res_list_cxt_rel_cpl.to_json(j);
  }
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  if (paging_assis_datafor_c_ecapab_ue_present) {
    j.write_fieldname("");
    paging_assis_datafor_c_ecapab_ue.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<ue_context_release_request_ies_o>;

ue_context_release_request_ies_container::ue_context_release_request_ies_container() :
  amf_ue_ngap_id(10, crit_e::reject),
  ran_ue_ngap_id(85, crit_e::reject),
  pdu_session_res_list_cxt_rel_req(133, crit_e::reject),
  cause(15, crit_e::ignore)
{
}
SRSASN_CODE ue_context_release_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += pdu_session_res_list_cxt_rel_req_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  if (pdu_session_res_list_cxt_rel_req_present) {
    HANDLE_CODE(pdu_session_res_list_cxt_rel_req.pack(bref));
  }
  HANDLE_CODE(cause.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_release_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 133: {
        pdu_session_res_list_cxt_rel_req_present = true;
        pdu_session_res_list_cxt_rel_req.id      = id;
        HANDLE_CODE(pdu_session_res_list_cxt_rel_req.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pdu_session_res_list_cxt_rel_req.value.unpack(bref));
        break;
      }
      case 15: {
        nof_mandatory_ies--;
        cause.id = id;
        HANDLE_CODE(cause.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ue_context_release_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  if (pdu_session_res_list_cxt_rel_req_present) {
    j.write_fieldname("");
    pdu_session_res_list_cxt_rel_req.to_json(j);
  }
  j.write_fieldname("");
  cause.to_json(j);
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<ue_context_resume_fail_ies_o>;

ue_context_resume_fail_ies_container::ue_context_resume_fail_ies_container() :
  amf_ue_ngap_id(10, crit_e::ignore),
  ran_ue_ngap_id(85, crit_e::ignore),
  cause(15, crit_e::ignore),
  crit_diagnostics(19, crit_e::ignore)
{
}
SRSASN_CODE ue_context_resume_fail_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  HANDLE_CODE(cause.pack(bref));
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_resume_fail_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 15: {
        nof_mandatory_ies--;
        cause.id = id;
        HANDLE_CODE(cause.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.value.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        crit_diagnostics.id      = id;
        HANDLE_CODE(crit_diagnostics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ue_context_resume_fail_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  cause.to_json(j);
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<ue_context_resume_request_ies_o>;

ue_context_resume_request_ies_container::ue_context_resume_request_ies_container() :
  amf_ue_ngap_id(10, crit_e::reject),
  ran_ue_ngap_id(85, crit_e::reject),
  rrc_resume_cause(237, crit_e::ignore),
  pdu_session_res_resume_list_res_req(232, crit_e::reject),
  pdu_session_res_failed_to_resume_list_res_req(229, crit_e::reject),
  suspend_request_ind(235, crit_e::ignore),
  info_on_recommended_cells_and_ran_nodes_for_paging(32, crit_e::ignore),
  paging_assis_datafor_c_ecapab_ue(207, crit_e::ignore)
{
}
SRSASN_CODE ue_context_resume_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += pdu_session_res_resume_list_res_req_present ? 1 : 0;
  nof_ies += pdu_session_res_failed_to_resume_list_res_req_present ? 1 : 0;
  nof_ies += suspend_request_ind_present ? 1 : 0;
  nof_ies += info_on_recommended_cells_and_ran_nodes_for_paging_present ? 1 : 0;
  nof_ies += paging_assis_datafor_c_ecapab_ue_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  HANDLE_CODE(rrc_resume_cause.pack(bref));
  if (pdu_session_res_resume_list_res_req_present) {
    HANDLE_CODE(pdu_session_res_resume_list_res_req.pack(bref));
  }
  if (pdu_session_res_failed_to_resume_list_res_req_present) {
    HANDLE_CODE(pdu_session_res_failed_to_resume_list_res_req.pack(bref));
  }
  if (suspend_request_ind_present) {
    HANDLE_CODE(suspend_request_ind.pack(bref));
  }
  if (info_on_recommended_cells_and_ran_nodes_for_paging_present) {
    HANDLE_CODE(info_on_recommended_cells_and_ran_nodes_for_paging.pack(bref));
  }
  if (paging_assis_datafor_c_ecapab_ue_present) {
    HANDLE_CODE(paging_assis_datafor_c_ecapab_ue.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_resume_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 237: {
        nof_mandatory_ies--;
        rrc_resume_cause.id = id;
        HANDLE_CODE(rrc_resume_cause.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(rrc_resume_cause.value.unpack(bref));
        break;
      }
      case 232: {
        pdu_session_res_resume_list_res_req_present = true;
        pdu_session_res_resume_list_res_req.id      = id;
        HANDLE_CODE(pdu_session_res_resume_list_res_req.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pdu_session_res_resume_list_res_req.value.unpack(bref));
        break;
      }
      case 229: {
        pdu_session_res_failed_to_resume_list_res_req_present = true;
        pdu_session_res_failed_to_resume_list_res_req.id      = id;
        HANDLE_CODE(pdu_session_res_failed_to_resume_list_res_req.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pdu_session_res_failed_to_resume_list_res_req.value.unpack(bref));
        break;
      }
      case 235: {
        suspend_request_ind_present = true;
        suspend_request_ind.id      = id;
        HANDLE_CODE(suspend_request_ind.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(suspend_request_ind.value.unpack(bref));
        break;
      }
      case 32: {
        info_on_recommended_cells_and_ran_nodes_for_paging_present = true;
        info_on_recommended_cells_and_ran_nodes_for_paging.id      = id;
        HANDLE_CODE(info_on_recommended_cells_and_ran_nodes_for_paging.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(info_on_recommended_cells_and_ran_nodes_for_paging.value.unpack(bref));
        break;
      }
      case 207: {
        paging_assis_datafor_c_ecapab_ue_present = true;
        paging_assis_datafor_c_ecapab_ue.id      = id;
        HANDLE_CODE(paging_assis_datafor_c_ecapab_ue.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(paging_assis_datafor_c_ecapab_ue.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ue_context_resume_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  rrc_resume_cause.to_json(j);
  if (pdu_session_res_resume_list_res_req_present) {
    j.write_fieldname("");
    pdu_session_res_resume_list_res_req.to_json(j);
  }
  if (pdu_session_res_failed_to_resume_list_res_req_present) {
    j.write_fieldname("");
    pdu_session_res_failed_to_resume_list_res_req.to_json(j);
  }
  if (suspend_request_ind_present) {
    j.write_fieldname("");
    suspend_request_ind.to_json(j);
  }
  if (info_on_recommended_cells_and_ran_nodes_for_paging_present) {
    j.write_fieldname("");
    info_on_recommended_cells_and_ran_nodes_for_paging.to_json(j);
  }
  if (paging_assis_datafor_c_ecapab_ue_present) {
    j.write_fieldname("");
    paging_assis_datafor_c_ecapab_ue.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<ue_context_resume_resp_ies_o>;

ue_context_resume_resp_ies_container::ue_context_resume_resp_ies_container() :
  amf_ue_ngap_id(10, crit_e::ignore),
  ran_ue_ngap_id(85, crit_e::ignore),
  pdu_session_res_resume_list_res_res(233, crit_e::reject),
  pdu_session_res_failed_to_resume_list_res_res(230, crit_e::reject),
  security_context(93, crit_e::reject),
  suspend_resp_ind(236, crit_e::ignore),
  extended_connected_time(206, crit_e::ignore),
  crit_diagnostics(19, crit_e::ignore)
{
}
SRSASN_CODE ue_context_resume_resp_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += pdu_session_res_resume_list_res_res_present ? 1 : 0;
  nof_ies += pdu_session_res_failed_to_resume_list_res_res_present ? 1 : 0;
  nof_ies += security_context_present ? 1 : 0;
  nof_ies += suspend_resp_ind_present ? 1 : 0;
  nof_ies += extended_connected_time_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  if (pdu_session_res_resume_list_res_res_present) {
    HANDLE_CODE(pdu_session_res_resume_list_res_res.pack(bref));
  }
  if (pdu_session_res_failed_to_resume_list_res_res_present) {
    HANDLE_CODE(pdu_session_res_failed_to_resume_list_res_res.pack(bref));
  }
  if (security_context_present) {
    HANDLE_CODE(security_context.pack(bref));
  }
  if (suspend_resp_ind_present) {
    HANDLE_CODE(suspend_resp_ind.pack(bref));
  }
  if (extended_connected_time_present) {
    HANDLE_CODE(extended_connected_time.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_resume_resp_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 233: {
        pdu_session_res_resume_list_res_res_present = true;
        pdu_session_res_resume_list_res_res.id      = id;
        HANDLE_CODE(pdu_session_res_resume_list_res_res.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pdu_session_res_resume_list_res_res.value.unpack(bref));
        break;
      }
      case 230: {
        pdu_session_res_failed_to_resume_list_res_res_present = true;
        pdu_session_res_failed_to_resume_list_res_res.id      = id;
        HANDLE_CODE(pdu_session_res_failed_to_resume_list_res_res.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pdu_session_res_failed_to_resume_list_res_res.value.unpack(bref));
        break;
      }
      case 93: {
        security_context_present = true;
        security_context.id      = id;
        HANDLE_CODE(security_context.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(security_context.value.unpack(bref));
        break;
      }
      case 236: {
        suspend_resp_ind_present = true;
        suspend_resp_ind.id      = id;
        HANDLE_CODE(suspend_resp_ind.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(suspend_resp_ind.value.unpack(bref));
        break;
      }
      case 206: {
        extended_connected_time_present = true;
        extended_connected_time.id      = id;
        HANDLE_CODE(extended_connected_time.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(extended_connected_time.value.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        crit_diagnostics.id      = id;
        HANDLE_CODE(crit_diagnostics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ue_context_resume_resp_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  if (pdu_session_res_resume_list_res_res_present) {
    j.write_fieldname("");
    pdu_session_res_resume_list_res_res.to_json(j);
  }
  if (pdu_session_res_failed_to_resume_list_res_res_present) {
    j.write_fieldname("");
    pdu_session_res_failed_to_resume_list_res_res.to_json(j);
  }
  if (security_context_present) {
    j.write_fieldname("");
    security_context.to_json(j);
  }
  if (suspend_resp_ind_present) {
    j.write_fieldname("");
    suspend_resp_ind.to_json(j);
  }
  if (extended_connected_time_present) {
    j.write_fieldname("");
    extended_connected_time.to_json(j);
  }
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<ue_context_suspend_fail_ies_o>;

ue_context_suspend_fail_ies_container::ue_context_suspend_fail_ies_container() :
  amf_ue_ngap_id(10, crit_e::ignore),
  ran_ue_ngap_id(85, crit_e::ignore),
  cause(15, crit_e::ignore),
  crit_diagnostics(19, crit_e::ignore)
{
}
SRSASN_CODE ue_context_suspend_fail_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  HANDLE_CODE(cause.pack(bref));
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_suspend_fail_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 15: {
        nof_mandatory_ies--;
        cause.id = id;
        HANDLE_CODE(cause.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.value.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        crit_diagnostics.id      = id;
        HANDLE_CODE(crit_diagnostics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ue_context_suspend_fail_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  cause.to_json(j);
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<ue_context_suspend_request_ies_o>;

ue_context_suspend_request_ies_container::ue_context_suspend_request_ies_container() :
  amf_ue_ngap_id(10, crit_e::reject),
  ran_ue_ngap_id(85, crit_e::reject),
  info_on_recommended_cells_and_ran_nodes_for_paging(32, crit_e::ignore),
  paging_assis_datafor_c_ecapab_ue(207, crit_e::ignore),
  pdu_session_res_suspend_list_sus_req(231, crit_e::reject)
{
}
SRSASN_CODE ue_context_suspend_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += info_on_recommended_cells_and_ran_nodes_for_paging_present ? 1 : 0;
  nof_ies += paging_assis_datafor_c_ecapab_ue_present ? 1 : 0;
  nof_ies += pdu_session_res_suspend_list_sus_req_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  if (info_on_recommended_cells_and_ran_nodes_for_paging_present) {
    HANDLE_CODE(info_on_recommended_cells_and_ran_nodes_for_paging.pack(bref));
  }
  if (paging_assis_datafor_c_ecapab_ue_present) {
    HANDLE_CODE(paging_assis_datafor_c_ecapab_ue.pack(bref));
  }
  if (pdu_session_res_suspend_list_sus_req_present) {
    HANDLE_CODE(pdu_session_res_suspend_list_sus_req.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_suspend_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 32: {
        info_on_recommended_cells_and_ran_nodes_for_paging_present = true;
        info_on_recommended_cells_and_ran_nodes_for_paging.id      = id;
        HANDLE_CODE(info_on_recommended_cells_and_ran_nodes_for_paging.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(info_on_recommended_cells_and_ran_nodes_for_paging.value.unpack(bref));
        break;
      }
      case 207: {
        paging_assis_datafor_c_ecapab_ue_present = true;
        paging_assis_datafor_c_ecapab_ue.id      = id;
        HANDLE_CODE(paging_assis_datafor_c_ecapab_ue.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(paging_assis_datafor_c_ecapab_ue.value.unpack(bref));
        break;
      }
      case 231: {
        pdu_session_res_suspend_list_sus_req_present = true;
        pdu_session_res_suspend_list_sus_req.id      = id;
        HANDLE_CODE(pdu_session_res_suspend_list_sus_req.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pdu_session_res_suspend_list_sus_req.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ue_context_suspend_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  if (info_on_recommended_cells_and_ran_nodes_for_paging_present) {
    j.write_fieldname("");
    info_on_recommended_cells_and_ran_nodes_for_paging.to_json(j);
  }
  if (paging_assis_datafor_c_ecapab_ue_present) {
    j.write_fieldname("");
    paging_assis_datafor_c_ecapab_ue.to_json(j);
  }
  if (pdu_session_res_suspend_list_sus_req_present) {
    j.write_fieldname("");
    pdu_session_res_suspend_list_sus_req.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<ue_context_suspend_resp_ies_o>;

ue_context_suspend_resp_ies_container::ue_context_suspend_resp_ies_container() :
  amf_ue_ngap_id(10, crit_e::ignore),
  ran_ue_ngap_id(85, crit_e::ignore),
  security_context(93, crit_e::reject),
  crit_diagnostics(19, crit_e::ignore)
{
}
SRSASN_CODE ue_context_suspend_resp_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += security_context_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  if (security_context_present) {
    HANDLE_CODE(security_context.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_suspend_resp_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 93: {
        security_context_present = true;
        security_context.id      = id;
        HANDLE_CODE(security_context.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(security_context.value.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        crit_diagnostics.id      = id;
        HANDLE_CODE(crit_diagnostics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ue_context_suspend_resp_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  if (security_context_present) {
    j.write_fieldname("");
    security_context.to_json(j);
  }
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<ue_info_transfer_ies_o>;

ue_info_transfer_ies_container::ue_info_transfer_ies_container() :
  five_g_s_tmsi(26, crit_e::reject),
  nb_iot_ue_prio(210, crit_e::ignore),
  ue_radio_cap(117, crit_e::ignore),
  s_nssai(148, crit_e::ignore),
  allowed_nssai(0, crit_e::ignore),
  ue_diff_info(209, crit_e::ignore),
  masked_imeisv(34, crit_e::ignore)
{
}
SRSASN_CODE ue_info_transfer_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 1;
  nof_ies += nb_iot_ue_prio_present ? 1 : 0;
  nof_ies += ue_radio_cap_present ? 1 : 0;
  nof_ies += s_nssai_present ? 1 : 0;
  nof_ies += allowed_nssai_present ? 1 : 0;
  nof_ies += ue_diff_info_present ? 1 : 0;
  nof_ies += masked_imeisv_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(five_g_s_tmsi.pack(bref));
  if (nb_iot_ue_prio_present) {
    HANDLE_CODE(nb_iot_ue_prio.pack(bref));
  }
  if (ue_radio_cap_present) {
    HANDLE_CODE(ue_radio_cap.pack(bref));
  }
  if (s_nssai_present) {
    HANDLE_CODE(s_nssai.pack(bref));
  }
  if (allowed_nssai_present) {
    HANDLE_CODE(allowed_nssai.pack(bref));
  }
  if (ue_diff_info_present) {
    HANDLE_CODE(ue_diff_info.pack(bref));
  }
  if (masked_imeisv_present) {
    HANDLE_CODE(masked_imeisv.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_info_transfer_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 1;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 26: {
        nof_mandatory_ies--;
        five_g_s_tmsi.id = id;
        HANDLE_CODE(five_g_s_tmsi.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(five_g_s_tmsi.value.unpack(bref));
        break;
      }
      case 210: {
        nb_iot_ue_prio_present = true;
        nb_iot_ue_prio.id      = id;
        HANDLE_CODE(nb_iot_ue_prio.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nb_iot_ue_prio.value.unpack(bref));
        break;
      }
      case 117: {
        ue_radio_cap_present = true;
        ue_radio_cap.id      = id;
        HANDLE_CODE(ue_radio_cap.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_radio_cap.value.unpack(bref));
        break;
      }
      case 148: {
        s_nssai_present = true;
        s_nssai.id      = id;
        HANDLE_CODE(s_nssai.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(s_nssai.value.unpack(bref));
        break;
      }
      case 0: {
        allowed_nssai_present = true;
        allowed_nssai.id      = id;
        HANDLE_CODE(allowed_nssai.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(allowed_nssai.value.unpack(bref));
        break;
      }
      case 209: {
        ue_diff_info_present = true;
        ue_diff_info.id      = id;
        HANDLE_CODE(ue_diff_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_diff_info.value.unpack(bref));
        break;
      }
      case 34: {
        masked_imeisv_present = true;
        masked_imeisv.id      = id;
        HANDLE_CODE(masked_imeisv.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(masked_imeisv.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ue_info_transfer_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  five_g_s_tmsi.to_json(j);
  if (nb_iot_ue_prio_present) {
    j.write_fieldname("");
    nb_iot_ue_prio.to_json(j);
  }
  if (ue_radio_cap_present) {
    j.write_fieldname("");
    ue_radio_cap.to_json(j);
  }
  if (s_nssai_present) {
    j.write_fieldname("");
    s_nssai.to_json(j);
  }
  if (allowed_nssai_present) {
    j.write_fieldname("");
    allowed_nssai.to_json(j);
  }
  if (ue_diff_info_present) {
    j.write_fieldname("");
    ue_diff_info.to_json(j);
  }
  if (masked_imeisv_present) {
    j.write_fieldname("");
    masked_imeisv.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<ue_radio_cap_check_request_ies_o>;

ue_radio_cap_check_request_ies_container::ue_radio_cap_check_request_ies_container() :
  amf_ue_ngap_id(10, crit_e::reject),
  ran_ue_ngap_id(85, crit_e::reject),
  ue_radio_cap(117, crit_e::ignore),
  ue_radio_cap_id(264, crit_e::reject)
{
}
SRSASN_CODE ue_radio_cap_check_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += ue_radio_cap_present ? 1 : 0;
  nof_ies += ue_radio_cap_id_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  if (ue_radio_cap_present) {
    HANDLE_CODE(ue_radio_cap.pack(bref));
  }
  if (ue_radio_cap_id_present) {
    HANDLE_CODE(ue_radio_cap_id.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_radio_cap_check_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 117: {
        ue_radio_cap_present = true;
        ue_radio_cap.id      = id;
        HANDLE_CODE(ue_radio_cap.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_radio_cap.value.unpack(bref));
        break;
      }
      case 264: {
        ue_radio_cap_id_present = true;
        ue_radio_cap_id.id      = id;
        HANDLE_CODE(ue_radio_cap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_radio_cap_id.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ue_radio_cap_check_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  if (ue_radio_cap_present) {
    j.write_fieldname("");
    ue_radio_cap.to_json(j);
  }
  if (ue_radio_cap_id_present) {
    j.write_fieldname("");
    ue_radio_cap_id.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<ue_radio_cap_check_resp_ies_o>;

ue_radio_cap_check_resp_ies_container::ue_radio_cap_check_resp_ies_container() :
  amf_ue_ngap_id(10, crit_e::ignore),
  ran_ue_ngap_id(85, crit_e::ignore),
  ims_voice_support_ind(30, crit_e::reject),
  crit_diagnostics(19, crit_e::ignore)
{
}
SRSASN_CODE ue_radio_cap_check_resp_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  HANDLE_CODE(ims_voice_support_ind.pack(bref));
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_radio_cap_check_resp_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 30: {
        nof_mandatory_ies--;
        ims_voice_support_ind.id = id;
        HANDLE_CODE(ims_voice_support_ind.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ims_voice_support_ind.value.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        crit_diagnostics.id      = id;
        HANDLE_CODE(crit_diagnostics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ue_radio_cap_check_resp_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ims_voice_support_ind.to_json(j);
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<ue_radio_cap_id_map_resp_ies_o>;

ue_radio_cap_id_map_resp_ies_container::ue_radio_cap_id_map_resp_ies_container() :
  ue_radio_cap_id(264, crit_e::reject), ue_radio_cap(117, crit_e::ignore), crit_diagnostics(19, crit_e::ignore)
{
}
SRSASN_CODE ue_radio_cap_id_map_resp_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(ue_radio_cap_id.pack(bref));
  HANDLE_CODE(ue_radio_cap.pack(bref));
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_radio_cap_id_map_resp_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 264: {
        nof_mandatory_ies--;
        ue_radio_cap_id.id = id;
        HANDLE_CODE(ue_radio_cap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_radio_cap_id.value.unpack(bref));
        break;
      }
      case 117: {
        nof_mandatory_ies--;
        ue_radio_cap.id = id;
        HANDLE_CODE(ue_radio_cap.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_radio_cap.value.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        crit_diagnostics.id      = id;
        HANDLE_CODE(crit_diagnostics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ue_radio_cap_id_map_resp_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  ue_radio_cap_id.to_json(j);
  j.write_fieldname("");
  ue_radio_cap.to_json(j);
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<ue_radio_cap_info_ind_ies_o>;

ue_radio_cap_info_ind_ies_container::ue_radio_cap_info_ind_ies_container() :
  amf_ue_ngap_id(10, crit_e::reject),
  ran_ue_ngap_id(85, crit_e::reject),
  ue_radio_cap(117, crit_e::ignore),
  ue_radio_cap_for_paging(118, crit_e::ignore),
  ue_radio_cap_eutra_format(265, crit_e::ignore)
{
}
SRSASN_CODE ue_radio_cap_info_ind_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += ue_radio_cap_for_paging_present ? 1 : 0;
  nof_ies += ue_radio_cap_eutra_format_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  HANDLE_CODE(ue_radio_cap.pack(bref));
  if (ue_radio_cap_for_paging_present) {
    HANDLE_CODE(ue_radio_cap_for_paging.pack(bref));
  }
  if (ue_radio_cap_eutra_format_present) {
    HANDLE_CODE(ue_radio_cap_eutra_format.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_radio_cap_info_ind_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 117: {
        nof_mandatory_ies--;
        ue_radio_cap.id = id;
        HANDLE_CODE(ue_radio_cap.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_radio_cap.value.unpack(bref));
        break;
      }
      case 118: {
        ue_radio_cap_for_paging_present = true;
        ue_radio_cap_for_paging.id      = id;
        HANDLE_CODE(ue_radio_cap_for_paging.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_radio_cap_for_paging.value.unpack(bref));
        break;
      }
      case 265: {
        ue_radio_cap_eutra_format_present = true;
        ue_radio_cap_eutra_format.id      = id;
        HANDLE_CODE(ue_radio_cap_eutra_format.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_radio_cap_eutra_format.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ue_radio_cap_info_ind_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ue_radio_cap.to_json(j);
  if (ue_radio_cap_for_paging_present) {
    j.write_fieldname("");
    ue_radio_cap_for_paging.to_json(j);
  }
  if (ue_radio_cap_eutra_format_present) {
    j.write_fieldname("");
    ue_radio_cap_eutra_format.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<ue_tnla_binding_release_request_ies_o>;

ue_tnla_binding_release_request_ies_container::ue_tnla_binding_release_request_ies_container() :
  amf_ue_ngap_id(10, crit_e::reject), ran_ue_ngap_id(85, crit_e::reject)
{
}
SRSASN_CODE ue_tnla_binding_release_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_tnla_binding_release_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ue_tnla_binding_release_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<ul_nas_transport_ies_o>;

ul_nas_transport_ies_container::ul_nas_transport_ies_container() :
  amf_ue_ngap_id(10, crit_e::reject),
  ran_ue_ngap_id(85, crit_e::reject),
  nas_pdu(38, crit_e::reject),
  user_location_info(121, crit_e::ignore),
  w_agf_id_info(239, crit_e::reject),
  tngf_id_info(246, crit_e::reject),
  twif_id_info(247, crit_e::reject)
{
}
SRSASN_CODE ul_nas_transport_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 4;
  nof_ies += w_agf_id_info_present ? 1 : 0;
  nof_ies += tngf_id_info_present ? 1 : 0;
  nof_ies += twif_id_info_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  HANDLE_CODE(nas_pdu.pack(bref));
  HANDLE_CODE(user_location_info.pack(bref));
  if (w_agf_id_info_present) {
    HANDLE_CODE(w_agf_id_info.pack(bref));
  }
  if (tngf_id_info_present) {
    HANDLE_CODE(tngf_id_info.pack(bref));
  }
  if (twif_id_info_present) {
    HANDLE_CODE(twif_id_info.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ul_nas_transport_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 4;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 38: {
        nof_mandatory_ies--;
        nas_pdu.id = id;
        HANDLE_CODE(nas_pdu.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nas_pdu.value.unpack(bref));
        break;
      }
      case 121: {
        nof_mandatory_ies--;
        user_location_info.id = id;
        HANDLE_CODE(user_location_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(user_location_info.value.unpack(bref));
        break;
      }
      case 239: {
        w_agf_id_info_present = true;
        w_agf_id_info.id      = id;
        HANDLE_CODE(w_agf_id_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(w_agf_id_info.value.unpack(bref));
        break;
      }
      case 246: {
        tngf_id_info_present = true;
        tngf_id_info.id      = id;
        HANDLE_CODE(tngf_id_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(tngf_id_info.value.unpack(bref));
        break;
      }
      case 247: {
        twif_id_info_present = true;
        twif_id_info.id      = id;
        HANDLE_CODE(twif_id_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(twif_id_info.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ul_nas_transport_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  nas_pdu.to_json(j);
  j.write_fieldname("");
  user_location_info.to_json(j);
  if (w_agf_id_info_present) {
    j.write_fieldname("");
    w_agf_id_info.to_json(j);
  }
  if (tngf_id_info_present) {
    j.write_fieldname("");
    tngf_id_info.to_json(j);
  }
  if (twif_id_info_present) {
    j.write_fieldname("");
    twif_id_info.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<ul_non_ue_associated_nrppa_transport_ies_o>;

ul_non_ue_associated_nrppa_transport_ies_container::ul_non_ue_associated_nrppa_transport_ies_container() :
  routing_id(89, crit_e::reject), nrppa_pdu(46, crit_e::reject)
{
}
SRSASN_CODE ul_non_ue_associated_nrppa_transport_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(routing_id.pack(bref));
  HANDLE_CODE(nrppa_pdu.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE ul_non_ue_associated_nrppa_transport_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 89: {
        nof_mandatory_ies--;
        routing_id.id = id;
        HANDLE_CODE(routing_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(routing_id.value.unpack(bref));
        break;
      }
      case 46: {
        nof_mandatory_ies--;
        nrppa_pdu.id = id;
        HANDLE_CODE(nrppa_pdu.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nrppa_pdu.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ul_non_ue_associated_nrppa_transport_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  routing_id.to_json(j);
  j.write_fieldname("");
  nrppa_pdu.to_json(j);
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<ul_ran_cfg_transfer_ies_o>;

ul_ran_cfg_transfer_ies_container::ul_ran_cfg_transfer_ies_container() :
  son_cfg_transfer_ul(99, crit_e::ignore),
  endc_son_cfg_transfer_ul(158, crit_e::ignore),
  intersys_son_cfg_transfer_ul(251, crit_e::ignore)
{
}
SRSASN_CODE ul_ran_cfg_transfer_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += son_cfg_transfer_ul_present ? 1 : 0;
  nof_ies += endc_son_cfg_transfer_ul_present ? 1 : 0;
  nof_ies += intersys_son_cfg_transfer_ul_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  if (son_cfg_transfer_ul_present) {
    HANDLE_CODE(son_cfg_transfer_ul.pack(bref));
  }
  if (endc_son_cfg_transfer_ul_present) {
    HANDLE_CODE(endc_son_cfg_transfer_ul.pack(bref));
  }
  if (intersys_son_cfg_transfer_ul_present) {
    HANDLE_CODE(intersys_son_cfg_transfer_ul.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ul_ran_cfg_transfer_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 99: {
        son_cfg_transfer_ul_present = true;
        son_cfg_transfer_ul.id      = id;
        HANDLE_CODE(son_cfg_transfer_ul.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(son_cfg_transfer_ul.value.unpack(bref));
        break;
      }
      case 158: {
        endc_son_cfg_transfer_ul_present = true;
        endc_son_cfg_transfer_ul.id      = id;
        HANDLE_CODE(endc_son_cfg_transfer_ul.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(endc_son_cfg_transfer_ul.value.unpack(bref));
        break;
      }
      case 251: {
        intersys_son_cfg_transfer_ul_present = true;
        intersys_son_cfg_transfer_ul.id      = id;
        HANDLE_CODE(intersys_son_cfg_transfer_ul.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(intersys_son_cfg_transfer_ul.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void ul_ran_cfg_transfer_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (son_cfg_transfer_ul_present) {
    j.write_fieldname("");
    son_cfg_transfer_ul.to_json(j);
  }
  if (endc_son_cfg_transfer_ul_present) {
    j.write_fieldname("");
    endc_son_cfg_transfer_ul.to_json(j);
  }
  if (intersys_son_cfg_transfer_ul_present) {
    j.write_fieldname("");
    intersys_son_cfg_transfer_ul.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<ul_ran_early_status_transfer_ies_o>;

ul_ran_early_status_transfer_ies_container::ul_ran_early_status_transfer_ies_container() :
  amf_ue_ngap_id(10, crit_e::reject),
  ran_ue_ngap_id(85, crit_e::reject),
  early_status_transfer_transparent_container(268, crit_e::reject)
{
}
SRSASN_CODE ul_ran_early_status_transfer_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  HANDLE_CODE(early_status_transfer_transparent_container.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE ul_ran_early_status_transfer_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 268: {
        nof_mandatory_ies--;
        early_status_transfer_transparent_container.id = id;
        HANDLE_CODE(early_status_transfer_transparent_container.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(early_status_transfer_transparent_container.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ul_ran_early_status_transfer_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  early_status_transfer_transparent_container.to_json(j);
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<ul_ran_status_transfer_ies_o>;

ul_ran_status_transfer_ies_container::ul_ran_status_transfer_ies_container() :
  amf_ue_ngap_id(10, crit_e::reject),
  ran_ue_ngap_id(85, crit_e::reject),
  ran_status_transfer_transparent_container(84, crit_e::reject)
{
}
SRSASN_CODE ul_ran_status_transfer_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_status_transfer_transparent_container.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE ul_ran_status_transfer_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 84: {
        nof_mandatory_ies--;
        ran_status_transfer_transparent_container.id = id;
        HANDLE_CODE(ran_status_transfer_transparent_container.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_status_transfer_transparent_container.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ul_ran_status_transfer_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_status_transfer_transparent_container.to_json(j);
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<ul_ue_associated_nrppa_transport_ies_o>;

ul_ue_associated_nrppa_transport_ies_container::ul_ue_associated_nrppa_transport_ies_container() :
  amf_ue_ngap_id(10, crit_e::reject),
  ran_ue_ngap_id(85, crit_e::reject),
  routing_id(89, crit_e::reject),
  nrppa_pdu(46, crit_e::reject)
{
}
SRSASN_CODE ul_ue_associated_nrppa_transport_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 4;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  HANDLE_CODE(routing_id.pack(bref));
  HANDLE_CODE(nrppa_pdu.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE ul_ue_associated_nrppa_transport_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 4;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 89: {
        nof_mandatory_ies--;
        routing_id.id = id;
        HANDLE_CODE(routing_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(routing_id.value.unpack(bref));
        break;
      }
      case 46: {
        nof_mandatory_ies--;
        nrppa_pdu.id = id;
        HANDLE_CODE(nrppa_pdu.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nrppa_pdu.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ul_ue_associated_nrppa_transport_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  routing_id.to_json(j);
  j.write_fieldname("");
  nrppa_pdu.to_json(j);
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<write_replace_warning_request_ies_o>;

write_replace_warning_request_ies_container::write_replace_warning_request_ies_container() :
  msg_id(35, crit_e::reject),
  serial_num(95, crit_e::reject),
  warning_area_list(122, crit_e::ignore),
  repeat_period(87, crit_e::reject),
  nof_broadcasts_requested(47, crit_e::reject),
  warning_type(125, crit_e::ignore),
  warning_security_info(124, crit_e::ignore),
  data_coding_scheme(20, crit_e::ignore),
  warning_msg_contents(123, crit_e::ignore),
  concurrent_warning_msg_ind(17, crit_e::reject),
  warning_area_coordinates(141, crit_e::ignore)
{
}
SRSASN_CODE write_replace_warning_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 4;
  nof_ies += warning_area_list_present ? 1 : 0;
  nof_ies += warning_type_present ? 1 : 0;
  nof_ies += warning_security_info_present ? 1 : 0;
  nof_ies += data_coding_scheme_present ? 1 : 0;
  nof_ies += warning_msg_contents_present ? 1 : 0;
  nof_ies += concurrent_warning_msg_ind_present ? 1 : 0;
  nof_ies += warning_area_coordinates_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(msg_id.pack(bref));
  HANDLE_CODE(serial_num.pack(bref));
  if (warning_area_list_present) {
    HANDLE_CODE(warning_area_list.pack(bref));
  }
  HANDLE_CODE(repeat_period.pack(bref));
  HANDLE_CODE(nof_broadcasts_requested.pack(bref));
  if (warning_type_present) {
    HANDLE_CODE(warning_type.pack(bref));
  }
  if (warning_security_info_present) {
    HANDLE_CODE(warning_security_info.pack(bref));
  }
  if (data_coding_scheme_present) {
    HANDLE_CODE(data_coding_scheme.pack(bref));
  }
  if (warning_msg_contents_present) {
    HANDLE_CODE(warning_msg_contents.pack(bref));
  }
  if (concurrent_warning_msg_ind_present) {
    HANDLE_CODE(concurrent_warning_msg_ind.pack(bref));
  }
  if (warning_area_coordinates_present) {
    HANDLE_CODE(warning_area_coordinates.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE write_replace_warning_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 4;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 35: {
        nof_mandatory_ies--;
        msg_id.id = id;
        HANDLE_CODE(msg_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(msg_id.value.unpack(bref));
        break;
      }
      case 95: {
        nof_mandatory_ies--;
        serial_num.id = id;
        HANDLE_CODE(serial_num.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(serial_num.value.unpack(bref));
        break;
      }
      case 122: {
        warning_area_list_present = true;
        warning_area_list.id      = id;
        HANDLE_CODE(warning_area_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(warning_area_list.value.unpack(bref));
        break;
      }
      case 87: {
        nof_mandatory_ies--;
        repeat_period.id = id;
        HANDLE_CODE(repeat_period.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(repeat_period.value.unpack(bref));
        break;
      }
      case 47: {
        nof_mandatory_ies--;
        nof_broadcasts_requested.id = id;
        HANDLE_CODE(nof_broadcasts_requested.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nof_broadcasts_requested.value.unpack(bref));
        break;
      }
      case 125: {
        warning_type_present = true;
        warning_type.id      = id;
        HANDLE_CODE(warning_type.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(warning_type.value.unpack(bref));
        break;
      }
      case 124: {
        warning_security_info_present = true;
        warning_security_info.id      = id;
        HANDLE_CODE(warning_security_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(warning_security_info.value.unpack(bref));
        break;
      }
      case 20: {
        data_coding_scheme_present = true;
        data_coding_scheme.id      = id;
        HANDLE_CODE(data_coding_scheme.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(data_coding_scheme.value.unpack(bref));
        break;
      }
      case 123: {
        warning_msg_contents_present = true;
        warning_msg_contents.id      = id;
        HANDLE_CODE(warning_msg_contents.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(warning_msg_contents.value.unpack(bref));
        break;
      }
      case 17: {
        concurrent_warning_msg_ind_present = true;
        concurrent_warning_msg_ind.id      = id;
        HANDLE_CODE(concurrent_warning_msg_ind.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(concurrent_warning_msg_ind.value.unpack(bref));
        break;
      }
      case 141: {
        warning_area_coordinates_present = true;
        warning_area_coordinates.id      = id;
        HANDLE_CODE(warning_area_coordinates.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(warning_area_coordinates.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void write_replace_warning_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  msg_id.to_json(j);
  j.write_fieldname("");
  serial_num.to_json(j);
  if (warning_area_list_present) {
    j.write_fieldname("");
    warning_area_list.to_json(j);
  }
  j.write_fieldname("");
  repeat_period.to_json(j);
  j.write_fieldname("");
  nof_broadcasts_requested.to_json(j);
  if (warning_type_present) {
    j.write_fieldname("");
    warning_type.to_json(j);
  }
  if (warning_security_info_present) {
    j.write_fieldname("");
    warning_security_info.to_json(j);
  }
  if (data_coding_scheme_present) {
    j.write_fieldname("");
    data_coding_scheme.to_json(j);
  }
  if (warning_msg_contents_present) {
    j.write_fieldname("");
    warning_msg_contents.to_json(j);
  }
  if (concurrent_warning_msg_ind_present) {
    j.write_fieldname("");
    concurrent_warning_msg_ind.to_json(j);
  }
  if (warning_area_coordinates_present) {
    j.write_fieldname("");
    warning_area_coordinates.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ie_field_s<write_replace_warning_resp_ies_o>;

write_replace_warning_resp_ies_container::write_replace_warning_resp_ies_container() :
  msg_id(35, crit_e::reject),
  serial_num(95, crit_e::reject),
  broadcast_completed_area_list(13, crit_e::ignore),
  crit_diagnostics(19, crit_e::ignore)
{
}
SRSASN_CODE write_replace_warning_resp_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += broadcast_completed_area_list_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(msg_id.pack(bref));
  HANDLE_CODE(serial_num.pack(bref));
  if (broadcast_completed_area_list_present) {
    HANDLE_CODE(broadcast_completed_area_list.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE write_replace_warning_resp_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 35: {
        nof_mandatory_ies--;
        msg_id.id = id;
        HANDLE_CODE(msg_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(msg_id.value.unpack(bref));
        break;
      }
      case 95: {
        nof_mandatory_ies--;
        serial_num.id = id;
        HANDLE_CODE(serial_num.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(serial_num.value.unpack(bref));
        break;
      }
      case 13: {
        broadcast_completed_area_list_present = true;
        broadcast_completed_area_list.id      = id;
        HANDLE_CODE(broadcast_completed_area_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(broadcast_completed_area_list.value.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        crit_diagnostics.id      = id;
        HANDLE_CODE(crit_diagnostics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void write_replace_warning_resp_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  msg_id.to_json(j);
  j.write_fieldname("");
  serial_num.to_json(j);
  if (broadcast_completed_area_list_present) {
    j.write_fieldname("");
    broadcast_completed_area_list.to_json(j);
  }
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

// NGAP-ELEMENTARY-PROCEDURES ::= OBJECT SET OF NGAP-ELEMENTARY-PROCEDURE
uint16_t ngap_elem_procs_o::idx_to_proc_code(uint32_t idx)
{
  static const uint16_t names[] = {0,  66, 67, 68, 69, 70, 10, 12, 13, 14, 71, 72, 73, 20, 21, 25, 26, 27, 28,
                                   29, 32, 35, 40, 41, 58, 59, 43, 60, 51, 64, 1,  75, 2,  65, 3,  4,  5,  6,
                                   63, 7,  54, 8,  9,  11, 61, 15, 18, 16, 17, 74, 19, 22, 23, 24, 30, 31, 33,
                                   34, 57, 36, 55, 37, 52, 38, 39, 42, 56, 44, 45, 46, 47, 48, 62, 49, 53, 50};
  return map_enum_number(names, 76, idx, "proc_code");
}
bool ngap_elem_procs_o::is_proc_code_valid(const uint16_t& proc_code)
{
  static const uint16_t names[] = {0,  66, 67, 68, 69, 70, 10, 12, 13, 14, 71, 72, 73, 20, 21, 25, 26, 27, 28,
                                   29, 32, 35, 40, 41, 58, 59, 43, 60, 51, 64, 1,  75, 2,  65, 3,  4,  5,  6,
                                   63, 7,  54, 8,  9,  11, 61, 15, 18, 16, 17, 74, 19, 22, 23, 24, 30, 31, 33,
                                   34, 57, 36, 55, 37, 52, 38, 39, 42, 56, 44, 45, 46, 47, 48, 62, 49, 53, 50};
  for (const auto& o : names) {
    if (o == proc_code) {
      return true;
    }
  }
  return false;
}
ngap_elem_procs_o::init_msg_c ngap_elem_procs_o::get_init_msg(const uint16_t& proc_code)
{
  init_msg_c ret{};
  switch (proc_code) {
    case 0:
      ret.set(init_msg_c::types::amf_cfg_upd);
      break;
    case 66:
      ret.set(init_msg_c::types::broadcast_session_mod_request);
      break;
    case 67:
      ret.set(init_msg_c::types::broadcast_session_release_request);
      break;
    case 68:
      ret.set(init_msg_c::types::broadcast_session_setup_request);
      break;
    case 69:
      ret.set(init_msg_c::types::distribution_setup_request);
      break;
    case 70:
      ret.set(init_msg_c::types::distribution_release_request);
      break;
    case 10:
      ret.set(init_msg_c::types::ho_cancel);
      break;
    case 12:
      ret.set(init_msg_c::types::ho_required);
      break;
    case 13:
      ret.set(init_msg_c::types::ho_request);
      break;
    case 14:
      ret.set(init_msg_c::types::init_context_setup_request);
      break;
    case 71:
      ret.set(init_msg_c::types::multicast_session_activation_request);
      break;
    case 72:
      ret.set(init_msg_c::types::multicast_session_deactivation_request);
      break;
    case 73:
      ret.set(init_msg_c::types::multicast_session_upd_request);
      break;
    case 20:
      ret.set(init_msg_c::types::ng_reset);
      break;
    case 21:
      ret.set(init_msg_c::types::ng_setup_request);
      break;
    case 25:
      ret.set(init_msg_c::types::path_switch_request);
      break;
    case 26:
      ret.set(init_msg_c::types::pdu_session_res_modify_request);
      break;
    case 27:
      ret.set(init_msg_c::types::pdu_session_res_modify_ind);
      break;
    case 28:
      ret.set(init_msg_c::types::pdu_session_res_release_cmd);
      break;
    case 29:
      ret.set(init_msg_c::types::pdu_session_res_setup_request);
      break;
    case 32:
      ret.set(init_msg_c::types::pws_cancel_request);
      break;
    case 35:
      ret.set(init_msg_c::types::ran_cfg_upd);
      break;
    case 40:
      ret.set(init_msg_c::types::ue_context_mod_request);
      break;
    case 41:
      ret.set(init_msg_c::types::ue_context_release_cmd);
      break;
    case 58:
      ret.set(init_msg_c::types::ue_context_resume_request);
      break;
    case 59:
      ret.set(init_msg_c::types::ue_context_suspend_request);
      break;
    case 43:
      ret.set(init_msg_c::types::ue_radio_cap_check_request);
      break;
    case 60:
      ret.set(init_msg_c::types::ue_radio_cap_id_map_request);
      break;
    case 51:
      ret.set(init_msg_c::types::write_replace_warning_request);
      break;
    case 64:
      ret.set(init_msg_c::types::amf_cp_relocation_ind);
      break;
    case 1:
      ret.set(init_msg_c::types::amf_status_ind);
      break;
    case 75:
      ret.set(init_msg_c::types::broadcast_session_release_required);
      break;
    case 2:
      ret.set(init_msg_c::types::cell_traffic_trace);
      break;
    case 65:
      ret.set(init_msg_c::types::conn_establishment_ind);
      break;
    case 3:
      ret.set(init_msg_c::types::deactiv_trace);
      break;
    case 4:
      ret.set(init_msg_c::types::dl_nas_transport);
      break;
    case 5:
      ret.set(init_msg_c::types::dl_non_ue_associated_nrppa_transport);
      break;
    case 6:
      ret.set(init_msg_c::types::dl_ran_cfg_transfer);
      break;
    case 63:
      ret.set(init_msg_c::types::dl_ran_early_status_transfer);
      break;
    case 7:
      ret.set(init_msg_c::types::dl_ran_status_transfer);
      break;
    case 54:
      ret.set(init_msg_c::types::dl_rim_info_transfer);
      break;
    case 8:
      ret.set(init_msg_c::types::dl_ue_associated_nrppa_transport);
      break;
    case 9:
      ret.set(init_msg_c::types::error_ind);
      break;
    case 11:
      ret.set(init_msg_c::types::ho_notify);
      break;
    case 61:
      ret.set(init_msg_c::types::ho_success);
      break;
    case 15:
      ret.set(init_msg_c::types::init_ue_msg);
      break;
    case 18:
      ret.set(init_msg_c::types::location_report);
      break;
    case 16:
      ret.set(init_msg_c::types::location_report_ctrl);
      break;
    case 17:
      ret.set(init_msg_c::types::location_report_fail_ind);
      break;
    case 74:
      ret.set(init_msg_c::types::multicast_group_paging);
      break;
    case 19:
      ret.set(init_msg_c::types::nas_non_delivery_ind);
      break;
    case 22:
      ret.set(init_msg_c::types::overload_start);
      break;
    case 23:
      ret.set(init_msg_c::types::overload_stop);
      break;
    case 24:
      ret.set(init_msg_c::types::paging);
      break;
    case 30:
      ret.set(init_msg_c::types::pdu_session_res_notify);
      break;
    case 31:
      ret.set(init_msg_c::types::private_msg);
      break;
    case 33:
      ret.set(init_msg_c::types::pws_fail_ind);
      break;
    case 34:
      ret.set(init_msg_c::types::pws_restart_ind);
      break;
    case 57:
      ret.set(init_msg_c::types::ran_cp_relocation_ind);
      break;
    case 36:
      ret.set(init_msg_c::types::reroute_nas_request);
      break;
    case 55:
      ret.set(init_msg_c::types::retrieve_ue_info);
      break;
    case 37:
      ret.set(init_msg_c::types::rrc_inactive_transition_report);
      break;
    case 52:
      ret.set(init_msg_c::types::secondary_rat_data_usage_report);
      break;
    case 38:
      ret.set(init_msg_c::types::trace_fail_ind);
      break;
    case 39:
      ret.set(init_msg_c::types::trace_start);
      break;
    case 42:
      ret.set(init_msg_c::types::ue_context_release_request);
      break;
    case 56:
      ret.set(init_msg_c::types::ue_info_transfer);
      break;
    case 44:
      ret.set(init_msg_c::types::ue_radio_cap_info_ind);
      break;
    case 45:
      ret.set(init_msg_c::types::ue_tnla_binding_release_request);
      break;
    case 46:
      ret.set(init_msg_c::types::ul_nas_transport);
      break;
    case 47:
      ret.set(init_msg_c::types::ul_non_ue_associated_nrppa_transport);
      break;
    case 48:
      ret.set(init_msg_c::types::ul_ran_cfg_transfer);
      break;
    case 62:
      ret.set(init_msg_c::types::ul_ran_early_status_transfer);
      break;
    case 49:
      ret.set(init_msg_c::types::ul_ran_status_transfer);
      break;
    case 53:
      ret.set(init_msg_c::types::ul_rim_info_transfer);
      break;
    case 50:
      ret.set(init_msg_c::types::ul_ue_associated_nrppa_transport);
      break;
    default:
      asn1::log_error("The proc_code={} is not recognized", proc_code);
  }
  return ret;
}
ngap_elem_procs_o::successful_outcome_c ngap_elem_procs_o::get_successful_outcome(const uint16_t& proc_code)
{
  successful_outcome_c ret{};
  switch (proc_code) {
    case 0:
      ret.set(successful_outcome_c::types::amf_cfg_upd_ack);
      break;
    case 66:
      ret.set(successful_outcome_c::types::broadcast_session_mod_resp);
      break;
    case 67:
      ret.set(successful_outcome_c::types::broadcast_session_release_resp);
      break;
    case 68:
      ret.set(successful_outcome_c::types::broadcast_session_setup_resp);
      break;
    case 69:
      ret.set(successful_outcome_c::types::distribution_setup_resp);
      break;
    case 70:
      ret.set(successful_outcome_c::types::distribution_release_resp);
      break;
    case 10:
      ret.set(successful_outcome_c::types::ho_cancel_ack);
      break;
    case 12:
      ret.set(successful_outcome_c::types::ho_cmd);
      break;
    case 13:
      ret.set(successful_outcome_c::types::ho_request_ack);
      break;
    case 14:
      ret.set(successful_outcome_c::types::init_context_setup_resp);
      break;
    case 71:
      ret.set(successful_outcome_c::types::multicast_session_activation_resp);
      break;
    case 72:
      ret.set(successful_outcome_c::types::multicast_session_deactivation_resp);
      break;
    case 73:
      ret.set(successful_outcome_c::types::multicast_session_upd_resp);
      break;
    case 20:
      ret.set(successful_outcome_c::types::ng_reset_ack);
      break;
    case 21:
      ret.set(successful_outcome_c::types::ng_setup_resp);
      break;
    case 25:
      ret.set(successful_outcome_c::types::path_switch_request_ack);
      break;
    case 26:
      ret.set(successful_outcome_c::types::pdu_session_res_modify_resp);
      break;
    case 27:
      ret.set(successful_outcome_c::types::pdu_session_res_modify_confirm);
      break;
    case 28:
      ret.set(successful_outcome_c::types::pdu_session_res_release_resp);
      break;
    case 29:
      ret.set(successful_outcome_c::types::pdu_session_res_setup_resp);
      break;
    case 32:
      ret.set(successful_outcome_c::types::pws_cancel_resp);
      break;
    case 35:
      ret.set(successful_outcome_c::types::ran_cfg_upd_ack);
      break;
    case 40:
      ret.set(successful_outcome_c::types::ue_context_mod_resp);
      break;
    case 41:
      ret.set(successful_outcome_c::types::ue_context_release_complete);
      break;
    case 58:
      ret.set(successful_outcome_c::types::ue_context_resume_resp);
      break;
    case 59:
      ret.set(successful_outcome_c::types::ue_context_suspend_resp);
      break;
    case 43:
      ret.set(successful_outcome_c::types::ue_radio_cap_check_resp);
      break;
    case 60:
      ret.set(successful_outcome_c::types::ue_radio_cap_id_map_resp);
      break;
    case 51:
      ret.set(successful_outcome_c::types::write_replace_warning_resp);
      break;
    default:
      asn1::log_error("The proc_code={} is not recognized", proc_code);
  }
  return ret;
}
ngap_elem_procs_o::unsuccessful_outcome_c ngap_elem_procs_o::get_unsuccessful_outcome(const uint16_t& proc_code)
{
  unsuccessful_outcome_c ret{};
  switch (proc_code) {
    case 0:
      ret.set(unsuccessful_outcome_c::types::amf_cfg_upd_fail);
      break;
    case 66:
      ret.set(unsuccessful_outcome_c::types::broadcast_session_mod_fail);
      break;
    case 68:
      ret.set(unsuccessful_outcome_c::types::broadcast_session_setup_fail);
      break;
    case 69:
      ret.set(unsuccessful_outcome_c::types::distribution_setup_fail);
      break;
    case 12:
      ret.set(unsuccessful_outcome_c::types::ho_prep_fail);
      break;
    case 13:
      ret.set(unsuccessful_outcome_c::types::ho_fail);
      break;
    case 14:
      ret.set(unsuccessful_outcome_c::types::init_context_setup_fail);
      break;
    case 71:
      ret.set(unsuccessful_outcome_c::types::multicast_session_activation_fail);
      break;
    case 73:
      ret.set(unsuccessful_outcome_c::types::multicast_session_upd_fail);
      break;
    case 21:
      ret.set(unsuccessful_outcome_c::types::ng_setup_fail);
      break;
    case 25:
      ret.set(unsuccessful_outcome_c::types::path_switch_request_fail);
      break;
    case 35:
      ret.set(unsuccessful_outcome_c::types::ran_cfg_upd_fail);
      break;
    case 40:
      ret.set(unsuccessful_outcome_c::types::ue_context_mod_fail);
      break;
    case 58:
      ret.set(unsuccessful_outcome_c::types::ue_context_resume_fail);
      break;
    case 59:
      ret.set(unsuccessful_outcome_c::types::ue_context_suspend_fail);
      break;
    default:
      asn1::log_error("The proc_code={} is not recognized", proc_code);
  }
  return ret;
}
crit_e ngap_elem_procs_o::get_crit(const uint16_t& proc_code)
{
  switch (proc_code) {
    case 0:
      return crit_e::reject;
    case 66:
      return crit_e::reject;
    case 67:
      return crit_e::reject;
    case 68:
      return crit_e::reject;
    case 69:
      return crit_e::reject;
    case 70:
      return crit_e::reject;
    case 10:
      return crit_e::reject;
    case 12:
      return crit_e::reject;
    case 13:
      return crit_e::reject;
    case 14:
      return crit_e::reject;
    case 71:
      return crit_e::reject;
    case 72:
      return crit_e::reject;
    case 73:
      return crit_e::reject;
    case 20:
      return crit_e::reject;
    case 21:
      return crit_e::reject;
    case 25:
      return crit_e::reject;
    case 26:
      return crit_e::reject;
    case 27:
      return crit_e::reject;
    case 28:
      return crit_e::reject;
    case 29:
      return crit_e::reject;
    case 32:
      return crit_e::reject;
    case 35:
      return crit_e::reject;
    case 40:
      return crit_e::reject;
    case 41:
      return crit_e::reject;
    case 58:
      return crit_e::reject;
    case 59:
      return crit_e::reject;
    case 43:
      return crit_e::reject;
    case 60:
      return crit_e::reject;
    case 51:
      return crit_e::reject;
    case 64:
      return crit_e::reject;
    case 1:
      return crit_e::ignore;
    case 75:
      return crit_e::reject;
    case 2:
      return crit_e::ignore;
    case 65:
      return crit_e::reject;
    case 3:
      return crit_e::ignore;
    case 4:
      return crit_e::ignore;
    case 5:
      return crit_e::ignore;
    case 6:
      return crit_e::ignore;
    case 63:
      return crit_e::ignore;
    case 7:
      return crit_e::ignore;
    case 54:
      return crit_e::ignore;
    case 8:
      return crit_e::ignore;
    case 9:
      return crit_e::ignore;
    case 11:
      return crit_e::ignore;
    case 61:
      return crit_e::ignore;
    case 15:
      return crit_e::ignore;
    case 18:
      return crit_e::ignore;
    case 16:
      return crit_e::ignore;
    case 17:
      return crit_e::ignore;
    case 74:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    case 22:
      return crit_e::ignore;
    case 23:
      return crit_e::reject;
    case 24:
      return crit_e::ignore;
    case 30:
      return crit_e::ignore;
    case 31:
      return crit_e::ignore;
    case 33:
      return crit_e::ignore;
    case 34:
      return crit_e::ignore;
    case 57:
      return crit_e::reject;
    case 36:
      return crit_e::reject;
    case 55:
      return crit_e::reject;
    case 37:
      return crit_e::ignore;
    case 52:
      return crit_e::ignore;
    case 38:
      return crit_e::ignore;
    case 39:
      return crit_e::ignore;
    case 42:
      return crit_e::ignore;
    case 56:
      return crit_e::reject;
    case 44:
      return crit_e::ignore;
    case 45:
      return crit_e::ignore;
    case 46:
      return crit_e::ignore;
    case 47:
      return crit_e::ignore;
    case 48:
      return crit_e::ignore;
    case 62:
      return crit_e::reject;
    case 49:
      return crit_e::ignore;
    case 53:
      return crit_e::ignore;
    case 50:
      return crit_e::ignore;
    default:
      asn1::log_error("The proc_code={} is not recognized", proc_code);
  }
  return {};
}

// InitiatingMessage ::= OPEN TYPE
void ngap_elem_procs_o::init_msg_c::destroy_()
{
  switch (type_) {
    case types::amf_cfg_upd:
      c.destroy<amf_cfg_upd_s>();
      break;
    case types::broadcast_session_mod_request:
      c.destroy<broadcast_session_mod_request_s>();
      break;
    case types::broadcast_session_release_request:
      c.destroy<broadcast_session_release_request_s>();
      break;
    case types::broadcast_session_setup_request:
      c.destroy<broadcast_session_setup_request_s>();
      break;
    case types::distribution_setup_request:
      c.destroy<distribution_setup_request_s>();
      break;
    case types::distribution_release_request:
      c.destroy<distribution_release_request_s>();
      break;
    case types::ho_cancel:
      c.destroy<ho_cancel_s>();
      break;
    case types::ho_required:
      c.destroy<ho_required_s>();
      break;
    case types::ho_request:
      c.destroy<ho_request_s>();
      break;
    case types::init_context_setup_request:
      c.destroy<init_context_setup_request_s>();
      break;
    case types::multicast_session_activation_request:
      c.destroy<multicast_session_activation_request_s>();
      break;
    case types::multicast_session_deactivation_request:
      c.destroy<multicast_session_deactivation_request_s>();
      break;
    case types::multicast_session_upd_request:
      c.destroy<multicast_session_upd_request_s>();
      break;
    case types::ng_reset:
      c.destroy<ng_reset_s>();
      break;
    case types::ng_setup_request:
      c.destroy<ng_setup_request_s>();
      break;
    case types::path_switch_request:
      c.destroy<path_switch_request_s>();
      break;
    case types::pdu_session_res_modify_request:
      c.destroy<pdu_session_res_modify_request_s>();
      break;
    case types::pdu_session_res_modify_ind:
      c.destroy<pdu_session_res_modify_ind_s>();
      break;
    case types::pdu_session_res_release_cmd:
      c.destroy<pdu_session_res_release_cmd_s>();
      break;
    case types::pdu_session_res_setup_request:
      c.destroy<pdu_session_res_setup_request_s>();
      break;
    case types::pws_cancel_request:
      c.destroy<pws_cancel_request_s>();
      break;
    case types::ran_cfg_upd:
      c.destroy<ran_cfg_upd_s>();
      break;
    case types::ue_context_mod_request:
      c.destroy<ue_context_mod_request_s>();
      break;
    case types::ue_context_release_cmd:
      c.destroy<ue_context_release_cmd_s>();
      break;
    case types::ue_context_resume_request:
      c.destroy<ue_context_resume_request_s>();
      break;
    case types::ue_context_suspend_request:
      c.destroy<ue_context_suspend_request_s>();
      break;
    case types::ue_radio_cap_check_request:
      c.destroy<ue_radio_cap_check_request_s>();
      break;
    case types::ue_radio_cap_id_map_request:
      c.destroy<ue_radio_cap_id_map_request_s>();
      break;
    case types::write_replace_warning_request:
      c.destroy<write_replace_warning_request_s>();
      break;
    case types::amf_cp_relocation_ind:
      c.destroy<amf_cp_relocation_ind_s>();
      break;
    case types::amf_status_ind:
      c.destroy<amf_status_ind_s>();
      break;
    case types::broadcast_session_release_required:
      c.destroy<broadcast_session_release_required_s>();
      break;
    case types::cell_traffic_trace:
      c.destroy<cell_traffic_trace_s>();
      break;
    case types::conn_establishment_ind:
      c.destroy<conn_establishment_ind_s>();
      break;
    case types::deactiv_trace:
      c.destroy<deactiv_trace_s>();
      break;
    case types::dl_nas_transport:
      c.destroy<dl_nas_transport_s>();
      break;
    case types::dl_non_ue_associated_nrppa_transport:
      c.destroy<dl_non_ue_associated_nrppa_transport_s>();
      break;
    case types::dl_ran_cfg_transfer:
      c.destroy<dl_ran_cfg_transfer_s>();
      break;
    case types::dl_ran_early_status_transfer:
      c.destroy<dl_ran_early_status_transfer_s>();
      break;
    case types::dl_ran_status_transfer:
      c.destroy<dl_ran_status_transfer_s>();
      break;
    case types::dl_rim_info_transfer:
      c.destroy<dl_rim_info_transfer_s>();
      break;
    case types::dl_ue_associated_nrppa_transport:
      c.destroy<dl_ue_associated_nrppa_transport_s>();
      break;
    case types::error_ind:
      c.destroy<error_ind_s>();
      break;
    case types::ho_notify:
      c.destroy<ho_notify_s>();
      break;
    case types::ho_success:
      c.destroy<ho_success_s>();
      break;
    case types::init_ue_msg:
      c.destroy<init_ue_msg_s>();
      break;
    case types::location_report:
      c.destroy<location_report_s>();
      break;
    case types::location_report_ctrl:
      c.destroy<location_report_ctrl_s>();
      break;
    case types::location_report_fail_ind:
      c.destroy<location_report_fail_ind_s>();
      break;
    case types::multicast_group_paging:
      c.destroy<multicast_group_paging_s>();
      break;
    case types::nas_non_delivery_ind:
      c.destroy<nas_non_delivery_ind_s>();
      break;
    case types::overload_start:
      c.destroy<overload_start_s>();
      break;
    case types::overload_stop:
      c.destroy<overload_stop_s>();
      break;
    case types::paging:
      c.destroy<paging_s>();
      break;
    case types::pdu_session_res_notify:
      c.destroy<pdu_session_res_notify_s>();
      break;
    case types::private_msg:
      c.destroy<private_msg_s>();
      break;
    case types::pws_fail_ind:
      c.destroy<pws_fail_ind_s>();
      break;
    case types::pws_restart_ind:
      c.destroy<pws_restart_ind_s>();
      break;
    case types::ran_cp_relocation_ind:
      c.destroy<ran_cp_relocation_ind_s>();
      break;
    case types::reroute_nas_request:
      c.destroy<reroute_nas_request_s>();
      break;
    case types::retrieve_ue_info:
      c.destroy<retrieve_ue_info_s>();
      break;
    case types::rrc_inactive_transition_report:
      c.destroy<rrc_inactive_transition_report_s>();
      break;
    case types::secondary_rat_data_usage_report:
      c.destroy<secondary_rat_data_usage_report_s>();
      break;
    case types::trace_fail_ind:
      c.destroy<trace_fail_ind_s>();
      break;
    case types::trace_start:
      c.destroy<trace_start_s>();
      break;
    case types::ue_context_release_request:
      c.destroy<ue_context_release_request_s>();
      break;
    case types::ue_info_transfer:
      c.destroy<ue_info_transfer_s>();
      break;
    case types::ue_radio_cap_info_ind:
      c.destroy<ue_radio_cap_info_ind_s>();
      break;
    case types::ue_tnla_binding_release_request:
      c.destroy<ue_tnla_binding_release_request_s>();
      break;
    case types::ul_nas_transport:
      c.destroy<ul_nas_transport_s>();
      break;
    case types::ul_non_ue_associated_nrppa_transport:
      c.destroy<ul_non_ue_associated_nrppa_transport_s>();
      break;
    case types::ul_ran_cfg_transfer:
      c.destroy<ul_ran_cfg_transfer_s>();
      break;
    case types::ul_ran_early_status_transfer:
      c.destroy<ul_ran_early_status_transfer_s>();
      break;
    case types::ul_ran_status_transfer:
      c.destroy<ul_ran_status_transfer_s>();
      break;
    case types::ul_rim_info_transfer:
      c.destroy<ul_rim_info_transfer_s>();
      break;
    case types::ul_ue_associated_nrppa_transport:
      c.destroy<ul_ue_associated_nrppa_transport_s>();
      break;
    default:
      break;
  }
}
void ngap_elem_procs_o::init_msg_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_cfg_upd:
      c.init<amf_cfg_upd_s>();
      break;
    case types::broadcast_session_mod_request:
      c.init<broadcast_session_mod_request_s>();
      break;
    case types::broadcast_session_release_request:
      c.init<broadcast_session_release_request_s>();
      break;
    case types::broadcast_session_setup_request:
      c.init<broadcast_session_setup_request_s>();
      break;
    case types::distribution_setup_request:
      c.init<distribution_setup_request_s>();
      break;
    case types::distribution_release_request:
      c.init<distribution_release_request_s>();
      break;
    case types::ho_cancel:
      c.init<ho_cancel_s>();
      break;
    case types::ho_required:
      c.init<ho_required_s>();
      break;
    case types::ho_request:
      c.init<ho_request_s>();
      break;
    case types::init_context_setup_request:
      c.init<init_context_setup_request_s>();
      break;
    case types::multicast_session_activation_request:
      c.init<multicast_session_activation_request_s>();
      break;
    case types::multicast_session_deactivation_request:
      c.init<multicast_session_deactivation_request_s>();
      break;
    case types::multicast_session_upd_request:
      c.init<multicast_session_upd_request_s>();
      break;
    case types::ng_reset:
      c.init<ng_reset_s>();
      break;
    case types::ng_setup_request:
      c.init<ng_setup_request_s>();
      break;
    case types::path_switch_request:
      c.init<path_switch_request_s>();
      break;
    case types::pdu_session_res_modify_request:
      c.init<pdu_session_res_modify_request_s>();
      break;
    case types::pdu_session_res_modify_ind:
      c.init<pdu_session_res_modify_ind_s>();
      break;
    case types::pdu_session_res_release_cmd:
      c.init<pdu_session_res_release_cmd_s>();
      break;
    case types::pdu_session_res_setup_request:
      c.init<pdu_session_res_setup_request_s>();
      break;
    case types::pws_cancel_request:
      c.init<pws_cancel_request_s>();
      break;
    case types::ran_cfg_upd:
      c.init<ran_cfg_upd_s>();
      break;
    case types::ue_context_mod_request:
      c.init<ue_context_mod_request_s>();
      break;
    case types::ue_context_release_cmd:
      c.init<ue_context_release_cmd_s>();
      break;
    case types::ue_context_resume_request:
      c.init<ue_context_resume_request_s>();
      break;
    case types::ue_context_suspend_request:
      c.init<ue_context_suspend_request_s>();
      break;
    case types::ue_radio_cap_check_request:
      c.init<ue_radio_cap_check_request_s>();
      break;
    case types::ue_radio_cap_id_map_request:
      c.init<ue_radio_cap_id_map_request_s>();
      break;
    case types::write_replace_warning_request:
      c.init<write_replace_warning_request_s>();
      break;
    case types::amf_cp_relocation_ind:
      c.init<amf_cp_relocation_ind_s>();
      break;
    case types::amf_status_ind:
      c.init<amf_status_ind_s>();
      break;
    case types::broadcast_session_release_required:
      c.init<broadcast_session_release_required_s>();
      break;
    case types::cell_traffic_trace:
      c.init<cell_traffic_trace_s>();
      break;
    case types::conn_establishment_ind:
      c.init<conn_establishment_ind_s>();
      break;
    case types::deactiv_trace:
      c.init<deactiv_trace_s>();
      break;
    case types::dl_nas_transport:
      c.init<dl_nas_transport_s>();
      break;
    case types::dl_non_ue_associated_nrppa_transport:
      c.init<dl_non_ue_associated_nrppa_transport_s>();
      break;
    case types::dl_ran_cfg_transfer:
      c.init<dl_ran_cfg_transfer_s>();
      break;
    case types::dl_ran_early_status_transfer:
      c.init<dl_ran_early_status_transfer_s>();
      break;
    case types::dl_ran_status_transfer:
      c.init<dl_ran_status_transfer_s>();
      break;
    case types::dl_rim_info_transfer:
      c.init<dl_rim_info_transfer_s>();
      break;
    case types::dl_ue_associated_nrppa_transport:
      c.init<dl_ue_associated_nrppa_transport_s>();
      break;
    case types::error_ind:
      c.init<error_ind_s>();
      break;
    case types::ho_notify:
      c.init<ho_notify_s>();
      break;
    case types::ho_success:
      c.init<ho_success_s>();
      break;
    case types::init_ue_msg:
      c.init<init_ue_msg_s>();
      break;
    case types::location_report:
      c.init<location_report_s>();
      break;
    case types::location_report_ctrl:
      c.init<location_report_ctrl_s>();
      break;
    case types::location_report_fail_ind:
      c.init<location_report_fail_ind_s>();
      break;
    case types::multicast_group_paging:
      c.init<multicast_group_paging_s>();
      break;
    case types::nas_non_delivery_ind:
      c.init<nas_non_delivery_ind_s>();
      break;
    case types::overload_start:
      c.init<overload_start_s>();
      break;
    case types::overload_stop:
      c.init<overload_stop_s>();
      break;
    case types::paging:
      c.init<paging_s>();
      break;
    case types::pdu_session_res_notify:
      c.init<pdu_session_res_notify_s>();
      break;
    case types::private_msg:
      c.init<private_msg_s>();
      break;
    case types::pws_fail_ind:
      c.init<pws_fail_ind_s>();
      break;
    case types::pws_restart_ind:
      c.init<pws_restart_ind_s>();
      break;
    case types::ran_cp_relocation_ind:
      c.init<ran_cp_relocation_ind_s>();
      break;
    case types::reroute_nas_request:
      c.init<reroute_nas_request_s>();
      break;
    case types::retrieve_ue_info:
      c.init<retrieve_ue_info_s>();
      break;
    case types::rrc_inactive_transition_report:
      c.init<rrc_inactive_transition_report_s>();
      break;
    case types::secondary_rat_data_usage_report:
      c.init<secondary_rat_data_usage_report_s>();
      break;
    case types::trace_fail_ind:
      c.init<trace_fail_ind_s>();
      break;
    case types::trace_start:
      c.init<trace_start_s>();
      break;
    case types::ue_context_release_request:
      c.init<ue_context_release_request_s>();
      break;
    case types::ue_info_transfer:
      c.init<ue_info_transfer_s>();
      break;
    case types::ue_radio_cap_info_ind:
      c.init<ue_radio_cap_info_ind_s>();
      break;
    case types::ue_tnla_binding_release_request:
      c.init<ue_tnla_binding_release_request_s>();
      break;
    case types::ul_nas_transport:
      c.init<ul_nas_transport_s>();
      break;
    case types::ul_non_ue_associated_nrppa_transport:
      c.init<ul_non_ue_associated_nrppa_transport_s>();
      break;
    case types::ul_ran_cfg_transfer:
      c.init<ul_ran_cfg_transfer_s>();
      break;
    case types::ul_ran_early_status_transfer:
      c.init<ul_ran_early_status_transfer_s>();
      break;
    case types::ul_ran_status_transfer:
      c.init<ul_ran_status_transfer_s>();
      break;
    case types::ul_rim_info_transfer:
      c.init<ul_rim_info_transfer_s>();
      break;
    case types::ul_ue_associated_nrppa_transport:
      c.init<ul_ue_associated_nrppa_transport_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ngap_elem_procs_o::init_msg_c");
  }
}
ngap_elem_procs_o::init_msg_c::init_msg_c(const ngap_elem_procs_o::init_msg_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_cfg_upd:
      c.init(other.c.get<amf_cfg_upd_s>());
      break;
    case types::broadcast_session_mod_request:
      c.init(other.c.get<broadcast_session_mod_request_s>());
      break;
    case types::broadcast_session_release_request:
      c.init(other.c.get<broadcast_session_release_request_s>());
      break;
    case types::broadcast_session_setup_request:
      c.init(other.c.get<broadcast_session_setup_request_s>());
      break;
    case types::distribution_setup_request:
      c.init(other.c.get<distribution_setup_request_s>());
      break;
    case types::distribution_release_request:
      c.init(other.c.get<distribution_release_request_s>());
      break;
    case types::ho_cancel:
      c.init(other.c.get<ho_cancel_s>());
      break;
    case types::ho_required:
      c.init(other.c.get<ho_required_s>());
      break;
    case types::ho_request:
      c.init(other.c.get<ho_request_s>());
      break;
    case types::init_context_setup_request:
      c.init(other.c.get<init_context_setup_request_s>());
      break;
    case types::multicast_session_activation_request:
      c.init(other.c.get<multicast_session_activation_request_s>());
      break;
    case types::multicast_session_deactivation_request:
      c.init(other.c.get<multicast_session_deactivation_request_s>());
      break;
    case types::multicast_session_upd_request:
      c.init(other.c.get<multicast_session_upd_request_s>());
      break;
    case types::ng_reset:
      c.init(other.c.get<ng_reset_s>());
      break;
    case types::ng_setup_request:
      c.init(other.c.get<ng_setup_request_s>());
      break;
    case types::path_switch_request:
      c.init(other.c.get<path_switch_request_s>());
      break;
    case types::pdu_session_res_modify_request:
      c.init(other.c.get<pdu_session_res_modify_request_s>());
      break;
    case types::pdu_session_res_modify_ind:
      c.init(other.c.get<pdu_session_res_modify_ind_s>());
      break;
    case types::pdu_session_res_release_cmd:
      c.init(other.c.get<pdu_session_res_release_cmd_s>());
      break;
    case types::pdu_session_res_setup_request:
      c.init(other.c.get<pdu_session_res_setup_request_s>());
      break;
    case types::pws_cancel_request:
      c.init(other.c.get<pws_cancel_request_s>());
      break;
    case types::ran_cfg_upd:
      c.init(other.c.get<ran_cfg_upd_s>());
      break;
    case types::ue_context_mod_request:
      c.init(other.c.get<ue_context_mod_request_s>());
      break;
    case types::ue_context_release_cmd:
      c.init(other.c.get<ue_context_release_cmd_s>());
      break;
    case types::ue_context_resume_request:
      c.init(other.c.get<ue_context_resume_request_s>());
      break;
    case types::ue_context_suspend_request:
      c.init(other.c.get<ue_context_suspend_request_s>());
      break;
    case types::ue_radio_cap_check_request:
      c.init(other.c.get<ue_radio_cap_check_request_s>());
      break;
    case types::ue_radio_cap_id_map_request:
      c.init(other.c.get<ue_radio_cap_id_map_request_s>());
      break;
    case types::write_replace_warning_request:
      c.init(other.c.get<write_replace_warning_request_s>());
      break;
    case types::amf_cp_relocation_ind:
      c.init(other.c.get<amf_cp_relocation_ind_s>());
      break;
    case types::amf_status_ind:
      c.init(other.c.get<amf_status_ind_s>());
      break;
    case types::broadcast_session_release_required:
      c.init(other.c.get<broadcast_session_release_required_s>());
      break;
    case types::cell_traffic_trace:
      c.init(other.c.get<cell_traffic_trace_s>());
      break;
    case types::conn_establishment_ind:
      c.init(other.c.get<conn_establishment_ind_s>());
      break;
    case types::deactiv_trace:
      c.init(other.c.get<deactiv_trace_s>());
      break;
    case types::dl_nas_transport:
      c.init(other.c.get<dl_nas_transport_s>());
      break;
    case types::dl_non_ue_associated_nrppa_transport:
      c.init(other.c.get<dl_non_ue_associated_nrppa_transport_s>());
      break;
    case types::dl_ran_cfg_transfer:
      c.init(other.c.get<dl_ran_cfg_transfer_s>());
      break;
    case types::dl_ran_early_status_transfer:
      c.init(other.c.get<dl_ran_early_status_transfer_s>());
      break;
    case types::dl_ran_status_transfer:
      c.init(other.c.get<dl_ran_status_transfer_s>());
      break;
    case types::dl_rim_info_transfer:
      c.init(other.c.get<dl_rim_info_transfer_s>());
      break;
    case types::dl_ue_associated_nrppa_transport:
      c.init(other.c.get<dl_ue_associated_nrppa_transport_s>());
      break;
    case types::error_ind:
      c.init(other.c.get<error_ind_s>());
      break;
    case types::ho_notify:
      c.init(other.c.get<ho_notify_s>());
      break;
    case types::ho_success:
      c.init(other.c.get<ho_success_s>());
      break;
    case types::init_ue_msg:
      c.init(other.c.get<init_ue_msg_s>());
      break;
    case types::location_report:
      c.init(other.c.get<location_report_s>());
      break;
    case types::location_report_ctrl:
      c.init(other.c.get<location_report_ctrl_s>());
      break;
    case types::location_report_fail_ind:
      c.init(other.c.get<location_report_fail_ind_s>());
      break;
    case types::multicast_group_paging:
      c.init(other.c.get<multicast_group_paging_s>());
      break;
    case types::nas_non_delivery_ind:
      c.init(other.c.get<nas_non_delivery_ind_s>());
      break;
    case types::overload_start:
      c.init(other.c.get<overload_start_s>());
      break;
    case types::overload_stop:
      c.init(other.c.get<overload_stop_s>());
      break;
    case types::paging:
      c.init(other.c.get<paging_s>());
      break;
    case types::pdu_session_res_notify:
      c.init(other.c.get<pdu_session_res_notify_s>());
      break;
    case types::private_msg:
      c.init(other.c.get<private_msg_s>());
      break;
    case types::pws_fail_ind:
      c.init(other.c.get<pws_fail_ind_s>());
      break;
    case types::pws_restart_ind:
      c.init(other.c.get<pws_restart_ind_s>());
      break;
    case types::ran_cp_relocation_ind:
      c.init(other.c.get<ran_cp_relocation_ind_s>());
      break;
    case types::reroute_nas_request:
      c.init(other.c.get<reroute_nas_request_s>());
      break;
    case types::retrieve_ue_info:
      c.init(other.c.get<retrieve_ue_info_s>());
      break;
    case types::rrc_inactive_transition_report:
      c.init(other.c.get<rrc_inactive_transition_report_s>());
      break;
    case types::secondary_rat_data_usage_report:
      c.init(other.c.get<secondary_rat_data_usage_report_s>());
      break;
    case types::trace_fail_ind:
      c.init(other.c.get<trace_fail_ind_s>());
      break;
    case types::trace_start:
      c.init(other.c.get<trace_start_s>());
      break;
    case types::ue_context_release_request:
      c.init(other.c.get<ue_context_release_request_s>());
      break;
    case types::ue_info_transfer:
      c.init(other.c.get<ue_info_transfer_s>());
      break;
    case types::ue_radio_cap_info_ind:
      c.init(other.c.get<ue_radio_cap_info_ind_s>());
      break;
    case types::ue_tnla_binding_release_request:
      c.init(other.c.get<ue_tnla_binding_release_request_s>());
      break;
    case types::ul_nas_transport:
      c.init(other.c.get<ul_nas_transport_s>());
      break;
    case types::ul_non_ue_associated_nrppa_transport:
      c.init(other.c.get<ul_non_ue_associated_nrppa_transport_s>());
      break;
    case types::ul_ran_cfg_transfer:
      c.init(other.c.get<ul_ran_cfg_transfer_s>());
      break;
    case types::ul_ran_early_status_transfer:
      c.init(other.c.get<ul_ran_early_status_transfer_s>());
      break;
    case types::ul_ran_status_transfer:
      c.init(other.c.get<ul_ran_status_transfer_s>());
      break;
    case types::ul_rim_info_transfer:
      c.init(other.c.get<ul_rim_info_transfer_s>());
      break;
    case types::ul_ue_associated_nrppa_transport:
      c.init(other.c.get<ul_ue_associated_nrppa_transport_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ngap_elem_procs_o::init_msg_c");
  }
}
ngap_elem_procs_o::init_msg_c& ngap_elem_procs_o::init_msg_c::operator=(const ngap_elem_procs_o::init_msg_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_cfg_upd:
      c.set(other.c.get<amf_cfg_upd_s>());
      break;
    case types::broadcast_session_mod_request:
      c.set(other.c.get<broadcast_session_mod_request_s>());
      break;
    case types::broadcast_session_release_request:
      c.set(other.c.get<broadcast_session_release_request_s>());
      break;
    case types::broadcast_session_setup_request:
      c.set(other.c.get<broadcast_session_setup_request_s>());
      break;
    case types::distribution_setup_request:
      c.set(other.c.get<distribution_setup_request_s>());
      break;
    case types::distribution_release_request:
      c.set(other.c.get<distribution_release_request_s>());
      break;
    case types::ho_cancel:
      c.set(other.c.get<ho_cancel_s>());
      break;
    case types::ho_required:
      c.set(other.c.get<ho_required_s>());
      break;
    case types::ho_request:
      c.set(other.c.get<ho_request_s>());
      break;
    case types::init_context_setup_request:
      c.set(other.c.get<init_context_setup_request_s>());
      break;
    case types::multicast_session_activation_request:
      c.set(other.c.get<multicast_session_activation_request_s>());
      break;
    case types::multicast_session_deactivation_request:
      c.set(other.c.get<multicast_session_deactivation_request_s>());
      break;
    case types::multicast_session_upd_request:
      c.set(other.c.get<multicast_session_upd_request_s>());
      break;
    case types::ng_reset:
      c.set(other.c.get<ng_reset_s>());
      break;
    case types::ng_setup_request:
      c.set(other.c.get<ng_setup_request_s>());
      break;
    case types::path_switch_request:
      c.set(other.c.get<path_switch_request_s>());
      break;
    case types::pdu_session_res_modify_request:
      c.set(other.c.get<pdu_session_res_modify_request_s>());
      break;
    case types::pdu_session_res_modify_ind:
      c.set(other.c.get<pdu_session_res_modify_ind_s>());
      break;
    case types::pdu_session_res_release_cmd:
      c.set(other.c.get<pdu_session_res_release_cmd_s>());
      break;
    case types::pdu_session_res_setup_request:
      c.set(other.c.get<pdu_session_res_setup_request_s>());
      break;
    case types::pws_cancel_request:
      c.set(other.c.get<pws_cancel_request_s>());
      break;
    case types::ran_cfg_upd:
      c.set(other.c.get<ran_cfg_upd_s>());
      break;
    case types::ue_context_mod_request:
      c.set(other.c.get<ue_context_mod_request_s>());
      break;
    case types::ue_context_release_cmd:
      c.set(other.c.get<ue_context_release_cmd_s>());
      break;
    case types::ue_context_resume_request:
      c.set(other.c.get<ue_context_resume_request_s>());
      break;
    case types::ue_context_suspend_request:
      c.set(other.c.get<ue_context_suspend_request_s>());
      break;
    case types::ue_radio_cap_check_request:
      c.set(other.c.get<ue_radio_cap_check_request_s>());
      break;
    case types::ue_radio_cap_id_map_request:
      c.set(other.c.get<ue_radio_cap_id_map_request_s>());
      break;
    case types::write_replace_warning_request:
      c.set(other.c.get<write_replace_warning_request_s>());
      break;
    case types::amf_cp_relocation_ind:
      c.set(other.c.get<amf_cp_relocation_ind_s>());
      break;
    case types::amf_status_ind:
      c.set(other.c.get<amf_status_ind_s>());
      break;
    case types::broadcast_session_release_required:
      c.set(other.c.get<broadcast_session_release_required_s>());
      break;
    case types::cell_traffic_trace:
      c.set(other.c.get<cell_traffic_trace_s>());
      break;
    case types::conn_establishment_ind:
      c.set(other.c.get<conn_establishment_ind_s>());
      break;
    case types::deactiv_trace:
      c.set(other.c.get<deactiv_trace_s>());
      break;
    case types::dl_nas_transport:
      c.set(other.c.get<dl_nas_transport_s>());
      break;
    case types::dl_non_ue_associated_nrppa_transport:
      c.set(other.c.get<dl_non_ue_associated_nrppa_transport_s>());
      break;
    case types::dl_ran_cfg_transfer:
      c.set(other.c.get<dl_ran_cfg_transfer_s>());
      break;
    case types::dl_ran_early_status_transfer:
      c.set(other.c.get<dl_ran_early_status_transfer_s>());
      break;
    case types::dl_ran_status_transfer:
      c.set(other.c.get<dl_ran_status_transfer_s>());
      break;
    case types::dl_rim_info_transfer:
      c.set(other.c.get<dl_rim_info_transfer_s>());
      break;
    case types::dl_ue_associated_nrppa_transport:
      c.set(other.c.get<dl_ue_associated_nrppa_transport_s>());
      break;
    case types::error_ind:
      c.set(other.c.get<error_ind_s>());
      break;
    case types::ho_notify:
      c.set(other.c.get<ho_notify_s>());
      break;
    case types::ho_success:
      c.set(other.c.get<ho_success_s>());
      break;
    case types::init_ue_msg:
      c.set(other.c.get<init_ue_msg_s>());
      break;
    case types::location_report:
      c.set(other.c.get<location_report_s>());
      break;
    case types::location_report_ctrl:
      c.set(other.c.get<location_report_ctrl_s>());
      break;
    case types::location_report_fail_ind:
      c.set(other.c.get<location_report_fail_ind_s>());
      break;
    case types::multicast_group_paging:
      c.set(other.c.get<multicast_group_paging_s>());
      break;
    case types::nas_non_delivery_ind:
      c.set(other.c.get<nas_non_delivery_ind_s>());
      break;
    case types::overload_start:
      c.set(other.c.get<overload_start_s>());
      break;
    case types::overload_stop:
      c.set(other.c.get<overload_stop_s>());
      break;
    case types::paging:
      c.set(other.c.get<paging_s>());
      break;
    case types::pdu_session_res_notify:
      c.set(other.c.get<pdu_session_res_notify_s>());
      break;
    case types::private_msg:
      c.set(other.c.get<private_msg_s>());
      break;
    case types::pws_fail_ind:
      c.set(other.c.get<pws_fail_ind_s>());
      break;
    case types::pws_restart_ind:
      c.set(other.c.get<pws_restart_ind_s>());
      break;
    case types::ran_cp_relocation_ind:
      c.set(other.c.get<ran_cp_relocation_ind_s>());
      break;
    case types::reroute_nas_request:
      c.set(other.c.get<reroute_nas_request_s>());
      break;
    case types::retrieve_ue_info:
      c.set(other.c.get<retrieve_ue_info_s>());
      break;
    case types::rrc_inactive_transition_report:
      c.set(other.c.get<rrc_inactive_transition_report_s>());
      break;
    case types::secondary_rat_data_usage_report:
      c.set(other.c.get<secondary_rat_data_usage_report_s>());
      break;
    case types::trace_fail_ind:
      c.set(other.c.get<trace_fail_ind_s>());
      break;
    case types::trace_start:
      c.set(other.c.get<trace_start_s>());
      break;
    case types::ue_context_release_request:
      c.set(other.c.get<ue_context_release_request_s>());
      break;
    case types::ue_info_transfer:
      c.set(other.c.get<ue_info_transfer_s>());
      break;
    case types::ue_radio_cap_info_ind:
      c.set(other.c.get<ue_radio_cap_info_ind_s>());
      break;
    case types::ue_tnla_binding_release_request:
      c.set(other.c.get<ue_tnla_binding_release_request_s>());
      break;
    case types::ul_nas_transport:
      c.set(other.c.get<ul_nas_transport_s>());
      break;
    case types::ul_non_ue_associated_nrppa_transport:
      c.set(other.c.get<ul_non_ue_associated_nrppa_transport_s>());
      break;
    case types::ul_ran_cfg_transfer:
      c.set(other.c.get<ul_ran_cfg_transfer_s>());
      break;
    case types::ul_ran_early_status_transfer:
      c.set(other.c.get<ul_ran_early_status_transfer_s>());
      break;
    case types::ul_ran_status_transfer:
      c.set(other.c.get<ul_ran_status_transfer_s>());
      break;
    case types::ul_rim_info_transfer:
      c.set(other.c.get<ul_rim_info_transfer_s>());
      break;
    case types::ul_ue_associated_nrppa_transport:
      c.set(other.c.get<ul_ue_associated_nrppa_transport_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ngap_elem_procs_o::init_msg_c");
  }

  return *this;
}
amf_cfg_upd_s& ngap_elem_procs_o::init_msg_c::amf_cfg_upd()
{
  assert_choice_type(types::amf_cfg_upd, type_, "InitiatingMessage");
  return c.get<amf_cfg_upd_s>();
}
broadcast_session_mod_request_s& ngap_elem_procs_o::init_msg_c::broadcast_session_mod_request()
{
  assert_choice_type(types::broadcast_session_mod_request, type_, "InitiatingMessage");
  return c.get<broadcast_session_mod_request_s>();
}
broadcast_session_release_request_s& ngap_elem_procs_o::init_msg_c::broadcast_session_release_request()
{
  assert_choice_type(types::broadcast_session_release_request, type_, "InitiatingMessage");
  return c.get<broadcast_session_release_request_s>();
}
broadcast_session_setup_request_s& ngap_elem_procs_o::init_msg_c::broadcast_session_setup_request()
{
  assert_choice_type(types::broadcast_session_setup_request, type_, "InitiatingMessage");
  return c.get<broadcast_session_setup_request_s>();
}
distribution_setup_request_s& ngap_elem_procs_o::init_msg_c::distribution_setup_request()
{
  assert_choice_type(types::distribution_setup_request, type_, "InitiatingMessage");
  return c.get<distribution_setup_request_s>();
}
distribution_release_request_s& ngap_elem_procs_o::init_msg_c::distribution_release_request()
{
  assert_choice_type(types::distribution_release_request, type_, "InitiatingMessage");
  return c.get<distribution_release_request_s>();
}
ho_cancel_s& ngap_elem_procs_o::init_msg_c::ho_cancel()
{
  assert_choice_type(types::ho_cancel, type_, "InitiatingMessage");
  return c.get<ho_cancel_s>();
}
ho_required_s& ngap_elem_procs_o::init_msg_c::ho_required()
{
  assert_choice_type(types::ho_required, type_, "InitiatingMessage");
  return c.get<ho_required_s>();
}
ho_request_s& ngap_elem_procs_o::init_msg_c::ho_request()
{
  assert_choice_type(types::ho_request, type_, "InitiatingMessage");
  return c.get<ho_request_s>();
}
init_context_setup_request_s& ngap_elem_procs_o::init_msg_c::init_context_setup_request()
{
  assert_choice_type(types::init_context_setup_request, type_, "InitiatingMessage");
  return c.get<init_context_setup_request_s>();
}
multicast_session_activation_request_s& ngap_elem_procs_o::init_msg_c::multicast_session_activation_request()
{
  assert_choice_type(types::multicast_session_activation_request, type_, "InitiatingMessage");
  return c.get<multicast_session_activation_request_s>();
}
multicast_session_deactivation_request_s& ngap_elem_procs_o::init_msg_c::multicast_session_deactivation_request()
{
  assert_choice_type(types::multicast_session_deactivation_request, type_, "InitiatingMessage");
  return c.get<multicast_session_deactivation_request_s>();
}
multicast_session_upd_request_s& ngap_elem_procs_o::init_msg_c::multicast_session_upd_request()
{
  assert_choice_type(types::multicast_session_upd_request, type_, "InitiatingMessage");
  return c.get<multicast_session_upd_request_s>();
}
ng_reset_s& ngap_elem_procs_o::init_msg_c::ng_reset()
{
  assert_choice_type(types::ng_reset, type_, "InitiatingMessage");
  return c.get<ng_reset_s>();
}
ng_setup_request_s& ngap_elem_procs_o::init_msg_c::ng_setup_request()
{
  assert_choice_type(types::ng_setup_request, type_, "InitiatingMessage");
  return c.get<ng_setup_request_s>();
}
path_switch_request_s& ngap_elem_procs_o::init_msg_c::path_switch_request()
{
  assert_choice_type(types::path_switch_request, type_, "InitiatingMessage");
  return c.get<path_switch_request_s>();
}
pdu_session_res_modify_request_s& ngap_elem_procs_o::init_msg_c::pdu_session_res_modify_request()
{
  assert_choice_type(types::pdu_session_res_modify_request, type_, "InitiatingMessage");
  return c.get<pdu_session_res_modify_request_s>();
}
pdu_session_res_modify_ind_s& ngap_elem_procs_o::init_msg_c::pdu_session_res_modify_ind()
{
  assert_choice_type(types::pdu_session_res_modify_ind, type_, "InitiatingMessage");
  return c.get<pdu_session_res_modify_ind_s>();
}
pdu_session_res_release_cmd_s& ngap_elem_procs_o::init_msg_c::pdu_session_res_release_cmd()
{
  assert_choice_type(types::pdu_session_res_release_cmd, type_, "InitiatingMessage");
  return c.get<pdu_session_res_release_cmd_s>();
}
pdu_session_res_setup_request_s& ngap_elem_procs_o::init_msg_c::pdu_session_res_setup_request()
{
  assert_choice_type(types::pdu_session_res_setup_request, type_, "InitiatingMessage");
  return c.get<pdu_session_res_setup_request_s>();
}
pws_cancel_request_s& ngap_elem_procs_o::init_msg_c::pws_cancel_request()
{
  assert_choice_type(types::pws_cancel_request, type_, "InitiatingMessage");
  return c.get<pws_cancel_request_s>();
}
ran_cfg_upd_s& ngap_elem_procs_o::init_msg_c::ran_cfg_upd()
{
  assert_choice_type(types::ran_cfg_upd, type_, "InitiatingMessage");
  return c.get<ran_cfg_upd_s>();
}
ue_context_mod_request_s& ngap_elem_procs_o::init_msg_c::ue_context_mod_request()
{
  assert_choice_type(types::ue_context_mod_request, type_, "InitiatingMessage");
  return c.get<ue_context_mod_request_s>();
}
ue_context_release_cmd_s& ngap_elem_procs_o::init_msg_c::ue_context_release_cmd()
{
  assert_choice_type(types::ue_context_release_cmd, type_, "InitiatingMessage");
  return c.get<ue_context_release_cmd_s>();
}
ue_context_resume_request_s& ngap_elem_procs_o::init_msg_c::ue_context_resume_request()
{
  assert_choice_type(types::ue_context_resume_request, type_, "InitiatingMessage");
  return c.get<ue_context_resume_request_s>();
}
ue_context_suspend_request_s& ngap_elem_procs_o::init_msg_c::ue_context_suspend_request()
{
  assert_choice_type(types::ue_context_suspend_request, type_, "InitiatingMessage");
  return c.get<ue_context_suspend_request_s>();
}
ue_radio_cap_check_request_s& ngap_elem_procs_o::init_msg_c::ue_radio_cap_check_request()
{
  assert_choice_type(types::ue_radio_cap_check_request, type_, "InitiatingMessage");
  return c.get<ue_radio_cap_check_request_s>();
}
ue_radio_cap_id_map_request_s& ngap_elem_procs_o::init_msg_c::ue_radio_cap_id_map_request()
{
  assert_choice_type(types::ue_radio_cap_id_map_request, type_, "InitiatingMessage");
  return c.get<ue_radio_cap_id_map_request_s>();
}
write_replace_warning_request_s& ngap_elem_procs_o::init_msg_c::write_replace_warning_request()
{
  assert_choice_type(types::write_replace_warning_request, type_, "InitiatingMessage");
  return c.get<write_replace_warning_request_s>();
}
amf_cp_relocation_ind_s& ngap_elem_procs_o::init_msg_c::amf_cp_relocation_ind()
{
  assert_choice_type(types::amf_cp_relocation_ind, type_, "InitiatingMessage");
  return c.get<amf_cp_relocation_ind_s>();
}
amf_status_ind_s& ngap_elem_procs_o::init_msg_c::amf_status_ind()
{
  assert_choice_type(types::amf_status_ind, type_, "InitiatingMessage");
  return c.get<amf_status_ind_s>();
}
broadcast_session_release_required_s& ngap_elem_procs_o::init_msg_c::broadcast_session_release_required()
{
  assert_choice_type(types::broadcast_session_release_required, type_, "InitiatingMessage");
  return c.get<broadcast_session_release_required_s>();
}
cell_traffic_trace_s& ngap_elem_procs_o::init_msg_c::cell_traffic_trace()
{
  assert_choice_type(types::cell_traffic_trace, type_, "InitiatingMessage");
  return c.get<cell_traffic_trace_s>();
}
conn_establishment_ind_s& ngap_elem_procs_o::init_msg_c::conn_establishment_ind()
{
  assert_choice_type(types::conn_establishment_ind, type_, "InitiatingMessage");
  return c.get<conn_establishment_ind_s>();
}
deactiv_trace_s& ngap_elem_procs_o::init_msg_c::deactiv_trace()
{
  assert_choice_type(types::deactiv_trace, type_, "InitiatingMessage");
  return c.get<deactiv_trace_s>();
}
dl_nas_transport_s& ngap_elem_procs_o::init_msg_c::dl_nas_transport()
{
  assert_choice_type(types::dl_nas_transport, type_, "InitiatingMessage");
  return c.get<dl_nas_transport_s>();
}
dl_non_ue_associated_nrppa_transport_s& ngap_elem_procs_o::init_msg_c::dl_non_ue_associated_nrppa_transport()
{
  assert_choice_type(types::dl_non_ue_associated_nrppa_transport, type_, "InitiatingMessage");
  return c.get<dl_non_ue_associated_nrppa_transport_s>();
}
dl_ran_cfg_transfer_s& ngap_elem_procs_o::init_msg_c::dl_ran_cfg_transfer()
{
  assert_choice_type(types::dl_ran_cfg_transfer, type_, "InitiatingMessage");
  return c.get<dl_ran_cfg_transfer_s>();
}
dl_ran_early_status_transfer_s& ngap_elem_procs_o::init_msg_c::dl_ran_early_status_transfer()
{
  assert_choice_type(types::dl_ran_early_status_transfer, type_, "InitiatingMessage");
  return c.get<dl_ran_early_status_transfer_s>();
}
dl_ran_status_transfer_s& ngap_elem_procs_o::init_msg_c::dl_ran_status_transfer()
{
  assert_choice_type(types::dl_ran_status_transfer, type_, "InitiatingMessage");
  return c.get<dl_ran_status_transfer_s>();
}
dl_rim_info_transfer_s& ngap_elem_procs_o::init_msg_c::dl_rim_info_transfer()
{
  assert_choice_type(types::dl_rim_info_transfer, type_, "InitiatingMessage");
  return c.get<dl_rim_info_transfer_s>();
}
dl_ue_associated_nrppa_transport_s& ngap_elem_procs_o::init_msg_c::dl_ue_associated_nrppa_transport()
{
  assert_choice_type(types::dl_ue_associated_nrppa_transport, type_, "InitiatingMessage");
  return c.get<dl_ue_associated_nrppa_transport_s>();
}
error_ind_s& ngap_elem_procs_o::init_msg_c::error_ind()
{
  assert_choice_type(types::error_ind, type_, "InitiatingMessage");
  return c.get<error_ind_s>();
}
ho_notify_s& ngap_elem_procs_o::init_msg_c::ho_notify()
{
  assert_choice_type(types::ho_notify, type_, "InitiatingMessage");
  return c.get<ho_notify_s>();
}
ho_success_s& ngap_elem_procs_o::init_msg_c::ho_success()
{
  assert_choice_type(types::ho_success, type_, "InitiatingMessage");
  return c.get<ho_success_s>();
}
init_ue_msg_s& ngap_elem_procs_o::init_msg_c::init_ue_msg()
{
  assert_choice_type(types::init_ue_msg, type_, "InitiatingMessage");
  return c.get<init_ue_msg_s>();
}
location_report_s& ngap_elem_procs_o::init_msg_c::location_report()
{
  assert_choice_type(types::location_report, type_, "InitiatingMessage");
  return c.get<location_report_s>();
}
location_report_ctrl_s& ngap_elem_procs_o::init_msg_c::location_report_ctrl()
{
  assert_choice_type(types::location_report_ctrl, type_, "InitiatingMessage");
  return c.get<location_report_ctrl_s>();
}
location_report_fail_ind_s& ngap_elem_procs_o::init_msg_c::location_report_fail_ind()
{
  assert_choice_type(types::location_report_fail_ind, type_, "InitiatingMessage");
  return c.get<location_report_fail_ind_s>();
}
multicast_group_paging_s& ngap_elem_procs_o::init_msg_c::multicast_group_paging()
{
  assert_choice_type(types::multicast_group_paging, type_, "InitiatingMessage");
  return c.get<multicast_group_paging_s>();
}
nas_non_delivery_ind_s& ngap_elem_procs_o::init_msg_c::nas_non_delivery_ind()
{
  assert_choice_type(types::nas_non_delivery_ind, type_, "InitiatingMessage");
  return c.get<nas_non_delivery_ind_s>();
}
overload_start_s& ngap_elem_procs_o::init_msg_c::overload_start()
{
  assert_choice_type(types::overload_start, type_, "InitiatingMessage");
  return c.get<overload_start_s>();
}
overload_stop_s& ngap_elem_procs_o::init_msg_c::overload_stop()
{
  assert_choice_type(types::overload_stop, type_, "InitiatingMessage");
  return c.get<overload_stop_s>();
}
paging_s& ngap_elem_procs_o::init_msg_c::paging()
{
  assert_choice_type(types::paging, type_, "InitiatingMessage");
  return c.get<paging_s>();
}
pdu_session_res_notify_s& ngap_elem_procs_o::init_msg_c::pdu_session_res_notify()
{
  assert_choice_type(types::pdu_session_res_notify, type_, "InitiatingMessage");
  return c.get<pdu_session_res_notify_s>();
}
private_msg_s& ngap_elem_procs_o::init_msg_c::private_msg()
{
  assert_choice_type(types::private_msg, type_, "InitiatingMessage");
  return c.get<private_msg_s>();
}
pws_fail_ind_s& ngap_elem_procs_o::init_msg_c::pws_fail_ind()
{
  assert_choice_type(types::pws_fail_ind, type_, "InitiatingMessage");
  return c.get<pws_fail_ind_s>();
}
pws_restart_ind_s& ngap_elem_procs_o::init_msg_c::pws_restart_ind()
{
  assert_choice_type(types::pws_restart_ind, type_, "InitiatingMessage");
  return c.get<pws_restart_ind_s>();
}
ran_cp_relocation_ind_s& ngap_elem_procs_o::init_msg_c::ran_cp_relocation_ind()
{
  assert_choice_type(types::ran_cp_relocation_ind, type_, "InitiatingMessage");
  return c.get<ran_cp_relocation_ind_s>();
}
reroute_nas_request_s& ngap_elem_procs_o::init_msg_c::reroute_nas_request()
{
  assert_choice_type(types::reroute_nas_request, type_, "InitiatingMessage");
  return c.get<reroute_nas_request_s>();
}
retrieve_ue_info_s& ngap_elem_procs_o::init_msg_c::retrieve_ue_info()
{
  assert_choice_type(types::retrieve_ue_info, type_, "InitiatingMessage");
  return c.get<retrieve_ue_info_s>();
}
rrc_inactive_transition_report_s& ngap_elem_procs_o::init_msg_c::rrc_inactive_transition_report()
{
  assert_choice_type(types::rrc_inactive_transition_report, type_, "InitiatingMessage");
  return c.get<rrc_inactive_transition_report_s>();
}
secondary_rat_data_usage_report_s& ngap_elem_procs_o::init_msg_c::secondary_rat_data_usage_report()
{
  assert_choice_type(types::secondary_rat_data_usage_report, type_, "InitiatingMessage");
  return c.get<secondary_rat_data_usage_report_s>();
}
trace_fail_ind_s& ngap_elem_procs_o::init_msg_c::trace_fail_ind()
{
  assert_choice_type(types::trace_fail_ind, type_, "InitiatingMessage");
  return c.get<trace_fail_ind_s>();
}
trace_start_s& ngap_elem_procs_o::init_msg_c::trace_start()
{
  assert_choice_type(types::trace_start, type_, "InitiatingMessage");
  return c.get<trace_start_s>();
}
ue_context_release_request_s& ngap_elem_procs_o::init_msg_c::ue_context_release_request()
{
  assert_choice_type(types::ue_context_release_request, type_, "InitiatingMessage");
  return c.get<ue_context_release_request_s>();
}
ue_info_transfer_s& ngap_elem_procs_o::init_msg_c::ue_info_transfer()
{
  assert_choice_type(types::ue_info_transfer, type_, "InitiatingMessage");
  return c.get<ue_info_transfer_s>();
}
ue_radio_cap_info_ind_s& ngap_elem_procs_o::init_msg_c::ue_radio_cap_info_ind()
{
  assert_choice_type(types::ue_radio_cap_info_ind, type_, "InitiatingMessage");
  return c.get<ue_radio_cap_info_ind_s>();
}
ue_tnla_binding_release_request_s& ngap_elem_procs_o::init_msg_c::ue_tnla_binding_release_request()
{
  assert_choice_type(types::ue_tnla_binding_release_request, type_, "InitiatingMessage");
  return c.get<ue_tnla_binding_release_request_s>();
}
ul_nas_transport_s& ngap_elem_procs_o::init_msg_c::ul_nas_transport()
{
  assert_choice_type(types::ul_nas_transport, type_, "InitiatingMessage");
  return c.get<ul_nas_transport_s>();
}
ul_non_ue_associated_nrppa_transport_s& ngap_elem_procs_o::init_msg_c::ul_non_ue_associated_nrppa_transport()
{
  assert_choice_type(types::ul_non_ue_associated_nrppa_transport, type_, "InitiatingMessage");
  return c.get<ul_non_ue_associated_nrppa_transport_s>();
}
ul_ran_cfg_transfer_s& ngap_elem_procs_o::init_msg_c::ul_ran_cfg_transfer()
{
  assert_choice_type(types::ul_ran_cfg_transfer, type_, "InitiatingMessage");
  return c.get<ul_ran_cfg_transfer_s>();
}
ul_ran_early_status_transfer_s& ngap_elem_procs_o::init_msg_c::ul_ran_early_status_transfer()
{
  assert_choice_type(types::ul_ran_early_status_transfer, type_, "InitiatingMessage");
  return c.get<ul_ran_early_status_transfer_s>();
}
ul_ran_status_transfer_s& ngap_elem_procs_o::init_msg_c::ul_ran_status_transfer()
{
  assert_choice_type(types::ul_ran_status_transfer, type_, "InitiatingMessage");
  return c.get<ul_ran_status_transfer_s>();
}
ul_rim_info_transfer_s& ngap_elem_procs_o::init_msg_c::ul_rim_info_transfer()
{
  assert_choice_type(types::ul_rim_info_transfer, type_, "InitiatingMessage");
  return c.get<ul_rim_info_transfer_s>();
}
ul_ue_associated_nrppa_transport_s& ngap_elem_procs_o::init_msg_c::ul_ue_associated_nrppa_transport()
{
  assert_choice_type(types::ul_ue_associated_nrppa_transport, type_, "InitiatingMessage");
  return c.get<ul_ue_associated_nrppa_transport_s>();
}
const amf_cfg_upd_s& ngap_elem_procs_o::init_msg_c::amf_cfg_upd() const
{
  assert_choice_type(types::amf_cfg_upd, type_, "InitiatingMessage");
  return c.get<amf_cfg_upd_s>();
}
const broadcast_session_mod_request_s& ngap_elem_procs_o::init_msg_c::broadcast_session_mod_request() const
{
  assert_choice_type(types::broadcast_session_mod_request, type_, "InitiatingMessage");
  return c.get<broadcast_session_mod_request_s>();
}
const broadcast_session_release_request_s& ngap_elem_procs_o::init_msg_c::broadcast_session_release_request() const
{
  assert_choice_type(types::broadcast_session_release_request, type_, "InitiatingMessage");
  return c.get<broadcast_session_release_request_s>();
}
const broadcast_session_setup_request_s& ngap_elem_procs_o::init_msg_c::broadcast_session_setup_request() const
{
  assert_choice_type(types::broadcast_session_setup_request, type_, "InitiatingMessage");
  return c.get<broadcast_session_setup_request_s>();
}
const distribution_setup_request_s& ngap_elem_procs_o::init_msg_c::distribution_setup_request() const
{
  assert_choice_type(types::distribution_setup_request, type_, "InitiatingMessage");
  return c.get<distribution_setup_request_s>();
}
const distribution_release_request_s& ngap_elem_procs_o::init_msg_c::distribution_release_request() const
{
  assert_choice_type(types::distribution_release_request, type_, "InitiatingMessage");
  return c.get<distribution_release_request_s>();
}
const ho_cancel_s& ngap_elem_procs_o::init_msg_c::ho_cancel() const
{
  assert_choice_type(types::ho_cancel, type_, "InitiatingMessage");
  return c.get<ho_cancel_s>();
}
const ho_required_s& ngap_elem_procs_o::init_msg_c::ho_required() const
{
  assert_choice_type(types::ho_required, type_, "InitiatingMessage");
  return c.get<ho_required_s>();
}
const ho_request_s& ngap_elem_procs_o::init_msg_c::ho_request() const
{
  assert_choice_type(types::ho_request, type_, "InitiatingMessage");
  return c.get<ho_request_s>();
}
const init_context_setup_request_s& ngap_elem_procs_o::init_msg_c::init_context_setup_request() const
{
  assert_choice_type(types::init_context_setup_request, type_, "InitiatingMessage");
  return c.get<init_context_setup_request_s>();
}
const multicast_session_activation_request_s&
ngap_elem_procs_o::init_msg_c::multicast_session_activation_request() const
{
  assert_choice_type(types::multicast_session_activation_request, type_, "InitiatingMessage");
  return c.get<multicast_session_activation_request_s>();
}
const multicast_session_deactivation_request_s&
ngap_elem_procs_o::init_msg_c::multicast_session_deactivation_request() const
{
  assert_choice_type(types::multicast_session_deactivation_request, type_, "InitiatingMessage");
  return c.get<multicast_session_deactivation_request_s>();
}
const multicast_session_upd_request_s& ngap_elem_procs_o::init_msg_c::multicast_session_upd_request() const
{
  assert_choice_type(types::multicast_session_upd_request, type_, "InitiatingMessage");
  return c.get<multicast_session_upd_request_s>();
}
const ng_reset_s& ngap_elem_procs_o::init_msg_c::ng_reset() const
{
  assert_choice_type(types::ng_reset, type_, "InitiatingMessage");
  return c.get<ng_reset_s>();
}
const ng_setup_request_s& ngap_elem_procs_o::init_msg_c::ng_setup_request() const
{
  assert_choice_type(types::ng_setup_request, type_, "InitiatingMessage");
  return c.get<ng_setup_request_s>();
}
const path_switch_request_s& ngap_elem_procs_o::init_msg_c::path_switch_request() const
{
  assert_choice_type(types::path_switch_request, type_, "InitiatingMessage");
  return c.get<path_switch_request_s>();
}
const pdu_session_res_modify_request_s& ngap_elem_procs_o::init_msg_c::pdu_session_res_modify_request() const
{
  assert_choice_type(types::pdu_session_res_modify_request, type_, "InitiatingMessage");
  return c.get<pdu_session_res_modify_request_s>();
}
const pdu_session_res_modify_ind_s& ngap_elem_procs_o::init_msg_c::pdu_session_res_modify_ind() const
{
  assert_choice_type(types::pdu_session_res_modify_ind, type_, "InitiatingMessage");
  return c.get<pdu_session_res_modify_ind_s>();
}
const pdu_session_res_release_cmd_s& ngap_elem_procs_o::init_msg_c::pdu_session_res_release_cmd() const
{
  assert_choice_type(types::pdu_session_res_release_cmd, type_, "InitiatingMessage");
  return c.get<pdu_session_res_release_cmd_s>();
}
const pdu_session_res_setup_request_s& ngap_elem_procs_o::init_msg_c::pdu_session_res_setup_request() const
{
  assert_choice_type(types::pdu_session_res_setup_request, type_, "InitiatingMessage");
  return c.get<pdu_session_res_setup_request_s>();
}
const pws_cancel_request_s& ngap_elem_procs_o::init_msg_c::pws_cancel_request() const
{
  assert_choice_type(types::pws_cancel_request, type_, "InitiatingMessage");
  return c.get<pws_cancel_request_s>();
}
const ran_cfg_upd_s& ngap_elem_procs_o::init_msg_c::ran_cfg_upd() const
{
  assert_choice_type(types::ran_cfg_upd, type_, "InitiatingMessage");
  return c.get<ran_cfg_upd_s>();
}
const ue_context_mod_request_s& ngap_elem_procs_o::init_msg_c::ue_context_mod_request() const
{
  assert_choice_type(types::ue_context_mod_request, type_, "InitiatingMessage");
  return c.get<ue_context_mod_request_s>();
}
const ue_context_release_cmd_s& ngap_elem_procs_o::init_msg_c::ue_context_release_cmd() const
{
  assert_choice_type(types::ue_context_release_cmd, type_, "InitiatingMessage");
  return c.get<ue_context_release_cmd_s>();
}
const ue_context_resume_request_s& ngap_elem_procs_o::init_msg_c::ue_context_resume_request() const
{
  assert_choice_type(types::ue_context_resume_request, type_, "InitiatingMessage");
  return c.get<ue_context_resume_request_s>();
}
const ue_context_suspend_request_s& ngap_elem_procs_o::init_msg_c::ue_context_suspend_request() const
{
  assert_choice_type(types::ue_context_suspend_request, type_, "InitiatingMessage");
  return c.get<ue_context_suspend_request_s>();
}
const ue_radio_cap_check_request_s& ngap_elem_procs_o::init_msg_c::ue_radio_cap_check_request() const
{
  assert_choice_type(types::ue_radio_cap_check_request, type_, "InitiatingMessage");
  return c.get<ue_radio_cap_check_request_s>();
}
const ue_radio_cap_id_map_request_s& ngap_elem_procs_o::init_msg_c::ue_radio_cap_id_map_request() const
{
  assert_choice_type(types::ue_radio_cap_id_map_request, type_, "InitiatingMessage");
  return c.get<ue_radio_cap_id_map_request_s>();
}
const write_replace_warning_request_s& ngap_elem_procs_o::init_msg_c::write_replace_warning_request() const
{
  assert_choice_type(types::write_replace_warning_request, type_, "InitiatingMessage");
  return c.get<write_replace_warning_request_s>();
}
const amf_cp_relocation_ind_s& ngap_elem_procs_o::init_msg_c::amf_cp_relocation_ind() const
{
  assert_choice_type(types::amf_cp_relocation_ind, type_, "InitiatingMessage");
  return c.get<amf_cp_relocation_ind_s>();
}
const amf_status_ind_s& ngap_elem_procs_o::init_msg_c::amf_status_ind() const
{
  assert_choice_type(types::amf_status_ind, type_, "InitiatingMessage");
  return c.get<amf_status_ind_s>();
}
const broadcast_session_release_required_s& ngap_elem_procs_o::init_msg_c::broadcast_session_release_required() const
{
  assert_choice_type(types::broadcast_session_release_required, type_, "InitiatingMessage");
  return c.get<broadcast_session_release_required_s>();
}
const cell_traffic_trace_s& ngap_elem_procs_o::init_msg_c::cell_traffic_trace() const
{
  assert_choice_type(types::cell_traffic_trace, type_, "InitiatingMessage");
  return c.get<cell_traffic_trace_s>();
}
const conn_establishment_ind_s& ngap_elem_procs_o::init_msg_c::conn_establishment_ind() const
{
  assert_choice_type(types::conn_establishment_ind, type_, "InitiatingMessage");
  return c.get<conn_establishment_ind_s>();
}
const deactiv_trace_s& ngap_elem_procs_o::init_msg_c::deactiv_trace() const
{
  assert_choice_type(types::deactiv_trace, type_, "InitiatingMessage");
  return c.get<deactiv_trace_s>();
}
const dl_nas_transport_s& ngap_elem_procs_o::init_msg_c::dl_nas_transport() const
{
  assert_choice_type(types::dl_nas_transport, type_, "InitiatingMessage");
  return c.get<dl_nas_transport_s>();
}
const dl_non_ue_associated_nrppa_transport_s&
ngap_elem_procs_o::init_msg_c::dl_non_ue_associated_nrppa_transport() const
{
  assert_choice_type(types::dl_non_ue_associated_nrppa_transport, type_, "InitiatingMessage");
  return c.get<dl_non_ue_associated_nrppa_transport_s>();
}
const dl_ran_cfg_transfer_s& ngap_elem_procs_o::init_msg_c::dl_ran_cfg_transfer() const
{
  assert_choice_type(types::dl_ran_cfg_transfer, type_, "InitiatingMessage");
  return c.get<dl_ran_cfg_transfer_s>();
}
const dl_ran_early_status_transfer_s& ngap_elem_procs_o::init_msg_c::dl_ran_early_status_transfer() const
{
  assert_choice_type(types::dl_ran_early_status_transfer, type_, "InitiatingMessage");
  return c.get<dl_ran_early_status_transfer_s>();
}
const dl_ran_status_transfer_s& ngap_elem_procs_o::init_msg_c::dl_ran_status_transfer() const
{
  assert_choice_type(types::dl_ran_status_transfer, type_, "InitiatingMessage");
  return c.get<dl_ran_status_transfer_s>();
}
const dl_rim_info_transfer_s& ngap_elem_procs_o::init_msg_c::dl_rim_info_transfer() const
{
  assert_choice_type(types::dl_rim_info_transfer, type_, "InitiatingMessage");
  return c.get<dl_rim_info_transfer_s>();
}
const dl_ue_associated_nrppa_transport_s& ngap_elem_procs_o::init_msg_c::dl_ue_associated_nrppa_transport() const
{
  assert_choice_type(types::dl_ue_associated_nrppa_transport, type_, "InitiatingMessage");
  return c.get<dl_ue_associated_nrppa_transport_s>();
}
const error_ind_s& ngap_elem_procs_o::init_msg_c::error_ind() const
{
  assert_choice_type(types::error_ind, type_, "InitiatingMessage");
  return c.get<error_ind_s>();
}
const ho_notify_s& ngap_elem_procs_o::init_msg_c::ho_notify() const
{
  assert_choice_type(types::ho_notify, type_, "InitiatingMessage");
  return c.get<ho_notify_s>();
}
const ho_success_s& ngap_elem_procs_o::init_msg_c::ho_success() const
{
  assert_choice_type(types::ho_success, type_, "InitiatingMessage");
  return c.get<ho_success_s>();
}
const init_ue_msg_s& ngap_elem_procs_o::init_msg_c::init_ue_msg() const
{
  assert_choice_type(types::init_ue_msg, type_, "InitiatingMessage");
  return c.get<init_ue_msg_s>();
}
const location_report_s& ngap_elem_procs_o::init_msg_c::location_report() const
{
  assert_choice_type(types::location_report, type_, "InitiatingMessage");
  return c.get<location_report_s>();
}
const location_report_ctrl_s& ngap_elem_procs_o::init_msg_c::location_report_ctrl() const
{
  assert_choice_type(types::location_report_ctrl, type_, "InitiatingMessage");
  return c.get<location_report_ctrl_s>();
}
const location_report_fail_ind_s& ngap_elem_procs_o::init_msg_c::location_report_fail_ind() const
{
  assert_choice_type(types::location_report_fail_ind, type_, "InitiatingMessage");
  return c.get<location_report_fail_ind_s>();
}
const multicast_group_paging_s& ngap_elem_procs_o::init_msg_c::multicast_group_paging() const
{
  assert_choice_type(types::multicast_group_paging, type_, "InitiatingMessage");
  return c.get<multicast_group_paging_s>();
}
const nas_non_delivery_ind_s& ngap_elem_procs_o::init_msg_c::nas_non_delivery_ind() const
{
  assert_choice_type(types::nas_non_delivery_ind, type_, "InitiatingMessage");
  return c.get<nas_non_delivery_ind_s>();
}
const overload_start_s& ngap_elem_procs_o::init_msg_c::overload_start() const
{
  assert_choice_type(types::overload_start, type_, "InitiatingMessage");
  return c.get<overload_start_s>();
}
const overload_stop_s& ngap_elem_procs_o::init_msg_c::overload_stop() const
{
  assert_choice_type(types::overload_stop, type_, "InitiatingMessage");
  return c.get<overload_stop_s>();
}
const paging_s& ngap_elem_procs_o::init_msg_c::paging() const
{
  assert_choice_type(types::paging, type_, "InitiatingMessage");
  return c.get<paging_s>();
}
const pdu_session_res_notify_s& ngap_elem_procs_o::init_msg_c::pdu_session_res_notify() const
{
  assert_choice_type(types::pdu_session_res_notify, type_, "InitiatingMessage");
  return c.get<pdu_session_res_notify_s>();
}
const private_msg_s& ngap_elem_procs_o::init_msg_c::private_msg() const
{
  assert_choice_type(types::private_msg, type_, "InitiatingMessage");
  return c.get<private_msg_s>();
}
const pws_fail_ind_s& ngap_elem_procs_o::init_msg_c::pws_fail_ind() const
{
  assert_choice_type(types::pws_fail_ind, type_, "InitiatingMessage");
  return c.get<pws_fail_ind_s>();
}
const pws_restart_ind_s& ngap_elem_procs_o::init_msg_c::pws_restart_ind() const
{
  assert_choice_type(types::pws_restart_ind, type_, "InitiatingMessage");
  return c.get<pws_restart_ind_s>();
}
const ran_cp_relocation_ind_s& ngap_elem_procs_o::init_msg_c::ran_cp_relocation_ind() const
{
  assert_choice_type(types::ran_cp_relocation_ind, type_, "InitiatingMessage");
  return c.get<ran_cp_relocation_ind_s>();
}
const reroute_nas_request_s& ngap_elem_procs_o::init_msg_c::reroute_nas_request() const
{
  assert_choice_type(types::reroute_nas_request, type_, "InitiatingMessage");
  return c.get<reroute_nas_request_s>();
}
const retrieve_ue_info_s& ngap_elem_procs_o::init_msg_c::retrieve_ue_info() const
{
  assert_choice_type(types::retrieve_ue_info, type_, "InitiatingMessage");
  return c.get<retrieve_ue_info_s>();
}
const rrc_inactive_transition_report_s& ngap_elem_procs_o::init_msg_c::rrc_inactive_transition_report() const
{
  assert_choice_type(types::rrc_inactive_transition_report, type_, "InitiatingMessage");
  return c.get<rrc_inactive_transition_report_s>();
}
const secondary_rat_data_usage_report_s& ngap_elem_procs_o::init_msg_c::secondary_rat_data_usage_report() const
{
  assert_choice_type(types::secondary_rat_data_usage_report, type_, "InitiatingMessage");
  return c.get<secondary_rat_data_usage_report_s>();
}
const trace_fail_ind_s& ngap_elem_procs_o::init_msg_c::trace_fail_ind() const
{
  assert_choice_type(types::trace_fail_ind, type_, "InitiatingMessage");
  return c.get<trace_fail_ind_s>();
}
const trace_start_s& ngap_elem_procs_o::init_msg_c::trace_start() const
{
  assert_choice_type(types::trace_start, type_, "InitiatingMessage");
  return c.get<trace_start_s>();
}
const ue_context_release_request_s& ngap_elem_procs_o::init_msg_c::ue_context_release_request() const
{
  assert_choice_type(types::ue_context_release_request, type_, "InitiatingMessage");
  return c.get<ue_context_release_request_s>();
}
const ue_info_transfer_s& ngap_elem_procs_o::init_msg_c::ue_info_transfer() const
{
  assert_choice_type(types::ue_info_transfer, type_, "InitiatingMessage");
  return c.get<ue_info_transfer_s>();
}
const ue_radio_cap_info_ind_s& ngap_elem_procs_o::init_msg_c::ue_radio_cap_info_ind() const
{
  assert_choice_type(types::ue_radio_cap_info_ind, type_, "InitiatingMessage");
  return c.get<ue_radio_cap_info_ind_s>();
}
const ue_tnla_binding_release_request_s& ngap_elem_procs_o::init_msg_c::ue_tnla_binding_release_request() const
{
  assert_choice_type(types::ue_tnla_binding_release_request, type_, "InitiatingMessage");
  return c.get<ue_tnla_binding_release_request_s>();
}
const ul_nas_transport_s& ngap_elem_procs_o::init_msg_c::ul_nas_transport() const
{
  assert_choice_type(types::ul_nas_transport, type_, "InitiatingMessage");
  return c.get<ul_nas_transport_s>();
}
const ul_non_ue_associated_nrppa_transport_s&
ngap_elem_procs_o::init_msg_c::ul_non_ue_associated_nrppa_transport() const
{
  assert_choice_type(types::ul_non_ue_associated_nrppa_transport, type_, "InitiatingMessage");
  return c.get<ul_non_ue_associated_nrppa_transport_s>();
}
const ul_ran_cfg_transfer_s& ngap_elem_procs_o::init_msg_c::ul_ran_cfg_transfer() const
{
  assert_choice_type(types::ul_ran_cfg_transfer, type_, "InitiatingMessage");
  return c.get<ul_ran_cfg_transfer_s>();
}
const ul_ran_early_status_transfer_s& ngap_elem_procs_o::init_msg_c::ul_ran_early_status_transfer() const
{
  assert_choice_type(types::ul_ran_early_status_transfer, type_, "InitiatingMessage");
  return c.get<ul_ran_early_status_transfer_s>();
}
const ul_ran_status_transfer_s& ngap_elem_procs_o::init_msg_c::ul_ran_status_transfer() const
{
  assert_choice_type(types::ul_ran_status_transfer, type_, "InitiatingMessage");
  return c.get<ul_ran_status_transfer_s>();
}
const ul_rim_info_transfer_s& ngap_elem_procs_o::init_msg_c::ul_rim_info_transfer() const
{
  assert_choice_type(types::ul_rim_info_transfer, type_, "InitiatingMessage");
  return c.get<ul_rim_info_transfer_s>();
}
const ul_ue_associated_nrppa_transport_s& ngap_elem_procs_o::init_msg_c::ul_ue_associated_nrppa_transport() const
{
  assert_choice_type(types::ul_ue_associated_nrppa_transport, type_, "InitiatingMessage");
  return c.get<ul_ue_associated_nrppa_transport_s>();
}
void ngap_elem_procs_o::init_msg_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_cfg_upd:
      j.write_fieldname("AMFConfigurationUpdate");
      c.get<amf_cfg_upd_s>().to_json(j);
      break;
    case types::broadcast_session_mod_request:
      j.write_fieldname("BroadcastSessionModificationRequest");
      c.get<broadcast_session_mod_request_s>().to_json(j);
      break;
    case types::broadcast_session_release_request:
      j.write_fieldname("BroadcastSessionReleaseRequest");
      c.get<broadcast_session_release_request_s>().to_json(j);
      break;
    case types::broadcast_session_setup_request:
      j.write_fieldname("BroadcastSessionSetupRequest");
      c.get<broadcast_session_setup_request_s>().to_json(j);
      break;
    case types::distribution_setup_request:
      j.write_fieldname("DistributionSetupRequest");
      c.get<distribution_setup_request_s>().to_json(j);
      break;
    case types::distribution_release_request:
      j.write_fieldname("DistributionReleaseRequest");
      c.get<distribution_release_request_s>().to_json(j);
      break;
    case types::ho_cancel:
      j.write_fieldname("HandoverCancel");
      c.get<ho_cancel_s>().to_json(j);
      break;
    case types::ho_required:
      j.write_fieldname("HandoverRequired");
      c.get<ho_required_s>().to_json(j);
      break;
    case types::ho_request:
      j.write_fieldname("HandoverRequest");
      c.get<ho_request_s>().to_json(j);
      break;
    case types::init_context_setup_request:
      j.write_fieldname("InitialContextSetupRequest");
      c.get<init_context_setup_request_s>().to_json(j);
      break;
    case types::multicast_session_activation_request:
      j.write_fieldname("MulticastSessionActivationRequest");
      c.get<multicast_session_activation_request_s>().to_json(j);
      break;
    case types::multicast_session_deactivation_request:
      j.write_fieldname("MulticastSessionDeactivationRequest");
      c.get<multicast_session_deactivation_request_s>().to_json(j);
      break;
    case types::multicast_session_upd_request:
      j.write_fieldname("MulticastSessionUpdateRequest");
      c.get<multicast_session_upd_request_s>().to_json(j);
      break;
    case types::ng_reset:
      j.write_fieldname("NGReset");
      c.get<ng_reset_s>().to_json(j);
      break;
    case types::ng_setup_request:
      j.write_fieldname("NGSetupRequest");
      c.get<ng_setup_request_s>().to_json(j);
      break;
    case types::path_switch_request:
      j.write_fieldname("PathSwitchRequest");
      c.get<path_switch_request_s>().to_json(j);
      break;
    case types::pdu_session_res_modify_request:
      j.write_fieldname("PDUSessionResourceModifyRequest");
      c.get<pdu_session_res_modify_request_s>().to_json(j);
      break;
    case types::pdu_session_res_modify_ind:
      j.write_fieldname("PDUSessionResourceModifyIndication");
      c.get<pdu_session_res_modify_ind_s>().to_json(j);
      break;
    case types::pdu_session_res_release_cmd:
      j.write_fieldname("PDUSessionResourceReleaseCommand");
      c.get<pdu_session_res_release_cmd_s>().to_json(j);
      break;
    case types::pdu_session_res_setup_request:
      j.write_fieldname("PDUSessionResourceSetupRequest");
      c.get<pdu_session_res_setup_request_s>().to_json(j);
      break;
    case types::pws_cancel_request:
      j.write_fieldname("PWSCancelRequest");
      c.get<pws_cancel_request_s>().to_json(j);
      break;
    case types::ran_cfg_upd:
      j.write_fieldname("RANConfigurationUpdate");
      c.get<ran_cfg_upd_s>().to_json(j);
      break;
    case types::ue_context_mod_request:
      j.write_fieldname("UEContextModificationRequest");
      c.get<ue_context_mod_request_s>().to_json(j);
      break;
    case types::ue_context_release_cmd:
      j.write_fieldname("UEContextReleaseCommand");
      c.get<ue_context_release_cmd_s>().to_json(j);
      break;
    case types::ue_context_resume_request:
      j.write_fieldname("UEContextResumeRequest");
      c.get<ue_context_resume_request_s>().to_json(j);
      break;
    case types::ue_context_suspend_request:
      j.write_fieldname("UEContextSuspendRequest");
      c.get<ue_context_suspend_request_s>().to_json(j);
      break;
    case types::ue_radio_cap_check_request:
      j.write_fieldname("UERadioCapabilityCheckRequest");
      c.get<ue_radio_cap_check_request_s>().to_json(j);
      break;
    case types::ue_radio_cap_id_map_request:
      j.write_fieldname("UERadioCapabilityIDMappingRequest");
      c.get<ue_radio_cap_id_map_request_s>().to_json(j);
      break;
    case types::write_replace_warning_request:
      j.write_fieldname("WriteReplaceWarningRequest");
      c.get<write_replace_warning_request_s>().to_json(j);
      break;
    case types::amf_cp_relocation_ind:
      j.write_fieldname("AMFCPRelocationIndication");
      c.get<amf_cp_relocation_ind_s>().to_json(j);
      break;
    case types::amf_status_ind:
      j.write_fieldname("AMFStatusIndication");
      c.get<amf_status_ind_s>().to_json(j);
      break;
    case types::broadcast_session_release_required:
      j.write_fieldname("BroadcastSessionReleaseRequired");
      c.get<broadcast_session_release_required_s>().to_json(j);
      break;
    case types::cell_traffic_trace:
      j.write_fieldname("CellTrafficTrace");
      c.get<cell_traffic_trace_s>().to_json(j);
      break;
    case types::conn_establishment_ind:
      j.write_fieldname("ConnectionEstablishmentIndication");
      c.get<conn_establishment_ind_s>().to_json(j);
      break;
    case types::deactiv_trace:
      j.write_fieldname("DeactivateTrace");
      c.get<deactiv_trace_s>().to_json(j);
      break;
    case types::dl_nas_transport:
      j.write_fieldname("DownlinkNASTransport");
      c.get<dl_nas_transport_s>().to_json(j);
      break;
    case types::dl_non_ue_associated_nrppa_transport:
      j.write_fieldname("DownlinkNonUEAssociatedNRPPaTransport");
      c.get<dl_non_ue_associated_nrppa_transport_s>().to_json(j);
      break;
    case types::dl_ran_cfg_transfer:
      j.write_fieldname("DownlinkRANConfigurationTransfer");
      c.get<dl_ran_cfg_transfer_s>().to_json(j);
      break;
    case types::dl_ran_early_status_transfer:
      j.write_fieldname("DownlinkRANEarlyStatusTransfer");
      c.get<dl_ran_early_status_transfer_s>().to_json(j);
      break;
    case types::dl_ran_status_transfer:
      j.write_fieldname("DownlinkRANStatusTransfer");
      c.get<dl_ran_status_transfer_s>().to_json(j);
      break;
    case types::dl_rim_info_transfer:
      j.write_fieldname("DownlinkRIMInformationTransfer");
      c.get<dl_rim_info_transfer_s>().to_json(j);
      break;
    case types::dl_ue_associated_nrppa_transport:
      j.write_fieldname("DownlinkUEAssociatedNRPPaTransport");
      c.get<dl_ue_associated_nrppa_transport_s>().to_json(j);
      break;
    case types::error_ind:
      j.write_fieldname("ErrorIndication");
      c.get<error_ind_s>().to_json(j);
      break;
    case types::ho_notify:
      j.write_fieldname("HandoverNotify");
      c.get<ho_notify_s>().to_json(j);
      break;
    case types::ho_success:
      j.write_fieldname("HandoverSuccess");
      c.get<ho_success_s>().to_json(j);
      break;
    case types::init_ue_msg:
      j.write_fieldname("InitialUEMessage");
      c.get<init_ue_msg_s>().to_json(j);
      break;
    case types::location_report:
      j.write_fieldname("LocationReport");
      c.get<location_report_s>().to_json(j);
      break;
    case types::location_report_ctrl:
      j.write_fieldname("LocationReportingControl");
      c.get<location_report_ctrl_s>().to_json(j);
      break;
    case types::location_report_fail_ind:
      j.write_fieldname("LocationReportingFailureIndication");
      c.get<location_report_fail_ind_s>().to_json(j);
      break;
    case types::multicast_group_paging:
      j.write_fieldname("MulticastGroupPaging");
      c.get<multicast_group_paging_s>().to_json(j);
      break;
    case types::nas_non_delivery_ind:
      j.write_fieldname("NASNonDeliveryIndication");
      c.get<nas_non_delivery_ind_s>().to_json(j);
      break;
    case types::overload_start:
      j.write_fieldname("OverloadStart");
      c.get<overload_start_s>().to_json(j);
      break;
    case types::overload_stop:
      j.write_fieldname("OverloadStop");
      c.get<overload_stop_s>().to_json(j);
      break;
    case types::paging:
      j.write_fieldname("Paging");
      c.get<paging_s>().to_json(j);
      break;
    case types::pdu_session_res_notify:
      j.write_fieldname("PDUSessionResourceNotify");
      c.get<pdu_session_res_notify_s>().to_json(j);
      break;
    case types::private_msg:
      j.write_fieldname("PrivateMessage");
      c.get<private_msg_s>().to_json(j);
      break;
    case types::pws_fail_ind:
      j.write_fieldname("PWSFailureIndication");
      c.get<pws_fail_ind_s>().to_json(j);
      break;
    case types::pws_restart_ind:
      j.write_fieldname("PWSRestartIndication");
      c.get<pws_restart_ind_s>().to_json(j);
      break;
    case types::ran_cp_relocation_ind:
      j.write_fieldname("RANCPRelocationIndication");
      c.get<ran_cp_relocation_ind_s>().to_json(j);
      break;
    case types::reroute_nas_request:
      j.write_fieldname("RerouteNASRequest");
      c.get<reroute_nas_request_s>().to_json(j);
      break;
    case types::retrieve_ue_info:
      j.write_fieldname("RetrieveUEInformation");
      c.get<retrieve_ue_info_s>().to_json(j);
      break;
    case types::rrc_inactive_transition_report:
      j.write_fieldname("RRCInactiveTransitionReport");
      c.get<rrc_inactive_transition_report_s>().to_json(j);
      break;
    case types::secondary_rat_data_usage_report:
      j.write_fieldname("SecondaryRATDataUsageReport");
      c.get<secondary_rat_data_usage_report_s>().to_json(j);
      break;
    case types::trace_fail_ind:
      j.write_fieldname("TraceFailureIndication");
      c.get<trace_fail_ind_s>().to_json(j);
      break;
    case types::trace_start:
      j.write_fieldname("TraceStart");
      c.get<trace_start_s>().to_json(j);
      break;
    case types::ue_context_release_request:
      j.write_fieldname("UEContextReleaseRequest");
      c.get<ue_context_release_request_s>().to_json(j);
      break;
    case types::ue_info_transfer:
      j.write_fieldname("UEInformationTransfer");
      c.get<ue_info_transfer_s>().to_json(j);
      break;
    case types::ue_radio_cap_info_ind:
      j.write_fieldname("UERadioCapabilityInfoIndication");
      c.get<ue_radio_cap_info_ind_s>().to_json(j);
      break;
    case types::ue_tnla_binding_release_request:
      j.write_fieldname("UETNLABindingReleaseRequest");
      c.get<ue_tnla_binding_release_request_s>().to_json(j);
      break;
    case types::ul_nas_transport:
      j.write_fieldname("UplinkNASTransport");
      c.get<ul_nas_transport_s>().to_json(j);
      break;
    case types::ul_non_ue_associated_nrppa_transport:
      j.write_fieldname("UplinkNonUEAssociatedNRPPaTransport");
      c.get<ul_non_ue_associated_nrppa_transport_s>().to_json(j);
      break;
    case types::ul_ran_cfg_transfer:
      j.write_fieldname("UplinkRANConfigurationTransfer");
      c.get<ul_ran_cfg_transfer_s>().to_json(j);
      break;
    case types::ul_ran_early_status_transfer:
      j.write_fieldname("UplinkRANEarlyStatusTransfer");
      c.get<ul_ran_early_status_transfer_s>().to_json(j);
      break;
    case types::ul_ran_status_transfer:
      j.write_fieldname("UplinkRANStatusTransfer");
      c.get<ul_ran_status_transfer_s>().to_json(j);
      break;
    case types::ul_rim_info_transfer:
      j.write_fieldname("UplinkRIMInformationTransfer");
      c.get<ul_rim_info_transfer_s>().to_json(j);
      break;
    case types::ul_ue_associated_nrppa_transport:
      j.write_fieldname("UplinkUEAssociatedNRPPaTransport");
      c.get<ul_ue_associated_nrppa_transport_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ngap_elem_procs_o::init_msg_c");
  }
  j.end_obj();
}
SRSASN_CODE ngap_elem_procs_o::init_msg_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_cfg_upd:
      HANDLE_CODE(c.get<amf_cfg_upd_s>().pack(bref));
      break;
    case types::broadcast_session_mod_request:
      HANDLE_CODE(c.get<broadcast_session_mod_request_s>().pack(bref));
      break;
    case types::broadcast_session_release_request:
      HANDLE_CODE(c.get<broadcast_session_release_request_s>().pack(bref));
      break;
    case types::broadcast_session_setup_request:
      HANDLE_CODE(c.get<broadcast_session_setup_request_s>().pack(bref));
      break;
    case types::distribution_setup_request:
      HANDLE_CODE(c.get<distribution_setup_request_s>().pack(bref));
      break;
    case types::distribution_release_request:
      HANDLE_CODE(c.get<distribution_release_request_s>().pack(bref));
      break;
    case types::ho_cancel:
      HANDLE_CODE(c.get<ho_cancel_s>().pack(bref));
      break;
    case types::ho_required:
      HANDLE_CODE(c.get<ho_required_s>().pack(bref));
      break;
    case types::ho_request:
      HANDLE_CODE(c.get<ho_request_s>().pack(bref));
      break;
    case types::init_context_setup_request:
      HANDLE_CODE(c.get<init_context_setup_request_s>().pack(bref));
      break;
    case types::multicast_session_activation_request:
      HANDLE_CODE(c.get<multicast_session_activation_request_s>().pack(bref));
      break;
    case types::multicast_session_deactivation_request:
      HANDLE_CODE(c.get<multicast_session_deactivation_request_s>().pack(bref));
      break;
    case types::multicast_session_upd_request:
      HANDLE_CODE(c.get<multicast_session_upd_request_s>().pack(bref));
      break;
    case types::ng_reset:
      HANDLE_CODE(c.get<ng_reset_s>().pack(bref));
      break;
    case types::ng_setup_request:
      HANDLE_CODE(c.get<ng_setup_request_s>().pack(bref));
      break;
    case types::path_switch_request:
      HANDLE_CODE(c.get<path_switch_request_s>().pack(bref));
      break;
    case types::pdu_session_res_modify_request:
      HANDLE_CODE(c.get<pdu_session_res_modify_request_s>().pack(bref));
      break;
    case types::pdu_session_res_modify_ind:
      HANDLE_CODE(c.get<pdu_session_res_modify_ind_s>().pack(bref));
      break;
    case types::pdu_session_res_release_cmd:
      HANDLE_CODE(c.get<pdu_session_res_release_cmd_s>().pack(bref));
      break;
    case types::pdu_session_res_setup_request:
      HANDLE_CODE(c.get<pdu_session_res_setup_request_s>().pack(bref));
      break;
    case types::pws_cancel_request:
      HANDLE_CODE(c.get<pws_cancel_request_s>().pack(bref));
      break;
    case types::ran_cfg_upd:
      HANDLE_CODE(c.get<ran_cfg_upd_s>().pack(bref));
      break;
    case types::ue_context_mod_request:
      HANDLE_CODE(c.get<ue_context_mod_request_s>().pack(bref));
      break;
    case types::ue_context_release_cmd:
      HANDLE_CODE(c.get<ue_context_release_cmd_s>().pack(bref));
      break;
    case types::ue_context_resume_request:
      HANDLE_CODE(c.get<ue_context_resume_request_s>().pack(bref));
      break;
    case types::ue_context_suspend_request:
      HANDLE_CODE(c.get<ue_context_suspend_request_s>().pack(bref));
      break;
    case types::ue_radio_cap_check_request:
      HANDLE_CODE(c.get<ue_radio_cap_check_request_s>().pack(bref));
      break;
    case types::ue_radio_cap_id_map_request:
      HANDLE_CODE(c.get<ue_radio_cap_id_map_request_s>().pack(bref));
      break;
    case types::write_replace_warning_request:
      HANDLE_CODE(c.get<write_replace_warning_request_s>().pack(bref));
      break;
    case types::amf_cp_relocation_ind:
      HANDLE_CODE(c.get<amf_cp_relocation_ind_s>().pack(bref));
      break;
    case types::amf_status_ind:
      HANDLE_CODE(c.get<amf_status_ind_s>().pack(bref));
      break;
    case types::broadcast_session_release_required:
      HANDLE_CODE(c.get<broadcast_session_release_required_s>().pack(bref));
      break;
    case types::cell_traffic_trace:
      HANDLE_CODE(c.get<cell_traffic_trace_s>().pack(bref));
      break;
    case types::conn_establishment_ind:
      HANDLE_CODE(c.get<conn_establishment_ind_s>().pack(bref));
      break;
    case types::deactiv_trace:
      HANDLE_CODE(c.get<deactiv_trace_s>().pack(bref));
      break;
    case types::dl_nas_transport:
      HANDLE_CODE(c.get<dl_nas_transport_s>().pack(bref));
      break;
    case types::dl_non_ue_associated_nrppa_transport:
      HANDLE_CODE(c.get<dl_non_ue_associated_nrppa_transport_s>().pack(bref));
      break;
    case types::dl_ran_cfg_transfer:
      HANDLE_CODE(c.get<dl_ran_cfg_transfer_s>().pack(bref));
      break;
    case types::dl_ran_early_status_transfer:
      HANDLE_CODE(c.get<dl_ran_early_status_transfer_s>().pack(bref));
      break;
    case types::dl_ran_status_transfer:
      HANDLE_CODE(c.get<dl_ran_status_transfer_s>().pack(bref));
      break;
    case types::dl_rim_info_transfer:
      HANDLE_CODE(c.get<dl_rim_info_transfer_s>().pack(bref));
      break;
    case types::dl_ue_associated_nrppa_transport:
      HANDLE_CODE(c.get<dl_ue_associated_nrppa_transport_s>().pack(bref));
      break;
    case types::error_ind:
      HANDLE_CODE(c.get<error_ind_s>().pack(bref));
      break;
    case types::ho_notify:
      HANDLE_CODE(c.get<ho_notify_s>().pack(bref));
      break;
    case types::ho_success:
      HANDLE_CODE(c.get<ho_success_s>().pack(bref));
      break;
    case types::init_ue_msg:
      HANDLE_CODE(c.get<init_ue_msg_s>().pack(bref));
      break;
    case types::location_report:
      HANDLE_CODE(c.get<location_report_s>().pack(bref));
      break;
    case types::location_report_ctrl:
      HANDLE_CODE(c.get<location_report_ctrl_s>().pack(bref));
      break;
    case types::location_report_fail_ind:
      HANDLE_CODE(c.get<location_report_fail_ind_s>().pack(bref));
      break;
    case types::multicast_group_paging:
      HANDLE_CODE(c.get<multicast_group_paging_s>().pack(bref));
      break;
    case types::nas_non_delivery_ind:
      HANDLE_CODE(c.get<nas_non_delivery_ind_s>().pack(bref));
      break;
    case types::overload_start:
      HANDLE_CODE(c.get<overload_start_s>().pack(bref));
      break;
    case types::overload_stop:
      HANDLE_CODE(c.get<overload_stop_s>().pack(bref));
      break;
    case types::paging:
      HANDLE_CODE(c.get<paging_s>().pack(bref));
      break;
    case types::pdu_session_res_notify:
      HANDLE_CODE(c.get<pdu_session_res_notify_s>().pack(bref));
      break;
    case types::private_msg:
      HANDLE_CODE(c.get<private_msg_s>().pack(bref));
      break;
    case types::pws_fail_ind:
      HANDLE_CODE(c.get<pws_fail_ind_s>().pack(bref));
      break;
    case types::pws_restart_ind:
      HANDLE_CODE(c.get<pws_restart_ind_s>().pack(bref));
      break;
    case types::ran_cp_relocation_ind:
      HANDLE_CODE(c.get<ran_cp_relocation_ind_s>().pack(bref));
      break;
    case types::reroute_nas_request:
      HANDLE_CODE(c.get<reroute_nas_request_s>().pack(bref));
      break;
    case types::retrieve_ue_info:
      HANDLE_CODE(c.get<retrieve_ue_info_s>().pack(bref));
      break;
    case types::rrc_inactive_transition_report:
      HANDLE_CODE(c.get<rrc_inactive_transition_report_s>().pack(bref));
      break;
    case types::secondary_rat_data_usage_report:
      HANDLE_CODE(c.get<secondary_rat_data_usage_report_s>().pack(bref));
      break;
    case types::trace_fail_ind:
      HANDLE_CODE(c.get<trace_fail_ind_s>().pack(bref));
      break;
    case types::trace_start:
      HANDLE_CODE(c.get<trace_start_s>().pack(bref));
      break;
    case types::ue_context_release_request:
      HANDLE_CODE(c.get<ue_context_release_request_s>().pack(bref));
      break;
    case types::ue_info_transfer:
      HANDLE_CODE(c.get<ue_info_transfer_s>().pack(bref));
      break;
    case types::ue_radio_cap_info_ind:
      HANDLE_CODE(c.get<ue_radio_cap_info_ind_s>().pack(bref));
      break;
    case types::ue_tnla_binding_release_request:
      HANDLE_CODE(c.get<ue_tnla_binding_release_request_s>().pack(bref));
      break;
    case types::ul_nas_transport:
      HANDLE_CODE(c.get<ul_nas_transport_s>().pack(bref));
      break;
    case types::ul_non_ue_associated_nrppa_transport:
      HANDLE_CODE(c.get<ul_non_ue_associated_nrppa_transport_s>().pack(bref));
      break;
    case types::ul_ran_cfg_transfer:
      HANDLE_CODE(c.get<ul_ran_cfg_transfer_s>().pack(bref));
      break;
    case types::ul_ran_early_status_transfer:
      HANDLE_CODE(c.get<ul_ran_early_status_transfer_s>().pack(bref));
      break;
    case types::ul_ran_status_transfer:
      HANDLE_CODE(c.get<ul_ran_status_transfer_s>().pack(bref));
      break;
    case types::ul_rim_info_transfer:
      HANDLE_CODE(c.get<ul_rim_info_transfer_s>().pack(bref));
      break;
    case types::ul_ue_associated_nrppa_transport:
      HANDLE_CODE(c.get<ul_ue_associated_nrppa_transport_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ngap_elem_procs_o::init_msg_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ngap_elem_procs_o::init_msg_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_cfg_upd:
      HANDLE_CODE(c.get<amf_cfg_upd_s>().unpack(bref));
      break;
    case types::broadcast_session_mod_request:
      HANDLE_CODE(c.get<broadcast_session_mod_request_s>().unpack(bref));
      break;
    case types::broadcast_session_release_request:
      HANDLE_CODE(c.get<broadcast_session_release_request_s>().unpack(bref));
      break;
    case types::broadcast_session_setup_request:
      HANDLE_CODE(c.get<broadcast_session_setup_request_s>().unpack(bref));
      break;
    case types::distribution_setup_request:
      HANDLE_CODE(c.get<distribution_setup_request_s>().unpack(bref));
      break;
    case types::distribution_release_request:
      HANDLE_CODE(c.get<distribution_release_request_s>().unpack(bref));
      break;
    case types::ho_cancel:
      HANDLE_CODE(c.get<ho_cancel_s>().unpack(bref));
      break;
    case types::ho_required:
      HANDLE_CODE(c.get<ho_required_s>().unpack(bref));
      break;
    case types::ho_request:
      HANDLE_CODE(c.get<ho_request_s>().unpack(bref));
      break;
    case types::init_context_setup_request:
      HANDLE_CODE(c.get<init_context_setup_request_s>().unpack(bref));
      break;
    case types::multicast_session_activation_request:
      HANDLE_CODE(c.get<multicast_session_activation_request_s>().unpack(bref));
      break;
    case types::multicast_session_deactivation_request:
      HANDLE_CODE(c.get<multicast_session_deactivation_request_s>().unpack(bref));
      break;
    case types::multicast_session_upd_request:
      HANDLE_CODE(c.get<multicast_session_upd_request_s>().unpack(bref));
      break;
    case types::ng_reset:
      HANDLE_CODE(c.get<ng_reset_s>().unpack(bref));
      break;
    case types::ng_setup_request:
      HANDLE_CODE(c.get<ng_setup_request_s>().unpack(bref));
      break;
    case types::path_switch_request:
      HANDLE_CODE(c.get<path_switch_request_s>().unpack(bref));
      break;
    case types::pdu_session_res_modify_request:
      HANDLE_CODE(c.get<pdu_session_res_modify_request_s>().unpack(bref));
      break;
    case types::pdu_session_res_modify_ind:
      HANDLE_CODE(c.get<pdu_session_res_modify_ind_s>().unpack(bref));
      break;
    case types::pdu_session_res_release_cmd:
      HANDLE_CODE(c.get<pdu_session_res_release_cmd_s>().unpack(bref));
      break;
    case types::pdu_session_res_setup_request:
      HANDLE_CODE(c.get<pdu_session_res_setup_request_s>().unpack(bref));
      break;
    case types::pws_cancel_request:
      HANDLE_CODE(c.get<pws_cancel_request_s>().unpack(bref));
      break;
    case types::ran_cfg_upd:
      HANDLE_CODE(c.get<ran_cfg_upd_s>().unpack(bref));
      break;
    case types::ue_context_mod_request:
      HANDLE_CODE(c.get<ue_context_mod_request_s>().unpack(bref));
      break;
    case types::ue_context_release_cmd:
      HANDLE_CODE(c.get<ue_context_release_cmd_s>().unpack(bref));
      break;
    case types::ue_context_resume_request:
      HANDLE_CODE(c.get<ue_context_resume_request_s>().unpack(bref));
      break;
    case types::ue_context_suspend_request:
      HANDLE_CODE(c.get<ue_context_suspend_request_s>().unpack(bref));
      break;
    case types::ue_radio_cap_check_request:
      HANDLE_CODE(c.get<ue_radio_cap_check_request_s>().unpack(bref));
      break;
    case types::ue_radio_cap_id_map_request:
      HANDLE_CODE(c.get<ue_radio_cap_id_map_request_s>().unpack(bref));
      break;
    case types::write_replace_warning_request:
      HANDLE_CODE(c.get<write_replace_warning_request_s>().unpack(bref));
      break;
    case types::amf_cp_relocation_ind:
      HANDLE_CODE(c.get<amf_cp_relocation_ind_s>().unpack(bref));
      break;
    case types::amf_status_ind:
      HANDLE_CODE(c.get<amf_status_ind_s>().unpack(bref));
      break;
    case types::broadcast_session_release_required:
      HANDLE_CODE(c.get<broadcast_session_release_required_s>().unpack(bref));
      break;
    case types::cell_traffic_trace:
      HANDLE_CODE(c.get<cell_traffic_trace_s>().unpack(bref));
      break;
    case types::conn_establishment_ind:
      HANDLE_CODE(c.get<conn_establishment_ind_s>().unpack(bref));
      break;
    case types::deactiv_trace:
      HANDLE_CODE(c.get<deactiv_trace_s>().unpack(bref));
      break;
    case types::dl_nas_transport:
      HANDLE_CODE(c.get<dl_nas_transport_s>().unpack(bref));
      break;
    case types::dl_non_ue_associated_nrppa_transport:
      HANDLE_CODE(c.get<dl_non_ue_associated_nrppa_transport_s>().unpack(bref));
      break;
    case types::dl_ran_cfg_transfer:
      HANDLE_CODE(c.get<dl_ran_cfg_transfer_s>().unpack(bref));
      break;
    case types::dl_ran_early_status_transfer:
      HANDLE_CODE(c.get<dl_ran_early_status_transfer_s>().unpack(bref));
      break;
    case types::dl_ran_status_transfer:
      HANDLE_CODE(c.get<dl_ran_status_transfer_s>().unpack(bref));
      break;
    case types::dl_rim_info_transfer:
      HANDLE_CODE(c.get<dl_rim_info_transfer_s>().unpack(bref));
      break;
    case types::dl_ue_associated_nrppa_transport:
      HANDLE_CODE(c.get<dl_ue_associated_nrppa_transport_s>().unpack(bref));
      break;
    case types::error_ind:
      HANDLE_CODE(c.get<error_ind_s>().unpack(bref));
      break;
    case types::ho_notify:
      HANDLE_CODE(c.get<ho_notify_s>().unpack(bref));
      break;
    case types::ho_success:
      HANDLE_CODE(c.get<ho_success_s>().unpack(bref));
      break;
    case types::init_ue_msg:
      HANDLE_CODE(c.get<init_ue_msg_s>().unpack(bref));
      break;
    case types::location_report:
      HANDLE_CODE(c.get<location_report_s>().unpack(bref));
      break;
    case types::location_report_ctrl:
      HANDLE_CODE(c.get<location_report_ctrl_s>().unpack(bref));
      break;
    case types::location_report_fail_ind:
      HANDLE_CODE(c.get<location_report_fail_ind_s>().unpack(bref));
      break;
    case types::multicast_group_paging:
      HANDLE_CODE(c.get<multicast_group_paging_s>().unpack(bref));
      break;
    case types::nas_non_delivery_ind:
      HANDLE_CODE(c.get<nas_non_delivery_ind_s>().unpack(bref));
      break;
    case types::overload_start:
      HANDLE_CODE(c.get<overload_start_s>().unpack(bref));
      break;
    case types::overload_stop:
      HANDLE_CODE(c.get<overload_stop_s>().unpack(bref));
      break;
    case types::paging:
      HANDLE_CODE(c.get<paging_s>().unpack(bref));
      break;
    case types::pdu_session_res_notify:
      HANDLE_CODE(c.get<pdu_session_res_notify_s>().unpack(bref));
      break;
    case types::private_msg:
      HANDLE_CODE(c.get<private_msg_s>().unpack(bref));
      break;
    case types::pws_fail_ind:
      HANDLE_CODE(c.get<pws_fail_ind_s>().unpack(bref));
      break;
    case types::pws_restart_ind:
      HANDLE_CODE(c.get<pws_restart_ind_s>().unpack(bref));
      break;
    case types::ran_cp_relocation_ind:
      HANDLE_CODE(c.get<ran_cp_relocation_ind_s>().unpack(bref));
      break;
    case types::reroute_nas_request:
      HANDLE_CODE(c.get<reroute_nas_request_s>().unpack(bref));
      break;
    case types::retrieve_ue_info:
      HANDLE_CODE(c.get<retrieve_ue_info_s>().unpack(bref));
      break;
    case types::rrc_inactive_transition_report:
      HANDLE_CODE(c.get<rrc_inactive_transition_report_s>().unpack(bref));
      break;
    case types::secondary_rat_data_usage_report:
      HANDLE_CODE(c.get<secondary_rat_data_usage_report_s>().unpack(bref));
      break;
    case types::trace_fail_ind:
      HANDLE_CODE(c.get<trace_fail_ind_s>().unpack(bref));
      break;
    case types::trace_start:
      HANDLE_CODE(c.get<trace_start_s>().unpack(bref));
      break;
    case types::ue_context_release_request:
      HANDLE_CODE(c.get<ue_context_release_request_s>().unpack(bref));
      break;
    case types::ue_info_transfer:
      HANDLE_CODE(c.get<ue_info_transfer_s>().unpack(bref));
      break;
    case types::ue_radio_cap_info_ind:
      HANDLE_CODE(c.get<ue_radio_cap_info_ind_s>().unpack(bref));
      break;
    case types::ue_tnla_binding_release_request:
      HANDLE_CODE(c.get<ue_tnla_binding_release_request_s>().unpack(bref));
      break;
    case types::ul_nas_transport:
      HANDLE_CODE(c.get<ul_nas_transport_s>().unpack(bref));
      break;
    case types::ul_non_ue_associated_nrppa_transport:
      HANDLE_CODE(c.get<ul_non_ue_associated_nrppa_transport_s>().unpack(bref));
      break;
    case types::ul_ran_cfg_transfer:
      HANDLE_CODE(c.get<ul_ran_cfg_transfer_s>().unpack(bref));
      break;
    case types::ul_ran_early_status_transfer:
      HANDLE_CODE(c.get<ul_ran_early_status_transfer_s>().unpack(bref));
      break;
    case types::ul_ran_status_transfer:
      HANDLE_CODE(c.get<ul_ran_status_transfer_s>().unpack(bref));
      break;
    case types::ul_rim_info_transfer:
      HANDLE_CODE(c.get<ul_rim_info_transfer_s>().unpack(bref));
      break;
    case types::ul_ue_associated_nrppa_transport:
      HANDLE_CODE(c.get<ul_ue_associated_nrppa_transport_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ngap_elem_procs_o::init_msg_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ngap_elem_procs_o::init_msg_c::types_opts::to_string() const
{
  static const char* names[] = {"AMFConfigurationUpdate",
                                "BroadcastSessionModificationRequest",
                                "BroadcastSessionReleaseRequest",
                                "BroadcastSessionSetupRequest",
                                "DistributionSetupRequest",
                                "DistributionReleaseRequest",
                                "HandoverCancel",
                                "HandoverRequired",
                                "HandoverRequest",
                                "InitialContextSetupRequest",
                                "MulticastSessionActivationRequest",
                                "MulticastSessionDeactivationRequest",
                                "MulticastSessionUpdateRequest",
                                "NGReset",
                                "NGSetupRequest",
                                "PathSwitchRequest",
                                "PDUSessionResourceModifyRequest",
                                "PDUSessionResourceModifyIndication",
                                "PDUSessionResourceReleaseCommand",
                                "PDUSessionResourceSetupRequest",
                                "PWSCancelRequest",
                                "RANConfigurationUpdate",
                                "UEContextModificationRequest",
                                "UEContextReleaseCommand",
                                "UEContextResumeRequest",
                                "UEContextSuspendRequest",
                                "UERadioCapabilityCheckRequest",
                                "UERadioCapabilityIDMappingRequest",
                                "WriteReplaceWarningRequest",
                                "AMFCPRelocationIndication",
                                "AMFStatusIndication",
                                "BroadcastSessionReleaseRequired",
                                "CellTrafficTrace",
                                "ConnectionEstablishmentIndication",
                                "DeactivateTrace",
                                "DownlinkNASTransport",
                                "DownlinkNonUEAssociatedNRPPaTransport",
                                "DownlinkRANConfigurationTransfer",
                                "DownlinkRANEarlyStatusTransfer",
                                "DownlinkRANStatusTransfer",
                                "DownlinkRIMInformationTransfer",
                                "DownlinkUEAssociatedNRPPaTransport",
                                "ErrorIndication",
                                "HandoverNotify",
                                "HandoverSuccess",
                                "InitialUEMessage",
                                "LocationReport",
                                "LocationReportingControl",
                                "LocationReportingFailureIndication",
                                "MulticastGroupPaging",
                                "NASNonDeliveryIndication",
                                "OverloadStart",
                                "OverloadStop",
                                "Paging",
                                "PDUSessionResourceNotify",
                                "PrivateMessage",
                                "PWSFailureIndication",
                                "PWSRestartIndication",
                                "RANCPRelocationIndication",
                                "RerouteNASRequest",
                                "RetrieveUEInformation",
                                "RRCInactiveTransitionReport",
                                "SecondaryRATDataUsageReport",
                                "TraceFailureIndication",
                                "TraceStart",
                                "UEContextReleaseRequest",
                                "UEInformationTransfer",
                                "UERadioCapabilityInfoIndication",
                                "UETNLABindingReleaseRequest",
                                "UplinkNASTransport",
                                "UplinkNonUEAssociatedNRPPaTransport",
                                "UplinkRANConfigurationTransfer",
                                "UplinkRANEarlyStatusTransfer",
                                "UplinkRANStatusTransfer",
                                "UplinkRIMInformationTransfer",
                                "UplinkUEAssociatedNRPPaTransport"};
  return convert_enum_idx(names, 76, value, "ngap_elem_procs_o::init_msg_c::types");
}

// SuccessfulOutcome ::= OPEN TYPE
void ngap_elem_procs_o::successful_outcome_c::destroy_()
{
  switch (type_) {
    case types::amf_cfg_upd_ack:
      c.destroy<amf_cfg_upd_ack_s>();
      break;
    case types::broadcast_session_mod_resp:
      c.destroy<broadcast_session_mod_resp_s>();
      break;
    case types::broadcast_session_release_resp:
      c.destroy<broadcast_session_release_resp_s>();
      break;
    case types::broadcast_session_setup_resp:
      c.destroy<broadcast_session_setup_resp_s>();
      break;
    case types::distribution_setup_resp:
      c.destroy<distribution_setup_resp_s>();
      break;
    case types::distribution_release_resp:
      c.destroy<distribution_release_resp_s>();
      break;
    case types::ho_cancel_ack:
      c.destroy<ho_cancel_ack_s>();
      break;
    case types::ho_cmd:
      c.destroy<ho_cmd_s>();
      break;
    case types::ho_request_ack:
      c.destroy<ho_request_ack_s>();
      break;
    case types::init_context_setup_resp:
      c.destroy<init_context_setup_resp_s>();
      break;
    case types::multicast_session_activation_resp:
      c.destroy<multicast_session_activation_resp_s>();
      break;
    case types::multicast_session_deactivation_resp:
      c.destroy<multicast_session_deactivation_resp_s>();
      break;
    case types::multicast_session_upd_resp:
      c.destroy<multicast_session_upd_resp_s>();
      break;
    case types::ng_reset_ack:
      c.destroy<ng_reset_ack_s>();
      break;
    case types::ng_setup_resp:
      c.destroy<ng_setup_resp_s>();
      break;
    case types::path_switch_request_ack:
      c.destroy<path_switch_request_ack_s>();
      break;
    case types::pdu_session_res_modify_resp:
      c.destroy<pdu_session_res_modify_resp_s>();
      break;
    case types::pdu_session_res_modify_confirm:
      c.destroy<pdu_session_res_modify_confirm_s>();
      break;
    case types::pdu_session_res_release_resp:
      c.destroy<pdu_session_res_release_resp_s>();
      break;
    case types::pdu_session_res_setup_resp:
      c.destroy<pdu_session_res_setup_resp_s>();
      break;
    case types::pws_cancel_resp:
      c.destroy<pws_cancel_resp_s>();
      break;
    case types::ran_cfg_upd_ack:
      c.destroy<ran_cfg_upd_ack_s>();
      break;
    case types::ue_context_mod_resp:
      c.destroy<ue_context_mod_resp_s>();
      break;
    case types::ue_context_release_complete:
      c.destroy<ue_context_release_complete_s>();
      break;
    case types::ue_context_resume_resp:
      c.destroy<ue_context_resume_resp_s>();
      break;
    case types::ue_context_suspend_resp:
      c.destroy<ue_context_suspend_resp_s>();
      break;
    case types::ue_radio_cap_check_resp:
      c.destroy<ue_radio_cap_check_resp_s>();
      break;
    case types::ue_radio_cap_id_map_resp:
      c.destroy<ue_radio_cap_id_map_resp_s>();
      break;
    case types::write_replace_warning_resp:
      c.destroy<write_replace_warning_resp_s>();
      break;
    default:
      break;
  }
}
void ngap_elem_procs_o::successful_outcome_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_cfg_upd_ack:
      c.init<amf_cfg_upd_ack_s>();
      break;
    case types::broadcast_session_mod_resp:
      c.init<broadcast_session_mod_resp_s>();
      break;
    case types::broadcast_session_release_resp:
      c.init<broadcast_session_release_resp_s>();
      break;
    case types::broadcast_session_setup_resp:
      c.init<broadcast_session_setup_resp_s>();
      break;
    case types::distribution_setup_resp:
      c.init<distribution_setup_resp_s>();
      break;
    case types::distribution_release_resp:
      c.init<distribution_release_resp_s>();
      break;
    case types::ho_cancel_ack:
      c.init<ho_cancel_ack_s>();
      break;
    case types::ho_cmd:
      c.init<ho_cmd_s>();
      break;
    case types::ho_request_ack:
      c.init<ho_request_ack_s>();
      break;
    case types::init_context_setup_resp:
      c.init<init_context_setup_resp_s>();
      break;
    case types::multicast_session_activation_resp:
      c.init<multicast_session_activation_resp_s>();
      break;
    case types::multicast_session_deactivation_resp:
      c.init<multicast_session_deactivation_resp_s>();
      break;
    case types::multicast_session_upd_resp:
      c.init<multicast_session_upd_resp_s>();
      break;
    case types::ng_reset_ack:
      c.init<ng_reset_ack_s>();
      break;
    case types::ng_setup_resp:
      c.init<ng_setup_resp_s>();
      break;
    case types::path_switch_request_ack:
      c.init<path_switch_request_ack_s>();
      break;
    case types::pdu_session_res_modify_resp:
      c.init<pdu_session_res_modify_resp_s>();
      break;
    case types::pdu_session_res_modify_confirm:
      c.init<pdu_session_res_modify_confirm_s>();
      break;
    case types::pdu_session_res_release_resp:
      c.init<pdu_session_res_release_resp_s>();
      break;
    case types::pdu_session_res_setup_resp:
      c.init<pdu_session_res_setup_resp_s>();
      break;
    case types::pws_cancel_resp:
      c.init<pws_cancel_resp_s>();
      break;
    case types::ran_cfg_upd_ack:
      c.init<ran_cfg_upd_ack_s>();
      break;
    case types::ue_context_mod_resp:
      c.init<ue_context_mod_resp_s>();
      break;
    case types::ue_context_release_complete:
      c.init<ue_context_release_complete_s>();
      break;
    case types::ue_context_resume_resp:
      c.init<ue_context_resume_resp_s>();
      break;
    case types::ue_context_suspend_resp:
      c.init<ue_context_suspend_resp_s>();
      break;
    case types::ue_radio_cap_check_resp:
      c.init<ue_radio_cap_check_resp_s>();
      break;
    case types::ue_radio_cap_id_map_resp:
      c.init<ue_radio_cap_id_map_resp_s>();
      break;
    case types::write_replace_warning_resp:
      c.init<write_replace_warning_resp_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ngap_elem_procs_o::successful_outcome_c");
  }
}
ngap_elem_procs_o::successful_outcome_c::successful_outcome_c(const ngap_elem_procs_o::successful_outcome_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_cfg_upd_ack:
      c.init(other.c.get<amf_cfg_upd_ack_s>());
      break;
    case types::broadcast_session_mod_resp:
      c.init(other.c.get<broadcast_session_mod_resp_s>());
      break;
    case types::broadcast_session_release_resp:
      c.init(other.c.get<broadcast_session_release_resp_s>());
      break;
    case types::broadcast_session_setup_resp:
      c.init(other.c.get<broadcast_session_setup_resp_s>());
      break;
    case types::distribution_setup_resp:
      c.init(other.c.get<distribution_setup_resp_s>());
      break;
    case types::distribution_release_resp:
      c.init(other.c.get<distribution_release_resp_s>());
      break;
    case types::ho_cancel_ack:
      c.init(other.c.get<ho_cancel_ack_s>());
      break;
    case types::ho_cmd:
      c.init(other.c.get<ho_cmd_s>());
      break;
    case types::ho_request_ack:
      c.init(other.c.get<ho_request_ack_s>());
      break;
    case types::init_context_setup_resp:
      c.init(other.c.get<init_context_setup_resp_s>());
      break;
    case types::multicast_session_activation_resp:
      c.init(other.c.get<multicast_session_activation_resp_s>());
      break;
    case types::multicast_session_deactivation_resp:
      c.init(other.c.get<multicast_session_deactivation_resp_s>());
      break;
    case types::multicast_session_upd_resp:
      c.init(other.c.get<multicast_session_upd_resp_s>());
      break;
    case types::ng_reset_ack:
      c.init(other.c.get<ng_reset_ack_s>());
      break;
    case types::ng_setup_resp:
      c.init(other.c.get<ng_setup_resp_s>());
      break;
    case types::path_switch_request_ack:
      c.init(other.c.get<path_switch_request_ack_s>());
      break;
    case types::pdu_session_res_modify_resp:
      c.init(other.c.get<pdu_session_res_modify_resp_s>());
      break;
    case types::pdu_session_res_modify_confirm:
      c.init(other.c.get<pdu_session_res_modify_confirm_s>());
      break;
    case types::pdu_session_res_release_resp:
      c.init(other.c.get<pdu_session_res_release_resp_s>());
      break;
    case types::pdu_session_res_setup_resp:
      c.init(other.c.get<pdu_session_res_setup_resp_s>());
      break;
    case types::pws_cancel_resp:
      c.init(other.c.get<pws_cancel_resp_s>());
      break;
    case types::ran_cfg_upd_ack:
      c.init(other.c.get<ran_cfg_upd_ack_s>());
      break;
    case types::ue_context_mod_resp:
      c.init(other.c.get<ue_context_mod_resp_s>());
      break;
    case types::ue_context_release_complete:
      c.init(other.c.get<ue_context_release_complete_s>());
      break;
    case types::ue_context_resume_resp:
      c.init(other.c.get<ue_context_resume_resp_s>());
      break;
    case types::ue_context_suspend_resp:
      c.init(other.c.get<ue_context_suspend_resp_s>());
      break;
    case types::ue_radio_cap_check_resp:
      c.init(other.c.get<ue_radio_cap_check_resp_s>());
      break;
    case types::ue_radio_cap_id_map_resp:
      c.init(other.c.get<ue_radio_cap_id_map_resp_s>());
      break;
    case types::write_replace_warning_resp:
      c.init(other.c.get<write_replace_warning_resp_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ngap_elem_procs_o::successful_outcome_c");
  }
}
ngap_elem_procs_o::successful_outcome_c&
ngap_elem_procs_o::successful_outcome_c::operator=(const ngap_elem_procs_o::successful_outcome_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_cfg_upd_ack:
      c.set(other.c.get<amf_cfg_upd_ack_s>());
      break;
    case types::broadcast_session_mod_resp:
      c.set(other.c.get<broadcast_session_mod_resp_s>());
      break;
    case types::broadcast_session_release_resp:
      c.set(other.c.get<broadcast_session_release_resp_s>());
      break;
    case types::broadcast_session_setup_resp:
      c.set(other.c.get<broadcast_session_setup_resp_s>());
      break;
    case types::distribution_setup_resp:
      c.set(other.c.get<distribution_setup_resp_s>());
      break;
    case types::distribution_release_resp:
      c.set(other.c.get<distribution_release_resp_s>());
      break;
    case types::ho_cancel_ack:
      c.set(other.c.get<ho_cancel_ack_s>());
      break;
    case types::ho_cmd:
      c.set(other.c.get<ho_cmd_s>());
      break;
    case types::ho_request_ack:
      c.set(other.c.get<ho_request_ack_s>());
      break;
    case types::init_context_setup_resp:
      c.set(other.c.get<init_context_setup_resp_s>());
      break;
    case types::multicast_session_activation_resp:
      c.set(other.c.get<multicast_session_activation_resp_s>());
      break;
    case types::multicast_session_deactivation_resp:
      c.set(other.c.get<multicast_session_deactivation_resp_s>());
      break;
    case types::multicast_session_upd_resp:
      c.set(other.c.get<multicast_session_upd_resp_s>());
      break;
    case types::ng_reset_ack:
      c.set(other.c.get<ng_reset_ack_s>());
      break;
    case types::ng_setup_resp:
      c.set(other.c.get<ng_setup_resp_s>());
      break;
    case types::path_switch_request_ack:
      c.set(other.c.get<path_switch_request_ack_s>());
      break;
    case types::pdu_session_res_modify_resp:
      c.set(other.c.get<pdu_session_res_modify_resp_s>());
      break;
    case types::pdu_session_res_modify_confirm:
      c.set(other.c.get<pdu_session_res_modify_confirm_s>());
      break;
    case types::pdu_session_res_release_resp:
      c.set(other.c.get<pdu_session_res_release_resp_s>());
      break;
    case types::pdu_session_res_setup_resp:
      c.set(other.c.get<pdu_session_res_setup_resp_s>());
      break;
    case types::pws_cancel_resp:
      c.set(other.c.get<pws_cancel_resp_s>());
      break;
    case types::ran_cfg_upd_ack:
      c.set(other.c.get<ran_cfg_upd_ack_s>());
      break;
    case types::ue_context_mod_resp:
      c.set(other.c.get<ue_context_mod_resp_s>());
      break;
    case types::ue_context_release_complete:
      c.set(other.c.get<ue_context_release_complete_s>());
      break;
    case types::ue_context_resume_resp:
      c.set(other.c.get<ue_context_resume_resp_s>());
      break;
    case types::ue_context_suspend_resp:
      c.set(other.c.get<ue_context_suspend_resp_s>());
      break;
    case types::ue_radio_cap_check_resp:
      c.set(other.c.get<ue_radio_cap_check_resp_s>());
      break;
    case types::ue_radio_cap_id_map_resp:
      c.set(other.c.get<ue_radio_cap_id_map_resp_s>());
      break;
    case types::write_replace_warning_resp:
      c.set(other.c.get<write_replace_warning_resp_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ngap_elem_procs_o::successful_outcome_c");
  }

  return *this;
}
amf_cfg_upd_ack_s& ngap_elem_procs_o::successful_outcome_c::amf_cfg_upd_ack()
{
  assert_choice_type(types::amf_cfg_upd_ack, type_, "SuccessfulOutcome");
  return c.get<amf_cfg_upd_ack_s>();
}
broadcast_session_mod_resp_s& ngap_elem_procs_o::successful_outcome_c::broadcast_session_mod_resp()
{
  assert_choice_type(types::broadcast_session_mod_resp, type_, "SuccessfulOutcome");
  return c.get<broadcast_session_mod_resp_s>();
}
broadcast_session_release_resp_s& ngap_elem_procs_o::successful_outcome_c::broadcast_session_release_resp()
{
  assert_choice_type(types::broadcast_session_release_resp, type_, "SuccessfulOutcome");
  return c.get<broadcast_session_release_resp_s>();
}
broadcast_session_setup_resp_s& ngap_elem_procs_o::successful_outcome_c::broadcast_session_setup_resp()
{
  assert_choice_type(types::broadcast_session_setup_resp, type_, "SuccessfulOutcome");
  return c.get<broadcast_session_setup_resp_s>();
}
distribution_setup_resp_s& ngap_elem_procs_o::successful_outcome_c::distribution_setup_resp()
{
  assert_choice_type(types::distribution_setup_resp, type_, "SuccessfulOutcome");
  return c.get<distribution_setup_resp_s>();
}
distribution_release_resp_s& ngap_elem_procs_o::successful_outcome_c::distribution_release_resp()
{
  assert_choice_type(types::distribution_release_resp, type_, "SuccessfulOutcome");
  return c.get<distribution_release_resp_s>();
}
ho_cancel_ack_s& ngap_elem_procs_o::successful_outcome_c::ho_cancel_ack()
{
  assert_choice_type(types::ho_cancel_ack, type_, "SuccessfulOutcome");
  return c.get<ho_cancel_ack_s>();
}
ho_cmd_s& ngap_elem_procs_o::successful_outcome_c::ho_cmd()
{
  assert_choice_type(types::ho_cmd, type_, "SuccessfulOutcome");
  return c.get<ho_cmd_s>();
}
ho_request_ack_s& ngap_elem_procs_o::successful_outcome_c::ho_request_ack()
{
  assert_choice_type(types::ho_request_ack, type_, "SuccessfulOutcome");
  return c.get<ho_request_ack_s>();
}
init_context_setup_resp_s& ngap_elem_procs_o::successful_outcome_c::init_context_setup_resp()
{
  assert_choice_type(types::init_context_setup_resp, type_, "SuccessfulOutcome");
  return c.get<init_context_setup_resp_s>();
}
multicast_session_activation_resp_s& ngap_elem_procs_o::successful_outcome_c::multicast_session_activation_resp()
{
  assert_choice_type(types::multicast_session_activation_resp, type_, "SuccessfulOutcome");
  return c.get<multicast_session_activation_resp_s>();
}
multicast_session_deactivation_resp_s& ngap_elem_procs_o::successful_outcome_c::multicast_session_deactivation_resp()
{
  assert_choice_type(types::multicast_session_deactivation_resp, type_, "SuccessfulOutcome");
  return c.get<multicast_session_deactivation_resp_s>();
}
multicast_session_upd_resp_s& ngap_elem_procs_o::successful_outcome_c::multicast_session_upd_resp()
{
  assert_choice_type(types::multicast_session_upd_resp, type_, "SuccessfulOutcome");
  return c.get<multicast_session_upd_resp_s>();
}
ng_reset_ack_s& ngap_elem_procs_o::successful_outcome_c::ng_reset_ack()
{
  assert_choice_type(types::ng_reset_ack, type_, "SuccessfulOutcome");
  return c.get<ng_reset_ack_s>();
}
ng_setup_resp_s& ngap_elem_procs_o::successful_outcome_c::ng_setup_resp()
{
  assert_choice_type(types::ng_setup_resp, type_, "SuccessfulOutcome");
  return c.get<ng_setup_resp_s>();
}
path_switch_request_ack_s& ngap_elem_procs_o::successful_outcome_c::path_switch_request_ack()
{
  assert_choice_type(types::path_switch_request_ack, type_, "SuccessfulOutcome");
  return c.get<path_switch_request_ack_s>();
}
pdu_session_res_modify_resp_s& ngap_elem_procs_o::successful_outcome_c::pdu_session_res_modify_resp()
{
  assert_choice_type(types::pdu_session_res_modify_resp, type_, "SuccessfulOutcome");
  return c.get<pdu_session_res_modify_resp_s>();
}
pdu_session_res_modify_confirm_s& ngap_elem_procs_o::successful_outcome_c::pdu_session_res_modify_confirm()
{
  assert_choice_type(types::pdu_session_res_modify_confirm, type_, "SuccessfulOutcome");
  return c.get<pdu_session_res_modify_confirm_s>();
}
pdu_session_res_release_resp_s& ngap_elem_procs_o::successful_outcome_c::pdu_session_res_release_resp()
{
  assert_choice_type(types::pdu_session_res_release_resp, type_, "SuccessfulOutcome");
  return c.get<pdu_session_res_release_resp_s>();
}
pdu_session_res_setup_resp_s& ngap_elem_procs_o::successful_outcome_c::pdu_session_res_setup_resp()
{
  assert_choice_type(types::pdu_session_res_setup_resp, type_, "SuccessfulOutcome");
  return c.get<pdu_session_res_setup_resp_s>();
}
pws_cancel_resp_s& ngap_elem_procs_o::successful_outcome_c::pws_cancel_resp()
{
  assert_choice_type(types::pws_cancel_resp, type_, "SuccessfulOutcome");
  return c.get<pws_cancel_resp_s>();
}
ran_cfg_upd_ack_s& ngap_elem_procs_o::successful_outcome_c::ran_cfg_upd_ack()
{
  assert_choice_type(types::ran_cfg_upd_ack, type_, "SuccessfulOutcome");
  return c.get<ran_cfg_upd_ack_s>();
}
ue_context_mod_resp_s& ngap_elem_procs_o::successful_outcome_c::ue_context_mod_resp()
{
  assert_choice_type(types::ue_context_mod_resp, type_, "SuccessfulOutcome");
  return c.get<ue_context_mod_resp_s>();
}
ue_context_release_complete_s& ngap_elem_procs_o::successful_outcome_c::ue_context_release_complete()
{
  assert_choice_type(types::ue_context_release_complete, type_, "SuccessfulOutcome");
  return c.get<ue_context_release_complete_s>();
}
ue_context_resume_resp_s& ngap_elem_procs_o::successful_outcome_c::ue_context_resume_resp()
{
  assert_choice_type(types::ue_context_resume_resp, type_, "SuccessfulOutcome");
  return c.get<ue_context_resume_resp_s>();
}
ue_context_suspend_resp_s& ngap_elem_procs_o::successful_outcome_c::ue_context_suspend_resp()
{
  assert_choice_type(types::ue_context_suspend_resp, type_, "SuccessfulOutcome");
  return c.get<ue_context_suspend_resp_s>();
}
ue_radio_cap_check_resp_s& ngap_elem_procs_o::successful_outcome_c::ue_radio_cap_check_resp()
{
  assert_choice_type(types::ue_radio_cap_check_resp, type_, "SuccessfulOutcome");
  return c.get<ue_radio_cap_check_resp_s>();
}
ue_radio_cap_id_map_resp_s& ngap_elem_procs_o::successful_outcome_c::ue_radio_cap_id_map_resp()
{
  assert_choice_type(types::ue_radio_cap_id_map_resp, type_, "SuccessfulOutcome");
  return c.get<ue_radio_cap_id_map_resp_s>();
}
write_replace_warning_resp_s& ngap_elem_procs_o::successful_outcome_c::write_replace_warning_resp()
{
  assert_choice_type(types::write_replace_warning_resp, type_, "SuccessfulOutcome");
  return c.get<write_replace_warning_resp_s>();
}
const amf_cfg_upd_ack_s& ngap_elem_procs_o::successful_outcome_c::amf_cfg_upd_ack() const
{
  assert_choice_type(types::amf_cfg_upd_ack, type_, "SuccessfulOutcome");
  return c.get<amf_cfg_upd_ack_s>();
}
const broadcast_session_mod_resp_s& ngap_elem_procs_o::successful_outcome_c::broadcast_session_mod_resp() const
{
  assert_choice_type(types::broadcast_session_mod_resp, type_, "SuccessfulOutcome");
  return c.get<broadcast_session_mod_resp_s>();
}
const broadcast_session_release_resp_s& ngap_elem_procs_o::successful_outcome_c::broadcast_session_release_resp() const
{
  assert_choice_type(types::broadcast_session_release_resp, type_, "SuccessfulOutcome");
  return c.get<broadcast_session_release_resp_s>();
}
const broadcast_session_setup_resp_s& ngap_elem_procs_o::successful_outcome_c::broadcast_session_setup_resp() const
{
  assert_choice_type(types::broadcast_session_setup_resp, type_, "SuccessfulOutcome");
  return c.get<broadcast_session_setup_resp_s>();
}
const distribution_setup_resp_s& ngap_elem_procs_o::successful_outcome_c::distribution_setup_resp() const
{
  assert_choice_type(types::distribution_setup_resp, type_, "SuccessfulOutcome");
  return c.get<distribution_setup_resp_s>();
}
const distribution_release_resp_s& ngap_elem_procs_o::successful_outcome_c::distribution_release_resp() const
{
  assert_choice_type(types::distribution_release_resp, type_, "SuccessfulOutcome");
  return c.get<distribution_release_resp_s>();
}
const ho_cancel_ack_s& ngap_elem_procs_o::successful_outcome_c::ho_cancel_ack() const
{
  assert_choice_type(types::ho_cancel_ack, type_, "SuccessfulOutcome");
  return c.get<ho_cancel_ack_s>();
}
const ho_cmd_s& ngap_elem_procs_o::successful_outcome_c::ho_cmd() const
{
  assert_choice_type(types::ho_cmd, type_, "SuccessfulOutcome");
  return c.get<ho_cmd_s>();
}
const ho_request_ack_s& ngap_elem_procs_o::successful_outcome_c::ho_request_ack() const
{
  assert_choice_type(types::ho_request_ack, type_, "SuccessfulOutcome");
  return c.get<ho_request_ack_s>();
}
const init_context_setup_resp_s& ngap_elem_procs_o::successful_outcome_c::init_context_setup_resp() const
{
  assert_choice_type(types::init_context_setup_resp, type_, "SuccessfulOutcome");
  return c.get<init_context_setup_resp_s>();
}
const multicast_session_activation_resp_s&
ngap_elem_procs_o::successful_outcome_c::multicast_session_activation_resp() const
{
  assert_choice_type(types::multicast_session_activation_resp, type_, "SuccessfulOutcome");
  return c.get<multicast_session_activation_resp_s>();
}
const multicast_session_deactivation_resp_s&
ngap_elem_procs_o::successful_outcome_c::multicast_session_deactivation_resp() const
{
  assert_choice_type(types::multicast_session_deactivation_resp, type_, "SuccessfulOutcome");
  return c.get<multicast_session_deactivation_resp_s>();
}
const multicast_session_upd_resp_s& ngap_elem_procs_o::successful_outcome_c::multicast_session_upd_resp() const
{
  assert_choice_type(types::multicast_session_upd_resp, type_, "SuccessfulOutcome");
  return c.get<multicast_session_upd_resp_s>();
}
const ng_reset_ack_s& ngap_elem_procs_o::successful_outcome_c::ng_reset_ack() const
{
  assert_choice_type(types::ng_reset_ack, type_, "SuccessfulOutcome");
  return c.get<ng_reset_ack_s>();
}
const ng_setup_resp_s& ngap_elem_procs_o::successful_outcome_c::ng_setup_resp() const
{
  assert_choice_type(types::ng_setup_resp, type_, "SuccessfulOutcome");
  return c.get<ng_setup_resp_s>();
}
const path_switch_request_ack_s& ngap_elem_procs_o::successful_outcome_c::path_switch_request_ack() const
{
  assert_choice_type(types::path_switch_request_ack, type_, "SuccessfulOutcome");
  return c.get<path_switch_request_ack_s>();
}
const pdu_session_res_modify_resp_s& ngap_elem_procs_o::successful_outcome_c::pdu_session_res_modify_resp() const
{
  assert_choice_type(types::pdu_session_res_modify_resp, type_, "SuccessfulOutcome");
  return c.get<pdu_session_res_modify_resp_s>();
}
const pdu_session_res_modify_confirm_s& ngap_elem_procs_o::successful_outcome_c::pdu_session_res_modify_confirm() const
{
  assert_choice_type(types::pdu_session_res_modify_confirm, type_, "SuccessfulOutcome");
  return c.get<pdu_session_res_modify_confirm_s>();
}
const pdu_session_res_release_resp_s& ngap_elem_procs_o::successful_outcome_c::pdu_session_res_release_resp() const
{
  assert_choice_type(types::pdu_session_res_release_resp, type_, "SuccessfulOutcome");
  return c.get<pdu_session_res_release_resp_s>();
}
const pdu_session_res_setup_resp_s& ngap_elem_procs_o::successful_outcome_c::pdu_session_res_setup_resp() const
{
  assert_choice_type(types::pdu_session_res_setup_resp, type_, "SuccessfulOutcome");
  return c.get<pdu_session_res_setup_resp_s>();
}
const pws_cancel_resp_s& ngap_elem_procs_o::successful_outcome_c::pws_cancel_resp() const
{
  assert_choice_type(types::pws_cancel_resp, type_, "SuccessfulOutcome");
  return c.get<pws_cancel_resp_s>();
}
const ran_cfg_upd_ack_s& ngap_elem_procs_o::successful_outcome_c::ran_cfg_upd_ack() const
{
  assert_choice_type(types::ran_cfg_upd_ack, type_, "SuccessfulOutcome");
  return c.get<ran_cfg_upd_ack_s>();
}
const ue_context_mod_resp_s& ngap_elem_procs_o::successful_outcome_c::ue_context_mod_resp() const
{
  assert_choice_type(types::ue_context_mod_resp, type_, "SuccessfulOutcome");
  return c.get<ue_context_mod_resp_s>();
}
const ue_context_release_complete_s& ngap_elem_procs_o::successful_outcome_c::ue_context_release_complete() const
{
  assert_choice_type(types::ue_context_release_complete, type_, "SuccessfulOutcome");
  return c.get<ue_context_release_complete_s>();
}
const ue_context_resume_resp_s& ngap_elem_procs_o::successful_outcome_c::ue_context_resume_resp() const
{
  assert_choice_type(types::ue_context_resume_resp, type_, "SuccessfulOutcome");
  return c.get<ue_context_resume_resp_s>();
}
const ue_context_suspend_resp_s& ngap_elem_procs_o::successful_outcome_c::ue_context_suspend_resp() const
{
  assert_choice_type(types::ue_context_suspend_resp, type_, "SuccessfulOutcome");
  return c.get<ue_context_suspend_resp_s>();
}
const ue_radio_cap_check_resp_s& ngap_elem_procs_o::successful_outcome_c::ue_radio_cap_check_resp() const
{
  assert_choice_type(types::ue_radio_cap_check_resp, type_, "SuccessfulOutcome");
  return c.get<ue_radio_cap_check_resp_s>();
}
const ue_radio_cap_id_map_resp_s& ngap_elem_procs_o::successful_outcome_c::ue_radio_cap_id_map_resp() const
{
  assert_choice_type(types::ue_radio_cap_id_map_resp, type_, "SuccessfulOutcome");
  return c.get<ue_radio_cap_id_map_resp_s>();
}
const write_replace_warning_resp_s& ngap_elem_procs_o::successful_outcome_c::write_replace_warning_resp() const
{
  assert_choice_type(types::write_replace_warning_resp, type_, "SuccessfulOutcome");
  return c.get<write_replace_warning_resp_s>();
}
void ngap_elem_procs_o::successful_outcome_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_cfg_upd_ack:
      j.write_fieldname("AMFConfigurationUpdateAcknowledge");
      c.get<amf_cfg_upd_ack_s>().to_json(j);
      break;
    case types::broadcast_session_mod_resp:
      j.write_fieldname("BroadcastSessionModificationResponse");
      c.get<broadcast_session_mod_resp_s>().to_json(j);
      break;
    case types::broadcast_session_release_resp:
      j.write_fieldname("BroadcastSessionReleaseResponse");
      c.get<broadcast_session_release_resp_s>().to_json(j);
      break;
    case types::broadcast_session_setup_resp:
      j.write_fieldname("BroadcastSessionSetupResponse");
      c.get<broadcast_session_setup_resp_s>().to_json(j);
      break;
    case types::distribution_setup_resp:
      j.write_fieldname("DistributionSetupResponse");
      c.get<distribution_setup_resp_s>().to_json(j);
      break;
    case types::distribution_release_resp:
      j.write_fieldname("DistributionReleaseResponse");
      c.get<distribution_release_resp_s>().to_json(j);
      break;
    case types::ho_cancel_ack:
      j.write_fieldname("HandoverCancelAcknowledge");
      c.get<ho_cancel_ack_s>().to_json(j);
      break;
    case types::ho_cmd:
      j.write_fieldname("HandoverCommand");
      c.get<ho_cmd_s>().to_json(j);
      break;
    case types::ho_request_ack:
      j.write_fieldname("HandoverRequestAcknowledge");
      c.get<ho_request_ack_s>().to_json(j);
      break;
    case types::init_context_setup_resp:
      j.write_fieldname("InitialContextSetupResponse");
      c.get<init_context_setup_resp_s>().to_json(j);
      break;
    case types::multicast_session_activation_resp:
      j.write_fieldname("MulticastSessionActivationResponse");
      c.get<multicast_session_activation_resp_s>().to_json(j);
      break;
    case types::multicast_session_deactivation_resp:
      j.write_fieldname("MulticastSessionDeactivationResponse");
      c.get<multicast_session_deactivation_resp_s>().to_json(j);
      break;
    case types::multicast_session_upd_resp:
      j.write_fieldname("MulticastSessionUpdateResponse");
      c.get<multicast_session_upd_resp_s>().to_json(j);
      break;
    case types::ng_reset_ack:
      j.write_fieldname("NGResetAcknowledge");
      c.get<ng_reset_ack_s>().to_json(j);
      break;
    case types::ng_setup_resp:
      j.write_fieldname("NGSetupResponse");
      c.get<ng_setup_resp_s>().to_json(j);
      break;
    case types::path_switch_request_ack:
      j.write_fieldname("PathSwitchRequestAcknowledge");
      c.get<path_switch_request_ack_s>().to_json(j);
      break;
    case types::pdu_session_res_modify_resp:
      j.write_fieldname("PDUSessionResourceModifyResponse");
      c.get<pdu_session_res_modify_resp_s>().to_json(j);
      break;
    case types::pdu_session_res_modify_confirm:
      j.write_fieldname("PDUSessionResourceModifyConfirm");
      c.get<pdu_session_res_modify_confirm_s>().to_json(j);
      break;
    case types::pdu_session_res_release_resp:
      j.write_fieldname("PDUSessionResourceReleaseResponse");
      c.get<pdu_session_res_release_resp_s>().to_json(j);
      break;
    case types::pdu_session_res_setup_resp:
      j.write_fieldname("PDUSessionResourceSetupResponse");
      c.get<pdu_session_res_setup_resp_s>().to_json(j);
      break;
    case types::pws_cancel_resp:
      j.write_fieldname("PWSCancelResponse");
      c.get<pws_cancel_resp_s>().to_json(j);
      break;
    case types::ran_cfg_upd_ack:
      j.write_fieldname("RANConfigurationUpdateAcknowledge");
      c.get<ran_cfg_upd_ack_s>().to_json(j);
      break;
    case types::ue_context_mod_resp:
      j.write_fieldname("UEContextModificationResponse");
      c.get<ue_context_mod_resp_s>().to_json(j);
      break;
    case types::ue_context_release_complete:
      j.write_fieldname("UEContextReleaseComplete");
      c.get<ue_context_release_complete_s>().to_json(j);
      break;
    case types::ue_context_resume_resp:
      j.write_fieldname("UEContextResumeResponse");
      c.get<ue_context_resume_resp_s>().to_json(j);
      break;
    case types::ue_context_suspend_resp:
      j.write_fieldname("UEContextSuspendResponse");
      c.get<ue_context_suspend_resp_s>().to_json(j);
      break;
    case types::ue_radio_cap_check_resp:
      j.write_fieldname("UERadioCapabilityCheckResponse");
      c.get<ue_radio_cap_check_resp_s>().to_json(j);
      break;
    case types::ue_radio_cap_id_map_resp:
      j.write_fieldname("UERadioCapabilityIDMappingResponse");
      c.get<ue_radio_cap_id_map_resp_s>().to_json(j);
      break;
    case types::write_replace_warning_resp:
      j.write_fieldname("WriteReplaceWarningResponse");
      c.get<write_replace_warning_resp_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ngap_elem_procs_o::successful_outcome_c");
  }
  j.end_obj();
}
SRSASN_CODE ngap_elem_procs_o::successful_outcome_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_cfg_upd_ack:
      HANDLE_CODE(c.get<amf_cfg_upd_ack_s>().pack(bref));
      break;
    case types::broadcast_session_mod_resp:
      HANDLE_CODE(c.get<broadcast_session_mod_resp_s>().pack(bref));
      break;
    case types::broadcast_session_release_resp:
      HANDLE_CODE(c.get<broadcast_session_release_resp_s>().pack(bref));
      break;
    case types::broadcast_session_setup_resp:
      HANDLE_CODE(c.get<broadcast_session_setup_resp_s>().pack(bref));
      break;
    case types::distribution_setup_resp:
      HANDLE_CODE(c.get<distribution_setup_resp_s>().pack(bref));
      break;
    case types::distribution_release_resp:
      HANDLE_CODE(c.get<distribution_release_resp_s>().pack(bref));
      break;
    case types::ho_cancel_ack:
      HANDLE_CODE(c.get<ho_cancel_ack_s>().pack(bref));
      break;
    case types::ho_cmd:
      HANDLE_CODE(c.get<ho_cmd_s>().pack(bref));
      break;
    case types::ho_request_ack:
      HANDLE_CODE(c.get<ho_request_ack_s>().pack(bref));
      break;
    case types::init_context_setup_resp:
      HANDLE_CODE(c.get<init_context_setup_resp_s>().pack(bref));
      break;
    case types::multicast_session_activation_resp:
      HANDLE_CODE(c.get<multicast_session_activation_resp_s>().pack(bref));
      break;
    case types::multicast_session_deactivation_resp:
      HANDLE_CODE(c.get<multicast_session_deactivation_resp_s>().pack(bref));
      break;
    case types::multicast_session_upd_resp:
      HANDLE_CODE(c.get<multicast_session_upd_resp_s>().pack(bref));
      break;
    case types::ng_reset_ack:
      HANDLE_CODE(c.get<ng_reset_ack_s>().pack(bref));
      break;
    case types::ng_setup_resp:
      HANDLE_CODE(c.get<ng_setup_resp_s>().pack(bref));
      break;
    case types::path_switch_request_ack:
      HANDLE_CODE(c.get<path_switch_request_ack_s>().pack(bref));
      break;
    case types::pdu_session_res_modify_resp:
      HANDLE_CODE(c.get<pdu_session_res_modify_resp_s>().pack(bref));
      break;
    case types::pdu_session_res_modify_confirm:
      HANDLE_CODE(c.get<pdu_session_res_modify_confirm_s>().pack(bref));
      break;
    case types::pdu_session_res_release_resp:
      HANDLE_CODE(c.get<pdu_session_res_release_resp_s>().pack(bref));
      break;
    case types::pdu_session_res_setup_resp:
      HANDLE_CODE(c.get<pdu_session_res_setup_resp_s>().pack(bref));
      break;
    case types::pws_cancel_resp:
      HANDLE_CODE(c.get<pws_cancel_resp_s>().pack(bref));
      break;
    case types::ran_cfg_upd_ack:
      HANDLE_CODE(c.get<ran_cfg_upd_ack_s>().pack(bref));
      break;
    case types::ue_context_mod_resp:
      HANDLE_CODE(c.get<ue_context_mod_resp_s>().pack(bref));
      break;
    case types::ue_context_release_complete:
      HANDLE_CODE(c.get<ue_context_release_complete_s>().pack(bref));
      break;
    case types::ue_context_resume_resp:
      HANDLE_CODE(c.get<ue_context_resume_resp_s>().pack(bref));
      break;
    case types::ue_context_suspend_resp:
      HANDLE_CODE(c.get<ue_context_suspend_resp_s>().pack(bref));
      break;
    case types::ue_radio_cap_check_resp:
      HANDLE_CODE(c.get<ue_radio_cap_check_resp_s>().pack(bref));
      break;
    case types::ue_radio_cap_id_map_resp:
      HANDLE_CODE(c.get<ue_radio_cap_id_map_resp_s>().pack(bref));
      break;
    case types::write_replace_warning_resp:
      HANDLE_CODE(c.get<write_replace_warning_resp_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ngap_elem_procs_o::successful_outcome_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ngap_elem_procs_o::successful_outcome_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_cfg_upd_ack:
      HANDLE_CODE(c.get<amf_cfg_upd_ack_s>().unpack(bref));
      break;
    case types::broadcast_session_mod_resp:
      HANDLE_CODE(c.get<broadcast_session_mod_resp_s>().unpack(bref));
      break;
    case types::broadcast_session_release_resp:
      HANDLE_CODE(c.get<broadcast_session_release_resp_s>().unpack(bref));
      break;
    case types::broadcast_session_setup_resp:
      HANDLE_CODE(c.get<broadcast_session_setup_resp_s>().unpack(bref));
      break;
    case types::distribution_setup_resp:
      HANDLE_CODE(c.get<distribution_setup_resp_s>().unpack(bref));
      break;
    case types::distribution_release_resp:
      HANDLE_CODE(c.get<distribution_release_resp_s>().unpack(bref));
      break;
    case types::ho_cancel_ack:
      HANDLE_CODE(c.get<ho_cancel_ack_s>().unpack(bref));
      break;
    case types::ho_cmd:
      HANDLE_CODE(c.get<ho_cmd_s>().unpack(bref));
      break;
    case types::ho_request_ack:
      HANDLE_CODE(c.get<ho_request_ack_s>().unpack(bref));
      break;
    case types::init_context_setup_resp:
      HANDLE_CODE(c.get<init_context_setup_resp_s>().unpack(bref));
      break;
    case types::multicast_session_activation_resp:
      HANDLE_CODE(c.get<multicast_session_activation_resp_s>().unpack(bref));
      break;
    case types::multicast_session_deactivation_resp:
      HANDLE_CODE(c.get<multicast_session_deactivation_resp_s>().unpack(bref));
      break;
    case types::multicast_session_upd_resp:
      HANDLE_CODE(c.get<multicast_session_upd_resp_s>().unpack(bref));
      break;
    case types::ng_reset_ack:
      HANDLE_CODE(c.get<ng_reset_ack_s>().unpack(bref));
      break;
    case types::ng_setup_resp:
      HANDLE_CODE(c.get<ng_setup_resp_s>().unpack(bref));
      break;
    case types::path_switch_request_ack:
      HANDLE_CODE(c.get<path_switch_request_ack_s>().unpack(bref));
      break;
    case types::pdu_session_res_modify_resp:
      HANDLE_CODE(c.get<pdu_session_res_modify_resp_s>().unpack(bref));
      break;
    case types::pdu_session_res_modify_confirm:
      HANDLE_CODE(c.get<pdu_session_res_modify_confirm_s>().unpack(bref));
      break;
    case types::pdu_session_res_release_resp:
      HANDLE_CODE(c.get<pdu_session_res_release_resp_s>().unpack(bref));
      break;
    case types::pdu_session_res_setup_resp:
      HANDLE_CODE(c.get<pdu_session_res_setup_resp_s>().unpack(bref));
      break;
    case types::pws_cancel_resp:
      HANDLE_CODE(c.get<pws_cancel_resp_s>().unpack(bref));
      break;
    case types::ran_cfg_upd_ack:
      HANDLE_CODE(c.get<ran_cfg_upd_ack_s>().unpack(bref));
      break;
    case types::ue_context_mod_resp:
      HANDLE_CODE(c.get<ue_context_mod_resp_s>().unpack(bref));
      break;
    case types::ue_context_release_complete:
      HANDLE_CODE(c.get<ue_context_release_complete_s>().unpack(bref));
      break;
    case types::ue_context_resume_resp:
      HANDLE_CODE(c.get<ue_context_resume_resp_s>().unpack(bref));
      break;
    case types::ue_context_suspend_resp:
      HANDLE_CODE(c.get<ue_context_suspend_resp_s>().unpack(bref));
      break;
    case types::ue_radio_cap_check_resp:
      HANDLE_CODE(c.get<ue_radio_cap_check_resp_s>().unpack(bref));
      break;
    case types::ue_radio_cap_id_map_resp:
      HANDLE_CODE(c.get<ue_radio_cap_id_map_resp_s>().unpack(bref));
      break;
    case types::write_replace_warning_resp:
      HANDLE_CODE(c.get<write_replace_warning_resp_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ngap_elem_procs_o::successful_outcome_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ngap_elem_procs_o::successful_outcome_c::types_opts::to_string() const
{
  static const char* names[] = {"AMFConfigurationUpdateAcknowledge",
                                "BroadcastSessionModificationResponse",
                                "BroadcastSessionReleaseResponse",
                                "BroadcastSessionSetupResponse",
                                "DistributionSetupResponse",
                                "DistributionReleaseResponse",
                                "HandoverCancelAcknowledge",
                                "HandoverCommand",
                                "HandoverRequestAcknowledge",
                                "InitialContextSetupResponse",
                                "MulticastSessionActivationResponse",
                                "MulticastSessionDeactivationResponse",
                                "MulticastSessionUpdateResponse",
                                "NGResetAcknowledge",
                                "NGSetupResponse",
                                "PathSwitchRequestAcknowledge",
                                "PDUSessionResourceModifyResponse",
                                "PDUSessionResourceModifyConfirm",
                                "PDUSessionResourceReleaseResponse",
                                "PDUSessionResourceSetupResponse",
                                "PWSCancelResponse",
                                "RANConfigurationUpdateAcknowledge",
                                "UEContextModificationResponse",
                                "UEContextReleaseComplete",
                                "UEContextResumeResponse",
                                "UEContextSuspendResponse",
                                "UERadioCapabilityCheckResponse",
                                "UERadioCapabilityIDMappingResponse",
                                "WriteReplaceWarningResponse"};
  return convert_enum_idx(names, 29, value, "ngap_elem_procs_o::successful_outcome_c::types");
}

// UnsuccessfulOutcome ::= OPEN TYPE
void ngap_elem_procs_o::unsuccessful_outcome_c::destroy_()
{
  switch (type_) {
    case types::amf_cfg_upd_fail:
      c.destroy<amf_cfg_upd_fail_s>();
      break;
    case types::broadcast_session_mod_fail:
      c.destroy<broadcast_session_mod_fail_s>();
      break;
    case types::broadcast_session_setup_fail:
      c.destroy<broadcast_session_setup_fail_s>();
      break;
    case types::distribution_setup_fail:
      c.destroy<distribution_setup_fail_s>();
      break;
    case types::ho_prep_fail:
      c.destroy<ho_prep_fail_s>();
      break;
    case types::ho_fail:
      c.destroy<ho_fail_s>();
      break;
    case types::init_context_setup_fail:
      c.destroy<init_context_setup_fail_s>();
      break;
    case types::multicast_session_activation_fail:
      c.destroy<multicast_session_activation_fail_s>();
      break;
    case types::multicast_session_upd_fail:
      c.destroy<multicast_session_upd_fail_s>();
      break;
    case types::ng_setup_fail:
      c.destroy<ng_setup_fail_s>();
      break;
    case types::path_switch_request_fail:
      c.destroy<path_switch_request_fail_s>();
      break;
    case types::ran_cfg_upd_fail:
      c.destroy<ran_cfg_upd_fail_s>();
      break;
    case types::ue_context_mod_fail:
      c.destroy<ue_context_mod_fail_s>();
      break;
    case types::ue_context_resume_fail:
      c.destroy<ue_context_resume_fail_s>();
      break;
    case types::ue_context_suspend_fail:
      c.destroy<ue_context_suspend_fail_s>();
      break;
    default:
      break;
  }
}
void ngap_elem_procs_o::unsuccessful_outcome_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_cfg_upd_fail:
      c.init<amf_cfg_upd_fail_s>();
      break;
    case types::broadcast_session_mod_fail:
      c.init<broadcast_session_mod_fail_s>();
      break;
    case types::broadcast_session_setup_fail:
      c.init<broadcast_session_setup_fail_s>();
      break;
    case types::distribution_setup_fail:
      c.init<distribution_setup_fail_s>();
      break;
    case types::ho_prep_fail:
      c.init<ho_prep_fail_s>();
      break;
    case types::ho_fail:
      c.init<ho_fail_s>();
      break;
    case types::init_context_setup_fail:
      c.init<init_context_setup_fail_s>();
      break;
    case types::multicast_session_activation_fail:
      c.init<multicast_session_activation_fail_s>();
      break;
    case types::multicast_session_upd_fail:
      c.init<multicast_session_upd_fail_s>();
      break;
    case types::ng_setup_fail:
      c.init<ng_setup_fail_s>();
      break;
    case types::path_switch_request_fail:
      c.init<path_switch_request_fail_s>();
      break;
    case types::ran_cfg_upd_fail:
      c.init<ran_cfg_upd_fail_s>();
      break;
    case types::ue_context_mod_fail:
      c.init<ue_context_mod_fail_s>();
      break;
    case types::ue_context_resume_fail:
      c.init<ue_context_resume_fail_s>();
      break;
    case types::ue_context_suspend_fail:
      c.init<ue_context_suspend_fail_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ngap_elem_procs_o::unsuccessful_outcome_c");
  }
}
ngap_elem_procs_o::unsuccessful_outcome_c::unsuccessful_outcome_c(
    const ngap_elem_procs_o::unsuccessful_outcome_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_cfg_upd_fail:
      c.init(other.c.get<amf_cfg_upd_fail_s>());
      break;
    case types::broadcast_session_mod_fail:
      c.init(other.c.get<broadcast_session_mod_fail_s>());
      break;
    case types::broadcast_session_setup_fail:
      c.init(other.c.get<broadcast_session_setup_fail_s>());
      break;
    case types::distribution_setup_fail:
      c.init(other.c.get<distribution_setup_fail_s>());
      break;
    case types::ho_prep_fail:
      c.init(other.c.get<ho_prep_fail_s>());
      break;
    case types::ho_fail:
      c.init(other.c.get<ho_fail_s>());
      break;
    case types::init_context_setup_fail:
      c.init(other.c.get<init_context_setup_fail_s>());
      break;
    case types::multicast_session_activation_fail:
      c.init(other.c.get<multicast_session_activation_fail_s>());
      break;
    case types::multicast_session_upd_fail:
      c.init(other.c.get<multicast_session_upd_fail_s>());
      break;
    case types::ng_setup_fail:
      c.init(other.c.get<ng_setup_fail_s>());
      break;
    case types::path_switch_request_fail:
      c.init(other.c.get<path_switch_request_fail_s>());
      break;
    case types::ran_cfg_upd_fail:
      c.init(other.c.get<ran_cfg_upd_fail_s>());
      break;
    case types::ue_context_mod_fail:
      c.init(other.c.get<ue_context_mod_fail_s>());
      break;
    case types::ue_context_resume_fail:
      c.init(other.c.get<ue_context_resume_fail_s>());
      break;
    case types::ue_context_suspend_fail:
      c.init(other.c.get<ue_context_suspend_fail_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ngap_elem_procs_o::unsuccessful_outcome_c");
  }
}
ngap_elem_procs_o::unsuccessful_outcome_c&
ngap_elem_procs_o::unsuccessful_outcome_c::operator=(const ngap_elem_procs_o::unsuccessful_outcome_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_cfg_upd_fail:
      c.set(other.c.get<amf_cfg_upd_fail_s>());
      break;
    case types::broadcast_session_mod_fail:
      c.set(other.c.get<broadcast_session_mod_fail_s>());
      break;
    case types::broadcast_session_setup_fail:
      c.set(other.c.get<broadcast_session_setup_fail_s>());
      break;
    case types::distribution_setup_fail:
      c.set(other.c.get<distribution_setup_fail_s>());
      break;
    case types::ho_prep_fail:
      c.set(other.c.get<ho_prep_fail_s>());
      break;
    case types::ho_fail:
      c.set(other.c.get<ho_fail_s>());
      break;
    case types::init_context_setup_fail:
      c.set(other.c.get<init_context_setup_fail_s>());
      break;
    case types::multicast_session_activation_fail:
      c.set(other.c.get<multicast_session_activation_fail_s>());
      break;
    case types::multicast_session_upd_fail:
      c.set(other.c.get<multicast_session_upd_fail_s>());
      break;
    case types::ng_setup_fail:
      c.set(other.c.get<ng_setup_fail_s>());
      break;
    case types::path_switch_request_fail:
      c.set(other.c.get<path_switch_request_fail_s>());
      break;
    case types::ran_cfg_upd_fail:
      c.set(other.c.get<ran_cfg_upd_fail_s>());
      break;
    case types::ue_context_mod_fail:
      c.set(other.c.get<ue_context_mod_fail_s>());
      break;
    case types::ue_context_resume_fail:
      c.set(other.c.get<ue_context_resume_fail_s>());
      break;
    case types::ue_context_suspend_fail:
      c.set(other.c.get<ue_context_suspend_fail_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ngap_elem_procs_o::unsuccessful_outcome_c");
  }

  return *this;
}
amf_cfg_upd_fail_s& ngap_elem_procs_o::unsuccessful_outcome_c::amf_cfg_upd_fail()
{
  assert_choice_type(types::amf_cfg_upd_fail, type_, "UnsuccessfulOutcome");
  return c.get<amf_cfg_upd_fail_s>();
}
broadcast_session_mod_fail_s& ngap_elem_procs_o::unsuccessful_outcome_c::broadcast_session_mod_fail()
{
  assert_choice_type(types::broadcast_session_mod_fail, type_, "UnsuccessfulOutcome");
  return c.get<broadcast_session_mod_fail_s>();
}
broadcast_session_setup_fail_s& ngap_elem_procs_o::unsuccessful_outcome_c::broadcast_session_setup_fail()
{
  assert_choice_type(types::broadcast_session_setup_fail, type_, "UnsuccessfulOutcome");
  return c.get<broadcast_session_setup_fail_s>();
}
distribution_setup_fail_s& ngap_elem_procs_o::unsuccessful_outcome_c::distribution_setup_fail()
{
  assert_choice_type(types::distribution_setup_fail, type_, "UnsuccessfulOutcome");
  return c.get<distribution_setup_fail_s>();
}
ho_prep_fail_s& ngap_elem_procs_o::unsuccessful_outcome_c::ho_prep_fail()
{
  assert_choice_type(types::ho_prep_fail, type_, "UnsuccessfulOutcome");
  return c.get<ho_prep_fail_s>();
}
ho_fail_s& ngap_elem_procs_o::unsuccessful_outcome_c::ho_fail()
{
  assert_choice_type(types::ho_fail, type_, "UnsuccessfulOutcome");
  return c.get<ho_fail_s>();
}
init_context_setup_fail_s& ngap_elem_procs_o::unsuccessful_outcome_c::init_context_setup_fail()
{
  assert_choice_type(types::init_context_setup_fail, type_, "UnsuccessfulOutcome");
  return c.get<init_context_setup_fail_s>();
}
multicast_session_activation_fail_s& ngap_elem_procs_o::unsuccessful_outcome_c::multicast_session_activation_fail()
{
  assert_choice_type(types::multicast_session_activation_fail, type_, "UnsuccessfulOutcome");
  return c.get<multicast_session_activation_fail_s>();
}
multicast_session_upd_fail_s& ngap_elem_procs_o::unsuccessful_outcome_c::multicast_session_upd_fail()
{
  assert_choice_type(types::multicast_session_upd_fail, type_, "UnsuccessfulOutcome");
  return c.get<multicast_session_upd_fail_s>();
}
ng_setup_fail_s& ngap_elem_procs_o::unsuccessful_outcome_c::ng_setup_fail()
{
  assert_choice_type(types::ng_setup_fail, type_, "UnsuccessfulOutcome");
  return c.get<ng_setup_fail_s>();
}
path_switch_request_fail_s& ngap_elem_procs_o::unsuccessful_outcome_c::path_switch_request_fail()
{
  assert_choice_type(types::path_switch_request_fail, type_, "UnsuccessfulOutcome");
  return c.get<path_switch_request_fail_s>();
}
ran_cfg_upd_fail_s& ngap_elem_procs_o::unsuccessful_outcome_c::ran_cfg_upd_fail()
{
  assert_choice_type(types::ran_cfg_upd_fail, type_, "UnsuccessfulOutcome");
  return c.get<ran_cfg_upd_fail_s>();
}
ue_context_mod_fail_s& ngap_elem_procs_o::unsuccessful_outcome_c::ue_context_mod_fail()
{
  assert_choice_type(types::ue_context_mod_fail, type_, "UnsuccessfulOutcome");
  return c.get<ue_context_mod_fail_s>();
}
ue_context_resume_fail_s& ngap_elem_procs_o::unsuccessful_outcome_c::ue_context_resume_fail()
{
  assert_choice_type(types::ue_context_resume_fail, type_, "UnsuccessfulOutcome");
  return c.get<ue_context_resume_fail_s>();
}
ue_context_suspend_fail_s& ngap_elem_procs_o::unsuccessful_outcome_c::ue_context_suspend_fail()
{
  assert_choice_type(types::ue_context_suspend_fail, type_, "UnsuccessfulOutcome");
  return c.get<ue_context_suspend_fail_s>();
}
const amf_cfg_upd_fail_s& ngap_elem_procs_o::unsuccessful_outcome_c::amf_cfg_upd_fail() const
{
  assert_choice_type(types::amf_cfg_upd_fail, type_, "UnsuccessfulOutcome");
  return c.get<amf_cfg_upd_fail_s>();
}
const broadcast_session_mod_fail_s& ngap_elem_procs_o::unsuccessful_outcome_c::broadcast_session_mod_fail() const
{
  assert_choice_type(types::broadcast_session_mod_fail, type_, "UnsuccessfulOutcome");
  return c.get<broadcast_session_mod_fail_s>();
}
const broadcast_session_setup_fail_s& ngap_elem_procs_o::unsuccessful_outcome_c::broadcast_session_setup_fail() const
{
  assert_choice_type(types::broadcast_session_setup_fail, type_, "UnsuccessfulOutcome");
  return c.get<broadcast_session_setup_fail_s>();
}
const distribution_setup_fail_s& ngap_elem_procs_o::unsuccessful_outcome_c::distribution_setup_fail() const
{
  assert_choice_type(types::distribution_setup_fail, type_, "UnsuccessfulOutcome");
  return c.get<distribution_setup_fail_s>();
}
const ho_prep_fail_s& ngap_elem_procs_o::unsuccessful_outcome_c::ho_prep_fail() const
{
  assert_choice_type(types::ho_prep_fail, type_, "UnsuccessfulOutcome");
  return c.get<ho_prep_fail_s>();
}
const ho_fail_s& ngap_elem_procs_o::unsuccessful_outcome_c::ho_fail() const
{
  assert_choice_type(types::ho_fail, type_, "UnsuccessfulOutcome");
  return c.get<ho_fail_s>();
}
const init_context_setup_fail_s& ngap_elem_procs_o::unsuccessful_outcome_c::init_context_setup_fail() const
{
  assert_choice_type(types::init_context_setup_fail, type_, "UnsuccessfulOutcome");
  return c.get<init_context_setup_fail_s>();
}
const multicast_session_activation_fail_s&
ngap_elem_procs_o::unsuccessful_outcome_c::multicast_session_activation_fail() const
{
  assert_choice_type(types::multicast_session_activation_fail, type_, "UnsuccessfulOutcome");
  return c.get<multicast_session_activation_fail_s>();
}
const multicast_session_upd_fail_s& ngap_elem_procs_o::unsuccessful_outcome_c::multicast_session_upd_fail() const
{
  assert_choice_type(types::multicast_session_upd_fail, type_, "UnsuccessfulOutcome");
  return c.get<multicast_session_upd_fail_s>();
}
const ng_setup_fail_s& ngap_elem_procs_o::unsuccessful_outcome_c::ng_setup_fail() const
{
  assert_choice_type(types::ng_setup_fail, type_, "UnsuccessfulOutcome");
  return c.get<ng_setup_fail_s>();
}
const path_switch_request_fail_s& ngap_elem_procs_o::unsuccessful_outcome_c::path_switch_request_fail() const
{
  assert_choice_type(types::path_switch_request_fail, type_, "UnsuccessfulOutcome");
  return c.get<path_switch_request_fail_s>();
}
const ran_cfg_upd_fail_s& ngap_elem_procs_o::unsuccessful_outcome_c::ran_cfg_upd_fail() const
{
  assert_choice_type(types::ran_cfg_upd_fail, type_, "UnsuccessfulOutcome");
  return c.get<ran_cfg_upd_fail_s>();
}
const ue_context_mod_fail_s& ngap_elem_procs_o::unsuccessful_outcome_c::ue_context_mod_fail() const
{
  assert_choice_type(types::ue_context_mod_fail, type_, "UnsuccessfulOutcome");
  return c.get<ue_context_mod_fail_s>();
}
const ue_context_resume_fail_s& ngap_elem_procs_o::unsuccessful_outcome_c::ue_context_resume_fail() const
{
  assert_choice_type(types::ue_context_resume_fail, type_, "UnsuccessfulOutcome");
  return c.get<ue_context_resume_fail_s>();
}
const ue_context_suspend_fail_s& ngap_elem_procs_o::unsuccessful_outcome_c::ue_context_suspend_fail() const
{
  assert_choice_type(types::ue_context_suspend_fail, type_, "UnsuccessfulOutcome");
  return c.get<ue_context_suspend_fail_s>();
}
void ngap_elem_procs_o::unsuccessful_outcome_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_cfg_upd_fail:
      j.write_fieldname("AMFConfigurationUpdateFailure");
      c.get<amf_cfg_upd_fail_s>().to_json(j);
      break;
    case types::broadcast_session_mod_fail:
      j.write_fieldname("BroadcastSessionModificationFailure");
      c.get<broadcast_session_mod_fail_s>().to_json(j);
      break;
    case types::broadcast_session_setup_fail:
      j.write_fieldname("BroadcastSessionSetupFailure");
      c.get<broadcast_session_setup_fail_s>().to_json(j);
      break;
    case types::distribution_setup_fail:
      j.write_fieldname("DistributionSetupFailure");
      c.get<distribution_setup_fail_s>().to_json(j);
      break;
    case types::ho_prep_fail:
      j.write_fieldname("HandoverPreparationFailure");
      c.get<ho_prep_fail_s>().to_json(j);
      break;
    case types::ho_fail:
      j.write_fieldname("HandoverFailure");
      c.get<ho_fail_s>().to_json(j);
      break;
    case types::init_context_setup_fail:
      j.write_fieldname("InitialContextSetupFailure");
      c.get<init_context_setup_fail_s>().to_json(j);
      break;
    case types::multicast_session_activation_fail:
      j.write_fieldname("MulticastSessionActivationFailure");
      c.get<multicast_session_activation_fail_s>().to_json(j);
      break;
    case types::multicast_session_upd_fail:
      j.write_fieldname("MulticastSessionUpdateFailure");
      c.get<multicast_session_upd_fail_s>().to_json(j);
      break;
    case types::ng_setup_fail:
      j.write_fieldname("NGSetupFailure");
      c.get<ng_setup_fail_s>().to_json(j);
      break;
    case types::path_switch_request_fail:
      j.write_fieldname("PathSwitchRequestFailure");
      c.get<path_switch_request_fail_s>().to_json(j);
      break;
    case types::ran_cfg_upd_fail:
      j.write_fieldname("RANConfigurationUpdateFailure");
      c.get<ran_cfg_upd_fail_s>().to_json(j);
      break;
    case types::ue_context_mod_fail:
      j.write_fieldname("UEContextModificationFailure");
      c.get<ue_context_mod_fail_s>().to_json(j);
      break;
    case types::ue_context_resume_fail:
      j.write_fieldname("UEContextResumeFailure");
      c.get<ue_context_resume_fail_s>().to_json(j);
      break;
    case types::ue_context_suspend_fail:
      j.write_fieldname("UEContextSuspendFailure");
      c.get<ue_context_suspend_fail_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ngap_elem_procs_o::unsuccessful_outcome_c");
  }
  j.end_obj();
}
SRSASN_CODE ngap_elem_procs_o::unsuccessful_outcome_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_cfg_upd_fail:
      HANDLE_CODE(c.get<amf_cfg_upd_fail_s>().pack(bref));
      break;
    case types::broadcast_session_mod_fail:
      HANDLE_CODE(c.get<broadcast_session_mod_fail_s>().pack(bref));
      break;
    case types::broadcast_session_setup_fail:
      HANDLE_CODE(c.get<broadcast_session_setup_fail_s>().pack(bref));
      break;
    case types::distribution_setup_fail:
      HANDLE_CODE(c.get<distribution_setup_fail_s>().pack(bref));
      break;
    case types::ho_prep_fail:
      HANDLE_CODE(c.get<ho_prep_fail_s>().pack(bref));
      break;
    case types::ho_fail:
      HANDLE_CODE(c.get<ho_fail_s>().pack(bref));
      break;
    case types::init_context_setup_fail:
      HANDLE_CODE(c.get<init_context_setup_fail_s>().pack(bref));
      break;
    case types::multicast_session_activation_fail:
      HANDLE_CODE(c.get<multicast_session_activation_fail_s>().pack(bref));
      break;
    case types::multicast_session_upd_fail:
      HANDLE_CODE(c.get<multicast_session_upd_fail_s>().pack(bref));
      break;
    case types::ng_setup_fail:
      HANDLE_CODE(c.get<ng_setup_fail_s>().pack(bref));
      break;
    case types::path_switch_request_fail:
      HANDLE_CODE(c.get<path_switch_request_fail_s>().pack(bref));
      break;
    case types::ran_cfg_upd_fail:
      HANDLE_CODE(c.get<ran_cfg_upd_fail_s>().pack(bref));
      break;
    case types::ue_context_mod_fail:
      HANDLE_CODE(c.get<ue_context_mod_fail_s>().pack(bref));
      break;
    case types::ue_context_resume_fail:
      HANDLE_CODE(c.get<ue_context_resume_fail_s>().pack(bref));
      break;
    case types::ue_context_suspend_fail:
      HANDLE_CODE(c.get<ue_context_suspend_fail_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ngap_elem_procs_o::unsuccessful_outcome_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ngap_elem_procs_o::unsuccessful_outcome_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_cfg_upd_fail:
      HANDLE_CODE(c.get<amf_cfg_upd_fail_s>().unpack(bref));
      break;
    case types::broadcast_session_mod_fail:
      HANDLE_CODE(c.get<broadcast_session_mod_fail_s>().unpack(bref));
      break;
    case types::broadcast_session_setup_fail:
      HANDLE_CODE(c.get<broadcast_session_setup_fail_s>().unpack(bref));
      break;
    case types::distribution_setup_fail:
      HANDLE_CODE(c.get<distribution_setup_fail_s>().unpack(bref));
      break;
    case types::ho_prep_fail:
      HANDLE_CODE(c.get<ho_prep_fail_s>().unpack(bref));
      break;
    case types::ho_fail:
      HANDLE_CODE(c.get<ho_fail_s>().unpack(bref));
      break;
    case types::init_context_setup_fail:
      HANDLE_CODE(c.get<init_context_setup_fail_s>().unpack(bref));
      break;
    case types::multicast_session_activation_fail:
      HANDLE_CODE(c.get<multicast_session_activation_fail_s>().unpack(bref));
      break;
    case types::multicast_session_upd_fail:
      HANDLE_CODE(c.get<multicast_session_upd_fail_s>().unpack(bref));
      break;
    case types::ng_setup_fail:
      HANDLE_CODE(c.get<ng_setup_fail_s>().unpack(bref));
      break;
    case types::path_switch_request_fail:
      HANDLE_CODE(c.get<path_switch_request_fail_s>().unpack(bref));
      break;
    case types::ran_cfg_upd_fail:
      HANDLE_CODE(c.get<ran_cfg_upd_fail_s>().unpack(bref));
      break;
    case types::ue_context_mod_fail:
      HANDLE_CODE(c.get<ue_context_mod_fail_s>().unpack(bref));
      break;
    case types::ue_context_resume_fail:
      HANDLE_CODE(c.get<ue_context_resume_fail_s>().unpack(bref));
      break;
    case types::ue_context_suspend_fail:
      HANDLE_CODE(c.get<ue_context_suspend_fail_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ngap_elem_procs_o::unsuccessful_outcome_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ngap_elem_procs_o::unsuccessful_outcome_c::types_opts::to_string() const
{
  static const char* names[] = {"AMFConfigurationUpdateFailure",
                                "BroadcastSessionModificationFailure",
                                "BroadcastSessionSetupFailure",
                                "DistributionSetupFailure",
                                "HandoverPreparationFailure",
                                "HandoverFailure",
                                "InitialContextSetupFailure",
                                "MulticastSessionActivationFailure",
                                "MulticastSessionUpdateFailure",
                                "NGSetupFailure",
                                "PathSwitchRequestFailure",
                                "RANConfigurationUpdateFailure",
                                "UEContextModificationFailure",
                                "UEContextResumeFailure",
                                "UEContextSuspendFailure"};
  return convert_enum_idx(names, 15, value, "ngap_elem_procs_o::unsuccessful_outcome_c::types");
}

// InitiatingMessage ::= SEQUENCE{{NGAP-ELEMENTARY-PROCEDURE}}
SRSASN_CODE init_msg_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(pack_integer(bref, proc_code, (uint16_t)0u, (uint16_t)255u, false, true));
  warn_assert(crit != ngap_elem_procs_o::get_crit(proc_code), __func__, __LINE__);
  HANDLE_CODE(crit.pack(bref));
  HANDLE_CODE(value.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE init_msg_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(unpack_integer(proc_code, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(crit.unpack(bref));
  value = ngap_elem_procs_o::get_init_msg(proc_code);
  HANDLE_CODE(value.unpack(bref));

  return SRSASN_SUCCESS;
}
void init_msg_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("procedureCode", proc_code);
  j.write_str("criticality", crit.to_string());
  j.write_fieldname("value");
  value.to_json(j);
  j.end_obj();
}
bool init_msg_s::load_info_obj(const uint16_t& proc_code_)
{
  if (not ngap_elem_procs_o::is_proc_code_valid(proc_code_)) {
    return false;
  }
  proc_code = proc_code_;
  crit      = ngap_elem_procs_o::get_crit(proc_code);
  value     = ngap_elem_procs_o::get_init_msg(proc_code);
  return value.type().value != ngap_elem_procs_o::init_msg_c::types_opts::nulltype;
}

// LastVisitedPSCellInformation ::= SEQUENCE
SRSASN_CODE last_visited_pscell_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(pscell_id_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (pscell_id_present) {
    HANDLE_CODE(pscell_id.pack(bref));
  }
  HANDLE_CODE(pack_integer(bref, time_stay, (uint16_t)0u, (uint16_t)40950u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE last_visited_pscell_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(pscell_id_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (pscell_id_present) {
    HANDLE_CODE(pscell_id.unpack(bref));
  }
  HANDLE_CODE(unpack_integer(time_stay, bref, (uint16_t)0u, (uint16_t)40950u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void last_visited_pscell_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (pscell_id_present) {
    j.write_fieldname("pSCellID");
    pscell_id.to_json(j);
  }
  j.write_int("timeStay", time_stay);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// LastVisitedNGRANCellInformation-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t last_visited_ngran_cell_info_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {289};
  return map_enum_number(names, 1, idx, "id");
}
bool last_visited_ngran_cell_info_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 289 == id;
}
crit_e last_visited_ngran_cell_info_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 289) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
last_visited_ngran_cell_info_ext_ies_o::ext_c last_visited_ngran_cell_info_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 289) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e last_visited_ngran_cell_info_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 289) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void last_visited_ngran_cell_info_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("LastVisitedPSCellList");
  for (const auto& e1 : c) {
    e1.to_json(j);
  }
  j.end_array();
  j.end_obj();
}
SRSASN_CODE last_visited_ngran_cell_info_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(pack_dyn_seq_of(bref, c, 1, 8, true));
  return SRSASN_SUCCESS;
}
SRSASN_CODE last_visited_ngran_cell_info_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(unpack_dyn_seq_of(c, bref, 1, 8, true));
  return SRSASN_SUCCESS;
}

const char* last_visited_ngran_cell_info_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"LastVisitedPSCellList"};
  return convert_enum_idx(names, 1, value, "last_visited_ngran_cell_info_ext_ies_o::ext_c::types");
}

// LastVisitedNGRANCellInformation ::= SEQUENCE
SRSASN_CODE last_visited_ngran_cell_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(time_ue_stayed_in_cell_enhanced_granularity_present, 1));
  HANDLE_CODE(bref.pack(ho_cause_value_present, 1));
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(global_cell_id.pack(bref));
  HANDLE_CODE(cell_type.pack(bref));
  HANDLE_CODE(pack_integer(bref, time_ue_stayed_in_cell, (uint16_t)0u, (uint16_t)4095u, false, true));
  if (time_ue_stayed_in_cell_enhanced_granularity_present) {
    HANDLE_CODE(
        pack_integer(bref, time_ue_stayed_in_cell_enhanced_granularity, (uint16_t)0u, (uint16_t)40950u, false, true));
  }
  if (ho_cause_value_present) {
    HANDLE_CODE(ho_cause_value.pack(bref));
  }
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE last_visited_ngran_cell_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(time_ue_stayed_in_cell_enhanced_granularity_present, 1));
  HANDLE_CODE(bref.unpack(ho_cause_value_present, 1));
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(global_cell_id.unpack(bref));
  HANDLE_CODE(cell_type.unpack(bref));
  HANDLE_CODE(unpack_integer(time_ue_stayed_in_cell, bref, (uint16_t)0u, (uint16_t)4095u, false, true));
  if (time_ue_stayed_in_cell_enhanced_granularity_present) {
    HANDLE_CODE(
        unpack_integer(time_ue_stayed_in_cell_enhanced_granularity, bref, (uint16_t)0u, (uint16_t)40950u, false, true));
  }
  if (ho_cause_value_present) {
    HANDLE_CODE(ho_cause_value.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void last_visited_ngran_cell_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("globalCellID");
  global_cell_id.to_json(j);
  j.write_fieldname("cellType");
  cell_type.to_json(j);
  j.write_int("timeUEStayedInCell", time_ue_stayed_in_cell);
  if (time_ue_stayed_in_cell_enhanced_granularity_present) {
    j.write_int("timeUEStayedInCellEnhancedGranularity", time_ue_stayed_in_cell_enhanced_granularity);
  }
  if (ho_cause_value_present) {
    j.write_fieldname("hOCauseValue");
    ho_cause_value.to_json(j);
  }
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// LastVisitedCellInformation ::= CHOICE
void last_visited_cell_info_c::destroy_()
{
  switch (type_) {
    case types::ngran_cell:
      c.destroy<last_visited_ngran_cell_info_s>();
      break;
    case types::eutran_cell:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::utran_cell:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::geran_cell:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<last_visited_cell_info_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void last_visited_cell_info_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::ngran_cell:
      c.init<last_visited_ngran_cell_info_s>();
      break;
    case types::eutran_cell:
      c.init<unbounded_octstring<true>>();
      break;
    case types::utran_cell:
      c.init<unbounded_octstring<true>>();
      break;
    case types::geran_cell:
      c.init<unbounded_octstring<true>>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<last_visited_cell_info_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "last_visited_cell_info_c");
  }
}
last_visited_cell_info_c::last_visited_cell_info_c(const last_visited_cell_info_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::ngran_cell:
      c.init(other.c.get<last_visited_ngran_cell_info_s>());
      break;
    case types::eutran_cell:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::utran_cell:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::geran_cell:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<last_visited_cell_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "last_visited_cell_info_c");
  }
}
last_visited_cell_info_c& last_visited_cell_info_c::operator=(const last_visited_cell_info_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::ngran_cell:
      c.set(other.c.get<last_visited_ngran_cell_info_s>());
      break;
    case types::eutran_cell:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::utran_cell:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::geran_cell:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<last_visited_cell_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "last_visited_cell_info_c");
  }

  return *this;
}
last_visited_ngran_cell_info_s& last_visited_cell_info_c::set_ngran_cell()
{
  set(types::ngran_cell);
  return c.get<last_visited_ngran_cell_info_s>();
}
unbounded_octstring<true>& last_visited_cell_info_c::set_eutran_cell()
{
  set(types::eutran_cell);
  return c.get<unbounded_octstring<true>>();
}
unbounded_octstring<true>& last_visited_cell_info_c::set_utran_cell()
{
  set(types::utran_cell);
  return c.get<unbounded_octstring<true>>();
}
unbounded_octstring<true>& last_visited_cell_info_c::set_geran_cell()
{
  set(types::geran_cell);
  return c.get<unbounded_octstring<true>>();
}
protocol_ie_single_container_s<last_visited_cell_info_ext_ies_o>& last_visited_cell_info_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<last_visited_cell_info_ext_ies_o>>();
}
void last_visited_cell_info_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::ngran_cell:
      j.write_fieldname("nGRANCell");
      c.get<last_visited_ngran_cell_info_s>().to_json(j);
      break;
    case types::eutran_cell:
      j.write_str("eUTRANCell", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::utran_cell:
      j.write_str("uTRANCell", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::geran_cell:
      j.write_str("gERANCell", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<last_visited_cell_info_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "last_visited_cell_info_c");
  }
  j.end_obj();
}
SRSASN_CODE last_visited_cell_info_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::ngran_cell:
      HANDLE_CODE(c.get<last_visited_ngran_cell_info_s>().pack(bref));
      break;
    case types::eutran_cell:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::utran_cell:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::geran_cell:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<last_visited_cell_info_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "last_visited_cell_info_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE last_visited_cell_info_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::ngran_cell:
      HANDLE_CODE(c.get<last_visited_ngran_cell_info_s>().unpack(bref));
      break;
    case types::eutran_cell:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::utran_cell:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::geran_cell:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<last_visited_cell_info_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "last_visited_cell_info_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* last_visited_cell_info_c::types_opts::to_string() const
{
  static const char* names[] = {"nGRANCell", "eUTRANCell", "uTRANCell", "gERANCell", "choice-Extensions"};
  return convert_enum_idx(names, 5, value, "last_visited_cell_info_c::types");
}

// LastVisitedCellItem ::= SEQUENCE
SRSASN_CODE last_visited_cell_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(last_visited_cell_info.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE last_visited_cell_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(last_visited_cell_info.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void last_visited_cell_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("lastVisitedCellInformation");
  last_visited_cell_info.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// NonDynamic5QIDescriptor-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t non_dyn_5qi_descriptor_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {187, 188};
  return map_enum_number(names, 2, idx, "id");
}
bool non_dyn_5qi_descriptor_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {187, 188};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e non_dyn_5qi_descriptor_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 187:
      return crit_e::ignore;
    case 188:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
non_dyn_5qi_descriptor_ext_ies_o::ext_c non_dyn_5qi_descriptor_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 187:
      ret.set(ext_c::types::cn_packet_delay_budget_dl);
      break;
    case 188:
      ret.set(ext_c::types::cn_packet_delay_budget_ul);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e non_dyn_5qi_descriptor_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 187:
      return presence_e::optional;
    case 188:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void non_dyn_5qi_descriptor_ext_ies_o::ext_c::destroy_() {}
void non_dyn_5qi_descriptor_ext_ies_o::ext_c::set(types::options e)
{
  destroy_();
  type_ = e;
}
non_dyn_5qi_descriptor_ext_ies_o::ext_c::ext_c(const non_dyn_5qi_descriptor_ext_ies_o::ext_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::cn_packet_delay_budget_dl:
      c.init(other.c.get<uint32_t>());
      break;
    case types::cn_packet_delay_budget_ul:
      c.init(other.c.get<uint32_t>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "non_dyn_5qi_descriptor_ext_ies_o::ext_c");
  }
}
non_dyn_5qi_descriptor_ext_ies_o::ext_c&
non_dyn_5qi_descriptor_ext_ies_o::ext_c::operator=(const non_dyn_5qi_descriptor_ext_ies_o::ext_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::cn_packet_delay_budget_dl:
      c.set(other.c.get<uint32_t>());
      break;
    case types::cn_packet_delay_budget_ul:
      c.set(other.c.get<uint32_t>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "non_dyn_5qi_descriptor_ext_ies_o::ext_c");
  }

  return *this;
}
uint32_t& non_dyn_5qi_descriptor_ext_ies_o::ext_c::cn_packet_delay_budget_dl()
{
  assert_choice_type(types::cn_packet_delay_budget_dl, type_, "Extension");
  return c.get<uint32_t>();
}
uint32_t& non_dyn_5qi_descriptor_ext_ies_o::ext_c::cn_packet_delay_budget_ul()
{
  assert_choice_type(types::cn_packet_delay_budget_ul, type_, "Extension");
  return c.get<uint32_t>();
}
const uint32_t& non_dyn_5qi_descriptor_ext_ies_o::ext_c::cn_packet_delay_budget_dl() const
{
  assert_choice_type(types::cn_packet_delay_budget_dl, type_, "Extension");
  return c.get<uint32_t>();
}
const uint32_t& non_dyn_5qi_descriptor_ext_ies_o::ext_c::cn_packet_delay_budget_ul() const
{
  assert_choice_type(types::cn_packet_delay_budget_ul, type_, "Extension");
  return c.get<uint32_t>();
}
void non_dyn_5qi_descriptor_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::cn_packet_delay_budget_dl:
      j.write_int("INTEGER (1..65535,...)", c.get<uint32_t>());
      break;
    case types::cn_packet_delay_budget_ul:
      j.write_int("INTEGER (1..65535,...)", c.get<uint32_t>());
      break;
    default:
      log_invalid_choice_id(type_, "non_dyn_5qi_descriptor_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE non_dyn_5qi_descriptor_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::cn_packet_delay_budget_dl:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)1u, (uint32_t)65535u, true, true));
      break;
    case types::cn_packet_delay_budget_ul:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)1u, (uint32_t)65535u, true, true));
      break;
    default:
      log_invalid_choice_id(type_, "non_dyn_5qi_descriptor_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE non_dyn_5qi_descriptor_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::cn_packet_delay_budget_dl:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)1u, (uint32_t)65535u, true, true));
      break;
    case types::cn_packet_delay_budget_ul:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)1u, (uint32_t)65535u, true, true));
      break;
    default:
      log_invalid_choice_id(type_, "non_dyn_5qi_descriptor_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* non_dyn_5qi_descriptor_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (1..65535,...)", "INTEGER (1..65535,...)"};
  return convert_enum_idx(names, 2, value, "non_dyn_5qi_descriptor_ext_ies_o::ext_c::types");
}

template struct asn1::protocol_ext_field_s<non_dyn_5qi_descriptor_ext_ies_o>;

non_dyn_5qi_descriptor_ext_ies_container::non_dyn_5qi_descriptor_ext_ies_container() :
  cn_packet_delay_budget_dl(187, crit_e::ignore), cn_packet_delay_budget_ul(188, crit_e::ignore)
{
}
SRSASN_CODE non_dyn_5qi_descriptor_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += cn_packet_delay_budget_dl_present ? 1 : 0;
  nof_ies += cn_packet_delay_budget_ul_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (cn_packet_delay_budget_dl_present) {
    HANDLE_CODE(cn_packet_delay_budget_dl.pack(bref));
  }
  if (cn_packet_delay_budget_ul_present) {
    HANDLE_CODE(cn_packet_delay_budget_ul.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE non_dyn_5qi_descriptor_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 187: {
        cn_packet_delay_budget_dl_present = true;
        cn_packet_delay_budget_dl.id      = id;
        HANDLE_CODE(cn_packet_delay_budget_dl.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cn_packet_delay_budget_dl.ext.unpack(bref));
        break;
      }
      case 188: {
        cn_packet_delay_budget_ul_present = true;
        cn_packet_delay_budget_ul.id      = id;
        HANDLE_CODE(cn_packet_delay_budget_ul.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cn_packet_delay_budget_ul.ext.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void non_dyn_5qi_descriptor_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (cn_packet_delay_budget_dl_present) {
    j.write_fieldname("");
    cn_packet_delay_budget_dl.to_json(j);
  }
  if (cn_packet_delay_budget_ul_present) {
    j.write_fieldname("");
    cn_packet_delay_budget_ul.to_json(j);
  }
  j.end_obj();
}

// NonDynamic5QIDescriptor ::= SEQUENCE
SRSASN_CODE non_dyn_5qi_descriptor_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(prio_level_qos_present, 1));
  HANDLE_CODE(bref.pack(averaging_win_present, 1));
  HANDLE_CODE(bref.pack(max_data_burst_volume_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, five_qi, (uint16_t)0u, (uint16_t)255u, true, true));
  if (prio_level_qos_present) {
    HANDLE_CODE(pack_integer(bref, prio_level_qos, (uint8_t)1u, (uint8_t)127u, true, true));
  }
  if (averaging_win_present) {
    HANDLE_CODE(pack_integer(bref, averaging_win, (uint16_t)0u, (uint16_t)4095u, true, true));
  }
  if (max_data_burst_volume_present) {
    HANDLE_CODE(pack_integer(bref, max_data_burst_volume, (uint16_t)0u, (uint16_t)4095u, true, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE non_dyn_5qi_descriptor_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(prio_level_qos_present, 1));
  HANDLE_CODE(bref.unpack(averaging_win_present, 1));
  HANDLE_CODE(bref.unpack(max_data_burst_volume_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(five_qi, bref, (uint16_t)0u, (uint16_t)255u, true, true));
  if (prio_level_qos_present) {
    HANDLE_CODE(unpack_integer(prio_level_qos, bref, (uint8_t)1u, (uint8_t)127u, true, true));
  }
  if (averaging_win_present) {
    HANDLE_CODE(unpack_integer(averaging_win, bref, (uint16_t)0u, (uint16_t)4095u, true, true));
  }
  if (max_data_burst_volume_present) {
    HANDLE_CODE(unpack_integer(max_data_burst_volume, bref, (uint16_t)0u, (uint16_t)4095u, true, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void non_dyn_5qi_descriptor_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("fiveQI", five_qi);
  if (prio_level_qos_present) {
    j.write_int("priorityLevelQos", prio_level_qos);
  }
  if (averaging_win_present) {
    j.write_int("averagingWindow", averaging_win);
  }
  if (max_data_burst_volume_present) {
    j.write_int("maximumDataBurstVolume", max_data_burst_volume);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// QosMonitoringRequest ::= ENUMERATED
const char* qos_monitoring_request_opts::to_string() const
{
  static const char* names[] = {"ul", "dl", "both", "stop"};
  return convert_enum_idx(names, 4, value, "qos_monitoring_request_e");
}

// AdditionalQosFlowInformation ::= ENUMERATED
const char* add_qos_flow_info_opts::to_string() const
{
  static const char* names[] = {"more-likely"};
  return convert_enum_idx(names, 1, value, "add_qos_flow_info_e");
}

// QosCharacteristics ::= CHOICE
void qos_characteristics_c::destroy_()
{
  switch (type_) {
    case types::non_dyn5qi:
      c.destroy<non_dyn_5qi_descriptor_s>();
      break;
    case types::dyn5qi:
      c.destroy<dyn_5qi_descriptor_s>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<qos_characteristics_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void qos_characteristics_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::non_dyn5qi:
      c.init<non_dyn_5qi_descriptor_s>();
      break;
    case types::dyn5qi:
      c.init<dyn_5qi_descriptor_s>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<qos_characteristics_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "qos_characteristics_c");
  }
}
qos_characteristics_c::qos_characteristics_c(const qos_characteristics_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::non_dyn5qi:
      c.init(other.c.get<non_dyn_5qi_descriptor_s>());
      break;
    case types::dyn5qi:
      c.init(other.c.get<dyn_5qi_descriptor_s>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<qos_characteristics_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "qos_characteristics_c");
  }
}
qos_characteristics_c& qos_characteristics_c::operator=(const qos_characteristics_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::non_dyn5qi:
      c.set(other.c.get<non_dyn_5qi_descriptor_s>());
      break;
    case types::dyn5qi:
      c.set(other.c.get<dyn_5qi_descriptor_s>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<qos_characteristics_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "qos_characteristics_c");
  }

  return *this;
}
non_dyn_5qi_descriptor_s& qos_characteristics_c::set_non_dyn5qi()
{
  set(types::non_dyn5qi);
  return c.get<non_dyn_5qi_descriptor_s>();
}
dyn_5qi_descriptor_s& qos_characteristics_c::set_dyn5qi()
{
  set(types::dyn5qi);
  return c.get<dyn_5qi_descriptor_s>();
}
protocol_ie_single_container_s<qos_characteristics_ext_ies_o>& qos_characteristics_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<qos_characteristics_ext_ies_o>>();
}
void qos_characteristics_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::non_dyn5qi:
      j.write_fieldname("nonDynamic5QI");
      c.get<non_dyn_5qi_descriptor_s>().to_json(j);
      break;
    case types::dyn5qi:
      j.write_fieldname("dynamic5QI");
      c.get<dyn_5qi_descriptor_s>().to_json(j);
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<qos_characteristics_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "qos_characteristics_c");
  }
  j.end_obj();
}
SRSASN_CODE qos_characteristics_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::non_dyn5qi:
      HANDLE_CODE(c.get<non_dyn_5qi_descriptor_s>().pack(bref));
      break;
    case types::dyn5qi:
      HANDLE_CODE(c.get<dyn_5qi_descriptor_s>().pack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<qos_characteristics_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "qos_characteristics_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_characteristics_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::non_dyn5qi:
      HANDLE_CODE(c.get<non_dyn_5qi_descriptor_s>().unpack(bref));
      break;
    case types::dyn5qi:
      HANDLE_CODE(c.get<dyn_5qi_descriptor_s>().unpack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<qos_characteristics_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "qos_characteristics_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* qos_characteristics_c::types_opts::to_string() const
{
  static const char* names[] = {"nonDynamic5QI", "dynamic5QI", "choice-Extensions"};
  return convert_enum_idx(names, 3, value, "qos_characteristics_c::types");
}

// QosFlowLevelQosParameters-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t qos_flow_level_qos_params_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {181, 276};
  return map_enum_number(names, 2, idx, "id");
}
bool qos_flow_level_qos_params_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {181, 276};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e qos_flow_level_qos_params_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 181:
      return crit_e::ignore;
    case 276:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
qos_flow_level_qos_params_ext_ies_o::ext_c qos_flow_level_qos_params_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 181:
      ret.set(ext_c::types::qos_monitoring_request);
      break;
    case 276:
      ret.set(ext_c::types::qos_monitoring_report_freq);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e qos_flow_level_qos_params_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 181:
      return presence_e::optional;
    case 276:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void qos_flow_level_qos_params_ext_ies_o::ext_c::destroy_() {}
void qos_flow_level_qos_params_ext_ies_o::ext_c::set(types::options e)
{
  destroy_();
  type_ = e;
}
qos_flow_level_qos_params_ext_ies_o::ext_c::ext_c(const qos_flow_level_qos_params_ext_ies_o::ext_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::qos_monitoring_request:
      c.init(other.c.get<qos_monitoring_request_e>());
      break;
    case types::qos_monitoring_report_freq:
      c.init(other.c.get<uint16_t>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "qos_flow_level_qos_params_ext_ies_o::ext_c");
  }
}
qos_flow_level_qos_params_ext_ies_o::ext_c&
qos_flow_level_qos_params_ext_ies_o::ext_c::operator=(const qos_flow_level_qos_params_ext_ies_o::ext_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::qos_monitoring_request:
      c.set(other.c.get<qos_monitoring_request_e>());
      break;
    case types::qos_monitoring_report_freq:
      c.set(other.c.get<uint16_t>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "qos_flow_level_qos_params_ext_ies_o::ext_c");
  }

  return *this;
}
qos_monitoring_request_e& qos_flow_level_qos_params_ext_ies_o::ext_c::qos_monitoring_request()
{
  assert_choice_type(types::qos_monitoring_request, type_, "Extension");
  return c.get<qos_monitoring_request_e>();
}
uint16_t& qos_flow_level_qos_params_ext_ies_o::ext_c::qos_monitoring_report_freq()
{
  assert_choice_type(types::qos_monitoring_report_freq, type_, "Extension");
  return c.get<uint16_t>();
}
const qos_monitoring_request_e& qos_flow_level_qos_params_ext_ies_o::ext_c::qos_monitoring_request() const
{
  assert_choice_type(types::qos_monitoring_request, type_, "Extension");
  return c.get<qos_monitoring_request_e>();
}
const uint16_t& qos_flow_level_qos_params_ext_ies_o::ext_c::qos_monitoring_report_freq() const
{
  assert_choice_type(types::qos_monitoring_report_freq, type_, "Extension");
  return c.get<uint16_t>();
}
void qos_flow_level_qos_params_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::qos_monitoring_request:
      j.write_str("QosMonitoringRequest", c.get<qos_monitoring_request_e>().to_string());
      break;
    case types::qos_monitoring_report_freq:
      j.write_int("INTEGER (1..1800,...)", c.get<uint16_t>());
      break;
    default:
      log_invalid_choice_id(type_, "qos_flow_level_qos_params_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE qos_flow_level_qos_params_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::qos_monitoring_request:
      HANDLE_CODE(c.get<qos_monitoring_request_e>().pack(bref));
      break;
    case types::qos_monitoring_report_freq:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)1u, (uint16_t)1800u, true, true));
      break;
    default:
      log_invalid_choice_id(type_, "qos_flow_level_qos_params_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_flow_level_qos_params_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::qos_monitoring_request:
      HANDLE_CODE(c.get<qos_monitoring_request_e>().unpack(bref));
      break;
    case types::qos_monitoring_report_freq:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)1u, (uint16_t)1800u, true, true));
      break;
    default:
      log_invalid_choice_id(type_, "qos_flow_level_qos_params_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* qos_flow_level_qos_params_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"QosMonitoringRequest", "INTEGER (1..1800,...)"};
  return convert_enum_idx(names, 2, value, "qos_flow_level_qos_params_ext_ies_o::ext_c::types");
}
uint8_t qos_flow_level_qos_params_ext_ies_o::ext_c::types_opts::to_number() const
{
  if (value == qos_monitoring_report_freq) {
    return 1;
  }
  invalid_enum_number(value, "qos_flow_level_qos_params_ext_ies_o::ext_c::types");
  return 0;
}

// ReflectiveQosAttribute ::= ENUMERATED
const char* reflective_qos_attribute_opts::to_string() const
{
  static const char* names[] = {"subject-to"};
  return convert_enum_idx(names, 1, value, "reflective_qos_attribute_e");
}

// MRB-ProgressInformation ::= CHOICE
void mrb_progress_info_c::destroy_()
{
  switch (type_) {
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<mrb_progress_info_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void mrb_progress_info_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::pdcp_sn_len12:
      break;
    case types::pdcp_sn_len18:
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<mrb_progress_info_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "mrb_progress_info_c");
  }
}
mrb_progress_info_c::mrb_progress_info_c(const mrb_progress_info_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::pdcp_sn_len12:
      c.init(other.c.get<uint16_t>());
      break;
    case types::pdcp_sn_len18:
      c.init(other.c.get<uint32_t>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<mrb_progress_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "mrb_progress_info_c");
  }
}
mrb_progress_info_c& mrb_progress_info_c::operator=(const mrb_progress_info_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::pdcp_sn_len12:
      c.set(other.c.get<uint16_t>());
      break;
    case types::pdcp_sn_len18:
      c.set(other.c.get<uint32_t>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<mrb_progress_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "mrb_progress_info_c");
  }

  return *this;
}
uint16_t& mrb_progress_info_c::set_pdcp_sn_len12()
{
  set(types::pdcp_sn_len12);
  return c.get<uint16_t>();
}
uint32_t& mrb_progress_info_c::set_pdcp_sn_len18()
{
  set(types::pdcp_sn_len18);
  return c.get<uint32_t>();
}
protocol_ie_single_container_s<mrb_progress_info_ext_ies_o>& mrb_progress_info_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<mrb_progress_info_ext_ies_o>>();
}
void mrb_progress_info_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::pdcp_sn_len12:
      j.write_int("pDCP-SN-Length12", c.get<uint16_t>());
      break;
    case types::pdcp_sn_len18:
      j.write_int("pDCP-SN-Length18", c.get<uint32_t>());
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<mrb_progress_info_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "mrb_progress_info_c");
  }
  j.end_obj();
}
SRSASN_CODE mrb_progress_info_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::pdcp_sn_len12:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)0u, (uint16_t)4095u, false, true));
      break;
    case types::pdcp_sn_len18:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)262143u, false, true));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<mrb_progress_info_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "mrb_progress_info_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE mrb_progress_info_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::pdcp_sn_len12:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)0u, (uint16_t)4095u, false, true));
      break;
    case types::pdcp_sn_len18:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)262143u, false, true));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<mrb_progress_info_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "mrb_progress_info_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* mrb_progress_info_c::types_opts::to_string() const
{
  static const char* names[] = {"pDCP-SN-Length12", "pDCP-SN-Length18", "choice-Extensions"};
  return convert_enum_idx(names, 3, value, "mrb_progress_info_c::types");
}
uint8_t mrb_progress_info_c::types_opts::to_number() const
{
  static const uint8_t numbers[] = {12, 18};
  return map_enum_number(numbers, 2, value, "mrb_progress_info_c::types");
}

template struct asn1::protocol_ext_field_s<qos_flow_level_qos_params_ext_ies_o>;

qos_flow_level_qos_params_ext_ies_container::qos_flow_level_qos_params_ext_ies_container() :
  qos_monitoring_request(181, crit_e::ignore), qos_monitoring_report_freq(276, crit_e::ignore)
{
}
SRSASN_CODE qos_flow_level_qos_params_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += qos_monitoring_request_present ? 1 : 0;
  nof_ies += qos_monitoring_report_freq_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (qos_monitoring_request_present) {
    HANDLE_CODE(qos_monitoring_request.pack(bref));
  }
  if (qos_monitoring_report_freq_present) {
    HANDLE_CODE(qos_monitoring_report_freq.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_flow_level_qos_params_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 181: {
        qos_monitoring_request_present = true;
        qos_monitoring_request.id      = id;
        HANDLE_CODE(qos_monitoring_request.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(qos_monitoring_request.ext.unpack(bref));
        break;
      }
      case 276: {
        qos_monitoring_report_freq_present = true;
        qos_monitoring_report_freq.id      = id;
        HANDLE_CODE(qos_monitoring_report_freq.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(qos_monitoring_report_freq.ext.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void qos_flow_level_qos_params_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (qos_monitoring_request_present) {
    j.write_fieldname("");
    qos_monitoring_request.to_json(j);
  }
  if (qos_monitoring_report_freq_present) {
    j.write_fieldname("");
    qos_monitoring_report_freq.to_json(j);
  }
  j.end_obj();
}

// QosFlowLevelQosParameters ::= SEQUENCE
SRSASN_CODE qos_flow_level_qos_params_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(gbr_qos_info_present, 1));
  HANDLE_CODE(bref.pack(reflective_qos_attribute_present, 1));
  HANDLE_CODE(bref.pack(add_qos_flow_info_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(qos_characteristics.pack(bref));
  HANDLE_CODE(alloc_and_retention_prio.pack(bref));
  if (gbr_qos_info_present) {
    HANDLE_CODE(gbr_qos_info.pack(bref));
  }
  if (reflective_qos_attribute_present) {
    HANDLE_CODE(reflective_qos_attribute.pack(bref));
  }
  if (add_qos_flow_info_present) {
    HANDLE_CODE(add_qos_flow_info.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_flow_level_qos_params_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(gbr_qos_info_present, 1));
  HANDLE_CODE(bref.unpack(reflective_qos_attribute_present, 1));
  HANDLE_CODE(bref.unpack(add_qos_flow_info_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(qos_characteristics.unpack(bref));
  HANDLE_CODE(alloc_and_retention_prio.unpack(bref));
  if (gbr_qos_info_present) {
    HANDLE_CODE(gbr_qos_info.unpack(bref));
  }
  if (reflective_qos_attribute_present) {
    HANDLE_CODE(reflective_qos_attribute.unpack(bref));
  }
  if (add_qos_flow_info_present) {
    HANDLE_CODE(add_qos_flow_info.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void qos_flow_level_qos_params_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("qosCharacteristics");
  qos_characteristics.to_json(j);
  j.write_fieldname("allocationAndRetentionPriority");
  alloc_and_retention_prio.to_json(j);
  if (gbr_qos_info_present) {
    j.write_fieldname("gBR-QosInformation");
    gbr_qos_info.to_json(j);
  }
  if (reflective_qos_attribute_present) {
    j.write_str("reflectiveQosAttribute", "subject-to");
  }
  if (add_qos_flow_info_present) {
    j.write_str("additionalQosFlowInformation", "more-likely");
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MBS-MappingandDataForwardingRequestItem ::= SEQUENCE
SRSASN_CODE mbs_mapand_data_forwarding_request_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(mrb_progress_info_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, mrb_id, (uint16_t)1u, (uint16_t)512u, true, true));
  HANDLE_CODE(pack_dyn_seq_of(bref, mbs_qos_flow_list, 1, 64, integer_packer<uint8_t>(0, 63, true, true)));
  if (mrb_progress_info_present) {
    HANDLE_CODE(mrb_progress_info.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mbs_mapand_data_forwarding_request_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(mrb_progress_info_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(mrb_id, bref, (uint16_t)1u, (uint16_t)512u, true, true));
  HANDLE_CODE(unpack_dyn_seq_of(mbs_qos_flow_list, bref, 1, 64, integer_packer<uint8_t>(0, 63, true, true)));
  if (mrb_progress_info_present) {
    HANDLE_CODE(mrb_progress_info.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void mbs_mapand_data_forwarding_request_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("mRB-ID", mrb_id);
  j.start_array("mBS-QoSFlowList");
  for (const auto& e1 : mbs_qos_flow_list) {
    j.write_int(e1);
  }
  j.end_array();
  if (mrb_progress_info_present) {
    j.write_fieldname("mRB-ProgressInformation");
    mrb_progress_info.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MBS-QoSFlowsToBeSetupItem ::= SEQUENCE
SRSASN_CODE mbs_qos_flows_to_be_setup_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, mb_sqos_flow_id, (uint8_t)0u, (uint8_t)63u, true, true));
  HANDLE_CODE(mb_sqos_flow_level_qos_params.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mbs_qos_flows_to_be_setup_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(mb_sqos_flow_id, bref, (uint8_t)0u, (uint8_t)63u, true, true));
  HANDLE_CODE(mb_sqos_flow_level_qos_params.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void mbs_qos_flows_to_be_setup_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("mBSqosFlowIdentifier", mb_sqos_flow_id);
  j.write_fieldname("mBSqosFlowLevelQosParameters");
  mb_sqos_flow_level_qos_params.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MBS-ActiveSessionInformation-SourcetoTargetItem ::= SEQUENCE
SRSASN_CODE mbs_active_session_info_sourceto_target_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(mbs_area_session_id_present, 1));
  HANDLE_CODE(bref.pack(mbs_service_area_present, 1));
  HANDLE_CODE(bref.pack(mbs_mapand_data_forwarding_request_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(mbs_session_id.pack(bref));
  if (mbs_area_session_id_present) {
    HANDLE_CODE(pack_integer(bref, mbs_area_session_id, (uint32_t)0u, (uint32_t)65535u, true, true));
  }
  if (mbs_service_area_present) {
    HANDLE_CODE(mbs_service_area.pack(bref));
  }
  HANDLE_CODE(pack_dyn_seq_of(bref, mbs_qos_flows_to_be_setup_list, 1, 64, true));
  if (mbs_mapand_data_forwarding_request_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, mbs_mapand_data_forwarding_request_list, 1, 32, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mbs_active_session_info_sourceto_target_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(mbs_area_session_id_present, 1));
  HANDLE_CODE(bref.unpack(mbs_service_area_present, 1));
  bool mbs_mapand_data_forwarding_request_list_present;
  HANDLE_CODE(bref.unpack(mbs_mapand_data_forwarding_request_list_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(mbs_session_id.unpack(bref));
  if (mbs_area_session_id_present) {
    HANDLE_CODE(unpack_integer(mbs_area_session_id, bref, (uint32_t)0u, (uint32_t)65535u, true, true));
  }
  if (mbs_service_area_present) {
    HANDLE_CODE(mbs_service_area.unpack(bref));
  }
  HANDLE_CODE(unpack_dyn_seq_of(mbs_qos_flows_to_be_setup_list, bref, 1, 64, true));
  if (mbs_mapand_data_forwarding_request_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(mbs_mapand_data_forwarding_request_list, bref, 1, 32, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void mbs_active_session_info_sourceto_target_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("mBS-SessionID");
  mbs_session_id.to_json(j);
  if (mbs_area_session_id_present) {
    j.write_int("mBS-AreaSessionID", mbs_area_session_id);
  }
  if (mbs_service_area_present) {
    j.write_fieldname("mBS-ServiceArea");
    mbs_service_area.to_json(j);
  }
  j.start_array("mBS-QoSFlowsToBeSetupList");
  for (const auto& e1 : mbs_qos_flows_to_be_setup_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (mbs_mapand_data_forwarding_request_list.size() > 0) {
    j.start_array("mBS-MappingandDataForwardingRequestList");
    for (const auto& e1 : mbs_mapand_data_forwarding_request_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MBS-DataForwardingResponseMRBItem ::= SEQUENCE
SRSASN_CODE mbs_data_forwarding_resp_mrb_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(mrb_progress_info_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, mrb_id, (uint16_t)1u, (uint16_t)512u, true, true));
  HANDLE_CODE(dl_forwarding_up_tnl_info.pack(bref));
  if (mrb_progress_info_present) {
    HANDLE_CODE(mrb_progress_info.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mbs_data_forwarding_resp_mrb_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(mrb_progress_info_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(mrb_id, bref, (uint16_t)1u, (uint16_t)512u, true, true));
  HANDLE_CODE(dl_forwarding_up_tnl_info.unpack(bref));
  if (mrb_progress_info_present) {
    HANDLE_CODE(mrb_progress_info.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void mbs_data_forwarding_resp_mrb_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("mRB-ID", mrb_id);
  j.write_fieldname("dL-Forwarding-UPTNLInformation");
  dl_forwarding_up_tnl_info.to_json(j);
  if (mrb_progress_info_present) {
    j.write_fieldname("mRB-ProgressInformation");
    mrb_progress_info.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MBS-ActiveSessionInformation-TargettoSourceItem ::= SEQUENCE
SRSASN_CODE mbs_active_session_info_targetto_source_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(mbs_data_forwarding_resp_mrb_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(mbs_session_id.pack(bref));
  if (mbs_data_forwarding_resp_mrb_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, mbs_data_forwarding_resp_mrb_list, 1, 32, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mbs_active_session_info_targetto_source_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool mbs_data_forwarding_resp_mrb_list_present;
  HANDLE_CODE(bref.unpack(mbs_data_forwarding_resp_mrb_list_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(mbs_session_id.unpack(bref));
  if (mbs_data_forwarding_resp_mrb_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(mbs_data_forwarding_resp_mrb_list, bref, 1, 32, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void mbs_active_session_info_targetto_source_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("mBS-SessionID");
  mbs_session_id.to_json(j);
  if (mbs_data_forwarding_resp_mrb_list.size() > 0) {
    j.start_array("mBS-DataForwardingResponseMRBList");
    for (const auto& e1 : mbs_data_forwarding_resp_mrb_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MBS-DistributionReleaseRequestTransfer ::= SEQUENCE
SRSASN_CODE mbs_distribution_release_request_transfer_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(mbs_area_session_id_present, 1));
  HANDLE_CODE(bref.pack(shared_ngu_unicast_tnl_info_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(mbs_session_id.pack(bref));
  if (mbs_area_session_id_present) {
    HANDLE_CODE(pack_integer(bref, mbs_area_session_id, (uint32_t)0u, (uint32_t)65535u, true, true));
  }
  if (shared_ngu_unicast_tnl_info_present) {
    HANDLE_CODE(shared_ngu_unicast_tnl_info.pack(bref));
  }
  HANDLE_CODE(cause.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mbs_distribution_release_request_transfer_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(mbs_area_session_id_present, 1));
  HANDLE_CODE(bref.unpack(shared_ngu_unicast_tnl_info_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(mbs_session_id.unpack(bref));
  if (mbs_area_session_id_present) {
    HANDLE_CODE(unpack_integer(mbs_area_session_id, bref, (uint32_t)0u, (uint32_t)65535u, true, true));
  }
  if (shared_ngu_unicast_tnl_info_present) {
    HANDLE_CODE(shared_ngu_unicast_tnl_info.unpack(bref));
  }
  HANDLE_CODE(cause.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void mbs_distribution_release_request_transfer_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("mBS-SessionID");
  mbs_session_id.to_json(j);
  if (mbs_area_session_id_present) {
    j.write_int("mBS-AreaSessionID", mbs_area_session_id);
  }
  if (shared_ngu_unicast_tnl_info_present) {
    j.write_fieldname("sharedNGU-UnicastTNLInformation");
    shared_ngu_unicast_tnl_info.to_json(j);
  }
  j.write_fieldname("cause");
  cause.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MBS-DistributionSetupRequestTransfer ::= SEQUENCE
SRSASN_CODE mbs_distribution_setup_request_transfer_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(mbs_area_session_id_present, 1));
  HANDLE_CODE(bref.pack(shared_ngu_unicast_tnl_info_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(mbs_session_id.pack(bref));
  if (mbs_area_session_id_present) {
    HANDLE_CODE(pack_integer(bref, mbs_area_session_id, (uint32_t)0u, (uint32_t)65535u, true, true));
  }
  if (shared_ngu_unicast_tnl_info_present) {
    HANDLE_CODE(shared_ngu_unicast_tnl_info.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mbs_distribution_setup_request_transfer_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(mbs_area_session_id_present, 1));
  HANDLE_CODE(bref.unpack(shared_ngu_unicast_tnl_info_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(mbs_session_id.unpack(bref));
  if (mbs_area_session_id_present) {
    HANDLE_CODE(unpack_integer(mbs_area_session_id, bref, (uint32_t)0u, (uint32_t)65535u, true, true));
  }
  if (shared_ngu_unicast_tnl_info_present) {
    HANDLE_CODE(shared_ngu_unicast_tnl_info.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void mbs_distribution_setup_request_transfer_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("mBS-SessionID");
  mbs_session_id.to_json(j);
  if (mbs_area_session_id_present) {
    j.write_int("mBS-AreaSessionID", mbs_area_session_id);
  }
  if (shared_ngu_unicast_tnl_info_present) {
    j.write_fieldname("sharedNGU-UnicastTNLInformation");
    shared_ngu_unicast_tnl_info.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SharedNGU-MulticastTNLInformation ::= SEQUENCE
SRSASN_CODE shared_ngu_multicast_tnl_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(ip_multicast_address.pack(bref));
  HANDLE_CODE(ip_source_address.pack(bref));
  HANDLE_CODE(gtp_teid.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE shared_ngu_multicast_tnl_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(ip_multicast_address.unpack(bref));
  HANDLE_CODE(ip_source_address.unpack(bref));
  HANDLE_CODE(gtp_teid.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void shared_ngu_multicast_tnl_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("iP-MulticastAddress", ip_multicast_address.to_string());
  j.write_str("iP-SourceAddress", ip_source_address.to_string());
  j.write_str("gTP-TEID", gtp_teid.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MBS-SessionTNLInfo5GCItem ::= SEQUENCE
SRSASN_CODE mbs_session_tnl_info5_gc_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, mbs_area_session_id, (uint32_t)0u, (uint32_t)65535u, true, true));
  HANDLE_CODE(shared_ngu_multicast_tnl_info.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mbs_session_tnl_info5_gc_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(mbs_area_session_id, bref, (uint32_t)0u, (uint32_t)65535u, true, true));
  HANDLE_CODE(shared_ngu_multicast_tnl_info.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void mbs_session_tnl_info5_gc_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("mBS-AreaSessionID", mbs_area_session_id);
  j.write_fieldname("sharedNGU-MulticastTNLInformation");
  shared_ngu_multicast_tnl_info.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MBSSessionStatus ::= ENUMERATED
const char* mbs_session_status_opts::to_string() const
{
  static const char* names[] = {"activated", "deactivated"};
  return convert_enum_idx(names, 2, value, "mbs_session_status_e");
}

// MBS-DistributionSetupResponseTransfer ::= SEQUENCE
SRSASN_CODE mbs_distribution_setup_resp_transfer_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(mbs_area_session_id_present, 1));
  HANDLE_CODE(bref.pack(shared_ngu_multicast_tnl_info_present, 1));
  HANDLE_CODE(bref.pack(mbs_service_area_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(mbs_session_id.pack(bref));
  if (mbs_area_session_id_present) {
    HANDLE_CODE(pack_integer(bref, mbs_area_session_id, (uint32_t)0u, (uint32_t)65535u, true, true));
  }
  if (shared_ngu_multicast_tnl_info_present) {
    HANDLE_CODE(shared_ngu_multicast_tnl_info.pack(bref));
  }
  HANDLE_CODE(pack_dyn_seq_of(bref, mbs_qos_flows_to_be_setup_list, 1, 64, true));
  HANDLE_CODE(mbs_session_status.pack(bref));
  if (mbs_service_area_present) {
    HANDLE_CODE(mbs_service_area.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mbs_distribution_setup_resp_transfer_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(mbs_area_session_id_present, 1));
  HANDLE_CODE(bref.unpack(shared_ngu_multicast_tnl_info_present, 1));
  HANDLE_CODE(bref.unpack(mbs_service_area_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(mbs_session_id.unpack(bref));
  if (mbs_area_session_id_present) {
    HANDLE_CODE(unpack_integer(mbs_area_session_id, bref, (uint32_t)0u, (uint32_t)65535u, true, true));
  }
  if (shared_ngu_multicast_tnl_info_present) {
    HANDLE_CODE(shared_ngu_multicast_tnl_info.unpack(bref));
  }
  HANDLE_CODE(unpack_dyn_seq_of(mbs_qos_flows_to_be_setup_list, bref, 1, 64, true));
  HANDLE_CODE(mbs_session_status.unpack(bref));
  if (mbs_service_area_present) {
    HANDLE_CODE(mbs_service_area.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void mbs_distribution_setup_resp_transfer_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("mBS-SessionID");
  mbs_session_id.to_json(j);
  if (mbs_area_session_id_present) {
    j.write_int("mBS-AreaSessionID", mbs_area_session_id);
  }
  if (shared_ngu_multicast_tnl_info_present) {
    j.write_fieldname("sharedNGU-MulticastTNLInformation");
    shared_ngu_multicast_tnl_info.to_json(j);
  }
  j.start_array("mBS-QoSFlowsToBeSetupList");
  for (const auto& e1 : mbs_qos_flows_to_be_setup_list) {
    e1.to_json(j);
  }
  j.end_array();
  j.write_str("mBSSessionStatus", mbs_session_status.to_string());
  if (mbs_service_area_present) {
    j.write_fieldname("mBS-ServiceArea");
    mbs_service_area.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MBS-DistributionSetupUnsuccessfulTransfer ::= SEQUENCE
SRSASN_CODE mbs_distribution_setup_unsuccessful_transfer_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(mbs_area_session_id_present, 1));
  HANDLE_CODE(bref.pack(crit_diagnostics_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(mbs_session_id.pack(bref));
  if (mbs_area_session_id_present) {
    HANDLE_CODE(pack_integer(bref, mbs_area_session_id, (uint32_t)0u, (uint32_t)65535u, true, true));
  }
  HANDLE_CODE(cause.pack(bref));
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mbs_distribution_setup_unsuccessful_transfer_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(mbs_area_session_id_present, 1));
  HANDLE_CODE(bref.unpack(crit_diagnostics_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(mbs_session_id.unpack(bref));
  if (mbs_area_session_id_present) {
    HANDLE_CODE(unpack_integer(mbs_area_session_id, bref, (uint32_t)0u, (uint32_t)65535u, true, true));
  }
  HANDLE_CODE(cause.unpack(bref));
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void mbs_distribution_setup_unsuccessful_transfer_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("mBS-SessionID");
  mbs_session_id.to_json(j);
  if (mbs_area_session_id_present) {
    j.write_int("mBS-AreaSessionID", mbs_area_session_id);
  }
  j.write_fieldname("cause");
  cause.to_json(j);
  if (crit_diagnostics_present) {
    j.write_fieldname("criticalityDiagnostics");
    crit_diagnostics.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MBS-SessionTNLInfo5GC ::= CHOICE
void mbs_session_tnl_info5_gc_c::destroy_()
{
  switch (type_) {
    case types::locationindependent:
      c.destroy<shared_ngu_multicast_tnl_info_s>();
      break;
    case types::locationdependent:
      c.destroy<mbs_session_tnl_info5_gc_list_l>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<mbs_session_tnl_info5_gc_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void mbs_session_tnl_info5_gc_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::locationindependent:
      c.init<shared_ngu_multicast_tnl_info_s>();
      break;
    case types::locationdependent:
      c.init<mbs_session_tnl_info5_gc_list_l>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<mbs_session_tnl_info5_gc_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "mbs_session_tnl_info5_gc_c");
  }
}
mbs_session_tnl_info5_gc_c::mbs_session_tnl_info5_gc_c(const mbs_session_tnl_info5_gc_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::locationindependent:
      c.init(other.c.get<shared_ngu_multicast_tnl_info_s>());
      break;
    case types::locationdependent:
      c.init(other.c.get<mbs_session_tnl_info5_gc_list_l>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<mbs_session_tnl_info5_gc_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "mbs_session_tnl_info5_gc_c");
  }
}
mbs_session_tnl_info5_gc_c& mbs_session_tnl_info5_gc_c::operator=(const mbs_session_tnl_info5_gc_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::locationindependent:
      c.set(other.c.get<shared_ngu_multicast_tnl_info_s>());
      break;
    case types::locationdependent:
      c.set(other.c.get<mbs_session_tnl_info5_gc_list_l>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<mbs_session_tnl_info5_gc_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "mbs_session_tnl_info5_gc_c");
  }

  return *this;
}
shared_ngu_multicast_tnl_info_s& mbs_session_tnl_info5_gc_c::set_locationindependent()
{
  set(types::locationindependent);
  return c.get<shared_ngu_multicast_tnl_info_s>();
}
mbs_session_tnl_info5_gc_list_l& mbs_session_tnl_info5_gc_c::set_locationdependent()
{
  set(types::locationdependent);
  return c.get<mbs_session_tnl_info5_gc_list_l>();
}
protocol_ie_single_container_s<mbs_session_tnl_info5_gc_ext_ies_o>& mbs_session_tnl_info5_gc_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<mbs_session_tnl_info5_gc_ext_ies_o>>();
}
void mbs_session_tnl_info5_gc_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::locationindependent:
      j.write_fieldname("locationindependent");
      c.get<shared_ngu_multicast_tnl_info_s>().to_json(j);
      break;
    case types::locationdependent:
      j.start_array("locationdependent");
      for (const auto& e1 : c.get<mbs_session_tnl_info5_gc_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<mbs_session_tnl_info5_gc_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "mbs_session_tnl_info5_gc_c");
  }
  j.end_obj();
}
SRSASN_CODE mbs_session_tnl_info5_gc_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::locationindependent:
      HANDLE_CODE(c.get<shared_ngu_multicast_tnl_info_s>().pack(bref));
      break;
    case types::locationdependent:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<mbs_session_tnl_info5_gc_list_l>(), 1, 256, true));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<mbs_session_tnl_info5_gc_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "mbs_session_tnl_info5_gc_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE mbs_session_tnl_info5_gc_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::locationindependent:
      HANDLE_CODE(c.get<shared_ngu_multicast_tnl_info_s>().unpack(bref));
      break;
    case types::locationdependent:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<mbs_session_tnl_info5_gc_list_l>(), bref, 1, 256, true));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<mbs_session_tnl_info5_gc_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "mbs_session_tnl_info5_gc_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* mbs_session_tnl_info5_gc_c::types_opts::to_string() const
{
  static const char* names[] = {"locationindependent", "locationdependent", "choice-Extensions"};
  return convert_enum_idx(names, 3, value, "mbs_session_tnl_info5_gc_c::types");
}

// MBS-SessionTNLInfoNGRANItem ::= SEQUENCE
SRSASN_CODE mbs_session_tnl_info_ngran_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(shared_ngu_unicast_tnl_info_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, mbs_area_session_id, (uint32_t)0u, (uint32_t)65535u, true, true));
  if (shared_ngu_unicast_tnl_info_present) {
    HANDLE_CODE(shared_ngu_unicast_tnl_info.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mbs_session_tnl_info_ngran_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(shared_ngu_unicast_tnl_info_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(mbs_area_session_id, bref, (uint32_t)0u, (uint32_t)65535u, true, true));
  if (shared_ngu_unicast_tnl_info_present) {
    HANDLE_CODE(shared_ngu_unicast_tnl_info.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void mbs_session_tnl_info_ngran_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("mBS-AreaSessionID", mbs_area_session_id);
  if (shared_ngu_unicast_tnl_info_present) {
    j.write_fieldname("sharedNGU-UnicastTNLInformation");
    shared_ngu_unicast_tnl_info.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MBS-SessionTNLInfoNGRAN ::= CHOICE
void mbs_session_tnl_info_ngran_c::destroy_()
{
  switch (type_) {
    case types::locationindependent:
      c.destroy<up_transport_layer_info_c>();
      break;
    case types::locationdependent:
      c.destroy<mbs_session_tnl_info_ngran_list_l>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<mbs_session_tnl_info_ngran_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void mbs_session_tnl_info_ngran_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::locationindependent:
      c.init<up_transport_layer_info_c>();
      break;
    case types::locationdependent:
      c.init<mbs_session_tnl_info_ngran_list_l>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<mbs_session_tnl_info_ngran_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "mbs_session_tnl_info_ngran_c");
  }
}
mbs_session_tnl_info_ngran_c::mbs_session_tnl_info_ngran_c(const mbs_session_tnl_info_ngran_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::locationindependent:
      c.init(other.c.get<up_transport_layer_info_c>());
      break;
    case types::locationdependent:
      c.init(other.c.get<mbs_session_tnl_info_ngran_list_l>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<mbs_session_tnl_info_ngran_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "mbs_session_tnl_info_ngran_c");
  }
}
mbs_session_tnl_info_ngran_c& mbs_session_tnl_info_ngran_c::operator=(const mbs_session_tnl_info_ngran_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::locationindependent:
      c.set(other.c.get<up_transport_layer_info_c>());
      break;
    case types::locationdependent:
      c.set(other.c.get<mbs_session_tnl_info_ngran_list_l>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<mbs_session_tnl_info_ngran_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "mbs_session_tnl_info_ngran_c");
  }

  return *this;
}
up_transport_layer_info_c& mbs_session_tnl_info_ngran_c::set_locationindependent()
{
  set(types::locationindependent);
  return c.get<up_transport_layer_info_c>();
}
mbs_session_tnl_info_ngran_list_l& mbs_session_tnl_info_ngran_c::set_locationdependent()
{
  set(types::locationdependent);
  return c.get<mbs_session_tnl_info_ngran_list_l>();
}
protocol_ie_single_container_s<mbs_session_tnl_info_ngran_ext_ies_o>& mbs_session_tnl_info_ngran_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<mbs_session_tnl_info_ngran_ext_ies_o>>();
}
void mbs_session_tnl_info_ngran_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::locationindependent:
      j.write_fieldname("locationindependent");
      c.get<up_transport_layer_info_c>().to_json(j);
      break;
    case types::locationdependent:
      j.start_array("locationdependent");
      for (const auto& e1 : c.get<mbs_session_tnl_info_ngran_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<mbs_session_tnl_info_ngran_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "mbs_session_tnl_info_ngran_c");
  }
  j.end_obj();
}
SRSASN_CODE mbs_session_tnl_info_ngran_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::locationindependent:
      HANDLE_CODE(c.get<up_transport_layer_info_c>().pack(bref));
      break;
    case types::locationdependent:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<mbs_session_tnl_info_ngran_list_l>(), 1, 256, true));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<mbs_session_tnl_info_ngran_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "mbs_session_tnl_info_ngran_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE mbs_session_tnl_info_ngran_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::locationindependent:
      HANDLE_CODE(c.get<up_transport_layer_info_c>().unpack(bref));
      break;
    case types::locationdependent:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<mbs_session_tnl_info_ngran_list_l>(), bref, 1, 256, true));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<mbs_session_tnl_info_ngran_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "mbs_session_tnl_info_ngran_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* mbs_session_tnl_info_ngran_c::types_opts::to_string() const
{
  static const char* names[] = {"locationindependent", "locationdependent", "choice-Extensions"};
  return convert_enum_idx(names, 3, value, "mbs_session_tnl_info_ngran_c::types");
}

// MBSSessionFailedtoSetupItem ::= SEQUENCE
SRSASN_CODE mbs_session_failedto_setup_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(mbs_area_session_id_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(mbs_session_id.pack(bref));
  if (mbs_area_session_id_present) {
    HANDLE_CODE(pack_integer(bref, mbs_area_session_id, (uint32_t)0u, (uint32_t)65535u, true, true));
  }
  HANDLE_CODE(cause.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mbs_session_failedto_setup_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(mbs_area_session_id_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(mbs_session_id.unpack(bref));
  if (mbs_area_session_id_present) {
    HANDLE_CODE(unpack_integer(mbs_area_session_id, bref, (uint32_t)0u, (uint32_t)65535u, true, true));
  }
  HANDLE_CODE(cause.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void mbs_session_failedto_setup_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("mBS-SessionID");
  mbs_session_id.to_json(j);
  if (mbs_area_session_id_present) {
    j.write_int("mBS-AreaSessionID", mbs_area_session_id);
  }
  j.write_fieldname("cause");
  cause.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MBSSessionReleaseResponseTransfer ::= SEQUENCE
SRSASN_CODE mbs_session_release_resp_transfer_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(mbs_session_tnl_info_ngran_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (mbs_session_tnl_info_ngran_present) {
    HANDLE_CODE(mbs_session_tnl_info_ngran.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mbs_session_release_resp_transfer_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(mbs_session_tnl_info_ngran_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (mbs_session_tnl_info_ngran_present) {
    HANDLE_CODE(mbs_session_tnl_info_ngran.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void mbs_session_release_resp_transfer_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (mbs_session_tnl_info_ngran_present) {
    j.write_fieldname("mBS-SessionTNLInfoNGRAN");
    mbs_session_tnl_info_ngran.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MBSSessionSetupOrModFailureTransfer ::= SEQUENCE
SRSASN_CODE mbs_session_setup_or_mod_fail_transfer_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(crit_diagnostics_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(cause.pack(bref));
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mbs_session_setup_or_mod_fail_transfer_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(crit_diagnostics_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(cause.unpack(bref));
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void mbs_session_setup_or_mod_fail_transfer_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("cause");
  cause.to_json(j);
  if (crit_diagnostics_present) {
    j.write_fieldname("criticalityDiagnostics");
    crit_diagnostics.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MBSSessionSetupOrModRequestTransferIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t mbs_session_setup_or_mod_request_transfer_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {352, 297, 357};
  return map_enum_number(names, 3, idx, "id");
}
bool mbs_session_setup_or_mod_request_transfer_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {352, 297, 357};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e mbs_session_setup_or_mod_request_transfer_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 352:
      return crit_e::reject;
    case 297:
      return crit_e::reject;
    case 357:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
mbs_session_setup_or_mod_request_transfer_ies_o::value_c
mbs_session_setup_or_mod_request_transfer_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 352:
      ret.set(value_c::types::mbs_session_tnl_info5_gc);
      break;
    case 297:
      ret.set(value_c::types::mbs_qos_flows_to_be_setup_mod_list);
      break;
    case 357:
      ret.set(value_c::types::mbs_session_fsa_id_list);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e mbs_session_setup_or_mod_request_transfer_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 352:
      return presence_e::optional;
    case 297:
      return presence_e::mandatory;
    case 357:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void mbs_session_setup_or_mod_request_transfer_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::mbs_session_tnl_info5_gc:
      c.destroy<mbs_session_tnl_info5_gc_c>();
      break;
    case types::mbs_qos_flows_to_be_setup_mod_list:
      c.destroy<mbs_qos_flows_to_be_setup_list_l>();
      break;
    case types::mbs_session_fsa_id_list:
      c.destroy<mbs_session_fsa_id_list_l>();
      break;
    default:
      break;
  }
}
void mbs_session_setup_or_mod_request_transfer_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mbs_session_tnl_info5_gc:
      c.init<mbs_session_tnl_info5_gc_c>();
      break;
    case types::mbs_qos_flows_to_be_setup_mod_list:
      c.init<mbs_qos_flows_to_be_setup_list_l>();
      break;
    case types::mbs_session_fsa_id_list:
      c.init<mbs_session_fsa_id_list_l>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "mbs_session_setup_or_mod_request_transfer_ies_o::value_c");
  }
}
mbs_session_setup_or_mod_request_transfer_ies_o::value_c::value_c(
    const mbs_session_setup_or_mod_request_transfer_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mbs_session_tnl_info5_gc:
      c.init(other.c.get<mbs_session_tnl_info5_gc_c>());
      break;
    case types::mbs_qos_flows_to_be_setup_mod_list:
      c.init(other.c.get<mbs_qos_flows_to_be_setup_list_l>());
      break;
    case types::mbs_session_fsa_id_list:
      c.init(other.c.get<mbs_session_fsa_id_list_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "mbs_session_setup_or_mod_request_transfer_ies_o::value_c");
  }
}
mbs_session_setup_or_mod_request_transfer_ies_o::value_c&
mbs_session_setup_or_mod_request_transfer_ies_o::value_c::operator=(
    const mbs_session_setup_or_mod_request_transfer_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mbs_session_tnl_info5_gc:
      c.set(other.c.get<mbs_session_tnl_info5_gc_c>());
      break;
    case types::mbs_qos_flows_to_be_setup_mod_list:
      c.set(other.c.get<mbs_qos_flows_to_be_setup_list_l>());
      break;
    case types::mbs_session_fsa_id_list:
      c.set(other.c.get<mbs_session_fsa_id_list_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "mbs_session_setup_or_mod_request_transfer_ies_o::value_c");
  }

  return *this;
}
mbs_session_tnl_info5_gc_c& mbs_session_setup_or_mod_request_transfer_ies_o::value_c::mbs_session_tnl_info5_gc()
{
  assert_choice_type(types::mbs_session_tnl_info5_gc, type_, "Value");
  return c.get<mbs_session_tnl_info5_gc_c>();
}
mbs_qos_flows_to_be_setup_list_l&
mbs_session_setup_or_mod_request_transfer_ies_o::value_c::mbs_qos_flows_to_be_setup_mod_list()
{
  assert_choice_type(types::mbs_qos_flows_to_be_setup_mod_list, type_, "Value");
  return c.get<mbs_qos_flows_to_be_setup_list_l>();
}
mbs_session_fsa_id_list_l& mbs_session_setup_or_mod_request_transfer_ies_o::value_c::mbs_session_fsa_id_list()
{
  assert_choice_type(types::mbs_session_fsa_id_list, type_, "Value");
  return c.get<mbs_session_fsa_id_list_l>();
}
const mbs_session_tnl_info5_gc_c&
mbs_session_setup_or_mod_request_transfer_ies_o::value_c::mbs_session_tnl_info5_gc() const
{
  assert_choice_type(types::mbs_session_tnl_info5_gc, type_, "Value");
  return c.get<mbs_session_tnl_info5_gc_c>();
}
const mbs_qos_flows_to_be_setup_list_l&
mbs_session_setup_or_mod_request_transfer_ies_o::value_c::mbs_qos_flows_to_be_setup_mod_list() const
{
  assert_choice_type(types::mbs_qos_flows_to_be_setup_mod_list, type_, "Value");
  return c.get<mbs_qos_flows_to_be_setup_list_l>();
}
const mbs_session_fsa_id_list_l&
mbs_session_setup_or_mod_request_transfer_ies_o::value_c::mbs_session_fsa_id_list() const
{
  assert_choice_type(types::mbs_session_fsa_id_list, type_, "Value");
  return c.get<mbs_session_fsa_id_list_l>();
}
void mbs_session_setup_or_mod_request_transfer_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_tnl_info5_gc:
      j.write_fieldname("MBS-SessionTNLInfo5GC");
      c.get<mbs_session_tnl_info5_gc_c>().to_json(j);
      break;
    case types::mbs_qos_flows_to_be_setup_mod_list:
      j.start_array("MBS-QoSFlowsToBeSetupList");
      for (const auto& e1 : c.get<mbs_qos_flows_to_be_setup_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::mbs_session_fsa_id_list:
      j.start_array("MBS-SessionFSAIDList");
      for (const auto& e1 : c.get<mbs_session_fsa_id_list_l>()) {
        j.write_str(e1.to_string());
      }
      j.end_array();
      break;
    default:
      log_invalid_choice_id(type_, "mbs_session_setup_or_mod_request_transfer_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE mbs_session_setup_or_mod_request_transfer_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_tnl_info5_gc:
      HANDLE_CODE(c.get<mbs_session_tnl_info5_gc_c>().pack(bref));
      break;
    case types::mbs_qos_flows_to_be_setup_mod_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<mbs_qos_flows_to_be_setup_list_l>(), 1, 64, true));
      break;
    case types::mbs_session_fsa_id_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<mbs_session_fsa_id_list_l>(), 1, 64, true));
      break;
    default:
      log_invalid_choice_id(type_, "mbs_session_setup_or_mod_request_transfer_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE mbs_session_setup_or_mod_request_transfer_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_tnl_info5_gc:
      HANDLE_CODE(c.get<mbs_session_tnl_info5_gc_c>().unpack(bref));
      break;
    case types::mbs_qos_flows_to_be_setup_mod_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<mbs_qos_flows_to_be_setup_list_l>(), bref, 1, 64, true));
      break;
    case types::mbs_session_fsa_id_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<mbs_session_fsa_id_list_l>(), bref, 1, 64, true));
      break;
    default:
      log_invalid_choice_id(type_, "mbs_session_setup_or_mod_request_transfer_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* mbs_session_setup_or_mod_request_transfer_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"MBS-SessionTNLInfo5GC", "MBS-QoSFlowsToBeSetupList", "MBS-SessionFSAIDList"};
  return convert_enum_idx(names, 3, value, "mbs_session_setup_or_mod_request_transfer_ies_o::value_c::types");
}
uint8_t mbs_session_setup_or_mod_request_transfer_ies_o::value_c::types_opts::to_number() const
{
  static const uint8_t numbers[] = {5};
  return map_enum_number(numbers, 1, value, "mbs_session_setup_or_mod_request_transfer_ies_o::value_c::types");
}

template struct asn1::protocol_ie_field_s<mbs_session_setup_or_mod_request_transfer_ies_o>;

mbs_session_setup_or_mod_request_transfer_ies_container::mbs_session_setup_or_mod_request_transfer_ies_container() :
  mbs_session_tnl_info5_gc(352, crit_e::reject),
  mbs_qos_flows_to_be_setup_mod_list(297, crit_e::reject),
  mbs_session_fsa_id_list(357, crit_e::ignore)
{
}
SRSASN_CODE mbs_session_setup_or_mod_request_transfer_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 1;
  nof_ies += mbs_session_tnl_info5_gc_present ? 1 : 0;
  nof_ies += mbs_session_fsa_id_list_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  if (mbs_session_tnl_info5_gc_present) {
    HANDLE_CODE(mbs_session_tnl_info5_gc.pack(bref));
  }
  HANDLE_CODE(mbs_qos_flows_to_be_setup_mod_list.pack(bref));
  if (mbs_session_fsa_id_list_present) {
    HANDLE_CODE(mbs_session_fsa_id_list.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mbs_session_setup_or_mod_request_transfer_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 1;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 352: {
        mbs_session_tnl_info5_gc_present = true;
        mbs_session_tnl_info5_gc.id      = id;
        HANDLE_CODE(mbs_session_tnl_info5_gc.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_tnl_info5_gc.value.unpack(bref));
        break;
      }
      case 297: {
        nof_mandatory_ies--;
        mbs_qos_flows_to_be_setup_mod_list.id = id;
        HANDLE_CODE(mbs_qos_flows_to_be_setup_mod_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_qos_flows_to_be_setup_mod_list.value.unpack(bref));
        break;
      }
      case 357: {
        mbs_session_fsa_id_list_present = true;
        mbs_session_fsa_id_list.id      = id;
        HANDLE_CODE(mbs_session_fsa_id_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_fsa_id_list.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void mbs_session_setup_or_mod_request_transfer_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (mbs_session_tnl_info5_gc_present) {
    j.write_fieldname("");
    mbs_session_tnl_info5_gc.to_json(j);
  }
  j.write_fieldname("");
  mbs_qos_flows_to_be_setup_mod_list.to_json(j);
  if (mbs_session_fsa_id_list_present) {
    j.write_fieldname("");
    mbs_session_fsa_id_list.to_json(j);
  }
  j.end_obj();
}

// MBSSessionSetupOrModResponseTransfer ::= SEQUENCE
SRSASN_CODE mbs_session_setup_or_mod_resp_transfer_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(mbs_session_tnl_info_ngran_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (mbs_session_tnl_info_ngran_present) {
    HANDLE_CODE(mbs_session_tnl_info_ngran.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mbs_session_setup_or_mod_resp_transfer_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(mbs_session_tnl_info_ngran_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (mbs_session_tnl_info_ngran_present) {
    HANDLE_CODE(mbs_session_tnl_info_ngran.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void mbs_session_setup_or_mod_resp_transfer_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (mbs_session_tnl_info_ngran_present) {
    j.write_fieldname("mBS-SessionTNLInfoNGRAN");
    mbs_session_tnl_info_ngran.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MBSSessionSetupRequestItem ::= SEQUENCE
SRSASN_CODE mbs_session_setup_request_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(mbs_area_session_id_present, 1));
  HANDLE_CODE(bref.pack(associated_mbs_qos_flow_setup_request_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(mbs_session_id.pack(bref));
  if (mbs_area_session_id_present) {
    HANDLE_CODE(pack_integer(bref, mbs_area_session_id, (uint32_t)0u, (uint32_t)65535u, true, true));
  }
  if (associated_mbs_qos_flow_setup_request_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, associated_mbs_qos_flow_setup_request_list, 1, 64, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mbs_session_setup_request_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(mbs_area_session_id_present, 1));
  bool associated_mbs_qos_flow_setup_request_list_present;
  HANDLE_CODE(bref.unpack(associated_mbs_qos_flow_setup_request_list_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(mbs_session_id.unpack(bref));
  if (mbs_area_session_id_present) {
    HANDLE_CODE(unpack_integer(mbs_area_session_id, bref, (uint32_t)0u, (uint32_t)65535u, true, true));
  }
  if (associated_mbs_qos_flow_setup_request_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(associated_mbs_qos_flow_setup_request_list, bref, 1, 64, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void mbs_session_setup_request_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("mBS-SessionID");
  mbs_session_id.to_json(j);
  if (mbs_area_session_id_present) {
    j.write_int("mBS-AreaSessionID", mbs_area_session_id);
  }
  if (associated_mbs_qos_flow_setup_request_list.size() > 0) {
    j.start_array("associatedMBSQosFlowSetupRequestList");
    for (const auto& e1 : associated_mbs_qos_flow_setup_request_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MBSSessionSetupResponseItem ::= SEQUENCE
SRSASN_CODE mbs_session_setup_resp_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(mbs_area_session_id_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(mbs_session_id.pack(bref));
  if (mbs_area_session_id_present) {
    HANDLE_CODE(pack_integer(bref, mbs_area_session_id, (uint32_t)0u, (uint32_t)65535u, true, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mbs_session_setup_resp_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(mbs_area_session_id_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(mbs_session_id.unpack(bref));
  if (mbs_area_session_id_present) {
    HANDLE_CODE(unpack_integer(mbs_area_session_id, bref, (uint32_t)0u, (uint32_t)65535u, true, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void mbs_session_setup_resp_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("mBS-SessionID");
  mbs_session_id.to_json(j);
  if (mbs_area_session_id_present) {
    j.write_int("mBS-AreaSessionID", mbs_area_session_id);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MBSSessionSetuporModifyRequestItem ::= SEQUENCE
SRSASN_CODE mbs_session_setupor_modify_request_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(mbs_area_session_id_present, 1));
  HANDLE_CODE(bref.pack(associated_mbs_qos_flow_setupor_modify_request_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(mbs_qos_flow_to_release_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(mbs_session_id.pack(bref));
  if (mbs_area_session_id_present) {
    HANDLE_CODE(pack_integer(bref, mbs_area_session_id, (uint32_t)0u, (uint32_t)65535u, true, true));
  }
  if (associated_mbs_qos_flow_setupor_modify_request_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, associated_mbs_qos_flow_setupor_modify_request_list, 1, 64, true));
  }
  if (mbs_qos_flow_to_release_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, mbs_qos_flow_to_release_list, 1, 64, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mbs_session_setupor_modify_request_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(mbs_area_session_id_present, 1));
  bool associated_mbs_qos_flow_setupor_modify_request_list_present;
  HANDLE_CODE(bref.unpack(associated_mbs_qos_flow_setupor_modify_request_list_present, 1));
  bool mbs_qos_flow_to_release_list_present;
  HANDLE_CODE(bref.unpack(mbs_qos_flow_to_release_list_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(mbs_session_id.unpack(bref));
  if (mbs_area_session_id_present) {
    HANDLE_CODE(unpack_integer(mbs_area_session_id, bref, (uint32_t)0u, (uint32_t)65535u, true, true));
  }
  if (associated_mbs_qos_flow_setupor_modify_request_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(associated_mbs_qos_flow_setupor_modify_request_list, bref, 1, 64, true));
  }
  if (mbs_qos_flow_to_release_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(mbs_qos_flow_to_release_list, bref, 1, 64, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void mbs_session_setupor_modify_request_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("mBS-SessionID");
  mbs_session_id.to_json(j);
  if (mbs_area_session_id_present) {
    j.write_int("mBS-AreaSessionID", mbs_area_session_id);
  }
  if (associated_mbs_qos_flow_setupor_modify_request_list.size() > 0) {
    j.start_array("associatedMBSQosFlowSetuporModifyRequestList");
    for (const auto& e1 : associated_mbs_qos_flow_setupor_modify_request_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (mbs_qos_flow_to_release_list.size() > 0) {
    j.start_array("mBS-QosFlowToReleaseList");
    for (const auto& e1 : mbs_qos_flow_to_release_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MBSSessionToReleaseItem ::= SEQUENCE
SRSASN_CODE mbs_session_to_release_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(mbs_session_id.pack(bref));
  HANDLE_CODE(cause.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mbs_session_to_release_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(mbs_session_id.unpack(bref));
  HANDLE_CODE(cause.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void mbs_session_to_release_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("mBS-SessionID");
  mbs_session_id.to_json(j);
  j.write_fieldname("cause");
  cause.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MulticastSessionActivationRequestTransfer ::= SEQUENCE
SRSASN_CODE multicast_session_activation_request_transfer_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(mbs_session_id.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_session_activation_request_transfer_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(mbs_session_id.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void multicast_session_activation_request_transfer_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("mBS-SessionID");
  mbs_session_id.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MulticastSessionDeactivationRequestTransfer ::= SEQUENCE
SRSASN_CODE multicast_session_deactivation_request_transfer_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(mbs_session_id.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_session_deactivation_request_transfer_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(mbs_session_id.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void multicast_session_deactivation_request_transfer_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("mBS-SessionID");
  mbs_session_id.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MulticastSessionUpdateRequestTransferIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t multicast_session_upd_request_transfer_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 298, 297, 351, 352};
  return map_enum_number(names, 5, idx, "id");
}
bool multicast_session_upd_request_transfer_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 298, 297, 351, 352};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e multicast_session_upd_request_transfer_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::reject;
    case 298:
      return crit_e::reject;
    case 297:
      return crit_e::reject;
    case 351:
      return crit_e::reject;
    case 352:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
multicast_session_upd_request_transfer_ies_o::value_c
multicast_session_upd_request_transfer_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 298:
      ret.set(value_c::types::mbs_service_area);
      break;
    case 297:
      ret.set(value_c::types::mbs_qos_flows_to_be_setup_mod_list);
      break;
    case 351:
      ret.set(value_c::types::mbs_qos_flow_to_release_list);
      break;
    case 352:
      ret.set(value_c::types::mbs_session_tnl_info5_gc);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e multicast_session_upd_request_transfer_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 298:
      return presence_e::optional;
    case 297:
      return presence_e::optional;
    case 351:
      return presence_e::optional;
    case 352:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void multicast_session_upd_request_transfer_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::mbs_session_id:
      c.destroy<mbs_session_id_s>();
      break;
    case types::mbs_service_area:
      c.destroy<mbs_service_area_c>();
      break;
    case types::mbs_qos_flows_to_be_setup_mod_list:
      c.destroy<mbs_qos_flows_to_be_setup_list_l>();
      break;
    case types::mbs_qos_flow_to_release_list:
      c.destroy<qos_flow_list_with_cause_l>();
      break;
    case types::mbs_session_tnl_info5_gc:
      c.destroy<mbs_session_tnl_info5_gc_c>();
      break;
    default:
      break;
  }
}
void multicast_session_upd_request_transfer_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c.init<mbs_session_id_s>();
      break;
    case types::mbs_service_area:
      c.init<mbs_service_area_c>();
      break;
    case types::mbs_qos_flows_to_be_setup_mod_list:
      c.init<mbs_qos_flows_to_be_setup_list_l>();
      break;
    case types::mbs_qos_flow_to_release_list:
      c.init<qos_flow_list_with_cause_l>();
      break;
    case types::mbs_session_tnl_info5_gc:
      c.init<mbs_session_tnl_info5_gc_c>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_upd_request_transfer_ies_o::value_c");
  }
}
multicast_session_upd_request_transfer_ies_o::value_c::value_c(
    const multicast_session_upd_request_transfer_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mbs_session_id:
      c.init(other.c.get<mbs_session_id_s>());
      break;
    case types::mbs_service_area:
      c.init(other.c.get<mbs_service_area_c>());
      break;
    case types::mbs_qos_flows_to_be_setup_mod_list:
      c.init(other.c.get<mbs_qos_flows_to_be_setup_list_l>());
      break;
    case types::mbs_qos_flow_to_release_list:
      c.init(other.c.get<qos_flow_list_with_cause_l>());
      break;
    case types::mbs_session_tnl_info5_gc:
      c.init(other.c.get<mbs_session_tnl_info5_gc_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_upd_request_transfer_ies_o::value_c");
  }
}
multicast_session_upd_request_transfer_ies_o::value_c& multicast_session_upd_request_transfer_ies_o::value_c::operator=(
    const multicast_session_upd_request_transfer_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mbs_session_id:
      c.set(other.c.get<mbs_session_id_s>());
      break;
    case types::mbs_service_area:
      c.set(other.c.get<mbs_service_area_c>());
      break;
    case types::mbs_qos_flows_to_be_setup_mod_list:
      c.set(other.c.get<mbs_qos_flows_to_be_setup_list_l>());
      break;
    case types::mbs_qos_flow_to_release_list:
      c.set(other.c.get<qos_flow_list_with_cause_l>());
      break;
    case types::mbs_session_tnl_info5_gc:
      c.set(other.c.get<mbs_session_tnl_info5_gc_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_upd_request_transfer_ies_o::value_c");
  }

  return *this;
}
mbs_session_id_s& multicast_session_upd_request_transfer_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
mbs_service_area_c& multicast_session_upd_request_transfer_ies_o::value_c::mbs_service_area()
{
  assert_choice_type(types::mbs_service_area, type_, "Value");
  return c.get<mbs_service_area_c>();
}
mbs_qos_flows_to_be_setup_list_l&
multicast_session_upd_request_transfer_ies_o::value_c::mbs_qos_flows_to_be_setup_mod_list()
{
  assert_choice_type(types::mbs_qos_flows_to_be_setup_mod_list, type_, "Value");
  return c.get<mbs_qos_flows_to_be_setup_list_l>();
}
qos_flow_list_with_cause_l& multicast_session_upd_request_transfer_ies_o::value_c::mbs_qos_flow_to_release_list()
{
  assert_choice_type(types::mbs_qos_flow_to_release_list, type_, "Value");
  return c.get<qos_flow_list_with_cause_l>();
}
mbs_session_tnl_info5_gc_c& multicast_session_upd_request_transfer_ies_o::value_c::mbs_session_tnl_info5_gc()
{
  assert_choice_type(types::mbs_session_tnl_info5_gc, type_, "Value");
  return c.get<mbs_session_tnl_info5_gc_c>();
}
const mbs_session_id_s& multicast_session_upd_request_transfer_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const mbs_service_area_c& multicast_session_upd_request_transfer_ies_o::value_c::mbs_service_area() const
{
  assert_choice_type(types::mbs_service_area, type_, "Value");
  return c.get<mbs_service_area_c>();
}
const mbs_qos_flows_to_be_setup_list_l&
multicast_session_upd_request_transfer_ies_o::value_c::mbs_qos_flows_to_be_setup_mod_list() const
{
  assert_choice_type(types::mbs_qos_flows_to_be_setup_mod_list, type_, "Value");
  return c.get<mbs_qos_flows_to_be_setup_list_l>();
}
const qos_flow_list_with_cause_l&
multicast_session_upd_request_transfer_ies_o::value_c::mbs_qos_flow_to_release_list() const
{
  assert_choice_type(types::mbs_qos_flow_to_release_list, type_, "Value");
  return c.get<qos_flow_list_with_cause_l>();
}
const mbs_session_tnl_info5_gc_c&
multicast_session_upd_request_transfer_ies_o::value_c::mbs_session_tnl_info5_gc() const
{
  assert_choice_type(types::mbs_session_tnl_info5_gc, type_, "Value");
  return c.get<mbs_session_tnl_info5_gc_c>();
}
void multicast_session_upd_request_transfer_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::mbs_service_area:
      j.write_fieldname("MBS-ServiceArea");
      c.get<mbs_service_area_c>().to_json(j);
      break;
    case types::mbs_qos_flows_to_be_setup_mod_list:
      j.start_array("MBS-QoSFlowsToBeSetupList");
      for (const auto& e1 : c.get<mbs_qos_flows_to_be_setup_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::mbs_qos_flow_to_release_list:
      j.start_array("QosFlowListWithCause");
      for (const auto& e1 : c.get<qos_flow_list_with_cause_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::mbs_session_tnl_info5_gc:
      j.write_fieldname("MBS-SessionTNLInfo5GC");
      c.get<mbs_session_tnl_info5_gc_c>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_upd_request_transfer_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE multicast_session_upd_request_transfer_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::mbs_service_area:
      HANDLE_CODE(c.get<mbs_service_area_c>().pack(bref));
      break;
    case types::mbs_qos_flows_to_be_setup_mod_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<mbs_qos_flows_to_be_setup_list_l>(), 1, 64, true));
      break;
    case types::mbs_qos_flow_to_release_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<qos_flow_list_with_cause_l>(), 1, 64, true));
      break;
    case types::mbs_session_tnl_info5_gc:
      HANDLE_CODE(c.get<mbs_session_tnl_info5_gc_c>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_upd_request_transfer_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_session_upd_request_transfer_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::mbs_service_area:
      HANDLE_CODE(c.get<mbs_service_area_c>().unpack(bref));
      break;
    case types::mbs_qos_flows_to_be_setup_mod_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<mbs_qos_flows_to_be_setup_list_l>(), bref, 1, 64, true));
      break;
    case types::mbs_qos_flow_to_release_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<qos_flow_list_with_cause_l>(), bref, 1, 64, true));
      break;
    case types::mbs_session_tnl_info5_gc:
      HANDLE_CODE(c.get<mbs_session_tnl_info5_gc_c>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_upd_request_transfer_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* multicast_session_upd_request_transfer_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {
      "MBS-SessionID", "MBS-ServiceArea", "MBS-QoSFlowsToBeSetupList", "QosFlowListWithCause", "MBS-SessionTNLInfo5GC"};
  return convert_enum_idx(names, 5, value, "multicast_session_upd_request_transfer_ies_o::value_c::types");
}
uint8_t multicast_session_upd_request_transfer_ies_o::value_c::types_opts::to_number() const
{
  if (value == mbs_session_tnl_info5_gc) {
    return 5;
  }
  invalid_enum_number(value, "multicast_session_upd_request_transfer_ies_o::value_c::types");
  return 0;
}

template struct asn1::protocol_ie_field_s<multicast_session_upd_request_transfer_ies_o>;

multicast_session_upd_request_transfer_ies_container::multicast_session_upd_request_transfer_ies_container() :
  mbs_session_id(299, crit_e::reject),
  mbs_service_area(298, crit_e::reject),
  mbs_qos_flows_to_be_setup_mod_list(297, crit_e::reject),
  mbs_qos_flow_to_release_list(351, crit_e::reject),
  mbs_session_tnl_info5_gc(352, crit_e::reject)
{
}
SRSASN_CODE multicast_session_upd_request_transfer_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 1;
  nof_ies += mbs_service_area_present ? 1 : 0;
  nof_ies += mbs_qos_flows_to_be_setup_mod_list_present ? 1 : 0;
  nof_ies += mbs_qos_flow_to_release_list_present ? 1 : 0;
  nof_ies += mbs_session_tnl_info5_gc_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mbs_session_id.pack(bref));
  if (mbs_service_area_present) {
    HANDLE_CODE(mbs_service_area.pack(bref));
  }
  if (mbs_qos_flows_to_be_setup_mod_list_present) {
    HANDLE_CODE(mbs_qos_flows_to_be_setup_mod_list.pack(bref));
  }
  if (mbs_qos_flow_to_release_list_present) {
    HANDLE_CODE(mbs_qos_flow_to_release_list.pack(bref));
  }
  if (mbs_session_tnl_info5_gc_present) {
    HANDLE_CODE(mbs_session_tnl_info5_gc.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_session_upd_request_transfer_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 1;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        mbs_session_id.id = id;
        HANDLE_CODE(mbs_session_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.value.unpack(bref));
        break;
      }
      case 298: {
        mbs_service_area_present = true;
        mbs_service_area.id      = id;
        HANDLE_CODE(mbs_service_area.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_service_area.value.unpack(bref));
        break;
      }
      case 297: {
        mbs_qos_flows_to_be_setup_mod_list_present = true;
        mbs_qos_flows_to_be_setup_mod_list.id      = id;
        HANDLE_CODE(mbs_qos_flows_to_be_setup_mod_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_qos_flows_to_be_setup_mod_list.value.unpack(bref));
        break;
      }
      case 351: {
        mbs_qos_flow_to_release_list_present = true;
        mbs_qos_flow_to_release_list.id      = id;
        HANDLE_CODE(mbs_qos_flow_to_release_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_qos_flow_to_release_list.value.unpack(bref));
        break;
      }
      case 352: {
        mbs_session_tnl_info5_gc_present = true;
        mbs_session_tnl_info5_gc.id      = id;
        HANDLE_CODE(mbs_session_tnl_info5_gc.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_tnl_info5_gc.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void multicast_session_upd_request_transfer_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mbs_session_id.to_json(j);
  if (mbs_service_area_present) {
    j.write_fieldname("");
    mbs_service_area.to_json(j);
  }
  if (mbs_qos_flows_to_be_setup_mod_list_present) {
    j.write_fieldname("");
    mbs_qos_flows_to_be_setup_mod_list.to_json(j);
  }
  if (mbs_qos_flow_to_release_list_present) {
    j.write_fieldname("");
    mbs_qos_flow_to_release_list.to_json(j);
  }
  if (mbs_session_tnl_info5_gc_present) {
    j.write_fieldname("");
    mbs_session_tnl_info5_gc.to_json(j);
  }
  j.end_obj();
}

// SuccessfulOutcome ::= SEQUENCE{{NGAP-ELEMENTARY-PROCEDURE}}
SRSASN_CODE successful_outcome_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(pack_integer(bref, proc_code, (uint16_t)0u, (uint16_t)255u, false, true));
  warn_assert(crit != ngap_elem_procs_o::get_crit(proc_code), __func__, __LINE__);
  HANDLE_CODE(crit.pack(bref));
  HANDLE_CODE(value.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE successful_outcome_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(unpack_integer(proc_code, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(crit.unpack(bref));
  value = ngap_elem_procs_o::get_successful_outcome(proc_code);
  HANDLE_CODE(value.unpack(bref));

  return SRSASN_SUCCESS;
}
void successful_outcome_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("procedureCode", proc_code);
  j.write_str("criticality", crit.to_string());
  j.write_fieldname("value");
  value.to_json(j);
  j.end_obj();
}
bool successful_outcome_s::load_info_obj(const uint16_t& proc_code_)
{
  if (not ngap_elem_procs_o::is_proc_code_valid(proc_code_)) {
    return false;
  }
  proc_code = proc_code_;
  crit      = ngap_elem_procs_o::get_crit(proc_code);
  value     = ngap_elem_procs_o::get_successful_outcome(proc_code);
  return value.type().value != ngap_elem_procs_o::successful_outcome_c::types_opts::nulltype;
}

// UnsuccessfulOutcome ::= SEQUENCE{{NGAP-ELEMENTARY-PROCEDURE}}
SRSASN_CODE unsuccessful_outcome_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(pack_integer(bref, proc_code, (uint16_t)0u, (uint16_t)255u, false, true));
  warn_assert(crit != ngap_elem_procs_o::get_crit(proc_code), __func__, __LINE__);
  HANDLE_CODE(crit.pack(bref));
  HANDLE_CODE(value.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE unsuccessful_outcome_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(unpack_integer(proc_code, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(crit.unpack(bref));
  value = ngap_elem_procs_o::get_unsuccessful_outcome(proc_code);
  HANDLE_CODE(value.unpack(bref));

  return SRSASN_SUCCESS;
}
void unsuccessful_outcome_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("procedureCode", proc_code);
  j.write_str("criticality", crit.to_string());
  j.write_fieldname("value");
  value.to_json(j);
  j.end_obj();
}
bool unsuccessful_outcome_s::load_info_obj(const uint16_t& proc_code_)
{
  if (not ngap_elem_procs_o::is_proc_code_valid(proc_code_)) {
    return false;
  }
  proc_code = proc_code_;
  crit      = ngap_elem_procs_o::get_crit(proc_code);
  value     = ngap_elem_procs_o::get_unsuccessful_outcome(proc_code);
  return value.type().value != ngap_elem_procs_o::unsuccessful_outcome_c::types_opts::nulltype;
}

// NGAP-PDU ::= CHOICE
void ngap_pdu_c::destroy_()
{
  switch (type_) {
    case types::init_msg:
      c.destroy<init_msg_s>();
      break;
    case types::successful_outcome:
      c.destroy<successful_outcome_s>();
      break;
    case types::unsuccessful_outcome:
      c.destroy<unsuccessful_outcome_s>();
      break;
    default:
      break;
  }
}
void ngap_pdu_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::init_msg:
      c.init<init_msg_s>();
      break;
    case types::successful_outcome:
      c.init<successful_outcome_s>();
      break;
    case types::unsuccessful_outcome:
      c.init<unsuccessful_outcome_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ngap_pdu_c");
  }
}
ngap_pdu_c::ngap_pdu_c(const ngap_pdu_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::init_msg:
      c.init(other.c.get<init_msg_s>());
      break;
    case types::successful_outcome:
      c.init(other.c.get<successful_outcome_s>());
      break;
    case types::unsuccessful_outcome:
      c.init(other.c.get<unsuccessful_outcome_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ngap_pdu_c");
  }
}
ngap_pdu_c& ngap_pdu_c::operator=(const ngap_pdu_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::init_msg:
      c.set(other.c.get<init_msg_s>());
      break;
    case types::successful_outcome:
      c.set(other.c.get<successful_outcome_s>());
      break;
    case types::unsuccessful_outcome:
      c.set(other.c.get<unsuccessful_outcome_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ngap_pdu_c");
  }

  return *this;
}
init_msg_s& ngap_pdu_c::set_init_msg()
{
  set(types::init_msg);
  return c.get<init_msg_s>();
}
successful_outcome_s& ngap_pdu_c::set_successful_outcome()
{
  set(types::successful_outcome);
  return c.get<successful_outcome_s>();
}
unsuccessful_outcome_s& ngap_pdu_c::set_unsuccessful_outcome()
{
  set(types::unsuccessful_outcome);
  return c.get<unsuccessful_outcome_s>();
}
void ngap_pdu_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::init_msg:
      j.write_fieldname("initiatingMessage");
      c.get<init_msg_s>().to_json(j);
      break;
    case types::successful_outcome:
      j.write_fieldname("successfulOutcome");
      c.get<successful_outcome_s>().to_json(j);
      break;
    case types::unsuccessful_outcome:
      j.write_fieldname("unsuccessfulOutcome");
      c.get<unsuccessful_outcome_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ngap_pdu_c");
  }
  j.end_obj();
}
SRSASN_CODE ngap_pdu_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::init_msg:
      HANDLE_CODE(c.get<init_msg_s>().pack(bref));
      break;
    case types::successful_outcome:
      HANDLE_CODE(c.get<successful_outcome_s>().pack(bref));
      break;
    case types::unsuccessful_outcome:
      HANDLE_CODE(c.get<unsuccessful_outcome_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ngap_pdu_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ngap_pdu_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::init_msg:
      HANDLE_CODE(c.get<init_msg_s>().unpack(bref));
      break;
    case types::successful_outcome:
      HANDLE_CODE(c.get<successful_outcome_s>().unpack(bref));
      break;
    case types::unsuccessful_outcome:
      HANDLE_CODE(c.get<unsuccessful_outcome_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ngap_pdu_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ngap_pdu_c::types_opts::to_string() const
{
  static const char* names[] = {"initiatingMessage", "successfulOutcome", "unsuccessfulOutcome"};
  return convert_enum_idx(names, 3, value, "ngap_pdu_c::types");
}

// NGAPIESupportInformationRequestItem ::= SEQUENCE
SRSASN_CODE ngap_ie_support_info_request_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, ngap_protocol_ie_id, (uint32_t)0u, (uint32_t)65535u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ngap_ie_support_info_request_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(ngap_protocol_ie_id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ngap_ie_support_info_request_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("ngap-ProtocolIE-Id", ngap_protocol_ie_id);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// NGAPIESupportInformationResponseItem ::= SEQUENCE
SRSASN_CODE ngap_ie_support_info_resp_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, ngap_protocol_ie_id, (uint32_t)0u, (uint32_t)65535u, false, true));
  HANDLE_CODE(ngap_protocol_ie_support_info.pack(bref));
  HANDLE_CODE(ngap_protocol_ie_presence_info.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ngap_ie_support_info_resp_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(ngap_protocol_ie_id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
  HANDLE_CODE(ngap_protocol_ie_support_info.unpack(bref));
  HANDLE_CODE(ngap_protocol_ie_presence_info.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ngap_ie_support_info_resp_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("ngap-ProtocolIE-Id", ngap_protocol_ie_id);
  j.write_str("ngap-ProtocolIESupportInfo", ngap_protocol_ie_support_info.to_string());
  j.write_str("ngap-ProtocolIEPresenceInfo", ngap_protocol_ie_presence_info.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* ngap_ie_support_info_resp_item_s::ngap_protocol_ie_support_info_opts::to_string() const
{
  static const char* names[] = {"supported", "not-supported"};
  return convert_enum_idx(names, 2, value, "ngap_ie_support_info_resp_item_s::ngap_protocol_ie_support_info_e_");
}

const char* ngap_ie_support_info_resp_item_s::ngap_protocol_ie_presence_info_opts::to_string() const
{
  static const char* names[] = {"present", "not-present"};
  return convert_enum_idx(names, 2, value, "ngap_ie_support_info_resp_item_s::ngap_protocol_ie_presence_info_e_");
}

// PDUSessionAggregateMaximumBitRate ::= SEQUENCE
SRSASN_CODE pdu_session_aggr_max_bit_rate_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pdu_session_aggr_max_bit_rate_dl, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  HANDLE_CODE(pack_integer(bref, pdu_session_aggr_max_bit_rate_ul, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_aggr_max_bit_rate_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(
      unpack_integer(pdu_session_aggr_max_bit_rate_dl, bref, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  HANDLE_CODE(
      unpack_integer(pdu_session_aggr_max_bit_rate_ul, bref, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_aggr_max_bit_rate_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pDUSessionAggregateMaximumBitRateDL", pdu_session_aggr_max_bit_rate_dl);
  j.write_int("pDUSessionAggregateMaximumBitRateUL", pdu_session_aggr_max_bit_rate_ul);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// ULForwarding ::= ENUMERATED
const char* ul_forwarding_opts::to_string() const
{
  static const char* names[] = {"ul-forwarding-proposed"};
  return convert_enum_idx(names, 1, value, "ul_forwarding_e");
}

// QosFlowInformationItem-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t qos_flow_info_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {163, 284, 354};
  return map_enum_number(names, 3, idx, "id");
}
bool qos_flow_info_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {163, 284, 354};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e qos_flow_info_item_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 163:
      return crit_e::ignore;
    case 284:
      return crit_e::ignore;
    case 354:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
qos_flow_info_item_ext_ies_o::ext_c qos_flow_info_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 163:
      ret.set(ext_c::types::ul_forwarding);
      break;
    case 284:
      ret.set(ext_c::types::source_tnla_ddr_info);
      break;
    case 354:
      ret.set(ext_c::types::source_node_tnla_ddr_info);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e qos_flow_info_item_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 163:
      return presence_e::optional;
    case 284:
      return presence_e::optional;
    case 354:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void qos_flow_info_item_ext_ies_o::ext_c::destroy_()
{
  switch (type_) {
    case types::source_tnla_ddr_info:
      c.destroy<bounded_bitstring<1, 160, true, true>>();
      break;
    case types::source_node_tnla_ddr_info:
      c.destroy<bounded_bitstring<1, 160, true, true>>();
      break;
    default:
      break;
  }
}
void qos_flow_info_item_ext_ies_o::ext_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::ul_forwarding:
      break;
    case types::source_tnla_ddr_info:
      c.init<bounded_bitstring<1, 160, true, true>>();
      break;
    case types::source_node_tnla_ddr_info:
      c.init<bounded_bitstring<1, 160, true, true>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "qos_flow_info_item_ext_ies_o::ext_c");
  }
}
qos_flow_info_item_ext_ies_o::ext_c::ext_c(const qos_flow_info_item_ext_ies_o::ext_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::ul_forwarding:
      c.init(other.c.get<ul_forwarding_e>());
      break;
    case types::source_tnla_ddr_info:
      c.init(other.c.get<bounded_bitstring<1, 160, true, true>>());
      break;
    case types::source_node_tnla_ddr_info:
      c.init(other.c.get<bounded_bitstring<1, 160, true, true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "qos_flow_info_item_ext_ies_o::ext_c");
  }
}
qos_flow_info_item_ext_ies_o::ext_c&
qos_flow_info_item_ext_ies_o::ext_c::operator=(const qos_flow_info_item_ext_ies_o::ext_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::ul_forwarding:
      c.set(other.c.get<ul_forwarding_e>());
      break;
    case types::source_tnla_ddr_info:
      c.set(other.c.get<bounded_bitstring<1, 160, true, true>>());
      break;
    case types::source_node_tnla_ddr_info:
      c.set(other.c.get<bounded_bitstring<1, 160, true, true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "qos_flow_info_item_ext_ies_o::ext_c");
  }

  return *this;
}
ul_forwarding_e& qos_flow_info_item_ext_ies_o::ext_c::ul_forwarding()
{
  assert_choice_type(types::ul_forwarding, type_, "Extension");
  return c.get<ul_forwarding_e>();
}
bounded_bitstring<1, 160, true, true>& qos_flow_info_item_ext_ies_o::ext_c::source_tnla_ddr_info()
{
  assert_choice_type(types::source_tnla_ddr_info, type_, "Extension");
  return c.get<bounded_bitstring<1, 160, true, true>>();
}
bounded_bitstring<1, 160, true, true>& qos_flow_info_item_ext_ies_o::ext_c::source_node_tnla_ddr_info()
{
  assert_choice_type(types::source_node_tnla_ddr_info, type_, "Extension");
  return c.get<bounded_bitstring<1, 160, true, true>>();
}
const ul_forwarding_e& qos_flow_info_item_ext_ies_o::ext_c::ul_forwarding() const
{
  assert_choice_type(types::ul_forwarding, type_, "Extension");
  return c.get<ul_forwarding_e>();
}
const bounded_bitstring<1, 160, true, true>& qos_flow_info_item_ext_ies_o::ext_c::source_tnla_ddr_info() const
{
  assert_choice_type(types::source_tnla_ddr_info, type_, "Extension");
  return c.get<bounded_bitstring<1, 160, true, true>>();
}
const bounded_bitstring<1, 160, true, true>& qos_flow_info_item_ext_ies_o::ext_c::source_node_tnla_ddr_info() const
{
  assert_choice_type(types::source_node_tnla_ddr_info, type_, "Extension");
  return c.get<bounded_bitstring<1, 160, true, true>>();
}
void qos_flow_info_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::ul_forwarding:
      j.write_str("ULForwarding", "ul-forwarding-proposed");
      break;
    case types::source_tnla_ddr_info:
      j.write_str("BIT STRING", c.get<bounded_bitstring<1, 160, true, true>>().to_string());
      break;
    case types::source_node_tnla_ddr_info:
      j.write_str("BIT STRING", c.get<bounded_bitstring<1, 160, true, true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "qos_flow_info_item_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE qos_flow_info_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ul_forwarding:
      HANDLE_CODE(c.get<ul_forwarding_e>().pack(bref));
      break;
    case types::source_tnla_ddr_info:
      HANDLE_CODE((c.get<bounded_bitstring<1, 160, true, true>>().pack(bref)));
      break;
    case types::source_node_tnla_ddr_info:
      HANDLE_CODE((c.get<bounded_bitstring<1, 160, true, true>>().pack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "qos_flow_info_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_flow_info_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ul_forwarding:
      HANDLE_CODE(c.get<ul_forwarding_e>().unpack(bref));
      break;
    case types::source_tnla_ddr_info:
      HANDLE_CODE((c.get<bounded_bitstring<1, 160, true, true>>().unpack(bref)));
      break;
    case types::source_node_tnla_ddr_info:
      HANDLE_CODE((c.get<bounded_bitstring<1, 160, true, true>>().unpack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "qos_flow_info_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* qos_flow_info_item_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"ULForwarding", "BIT STRING", "BIT STRING"};
  return convert_enum_idx(names, 3, value, "qos_flow_info_item_ext_ies_o::ext_c::types");
}

template struct asn1::protocol_ext_field_s<qos_flow_info_item_ext_ies_o>;

qos_flow_info_item_ext_ies_container::qos_flow_info_item_ext_ies_container() :
  ul_forwarding(163, crit_e::ignore),
  source_tnla_ddr_info(284, crit_e::ignore),
  source_node_tnla_ddr_info(354, crit_e::ignore)
{
}
SRSASN_CODE qos_flow_info_item_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += ul_forwarding_present ? 1 : 0;
  nof_ies += source_tnla_ddr_info_present ? 1 : 0;
  nof_ies += source_node_tnla_ddr_info_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (ul_forwarding_present) {
    HANDLE_CODE(ul_forwarding.pack(bref));
  }
  if (source_tnla_ddr_info_present) {
    HANDLE_CODE(source_tnla_ddr_info.pack(bref));
  }
  if (source_node_tnla_ddr_info_present) {
    HANDLE_CODE(source_node_tnla_ddr_info.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_flow_info_item_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 163: {
        ul_forwarding_present = true;
        ul_forwarding.id      = id;
        HANDLE_CODE(ul_forwarding.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ul_forwarding.ext.unpack(bref));
        break;
      }
      case 284: {
        source_tnla_ddr_info_present = true;
        source_tnla_ddr_info.id      = id;
        HANDLE_CODE(source_tnla_ddr_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(source_tnla_ddr_info.ext.unpack(bref));
        break;
      }
      case 354: {
        source_node_tnla_ddr_info_present = true;
        source_node_tnla_ddr_info.id      = id;
        HANDLE_CODE(source_node_tnla_ddr_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(source_node_tnla_ddr_info.ext.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void qos_flow_info_item_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (ul_forwarding_present) {
    j.write_fieldname("");
    ul_forwarding.to_json(j);
  }
  if (source_tnla_ddr_info_present) {
    j.write_fieldname("");
    source_tnla_ddr_info.to_json(j);
  }
  if (source_node_tnla_ddr_info_present) {
    j.write_fieldname("");
    source_node_tnla_ddr_info.to_json(j);
  }
  j.end_obj();
}

// QosFlowInformationItem ::= SEQUENCE
SRSASN_CODE qos_flow_info_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(dl_forwarding_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, qos_flow_id, (uint8_t)0u, (uint8_t)63u, true, true));
  if (dl_forwarding_present) {
    HANDLE_CODE(dl_forwarding.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_flow_info_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(dl_forwarding_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(qos_flow_id, bref, (uint8_t)0u, (uint8_t)63u, true, true));
  if (dl_forwarding_present) {
    HANDLE_CODE(dl_forwarding.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void qos_flow_info_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("qosFlowIdentifier", qos_flow_id);
  if (dl_forwarding_present) {
    j.write_str("dLForwarding", "dl-forwarding-proposed");
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceInformationItem ::= SEQUENCE
SRSASN_CODE pdu_session_res_info_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(drbs_to_qos_flows_map_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pdu_session_id, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(pack_dyn_seq_of(bref, qos_flow_info_list, 1, 64, true));
  if (drbs_to_qos_flows_map_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, drbs_to_qos_flows_map_list, 1, 32, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_info_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool drbs_to_qos_flows_map_list_present;
  HANDLE_CODE(bref.unpack(drbs_to_qos_flows_map_list_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pdu_session_id, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(unpack_dyn_seq_of(qos_flow_info_list, bref, 1, 64, true));
  if (drbs_to_qos_flows_map_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(drbs_to_qos_flows_map_list, bref, 1, 32, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_info_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pDUSessionID", pdu_session_id);
  j.start_array("qosFlowInformationList");
  for (const auto& e1 : qos_flow_info_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (drbs_to_qos_flows_map_list.size() > 0) {
    j.start_array("dRBsToQosFlowsMappingList");
    for (const auto& e1 : drbs_to_qos_flows_map_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// UPTransportLayerInformationPairItem ::= SEQUENCE
SRSASN_CODE up_transport_layer_info_pair_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(ul_ngu_up_tnl_info.pack(bref));
  HANDLE_CODE(dl_ngu_up_tnl_info.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE up_transport_layer_info_pair_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(ul_ngu_up_tnl_info.unpack(bref));
  HANDLE_CODE(dl_ngu_up_tnl_info.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void up_transport_layer_info_pair_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("uL-NGU-UP-TNLInformation");
  ul_ngu_up_tnl_info.to_json(j);
  j.write_fieldname("dL-NGU-UP-TNLInformation");
  dl_ngu_up_tnl_info.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// QosFlowModifyConfirmItem ::= SEQUENCE
SRSASN_CODE qos_flow_modify_confirm_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, qos_flow_id, (uint8_t)0u, (uint8_t)63u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_flow_modify_confirm_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(qos_flow_id, bref, (uint8_t)0u, (uint8_t)63u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void qos_flow_modify_confirm_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("qosFlowIdentifier", qos_flow_id);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceModifyConfirmTransfer-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t pdu_session_res_modify_confirm_transfer_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {195, 185};
  return map_enum_number(names, 2, idx, "id");
}
bool pdu_session_res_modify_confirm_transfer_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {195, 185};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e pdu_session_res_modify_confirm_transfer_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 195:
      return crit_e::ignore;
    case 185:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
pdu_session_res_modify_confirm_transfer_ext_ies_o::ext_c
pdu_session_res_modify_confirm_transfer_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 195:
      ret.set(ext_c::types::redundant_ul_ngu_up_tnl_info);
      break;
    case 185:
      ret.set(ext_c::types::add_redundant_ngu_up_tnl_info);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pdu_session_res_modify_confirm_transfer_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 195:
      return presence_e::optional;
    case 185:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void pdu_session_res_modify_confirm_transfer_ext_ies_o::ext_c::destroy_()
{
  switch (type_) {
    case types::redundant_ul_ngu_up_tnl_info:
      c.destroy<up_transport_layer_info_c>();
      break;
    case types::add_redundant_ngu_up_tnl_info:
      c.destroy<up_transport_layer_info_pair_list_l>();
      break;
    default:
      break;
  }
}
void pdu_session_res_modify_confirm_transfer_ext_ies_o::ext_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::redundant_ul_ngu_up_tnl_info:
      c.init<up_transport_layer_info_c>();
      break;
    case types::add_redundant_ngu_up_tnl_info:
      c.init<up_transport_layer_info_pair_list_l>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_confirm_transfer_ext_ies_o::ext_c");
  }
}
pdu_session_res_modify_confirm_transfer_ext_ies_o::ext_c::ext_c(
    const pdu_session_res_modify_confirm_transfer_ext_ies_o::ext_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::redundant_ul_ngu_up_tnl_info:
      c.init(other.c.get<up_transport_layer_info_c>());
      break;
    case types::add_redundant_ngu_up_tnl_info:
      c.init(other.c.get<up_transport_layer_info_pair_list_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_confirm_transfer_ext_ies_o::ext_c");
  }
}
pdu_session_res_modify_confirm_transfer_ext_ies_o::ext_c&
pdu_session_res_modify_confirm_transfer_ext_ies_o::ext_c::operator=(
    const pdu_session_res_modify_confirm_transfer_ext_ies_o::ext_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::redundant_ul_ngu_up_tnl_info:
      c.set(other.c.get<up_transport_layer_info_c>());
      break;
    case types::add_redundant_ngu_up_tnl_info:
      c.set(other.c.get<up_transport_layer_info_pair_list_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_confirm_transfer_ext_ies_o::ext_c");
  }

  return *this;
}
up_transport_layer_info_c& pdu_session_res_modify_confirm_transfer_ext_ies_o::ext_c::redundant_ul_ngu_up_tnl_info()
{
  assert_choice_type(types::redundant_ul_ngu_up_tnl_info, type_, "Extension");
  return c.get<up_transport_layer_info_c>();
}
up_transport_layer_info_pair_list_l&
pdu_session_res_modify_confirm_transfer_ext_ies_o::ext_c::add_redundant_ngu_up_tnl_info()
{
  assert_choice_type(types::add_redundant_ngu_up_tnl_info, type_, "Extension");
  return c.get<up_transport_layer_info_pair_list_l>();
}
const up_transport_layer_info_c&
pdu_session_res_modify_confirm_transfer_ext_ies_o::ext_c::redundant_ul_ngu_up_tnl_info() const
{
  assert_choice_type(types::redundant_ul_ngu_up_tnl_info, type_, "Extension");
  return c.get<up_transport_layer_info_c>();
}
const up_transport_layer_info_pair_list_l&
pdu_session_res_modify_confirm_transfer_ext_ies_o::ext_c::add_redundant_ngu_up_tnl_info() const
{
  assert_choice_type(types::add_redundant_ngu_up_tnl_info, type_, "Extension");
  return c.get<up_transport_layer_info_pair_list_l>();
}
void pdu_session_res_modify_confirm_transfer_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::redundant_ul_ngu_up_tnl_info:
      j.write_fieldname("UPTransportLayerInformation");
      c.get<up_transport_layer_info_c>().to_json(j);
      break;
    case types::add_redundant_ngu_up_tnl_info:
      j.start_array("UPTransportLayerInformationPairList");
      for (const auto& e1 : c.get<up_transport_layer_info_pair_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_confirm_transfer_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE pdu_session_res_modify_confirm_transfer_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::redundant_ul_ngu_up_tnl_info:
      HANDLE_CODE(c.get<up_transport_layer_info_c>().pack(bref));
      break;
    case types::add_redundant_ngu_up_tnl_info:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<up_transport_layer_info_pair_list_l>(), 1, 3, true));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_confirm_transfer_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_modify_confirm_transfer_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::redundant_ul_ngu_up_tnl_info:
      HANDLE_CODE(c.get<up_transport_layer_info_c>().unpack(bref));
      break;
    case types::add_redundant_ngu_up_tnl_info:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<up_transport_layer_info_pair_list_l>(), bref, 1, 3, true));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_confirm_transfer_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* pdu_session_res_modify_confirm_transfer_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"UPTransportLayerInformation", "UPTransportLayerInformationPairList"};
  return convert_enum_idx(names, 2, value, "pdu_session_res_modify_confirm_transfer_ext_ies_o::ext_c::types");
}

template struct asn1::protocol_ext_field_s<pdu_session_res_modify_confirm_transfer_ext_ies_o>;

pdu_session_res_modify_confirm_transfer_ext_ies_container::pdu_session_res_modify_confirm_transfer_ext_ies_container() :
  redundant_ul_ngu_up_tnl_info(195, crit_e::ignore), add_redundant_ngu_up_tnl_info(185, crit_e::ignore)
{
}
SRSASN_CODE pdu_session_res_modify_confirm_transfer_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += redundant_ul_ngu_up_tnl_info_present ? 1 : 0;
  nof_ies += add_redundant_ngu_up_tnl_info_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (redundant_ul_ngu_up_tnl_info_present) {
    HANDLE_CODE(redundant_ul_ngu_up_tnl_info.pack(bref));
  }
  if (add_redundant_ngu_up_tnl_info_present) {
    HANDLE_CODE(add_redundant_ngu_up_tnl_info.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_modify_confirm_transfer_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 195: {
        redundant_ul_ngu_up_tnl_info_present = true;
        redundant_ul_ngu_up_tnl_info.id      = id;
        HANDLE_CODE(redundant_ul_ngu_up_tnl_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(redundant_ul_ngu_up_tnl_info.ext.unpack(bref));
        break;
      }
      case 185: {
        add_redundant_ngu_up_tnl_info_present = true;
        add_redundant_ngu_up_tnl_info.id      = id;
        HANDLE_CODE(add_redundant_ngu_up_tnl_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(add_redundant_ngu_up_tnl_info.ext.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_modify_confirm_transfer_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (redundant_ul_ngu_up_tnl_info_present) {
    j.write_fieldname("");
    redundant_ul_ngu_up_tnl_info.to_json(j);
  }
  if (add_redundant_ngu_up_tnl_info_present) {
    j.write_fieldname("");
    add_redundant_ngu_up_tnl_info.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceModifyConfirmTransfer ::= SEQUENCE
SRSASN_CODE pdu_session_res_modify_confirm_transfer_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(add_ng_u_up_tnl_info.size() > 0, 1));
  HANDLE_CODE(bref.pack(qos_flow_failed_to_modify_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, qos_flow_modify_confirm_list, 1, 64, true));
  HANDLE_CODE(ul_ngu_up_tnl_info.pack(bref));
  if (add_ng_u_up_tnl_info.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, add_ng_u_up_tnl_info, 1, 3, true));
  }
  if (qos_flow_failed_to_modify_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, qos_flow_failed_to_modify_list, 1, 64, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_modify_confirm_transfer_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool add_ng_u_up_tnl_info_present;
  HANDLE_CODE(bref.unpack(add_ng_u_up_tnl_info_present, 1));
  bool qos_flow_failed_to_modify_list_present;
  HANDLE_CODE(bref.unpack(qos_flow_failed_to_modify_list_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(qos_flow_modify_confirm_list, bref, 1, 64, true));
  HANDLE_CODE(ul_ngu_up_tnl_info.unpack(bref));
  if (add_ng_u_up_tnl_info_present) {
    HANDLE_CODE(unpack_dyn_seq_of(add_ng_u_up_tnl_info, bref, 1, 3, true));
  }
  if (qos_flow_failed_to_modify_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(qos_flow_failed_to_modify_list, bref, 1, 64, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_modify_confirm_transfer_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("qosFlowModifyConfirmList");
  for (const auto& e1 : qos_flow_modify_confirm_list) {
    e1.to_json(j);
  }
  j.end_array();
  j.write_fieldname("uLNGU-UP-TNLInformation");
  ul_ngu_up_tnl_info.to_json(j);
  if (add_ng_u_up_tnl_info.size() > 0) {
    j.start_array("additionalNG-UUPTNLInformation");
    for (const auto& e1 : add_ng_u_up_tnl_info) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (qos_flow_failed_to_modify_list.size() > 0) {
    j.start_array("qosFlowFailedToModifyList");
    for (const auto& e1 : qos_flow_failed_to_modify_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// VolumeTimedReport-Item ::= SEQUENCE
SRSASN_CODE volume_timed_report_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(start_time_stamp.pack(bref));
  HANDLE_CODE(end_time_stamp.pack(bref));
  HANDLE_CODE(pack_integer(bref, usage_count_ul, (uint64_t)0u, (uint64_t)18446744073709551615u, false, true));
  HANDLE_CODE(pack_integer(bref, usage_count_dl, (uint64_t)0u, (uint64_t)18446744073709551615u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE volume_timed_report_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(start_time_stamp.unpack(bref));
  HANDLE_CODE(end_time_stamp.unpack(bref));
  HANDLE_CODE(unpack_integer(usage_count_ul, bref, (uint64_t)0u, (uint64_t)18446744073709551615u, false, true));
  HANDLE_CODE(unpack_integer(usage_count_dl, bref, (uint64_t)0u, (uint64_t)18446744073709551615u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void volume_timed_report_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("startTimeStamp", start_time_stamp.to_string());
  j.write_str("endTimeStamp", end_time_stamp.to_string());
  j.write_int("usageCountUL", usage_count_ul);
  j.write_int("usageCountDL", usage_count_dl);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// QoSFlowsUsageReport-Item ::= SEQUENCE
SRSASN_CODE qos_flows_usage_report_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, qos_flow_id, (uint8_t)0u, (uint8_t)63u, true, true));
  HANDLE_CODE(rat_type.pack(bref));
  HANDLE_CODE(pack_dyn_seq_of(bref, qos_flows_timed_report_list, 1, 2, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_flows_usage_report_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(qos_flow_id, bref, (uint8_t)0u, (uint8_t)63u, true, true));
  HANDLE_CODE(rat_type.unpack(bref));
  HANDLE_CODE(unpack_dyn_seq_of(qos_flows_timed_report_list, bref, 1, 2, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void qos_flows_usage_report_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("qosFlowIdentifier", qos_flow_id);
  j.write_str("rATType", rat_type.to_string());
  j.start_array("qoSFlowsTimedReportList");
  for (const auto& e1 : qos_flows_timed_report_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* qos_flows_usage_report_item_s::rat_type_opts::to_string() const
{
  static const char* names[] = {"nr", "eutra", "nr-unlicensed", "e-utra-unlicensed"};
  return convert_enum_idx(names, 4, value, "qos_flows_usage_report_item_s::rat_type_e_");
}

// PDUSessionUsageReport ::= SEQUENCE
SRSASN_CODE pdu_session_usage_report_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(rat_type.pack(bref));
  HANDLE_CODE(pack_dyn_seq_of(bref, pdu_session_timed_report_list, 1, 2, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_usage_report_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(rat_type.unpack(bref));
  HANDLE_CODE(unpack_dyn_seq_of(pdu_session_timed_report_list, bref, 1, 2, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_usage_report_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("rATType", rat_type.to_string());
  j.start_array("pDUSessionTimedReportList");
  for (const auto& e1 : pdu_session_timed_report_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* pdu_session_usage_report_s::rat_type_opts::to_string() const
{
  static const char* names[] = {"nr", "eutra", "nr-unlicensed", "e-utra-unlicensed"};
  return convert_enum_idx(names, 4, value, "pdu_session_usage_report_s::rat_type_e_");
}

// SecondaryRATUsageInformation ::= SEQUENCE
SRSASN_CODE secondary_rat_usage_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(pdu_session_usage_report_present, 1));
  HANDLE_CODE(bref.pack(qos_flows_usage_report_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  if (pdu_session_usage_report_present) {
    HANDLE_CODE(pdu_session_usage_report.pack(bref));
  }
  if (qos_flows_usage_report_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, qos_flows_usage_report_list, 1, 64, true));
  }
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE secondary_rat_usage_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(pdu_session_usage_report_present, 1));
  bool qos_flows_usage_report_list_present;
  HANDLE_CODE(bref.unpack(qos_flows_usage_report_list_present, 1));
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  if (pdu_session_usage_report_present) {
    HANDLE_CODE(pdu_session_usage_report.unpack(bref));
  }
  if (qos_flows_usage_report_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(qos_flows_usage_report_list, bref, 1, 64, true));
  }
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void secondary_rat_usage_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (pdu_session_usage_report_present) {
    j.write_fieldname("pDUSessionUsageReport");
    pdu_session_usage_report.to_json(j);
  }
  if (qos_flows_usage_report_list.size() > 0) {
    j.start_array("qosFlowsUsageReportList");
    for (const auto& e1 : qos_flows_usage_report_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceModifyIndicationTransfer-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t pdu_session_res_modify_ind_transfer_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {144, 156, 193, 184, 27};
  return map_enum_number(names, 5, idx, "id");
}
bool pdu_session_res_modify_ind_transfer_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {144, 156, 193, 184, 27};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e pdu_session_res_modify_ind_transfer_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 144:
      return crit_e::ignore;
    case 156:
      return crit_e::ignore;
    case 193:
      return crit_e::ignore;
    case 184:
      return crit_e::ignore;
    case 27:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
pdu_session_res_modify_ind_transfer_ext_ies_o::ext_c
pdu_session_res_modify_ind_transfer_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 144:
      ret.set(ext_c::types::secondary_rat_usage_info);
      break;
    case 156:
      ret.set(ext_c::types::security_result);
      break;
    case 193:
      ret.set(ext_c::types::redundant_dl_qos_flow_per_tnl_info);
      break;
    case 184:
      ret.set(ext_c::types::add_redundant_dl_qos_flow_per_tnl_info);
      break;
    case 27:
      ret.set(ext_c::types::global_ran_node_id);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pdu_session_res_modify_ind_transfer_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 144:
      return presence_e::optional;
    case 156:
      return presence_e::optional;
    case 193:
      return presence_e::optional;
    case 184:
      return presence_e::optional;
    case 27:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void pdu_session_res_modify_ind_transfer_ext_ies_o::ext_c::destroy_()
{
  switch (type_) {
    case types::secondary_rat_usage_info:
      c.destroy<secondary_rat_usage_info_s>();
      break;
    case types::security_result:
      c.destroy<security_result_s>();
      break;
    case types::redundant_dl_qos_flow_per_tnl_info:
      c.destroy<qos_flow_per_tnl_info_s>();
      break;
    case types::add_redundant_dl_qos_flow_per_tnl_info:
      c.destroy<qos_flow_per_tnl_info_list_l>();
      break;
    case types::global_ran_node_id:
      c.destroy<global_ran_node_id_c>();
      break;
    default:
      break;
  }
}
void pdu_session_res_modify_ind_transfer_ext_ies_o::ext_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::secondary_rat_usage_info:
      c.init<secondary_rat_usage_info_s>();
      break;
    case types::security_result:
      c.init<security_result_s>();
      break;
    case types::redundant_dl_qos_flow_per_tnl_info:
      c.init<qos_flow_per_tnl_info_s>();
      break;
    case types::add_redundant_dl_qos_flow_per_tnl_info:
      c.init<qos_flow_per_tnl_info_list_l>();
      break;
    case types::global_ran_node_id:
      c.init<global_ran_node_id_c>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_ind_transfer_ext_ies_o::ext_c");
  }
}
pdu_session_res_modify_ind_transfer_ext_ies_o::ext_c::ext_c(
    const pdu_session_res_modify_ind_transfer_ext_ies_o::ext_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::secondary_rat_usage_info:
      c.init(other.c.get<secondary_rat_usage_info_s>());
      break;
    case types::security_result:
      c.init(other.c.get<security_result_s>());
      break;
    case types::redundant_dl_qos_flow_per_tnl_info:
      c.init(other.c.get<qos_flow_per_tnl_info_s>());
      break;
    case types::add_redundant_dl_qos_flow_per_tnl_info:
      c.init(other.c.get<qos_flow_per_tnl_info_list_l>());
      break;
    case types::global_ran_node_id:
      c.init(other.c.get<global_ran_node_id_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_ind_transfer_ext_ies_o::ext_c");
  }
}
pdu_session_res_modify_ind_transfer_ext_ies_o::ext_c& pdu_session_res_modify_ind_transfer_ext_ies_o::ext_c::operator=(
    const pdu_session_res_modify_ind_transfer_ext_ies_o::ext_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::secondary_rat_usage_info:
      c.set(other.c.get<secondary_rat_usage_info_s>());
      break;
    case types::security_result:
      c.set(other.c.get<security_result_s>());
      break;
    case types::redundant_dl_qos_flow_per_tnl_info:
      c.set(other.c.get<qos_flow_per_tnl_info_s>());
      break;
    case types::add_redundant_dl_qos_flow_per_tnl_info:
      c.set(other.c.get<qos_flow_per_tnl_info_list_l>());
      break;
    case types::global_ran_node_id:
      c.set(other.c.get<global_ran_node_id_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_ind_transfer_ext_ies_o::ext_c");
  }

  return *this;
}
secondary_rat_usage_info_s& pdu_session_res_modify_ind_transfer_ext_ies_o::ext_c::secondary_rat_usage_info()
{
  assert_choice_type(types::secondary_rat_usage_info, type_, "Extension");
  return c.get<secondary_rat_usage_info_s>();
}
security_result_s& pdu_session_res_modify_ind_transfer_ext_ies_o::ext_c::security_result()
{
  assert_choice_type(types::security_result, type_, "Extension");
  return c.get<security_result_s>();
}
qos_flow_per_tnl_info_s& pdu_session_res_modify_ind_transfer_ext_ies_o::ext_c::redundant_dl_qos_flow_per_tnl_info()
{
  assert_choice_type(types::redundant_dl_qos_flow_per_tnl_info, type_, "Extension");
  return c.get<qos_flow_per_tnl_info_s>();
}
qos_flow_per_tnl_info_list_l&
pdu_session_res_modify_ind_transfer_ext_ies_o::ext_c::add_redundant_dl_qos_flow_per_tnl_info()
{
  assert_choice_type(types::add_redundant_dl_qos_flow_per_tnl_info, type_, "Extension");
  return c.get<qos_flow_per_tnl_info_list_l>();
}
global_ran_node_id_c& pdu_session_res_modify_ind_transfer_ext_ies_o::ext_c::global_ran_node_id()
{
  assert_choice_type(types::global_ran_node_id, type_, "Extension");
  return c.get<global_ran_node_id_c>();
}
const secondary_rat_usage_info_s& pdu_session_res_modify_ind_transfer_ext_ies_o::ext_c::secondary_rat_usage_info() const
{
  assert_choice_type(types::secondary_rat_usage_info, type_, "Extension");
  return c.get<secondary_rat_usage_info_s>();
}
const security_result_s& pdu_session_res_modify_ind_transfer_ext_ies_o::ext_c::security_result() const
{
  assert_choice_type(types::security_result, type_, "Extension");
  return c.get<security_result_s>();
}
const qos_flow_per_tnl_info_s&
pdu_session_res_modify_ind_transfer_ext_ies_o::ext_c::redundant_dl_qos_flow_per_tnl_info() const
{
  assert_choice_type(types::redundant_dl_qos_flow_per_tnl_info, type_, "Extension");
  return c.get<qos_flow_per_tnl_info_s>();
}
const qos_flow_per_tnl_info_list_l&
pdu_session_res_modify_ind_transfer_ext_ies_o::ext_c::add_redundant_dl_qos_flow_per_tnl_info() const
{
  assert_choice_type(types::add_redundant_dl_qos_flow_per_tnl_info, type_, "Extension");
  return c.get<qos_flow_per_tnl_info_list_l>();
}
const global_ran_node_id_c& pdu_session_res_modify_ind_transfer_ext_ies_o::ext_c::global_ran_node_id() const
{
  assert_choice_type(types::global_ran_node_id, type_, "Extension");
  return c.get<global_ran_node_id_c>();
}
void pdu_session_res_modify_ind_transfer_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::secondary_rat_usage_info:
      j.write_fieldname("SecondaryRATUsageInformation");
      c.get<secondary_rat_usage_info_s>().to_json(j);
      break;
    case types::security_result:
      j.write_fieldname("SecurityResult");
      c.get<security_result_s>().to_json(j);
      break;
    case types::redundant_dl_qos_flow_per_tnl_info:
      j.write_fieldname("QosFlowPerTNLInformation");
      c.get<qos_flow_per_tnl_info_s>().to_json(j);
      break;
    case types::add_redundant_dl_qos_flow_per_tnl_info:
      j.start_array("QosFlowPerTNLInformationList");
      for (const auto& e1 : c.get<qos_flow_per_tnl_info_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::global_ran_node_id:
      j.write_fieldname("GlobalRANNodeID");
      c.get<global_ran_node_id_c>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_ind_transfer_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE pdu_session_res_modify_ind_transfer_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::secondary_rat_usage_info:
      HANDLE_CODE(c.get<secondary_rat_usage_info_s>().pack(bref));
      break;
    case types::security_result:
      HANDLE_CODE(c.get<security_result_s>().pack(bref));
      break;
    case types::redundant_dl_qos_flow_per_tnl_info:
      HANDLE_CODE(c.get<qos_flow_per_tnl_info_s>().pack(bref));
      break;
    case types::add_redundant_dl_qos_flow_per_tnl_info:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<qos_flow_per_tnl_info_list_l>(), 1, 3, true));
      break;
    case types::global_ran_node_id:
      HANDLE_CODE(c.get<global_ran_node_id_c>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_ind_transfer_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_modify_ind_transfer_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::secondary_rat_usage_info:
      HANDLE_CODE(c.get<secondary_rat_usage_info_s>().unpack(bref));
      break;
    case types::security_result:
      HANDLE_CODE(c.get<security_result_s>().unpack(bref));
      break;
    case types::redundant_dl_qos_flow_per_tnl_info:
      HANDLE_CODE(c.get<qos_flow_per_tnl_info_s>().unpack(bref));
      break;
    case types::add_redundant_dl_qos_flow_per_tnl_info:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<qos_flow_per_tnl_info_list_l>(), bref, 1, 3, true));
      break;
    case types::global_ran_node_id:
      HANDLE_CODE(c.get<global_ran_node_id_c>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_ind_transfer_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* pdu_session_res_modify_ind_transfer_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"SecondaryRATUsageInformation",
                                "SecurityResult",
                                "QosFlowPerTNLInformation",
                                "QosFlowPerTNLInformationList",
                                "GlobalRANNodeID"};
  return convert_enum_idx(names, 5, value, "pdu_session_res_modify_ind_transfer_ext_ies_o::ext_c::types");
}

template struct asn1::protocol_ext_field_s<pdu_session_res_modify_ind_transfer_ext_ies_o>;

pdu_session_res_modify_ind_transfer_ext_ies_container::pdu_session_res_modify_ind_transfer_ext_ies_container() :
  secondary_rat_usage_info(144, crit_e::ignore),
  security_result(156, crit_e::ignore),
  redundant_dl_qos_flow_per_tnl_info(193, crit_e::ignore),
  add_redundant_dl_qos_flow_per_tnl_info(184, crit_e::ignore),
  global_ran_node_id(27, crit_e::ignore)
{
}
SRSASN_CODE pdu_session_res_modify_ind_transfer_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += secondary_rat_usage_info_present ? 1 : 0;
  nof_ies += security_result_present ? 1 : 0;
  nof_ies += redundant_dl_qos_flow_per_tnl_info_present ? 1 : 0;
  nof_ies += add_redundant_dl_qos_flow_per_tnl_info_present ? 1 : 0;
  nof_ies += global_ran_node_id_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (secondary_rat_usage_info_present) {
    HANDLE_CODE(secondary_rat_usage_info.pack(bref));
  }
  if (security_result_present) {
    HANDLE_CODE(security_result.pack(bref));
  }
  if (redundant_dl_qos_flow_per_tnl_info_present) {
    HANDLE_CODE(redundant_dl_qos_flow_per_tnl_info.pack(bref));
  }
  if (add_redundant_dl_qos_flow_per_tnl_info_present) {
    HANDLE_CODE(add_redundant_dl_qos_flow_per_tnl_info.pack(bref));
  }
  if (global_ran_node_id_present) {
    HANDLE_CODE(global_ran_node_id.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_modify_ind_transfer_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 144: {
        secondary_rat_usage_info_present = true;
        secondary_rat_usage_info.id      = id;
        HANDLE_CODE(secondary_rat_usage_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(secondary_rat_usage_info.ext.unpack(bref));
        break;
      }
      case 156: {
        security_result_present = true;
        security_result.id      = id;
        HANDLE_CODE(security_result.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(security_result.ext.unpack(bref));
        break;
      }
      case 193: {
        redundant_dl_qos_flow_per_tnl_info_present = true;
        redundant_dl_qos_flow_per_tnl_info.id      = id;
        HANDLE_CODE(redundant_dl_qos_flow_per_tnl_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(redundant_dl_qos_flow_per_tnl_info.ext.unpack(bref));
        break;
      }
      case 184: {
        add_redundant_dl_qos_flow_per_tnl_info_present = true;
        add_redundant_dl_qos_flow_per_tnl_info.id      = id;
        HANDLE_CODE(add_redundant_dl_qos_flow_per_tnl_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(add_redundant_dl_qos_flow_per_tnl_info.ext.unpack(bref));
        break;
      }
      case 27: {
        global_ran_node_id_present = true;
        global_ran_node_id.id      = id;
        HANDLE_CODE(global_ran_node_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(global_ran_node_id.ext.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_modify_ind_transfer_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (secondary_rat_usage_info_present) {
    j.write_fieldname("");
    secondary_rat_usage_info.to_json(j);
  }
  if (security_result_present) {
    j.write_fieldname("");
    security_result.to_json(j);
  }
  if (redundant_dl_qos_flow_per_tnl_info_present) {
    j.write_fieldname("");
    redundant_dl_qos_flow_per_tnl_info.to_json(j);
  }
  if (add_redundant_dl_qos_flow_per_tnl_info_present) {
    j.write_fieldname("");
    add_redundant_dl_qos_flow_per_tnl_info.to_json(j);
  }
  if (global_ran_node_id_present) {
    j.write_fieldname("");
    global_ran_node_id.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceModifyIndicationTransfer ::= SEQUENCE
SRSASN_CODE pdu_session_res_modify_ind_transfer_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(add_dl_qos_flow_per_tnl_info.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(dl_qos_flow_per_tnl_info.pack(bref));
  if (add_dl_qos_flow_per_tnl_info.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, add_dl_qos_flow_per_tnl_info, 1, 3, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_modify_ind_transfer_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool add_dl_qos_flow_per_tnl_info_present;
  HANDLE_CODE(bref.unpack(add_dl_qos_flow_per_tnl_info_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(dl_qos_flow_per_tnl_info.unpack(bref));
  if (add_dl_qos_flow_per_tnl_info_present) {
    HANDLE_CODE(unpack_dyn_seq_of(add_dl_qos_flow_per_tnl_info, bref, 1, 3, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_modify_ind_transfer_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("dLQosFlowPerTNLInformation");
  dl_qos_flow_per_tnl_info.to_json(j);
  if (add_dl_qos_flow_per_tnl_info.size() > 0) {
    j.start_array("additionalDLQosFlowPerTNLInformation");
    for (const auto& e1 : add_dl_qos_flow_per_tnl_info) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceModifyIndicationUnsuccessfulTransfer ::= SEQUENCE
SRSASN_CODE pdu_session_res_modify_ind_unsuccessful_transfer_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(cause.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_modify_ind_unsuccessful_transfer_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(cause.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_modify_ind_unsuccessful_transfer_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("cause");
  cause.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TSCAssistanceInformation-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t tsc_assist_info_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {327};
  return map_enum_number(names, 1, idx, "id");
}
bool tsc_assist_info_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 327 == id;
}
crit_e tsc_assist_info_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 327) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
tsc_assist_info_ext_ies_o::ext_c tsc_assist_info_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 327) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e tsc_assist_info_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 327) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void tsc_assist_info_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("INTEGER (0..1920000,...)", c);
  j.end_obj();
}
SRSASN_CODE tsc_assist_info_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(pack_integer(bref, c, (uint32_t)0u, (uint32_t)1920000u, true, true));
  return SRSASN_SUCCESS;
}
SRSASN_CODE tsc_assist_info_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(unpack_integer(c, bref, (uint32_t)0u, (uint32_t)1920000u, true, true));
  return SRSASN_SUCCESS;
}

const char* tsc_assist_info_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..1920000,...)"};
  return convert_enum_idx(names, 1, value, "tsc_assist_info_ext_ies_o::ext_c::types");
}
uint8_t tsc_assist_info_ext_ies_o::ext_c::types_opts::to_number() const
{
  static const uint8_t numbers[] = {0};
  return map_enum_number(numbers, 1, value, "tsc_assist_info_ext_ies_o::ext_c::types");
}

// TSCAssistanceInformation ::= SEQUENCE
SRSASN_CODE tsc_assist_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(burst_arrival_time.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(pack_integer(bref, periodicity, (uint32_t)0u, (uint32_t)640000u, true, true));
  if (burst_arrival_time.size() > 0) {
    HANDLE_CODE(burst_arrival_time.pack(bref));
  }
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE tsc_assist_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool burst_arrival_time_present;
  HANDLE_CODE(bref.unpack(burst_arrival_time_present, 1));
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(periodicity, bref, (uint32_t)0u, (uint32_t)640000u, true, true));
  if (burst_arrival_time_present) {
    HANDLE_CODE(burst_arrival_time.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void tsc_assist_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("periodicity", periodicity);
  if (burst_arrival_time.size() > 0) {
    j.write_str("burstArrivalTime", burst_arrival_time.to_string());
  }
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// RedundantQosFlowIndicator ::= ENUMERATED
const char* redundant_qos_flow_ind_opts::to_string() const
{
  static const char* names[] = {"true", "false"};
  return convert_enum_idx(names, 2, value, "redundant_qos_flow_ind_e");
}

// TSCTrafficCharacteristics ::= SEQUENCE
SRSASN_CODE tsc_traffic_characteristics_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(tsc_assist_info_dl_present, 1));
  HANDLE_CODE(bref.pack(tsc_assist_info_ul_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (tsc_assist_info_dl_present) {
    HANDLE_CODE(tsc_assist_info_dl.pack(bref));
  }
  if (tsc_assist_info_ul_present) {
    HANDLE_CODE(tsc_assist_info_ul.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE tsc_traffic_characteristics_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(tsc_assist_info_dl_present, 1));
  HANDLE_CODE(bref.unpack(tsc_assist_info_ul_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (tsc_assist_info_dl_present) {
    HANDLE_CODE(tsc_assist_info_dl.unpack(bref));
  }
  if (tsc_assist_info_ul_present) {
    HANDLE_CODE(tsc_assist_info_ul.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void tsc_traffic_characteristics_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (tsc_assist_info_dl_present) {
    j.write_fieldname("tSCAssistanceInformationDL");
    tsc_assist_info_dl.to_json(j);
  }
  if (tsc_assist_info_ul_present) {
    j.write_fieldname("tSCAssistanceInformationUL");
    tsc_assist_info_ul.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MaximumIntegrityProtectedDataRate ::= ENUMERATED
const char* max_integrity_protected_data_rate_opts::to_string() const
{
  static const char* names[] = {"bitrate64kbs", "maximum-UE-rate"};
  return convert_enum_idx(names, 2, value, "max_integrity_protected_data_rate_e");
}
uint8_t max_integrity_protected_data_rate_opts::to_number() const
{
  static const uint8_t numbers[] = {64};
  return map_enum_number(numbers, 1, value, "max_integrity_protected_data_rate_e");
}

// QosFlowAddOrModifyRequestItem-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t qos_flow_add_or_modify_request_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {196, 194};
  return map_enum_number(names, 2, idx, "id");
}
bool qos_flow_add_or_modify_request_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {196, 194};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e qos_flow_add_or_modify_request_item_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 196:
      return crit_e::ignore;
    case 194:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
qos_flow_add_or_modify_request_item_ext_ies_o::ext_c
qos_flow_add_or_modify_request_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 196:
      ret.set(ext_c::types::tsc_traffic_characteristics);
      break;
    case 194:
      ret.set(ext_c::types::redundant_qos_flow_ind);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e qos_flow_add_or_modify_request_item_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 196:
      return presence_e::optional;
    case 194:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void qos_flow_add_or_modify_request_item_ext_ies_o::ext_c::destroy_()
{
  switch (type_) {
    case types::tsc_traffic_characteristics:
      c.destroy<tsc_traffic_characteristics_s>();
      break;
    default:
      break;
  }
}
void qos_flow_add_or_modify_request_item_ext_ies_o::ext_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::tsc_traffic_characteristics:
      c.init<tsc_traffic_characteristics_s>();
      break;
    case types::redundant_qos_flow_ind:
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "qos_flow_add_or_modify_request_item_ext_ies_o::ext_c");
  }
}
qos_flow_add_or_modify_request_item_ext_ies_o::ext_c::ext_c(
    const qos_flow_add_or_modify_request_item_ext_ies_o::ext_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::tsc_traffic_characteristics:
      c.init(other.c.get<tsc_traffic_characteristics_s>());
      break;
    case types::redundant_qos_flow_ind:
      c.init(other.c.get<redundant_qos_flow_ind_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "qos_flow_add_or_modify_request_item_ext_ies_o::ext_c");
  }
}
qos_flow_add_or_modify_request_item_ext_ies_o::ext_c& qos_flow_add_or_modify_request_item_ext_ies_o::ext_c::operator=(
    const qos_flow_add_or_modify_request_item_ext_ies_o::ext_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::tsc_traffic_characteristics:
      c.set(other.c.get<tsc_traffic_characteristics_s>());
      break;
    case types::redundant_qos_flow_ind:
      c.set(other.c.get<redundant_qos_flow_ind_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "qos_flow_add_or_modify_request_item_ext_ies_o::ext_c");
  }

  return *this;
}
tsc_traffic_characteristics_s& qos_flow_add_or_modify_request_item_ext_ies_o::ext_c::tsc_traffic_characteristics()
{
  assert_choice_type(types::tsc_traffic_characteristics, type_, "Extension");
  return c.get<tsc_traffic_characteristics_s>();
}
redundant_qos_flow_ind_e& qos_flow_add_or_modify_request_item_ext_ies_o::ext_c::redundant_qos_flow_ind()
{
  assert_choice_type(types::redundant_qos_flow_ind, type_, "Extension");
  return c.get<redundant_qos_flow_ind_e>();
}
const tsc_traffic_characteristics_s&
qos_flow_add_or_modify_request_item_ext_ies_o::ext_c::tsc_traffic_characteristics() const
{
  assert_choice_type(types::tsc_traffic_characteristics, type_, "Extension");
  return c.get<tsc_traffic_characteristics_s>();
}
const redundant_qos_flow_ind_e& qos_flow_add_or_modify_request_item_ext_ies_o::ext_c::redundant_qos_flow_ind() const
{
  assert_choice_type(types::redundant_qos_flow_ind, type_, "Extension");
  return c.get<redundant_qos_flow_ind_e>();
}
void qos_flow_add_or_modify_request_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::tsc_traffic_characteristics:
      j.write_fieldname("TSCTrafficCharacteristics");
      c.get<tsc_traffic_characteristics_s>().to_json(j);
      break;
    case types::redundant_qos_flow_ind:
      j.write_str("RedundantQosFlowIndicator", c.get<redundant_qos_flow_ind_e>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "qos_flow_add_or_modify_request_item_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE qos_flow_add_or_modify_request_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::tsc_traffic_characteristics:
      HANDLE_CODE(c.get<tsc_traffic_characteristics_s>().pack(bref));
      break;
    case types::redundant_qos_flow_ind:
      HANDLE_CODE(c.get<redundant_qos_flow_ind_e>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "qos_flow_add_or_modify_request_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_flow_add_or_modify_request_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::tsc_traffic_characteristics:
      HANDLE_CODE(c.get<tsc_traffic_characteristics_s>().unpack(bref));
      break;
    case types::redundant_qos_flow_ind:
      HANDLE_CODE(c.get<redundant_qos_flow_ind_e>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "qos_flow_add_or_modify_request_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* qos_flow_add_or_modify_request_item_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"TSCTrafficCharacteristics", "RedundantQosFlowIndicator"};
  return convert_enum_idx(names, 2, value, "qos_flow_add_or_modify_request_item_ext_ies_o::ext_c::types");
}

// UL-NGU-UP-TNLModifyItem-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t ul_ngu_up_tnl_modify_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {195, 192};
  return map_enum_number(names, 2, idx, "id");
}
bool ul_ngu_up_tnl_modify_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {195, 192};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ul_ngu_up_tnl_modify_item_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 195:
      return crit_e::ignore;
    case 192:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ul_ngu_up_tnl_modify_item_ext_ies_o::ext_c ul_ngu_up_tnl_modify_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 195:
      ret.set(ext_c::types::redundant_ul_ngu_up_tnl_info);
      break;
    case 192:
      ret.set(ext_c::types::redundant_dl_ngu_up_tnl_info);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ul_ngu_up_tnl_modify_item_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 195:
      return presence_e::optional;
    case 192:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void ul_ngu_up_tnl_modify_item_ext_ies_o::ext_c::destroy_()
{
  switch (type_) {
    case types::redundant_ul_ngu_up_tnl_info:
      c.destroy<up_transport_layer_info_c>();
      break;
    case types::redundant_dl_ngu_up_tnl_info:
      c.destroy<up_transport_layer_info_c>();
      break;
    default:
      break;
  }
}
void ul_ngu_up_tnl_modify_item_ext_ies_o::ext_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::redundant_ul_ngu_up_tnl_info:
      c.init<up_transport_layer_info_c>();
      break;
    case types::redundant_dl_ngu_up_tnl_info:
      c.init<up_transport_layer_info_c>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ul_ngu_up_tnl_modify_item_ext_ies_o::ext_c");
  }
}
ul_ngu_up_tnl_modify_item_ext_ies_o::ext_c::ext_c(const ul_ngu_up_tnl_modify_item_ext_ies_o::ext_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::redundant_ul_ngu_up_tnl_info:
      c.init(other.c.get<up_transport_layer_info_c>());
      break;
    case types::redundant_dl_ngu_up_tnl_info:
      c.init(other.c.get<up_transport_layer_info_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ul_ngu_up_tnl_modify_item_ext_ies_o::ext_c");
  }
}
ul_ngu_up_tnl_modify_item_ext_ies_o::ext_c&
ul_ngu_up_tnl_modify_item_ext_ies_o::ext_c::operator=(const ul_ngu_up_tnl_modify_item_ext_ies_o::ext_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::redundant_ul_ngu_up_tnl_info:
      c.set(other.c.get<up_transport_layer_info_c>());
      break;
    case types::redundant_dl_ngu_up_tnl_info:
      c.set(other.c.get<up_transport_layer_info_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ul_ngu_up_tnl_modify_item_ext_ies_o::ext_c");
  }

  return *this;
}
up_transport_layer_info_c& ul_ngu_up_tnl_modify_item_ext_ies_o::ext_c::redundant_ul_ngu_up_tnl_info()
{
  assert_choice_type(types::redundant_ul_ngu_up_tnl_info, type_, "Extension");
  return c.get<up_transport_layer_info_c>();
}
up_transport_layer_info_c& ul_ngu_up_tnl_modify_item_ext_ies_o::ext_c::redundant_dl_ngu_up_tnl_info()
{
  assert_choice_type(types::redundant_dl_ngu_up_tnl_info, type_, "Extension");
  return c.get<up_transport_layer_info_c>();
}
const up_transport_layer_info_c& ul_ngu_up_tnl_modify_item_ext_ies_o::ext_c::redundant_ul_ngu_up_tnl_info() const
{
  assert_choice_type(types::redundant_ul_ngu_up_tnl_info, type_, "Extension");
  return c.get<up_transport_layer_info_c>();
}
const up_transport_layer_info_c& ul_ngu_up_tnl_modify_item_ext_ies_o::ext_c::redundant_dl_ngu_up_tnl_info() const
{
  assert_choice_type(types::redundant_dl_ngu_up_tnl_info, type_, "Extension");
  return c.get<up_transport_layer_info_c>();
}
void ul_ngu_up_tnl_modify_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::redundant_ul_ngu_up_tnl_info:
      j.write_fieldname("UPTransportLayerInformation");
      c.get<up_transport_layer_info_c>().to_json(j);
      break;
    case types::redundant_dl_ngu_up_tnl_info:
      j.write_fieldname("UPTransportLayerInformation");
      c.get<up_transport_layer_info_c>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ul_ngu_up_tnl_modify_item_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE ul_ngu_up_tnl_modify_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::redundant_ul_ngu_up_tnl_info:
      HANDLE_CODE(c.get<up_transport_layer_info_c>().pack(bref));
      break;
    case types::redundant_dl_ngu_up_tnl_info:
      HANDLE_CODE(c.get<up_transport_layer_info_c>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ul_ngu_up_tnl_modify_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ul_ngu_up_tnl_modify_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::redundant_ul_ngu_up_tnl_info:
      HANDLE_CODE(c.get<up_transport_layer_info_c>().unpack(bref));
      break;
    case types::redundant_dl_ngu_up_tnl_info:
      HANDLE_CODE(c.get<up_transport_layer_info_c>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ul_ngu_up_tnl_modify_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ul_ngu_up_tnl_modify_item_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"UPTransportLayerInformation", "UPTransportLayerInformation"};
  return convert_enum_idx(names, 2, value, "ul_ngu_up_tnl_modify_item_ext_ies_o::ext_c::types");
}

// ConfidentialityProtectionIndication ::= ENUMERATED
const char* confidentiality_protection_ind_opts::to_string() const
{
  static const char* names[] = {"required", "preferred", "not-needed"};
  return convert_enum_idx(names, 3, value, "confidentiality_protection_ind_e");
}

// IntegrityProtectionIndication ::= ENUMERATED
const char* integrity_protection_ind_opts::to_string() const
{
  static const char* names[] = {"required", "preferred", "not-needed"};
  return convert_enum_idx(names, 3, value, "integrity_protection_ind_e");
}

template struct asn1::protocol_ext_field_s<qos_flow_add_or_modify_request_item_ext_ies_o>;

qos_flow_add_or_modify_request_item_ext_ies_container::qos_flow_add_or_modify_request_item_ext_ies_container() :
  tsc_traffic_characteristics(196, crit_e::ignore), redundant_qos_flow_ind(194, crit_e::ignore)
{
}
SRSASN_CODE qos_flow_add_or_modify_request_item_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += tsc_traffic_characteristics_present ? 1 : 0;
  nof_ies += redundant_qos_flow_ind_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (tsc_traffic_characteristics_present) {
    HANDLE_CODE(tsc_traffic_characteristics.pack(bref));
  }
  if (redundant_qos_flow_ind_present) {
    HANDLE_CODE(redundant_qos_flow_ind.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_flow_add_or_modify_request_item_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 196: {
        tsc_traffic_characteristics_present = true;
        tsc_traffic_characteristics.id      = id;
        HANDLE_CODE(tsc_traffic_characteristics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(tsc_traffic_characteristics.ext.unpack(bref));
        break;
      }
      case 194: {
        redundant_qos_flow_ind_present = true;
        redundant_qos_flow_ind.id      = id;
        HANDLE_CODE(redundant_qos_flow_ind.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(redundant_qos_flow_ind.ext.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void qos_flow_add_or_modify_request_item_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (tsc_traffic_characteristics_present) {
    j.write_fieldname("");
    tsc_traffic_characteristics.to_json(j);
  }
  if (redundant_qos_flow_ind_present) {
    j.write_fieldname("");
    redundant_qos_flow_ind.to_json(j);
  }
  j.end_obj();
}

// QosFlowAddOrModifyRequestItem ::= SEQUENCE
SRSASN_CODE qos_flow_add_or_modify_request_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(qos_flow_level_qos_params_present, 1));
  HANDLE_CODE(bref.pack(erab_id_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, qos_flow_id, (uint8_t)0u, (uint8_t)63u, true, true));
  if (qos_flow_level_qos_params_present) {
    HANDLE_CODE(qos_flow_level_qos_params.pack(bref));
  }
  if (erab_id_present) {
    HANDLE_CODE(pack_integer(bref, erab_id, (uint8_t)0u, (uint8_t)15u, true, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_flow_add_or_modify_request_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(qos_flow_level_qos_params_present, 1));
  HANDLE_CODE(bref.unpack(erab_id_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(qos_flow_id, bref, (uint8_t)0u, (uint8_t)63u, true, true));
  if (qos_flow_level_qos_params_present) {
    HANDLE_CODE(qos_flow_level_qos_params.unpack(bref));
  }
  if (erab_id_present) {
    HANDLE_CODE(unpack_integer(erab_id, bref, (uint8_t)0u, (uint8_t)15u, true, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void qos_flow_add_or_modify_request_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("qosFlowIdentifier", qos_flow_id);
  if (qos_flow_level_qos_params_present) {
    j.write_fieldname("qosFlowLevelQosParameters");
    qos_flow_level_qos_params.to_json(j);
  }
  if (erab_id_present) {
    j.write_int("e-RAB-ID", erab_id);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SecurityIndication-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t security_ind_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {151};
  return map_enum_number(names, 1, idx, "id");
}
bool security_ind_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 151 == id;
}
crit_e security_ind_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 151) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
security_ind_ext_ies_o::ext_c security_ind_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 151) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e security_ind_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 151) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void security_ind_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("MaximumIntegrityProtectedDataRate", c.to_string());
  j.end_obj();
}
SRSASN_CODE security_ind_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE security_ind_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* security_ind_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"MaximumIntegrityProtectedDataRate"};
  return convert_enum_idx(names, 1, value, "security_ind_ext_ies_o::ext_c::types");
}

template struct asn1::protocol_ext_field_s<ul_ngu_up_tnl_modify_item_ext_ies_o>;

ul_ngu_up_tnl_modify_item_ext_ies_container::ul_ngu_up_tnl_modify_item_ext_ies_container() :
  redundant_ul_ngu_up_tnl_info(195, crit_e::ignore), redundant_dl_ngu_up_tnl_info(192, crit_e::ignore)
{
}
SRSASN_CODE ul_ngu_up_tnl_modify_item_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += redundant_ul_ngu_up_tnl_info_present ? 1 : 0;
  nof_ies += redundant_dl_ngu_up_tnl_info_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (redundant_ul_ngu_up_tnl_info_present) {
    HANDLE_CODE(redundant_ul_ngu_up_tnl_info.pack(bref));
  }
  if (redundant_dl_ngu_up_tnl_info_present) {
    HANDLE_CODE(redundant_dl_ngu_up_tnl_info.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ul_ngu_up_tnl_modify_item_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 195: {
        redundant_ul_ngu_up_tnl_info_present = true;
        redundant_ul_ngu_up_tnl_info.id      = id;
        HANDLE_CODE(redundant_ul_ngu_up_tnl_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(redundant_ul_ngu_up_tnl_info.ext.unpack(bref));
        break;
      }
      case 192: {
        redundant_dl_ngu_up_tnl_info_present = true;
        redundant_dl_ngu_up_tnl_info.id      = id;
        HANDLE_CODE(redundant_dl_ngu_up_tnl_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(redundant_dl_ngu_up_tnl_info.ext.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void ul_ngu_up_tnl_modify_item_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (redundant_ul_ngu_up_tnl_info_present) {
    j.write_fieldname("");
    redundant_ul_ngu_up_tnl_info.to_json(j);
  }
  if (redundant_dl_ngu_up_tnl_info_present) {
    j.write_fieldname("");
    redundant_dl_ngu_up_tnl_info.to_json(j);
  }
  j.end_obj();
}

// UL-NGU-UP-TNLModifyItem ::= SEQUENCE
SRSASN_CODE ul_ngu_up_tnl_modify_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(ul_ngu_up_tnl_info.pack(bref));
  HANDLE_CODE(dl_ngu_up_tnl_info.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ul_ngu_up_tnl_modify_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(ul_ngu_up_tnl_info.unpack(bref));
  HANDLE_CODE(dl_ngu_up_tnl_info.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ul_ngu_up_tnl_modify_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("uL-NGU-UP-TNLInformation");
  ul_ngu_up_tnl_info.to_json(j);
  j.write_fieldname("dL-NGU-UP-TNLInformation");
  dl_ngu_up_tnl_info.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SecurityIndication ::= SEQUENCE
SRSASN_CODE security_ind_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(max_integrity_protected_data_rate_ul_present, 1));
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(integrity_protection_ind.pack(bref));
  HANDLE_CODE(confidentiality_protection_ind.pack(bref));
  if (max_integrity_protected_data_rate_ul_present) {
    HANDLE_CODE(max_integrity_protected_data_rate_ul.pack(bref));
  }
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE security_ind_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(max_integrity_protected_data_rate_ul_present, 1));
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(integrity_protection_ind.unpack(bref));
  HANDLE_CODE(confidentiality_protection_ind.unpack(bref));
  if (max_integrity_protected_data_rate_ul_present) {
    HANDLE_CODE(max_integrity_protected_data_rate_ul.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void security_ind_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("integrityProtectionIndication", integrity_protection_ind.to_string());
  j.write_str("confidentialityProtectionIndication", confidentiality_protection_ind.to_string());
  if (max_integrity_protected_data_rate_ul_present) {
    j.write_str("maximumIntegrityProtectedDataRate-UL", max_integrity_protected_data_rate_ul.to_string());
  }
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// PDUSessionResourceModifyRequestTransferIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t pdu_session_res_modify_request_transfer_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {130, 140, 129, 135, 137, 126, 166, 186, 190, 195, 138, 319, 317};
  return map_enum_number(names, 13, idx, "id");
}
bool pdu_session_res_modify_request_transfer_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {130, 140, 129, 135, 137, 126, 166, 186, 190, 195, 138, 319, 317};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e pdu_session_res_modify_request_transfer_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 130:
      return crit_e::reject;
    case 140:
      return crit_e::reject;
    case 129:
      return crit_e::reject;
    case 135:
      return crit_e::reject;
    case 137:
      return crit_e::reject;
    case 126:
      return crit_e::reject;
    case 166:
      return crit_e::ignore;
    case 186:
      return crit_e::ignore;
    case 190:
      return crit_e::ignore;
    case 195:
      return crit_e::ignore;
    case 138:
      return crit_e::ignore;
    case 319:
      return crit_e::ignore;
    case 317:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
pdu_session_res_modify_request_transfer_ies_o::value_c
pdu_session_res_modify_request_transfer_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 130:
      ret.set(value_c::types::pdu_session_aggr_max_bit_rate);
      break;
    case 140:
      ret.set(value_c::types::ul_ngu_up_tnl_modify_list);
      break;
    case 129:
      ret.set(value_c::types::network_instance);
      break;
    case 135:
      ret.set(value_c::types::qos_flow_add_or_modify_request_list);
      break;
    case 137:
      ret.set(value_c::types::qos_flow_to_release_list);
      break;
    case 126:
      ret.set(value_c::types::add_ul_ngu_up_tnl_info);
      break;
    case 166:
      ret.set(value_c::types::common_network_instance);
      break;
    case 186:
      ret.set(value_c::types::add_redundant_ul_ngu_up_tnl_info);
      break;
    case 190:
      ret.set(value_c::types::redundant_common_network_instance);
      break;
    case 195:
      ret.set(value_c::types::redundant_ul_ngu_up_tnl_info);
      break;
    case 138:
      ret.set(value_c::types::security_ind);
      break;
    case 319:
      ret.set(value_c::types::mbs_session_setupor_modify_request_list);
      break;
    case 317:
      ret.set(value_c::types::mbs_session_to_release_list);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pdu_session_res_modify_request_transfer_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 130:
      return presence_e::optional;
    case 140:
      return presence_e::optional;
    case 129:
      return presence_e::optional;
    case 135:
      return presence_e::optional;
    case 137:
      return presence_e::optional;
    case 126:
      return presence_e::optional;
    case 166:
      return presence_e::optional;
    case 186:
      return presence_e::optional;
    case 190:
      return presence_e::optional;
    case 195:
      return presence_e::optional;
    case 138:
      return presence_e::optional;
    case 319:
      return presence_e::optional;
    case 317:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void pdu_session_res_modify_request_transfer_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::pdu_session_aggr_max_bit_rate:
      c.destroy<pdu_session_aggr_max_bit_rate_s>();
      break;
    case types::ul_ngu_up_tnl_modify_list:
      c.destroy<ul_ngu_up_tnl_modify_list_l>();
      break;
    case types::qos_flow_add_or_modify_request_list:
      c.destroy<qos_flow_add_or_modify_request_list_l>();
      break;
    case types::qos_flow_to_release_list:
      c.destroy<qos_flow_list_with_cause_l>();
      break;
    case types::add_ul_ngu_up_tnl_info:
      c.destroy<up_transport_layer_info_list_l>();
      break;
    case types::common_network_instance:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::add_redundant_ul_ngu_up_tnl_info:
      c.destroy<up_transport_layer_info_list_l>();
      break;
    case types::redundant_common_network_instance:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::redundant_ul_ngu_up_tnl_info:
      c.destroy<up_transport_layer_info_c>();
      break;
    case types::security_ind:
      c.destroy<security_ind_s>();
      break;
    case types::mbs_session_setupor_modify_request_list:
      c.destroy<mbs_session_setupor_modify_request_list_l>();
      break;
    case types::mbs_session_to_release_list:
      c.destroy<mbs_session_to_release_list_l>();
      break;
    default:
      break;
  }
}
void pdu_session_res_modify_request_transfer_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::pdu_session_aggr_max_bit_rate:
      c.init<pdu_session_aggr_max_bit_rate_s>();
      break;
    case types::ul_ngu_up_tnl_modify_list:
      c.init<ul_ngu_up_tnl_modify_list_l>();
      break;
    case types::network_instance:
      break;
    case types::qos_flow_add_or_modify_request_list:
      c.init<qos_flow_add_or_modify_request_list_l>();
      break;
    case types::qos_flow_to_release_list:
      c.init<qos_flow_list_with_cause_l>();
      break;
    case types::add_ul_ngu_up_tnl_info:
      c.init<up_transport_layer_info_list_l>();
      break;
    case types::common_network_instance:
      c.init<unbounded_octstring<true>>();
      break;
    case types::add_redundant_ul_ngu_up_tnl_info:
      c.init<up_transport_layer_info_list_l>();
      break;
    case types::redundant_common_network_instance:
      c.init<unbounded_octstring<true>>();
      break;
    case types::redundant_ul_ngu_up_tnl_info:
      c.init<up_transport_layer_info_c>();
      break;
    case types::security_ind:
      c.init<security_ind_s>();
      break;
    case types::mbs_session_setupor_modify_request_list:
      c.init<mbs_session_setupor_modify_request_list_l>();
      break;
    case types::mbs_session_to_release_list:
      c.init<mbs_session_to_release_list_l>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_request_transfer_ies_o::value_c");
  }
}
pdu_session_res_modify_request_transfer_ies_o::value_c::value_c(
    const pdu_session_res_modify_request_transfer_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::pdu_session_aggr_max_bit_rate:
      c.init(other.c.get<pdu_session_aggr_max_bit_rate_s>());
      break;
    case types::ul_ngu_up_tnl_modify_list:
      c.init(other.c.get<ul_ngu_up_tnl_modify_list_l>());
      break;
    case types::network_instance:
      c.init(other.c.get<uint16_t>());
      break;
    case types::qos_flow_add_or_modify_request_list:
      c.init(other.c.get<qos_flow_add_or_modify_request_list_l>());
      break;
    case types::qos_flow_to_release_list:
      c.init(other.c.get<qos_flow_list_with_cause_l>());
      break;
    case types::add_ul_ngu_up_tnl_info:
      c.init(other.c.get<up_transport_layer_info_list_l>());
      break;
    case types::common_network_instance:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::add_redundant_ul_ngu_up_tnl_info:
      c.init(other.c.get<up_transport_layer_info_list_l>());
      break;
    case types::redundant_common_network_instance:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::redundant_ul_ngu_up_tnl_info:
      c.init(other.c.get<up_transport_layer_info_c>());
      break;
    case types::security_ind:
      c.init(other.c.get<security_ind_s>());
      break;
    case types::mbs_session_setupor_modify_request_list:
      c.init(other.c.get<mbs_session_setupor_modify_request_list_l>());
      break;
    case types::mbs_session_to_release_list:
      c.init(other.c.get<mbs_session_to_release_list_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_request_transfer_ies_o::value_c");
  }
}
pdu_session_res_modify_request_transfer_ies_o::value_c&
pdu_session_res_modify_request_transfer_ies_o::value_c::operator=(
    const pdu_session_res_modify_request_transfer_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::pdu_session_aggr_max_bit_rate:
      c.set(other.c.get<pdu_session_aggr_max_bit_rate_s>());
      break;
    case types::ul_ngu_up_tnl_modify_list:
      c.set(other.c.get<ul_ngu_up_tnl_modify_list_l>());
      break;
    case types::network_instance:
      c.set(other.c.get<uint16_t>());
      break;
    case types::qos_flow_add_or_modify_request_list:
      c.set(other.c.get<qos_flow_add_or_modify_request_list_l>());
      break;
    case types::qos_flow_to_release_list:
      c.set(other.c.get<qos_flow_list_with_cause_l>());
      break;
    case types::add_ul_ngu_up_tnl_info:
      c.set(other.c.get<up_transport_layer_info_list_l>());
      break;
    case types::common_network_instance:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::add_redundant_ul_ngu_up_tnl_info:
      c.set(other.c.get<up_transport_layer_info_list_l>());
      break;
    case types::redundant_common_network_instance:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::redundant_ul_ngu_up_tnl_info:
      c.set(other.c.get<up_transport_layer_info_c>());
      break;
    case types::security_ind:
      c.set(other.c.get<security_ind_s>());
      break;
    case types::mbs_session_setupor_modify_request_list:
      c.set(other.c.get<mbs_session_setupor_modify_request_list_l>());
      break;
    case types::mbs_session_to_release_list:
      c.set(other.c.get<mbs_session_to_release_list_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_request_transfer_ies_o::value_c");
  }

  return *this;
}
pdu_session_aggr_max_bit_rate_s& pdu_session_res_modify_request_transfer_ies_o::value_c::pdu_session_aggr_max_bit_rate()
{
  assert_choice_type(types::pdu_session_aggr_max_bit_rate, type_, "Value");
  return c.get<pdu_session_aggr_max_bit_rate_s>();
}
ul_ngu_up_tnl_modify_list_l& pdu_session_res_modify_request_transfer_ies_o::value_c::ul_ngu_up_tnl_modify_list()
{
  assert_choice_type(types::ul_ngu_up_tnl_modify_list, type_, "Value");
  return c.get<ul_ngu_up_tnl_modify_list_l>();
}
uint16_t& pdu_session_res_modify_request_transfer_ies_o::value_c::network_instance()
{
  assert_choice_type(types::network_instance, type_, "Value");
  return c.get<uint16_t>();
}
qos_flow_add_or_modify_request_list_l&
pdu_session_res_modify_request_transfer_ies_o::value_c::qos_flow_add_or_modify_request_list()
{
  assert_choice_type(types::qos_flow_add_or_modify_request_list, type_, "Value");
  return c.get<qos_flow_add_or_modify_request_list_l>();
}
qos_flow_list_with_cause_l& pdu_session_res_modify_request_transfer_ies_o::value_c::qos_flow_to_release_list()
{
  assert_choice_type(types::qos_flow_to_release_list, type_, "Value");
  return c.get<qos_flow_list_with_cause_l>();
}
up_transport_layer_info_list_l& pdu_session_res_modify_request_transfer_ies_o::value_c::add_ul_ngu_up_tnl_info()
{
  assert_choice_type(types::add_ul_ngu_up_tnl_info, type_, "Value");
  return c.get<up_transport_layer_info_list_l>();
}
unbounded_octstring<true>& pdu_session_res_modify_request_transfer_ies_o::value_c::common_network_instance()
{
  assert_choice_type(types::common_network_instance, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
up_transport_layer_info_list_l&
pdu_session_res_modify_request_transfer_ies_o::value_c::add_redundant_ul_ngu_up_tnl_info()
{
  assert_choice_type(types::add_redundant_ul_ngu_up_tnl_info, type_, "Value");
  return c.get<up_transport_layer_info_list_l>();
}
unbounded_octstring<true>& pdu_session_res_modify_request_transfer_ies_o::value_c::redundant_common_network_instance()
{
  assert_choice_type(types::redundant_common_network_instance, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
up_transport_layer_info_c& pdu_session_res_modify_request_transfer_ies_o::value_c::redundant_ul_ngu_up_tnl_info()
{
  assert_choice_type(types::redundant_ul_ngu_up_tnl_info, type_, "Value");
  return c.get<up_transport_layer_info_c>();
}
security_ind_s& pdu_session_res_modify_request_transfer_ies_o::value_c::security_ind()
{
  assert_choice_type(types::security_ind, type_, "Value");
  return c.get<security_ind_s>();
}
mbs_session_setupor_modify_request_list_l&
pdu_session_res_modify_request_transfer_ies_o::value_c::mbs_session_setupor_modify_request_list()
{
  assert_choice_type(types::mbs_session_setupor_modify_request_list, type_, "Value");
  return c.get<mbs_session_setupor_modify_request_list_l>();
}
mbs_session_to_release_list_l& pdu_session_res_modify_request_transfer_ies_o::value_c::mbs_session_to_release_list()
{
  assert_choice_type(types::mbs_session_to_release_list, type_, "Value");
  return c.get<mbs_session_to_release_list_l>();
}
const pdu_session_aggr_max_bit_rate_s&
pdu_session_res_modify_request_transfer_ies_o::value_c::pdu_session_aggr_max_bit_rate() const
{
  assert_choice_type(types::pdu_session_aggr_max_bit_rate, type_, "Value");
  return c.get<pdu_session_aggr_max_bit_rate_s>();
}
const ul_ngu_up_tnl_modify_list_l&
pdu_session_res_modify_request_transfer_ies_o::value_c::ul_ngu_up_tnl_modify_list() const
{
  assert_choice_type(types::ul_ngu_up_tnl_modify_list, type_, "Value");
  return c.get<ul_ngu_up_tnl_modify_list_l>();
}
const uint16_t& pdu_session_res_modify_request_transfer_ies_o::value_c::network_instance() const
{
  assert_choice_type(types::network_instance, type_, "Value");
  return c.get<uint16_t>();
}
const qos_flow_add_or_modify_request_list_l&
pdu_session_res_modify_request_transfer_ies_o::value_c::qos_flow_add_or_modify_request_list() const
{
  assert_choice_type(types::qos_flow_add_or_modify_request_list, type_, "Value");
  return c.get<qos_flow_add_or_modify_request_list_l>();
}
const qos_flow_list_with_cause_l&
pdu_session_res_modify_request_transfer_ies_o::value_c::qos_flow_to_release_list() const
{
  assert_choice_type(types::qos_flow_to_release_list, type_, "Value");
  return c.get<qos_flow_list_with_cause_l>();
}
const up_transport_layer_info_list_l&
pdu_session_res_modify_request_transfer_ies_o::value_c::add_ul_ngu_up_tnl_info() const
{
  assert_choice_type(types::add_ul_ngu_up_tnl_info, type_, "Value");
  return c.get<up_transport_layer_info_list_l>();
}
const unbounded_octstring<true>& pdu_session_res_modify_request_transfer_ies_o::value_c::common_network_instance() const
{
  assert_choice_type(types::common_network_instance, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const up_transport_layer_info_list_l&
pdu_session_res_modify_request_transfer_ies_o::value_c::add_redundant_ul_ngu_up_tnl_info() const
{
  assert_choice_type(types::add_redundant_ul_ngu_up_tnl_info, type_, "Value");
  return c.get<up_transport_layer_info_list_l>();
}
const unbounded_octstring<true>&
pdu_session_res_modify_request_transfer_ies_o::value_c::redundant_common_network_instance() const
{
  assert_choice_type(types::redundant_common_network_instance, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const up_transport_layer_info_c&
pdu_session_res_modify_request_transfer_ies_o::value_c::redundant_ul_ngu_up_tnl_info() const
{
  assert_choice_type(types::redundant_ul_ngu_up_tnl_info, type_, "Value");
  return c.get<up_transport_layer_info_c>();
}
const security_ind_s& pdu_session_res_modify_request_transfer_ies_o::value_c::security_ind() const
{
  assert_choice_type(types::security_ind, type_, "Value");
  return c.get<security_ind_s>();
}
const mbs_session_setupor_modify_request_list_l&
pdu_session_res_modify_request_transfer_ies_o::value_c::mbs_session_setupor_modify_request_list() const
{
  assert_choice_type(types::mbs_session_setupor_modify_request_list, type_, "Value");
  return c.get<mbs_session_setupor_modify_request_list_l>();
}
const mbs_session_to_release_list_l&
pdu_session_res_modify_request_transfer_ies_o::value_c::mbs_session_to_release_list() const
{
  assert_choice_type(types::mbs_session_to_release_list, type_, "Value");
  return c.get<mbs_session_to_release_list_l>();
}
void pdu_session_res_modify_request_transfer_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::pdu_session_aggr_max_bit_rate:
      j.write_fieldname("PDUSessionAggregateMaximumBitRate");
      c.get<pdu_session_aggr_max_bit_rate_s>().to_json(j);
      break;
    case types::ul_ngu_up_tnl_modify_list:
      j.start_array("UL-NGU-UP-TNLModifyList");
      for (const auto& e1 : c.get<ul_ngu_up_tnl_modify_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::network_instance:
      j.write_int("INTEGER (1..256,...)", c.get<uint16_t>());
      break;
    case types::qos_flow_add_or_modify_request_list:
      j.start_array("QosFlowAddOrModifyRequestList");
      for (const auto& e1 : c.get<qos_flow_add_or_modify_request_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::qos_flow_to_release_list:
      j.start_array("QosFlowListWithCause");
      for (const auto& e1 : c.get<qos_flow_list_with_cause_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::add_ul_ngu_up_tnl_info:
      j.start_array("UPTransportLayerInformationList");
      for (const auto& e1 : c.get<up_transport_layer_info_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::common_network_instance:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::add_redundant_ul_ngu_up_tnl_info:
      j.start_array("UPTransportLayerInformationList");
      for (const auto& e1 : c.get<up_transport_layer_info_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::redundant_common_network_instance:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::redundant_ul_ngu_up_tnl_info:
      j.write_fieldname("UPTransportLayerInformation");
      c.get<up_transport_layer_info_c>().to_json(j);
      break;
    case types::security_ind:
      j.write_fieldname("SecurityIndication");
      c.get<security_ind_s>().to_json(j);
      break;
    case types::mbs_session_setupor_modify_request_list:
      j.start_array("MBSSessionSetuporModifyRequestList");
      for (const auto& e1 : c.get<mbs_session_setupor_modify_request_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::mbs_session_to_release_list:
      j.start_array("MBSSessionToReleaseList");
      for (const auto& e1 : c.get<mbs_session_to_release_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_request_transfer_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE pdu_session_res_modify_request_transfer_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::pdu_session_aggr_max_bit_rate:
      HANDLE_CODE(c.get<pdu_session_aggr_max_bit_rate_s>().pack(bref));
      break;
    case types::ul_ngu_up_tnl_modify_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<ul_ngu_up_tnl_modify_list_l>(), 1, 4, true));
      break;
    case types::network_instance:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)1u, (uint16_t)256u, true, true));
      break;
    case types::qos_flow_add_or_modify_request_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<qos_flow_add_or_modify_request_list_l>(), 1, 64, true));
      break;
    case types::qos_flow_to_release_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<qos_flow_list_with_cause_l>(), 1, 64, true));
      break;
    case types::add_ul_ngu_up_tnl_info:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<up_transport_layer_info_list_l>(), 1, 3, true));
      break;
    case types::common_network_instance:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::add_redundant_ul_ngu_up_tnl_info:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<up_transport_layer_info_list_l>(), 1, 3, true));
      break;
    case types::redundant_common_network_instance:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::redundant_ul_ngu_up_tnl_info:
      HANDLE_CODE(c.get<up_transport_layer_info_c>().pack(bref));
      break;
    case types::security_ind:
      HANDLE_CODE(c.get<security_ind_s>().pack(bref));
      break;
    case types::mbs_session_setupor_modify_request_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<mbs_session_setupor_modify_request_list_l>(), 1, 32, true));
      break;
    case types::mbs_session_to_release_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<mbs_session_to_release_list_l>(), 1, 32, true));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_request_transfer_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_modify_request_transfer_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::pdu_session_aggr_max_bit_rate:
      HANDLE_CODE(c.get<pdu_session_aggr_max_bit_rate_s>().unpack(bref));
      break;
    case types::ul_ngu_up_tnl_modify_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<ul_ngu_up_tnl_modify_list_l>(), bref, 1, 4, true));
      break;
    case types::network_instance:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)1u, (uint16_t)256u, true, true));
      break;
    case types::qos_flow_add_or_modify_request_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<qos_flow_add_or_modify_request_list_l>(), bref, 1, 64, true));
      break;
    case types::qos_flow_to_release_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<qos_flow_list_with_cause_l>(), bref, 1, 64, true));
      break;
    case types::add_ul_ngu_up_tnl_info:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<up_transport_layer_info_list_l>(), bref, 1, 3, true));
      break;
    case types::common_network_instance:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::add_redundant_ul_ngu_up_tnl_info:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<up_transport_layer_info_list_l>(), bref, 1, 3, true));
      break;
    case types::redundant_common_network_instance:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::redundant_ul_ngu_up_tnl_info:
      HANDLE_CODE(c.get<up_transport_layer_info_c>().unpack(bref));
      break;
    case types::security_ind:
      HANDLE_CODE(c.get<security_ind_s>().unpack(bref));
      break;
    case types::mbs_session_setupor_modify_request_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<mbs_session_setupor_modify_request_list_l>(), bref, 1, 32, true));
      break;
    case types::mbs_session_to_release_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<mbs_session_to_release_list_l>(), bref, 1, 32, true));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_request_transfer_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* pdu_session_res_modify_request_transfer_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"PDUSessionAggregateMaximumBitRate",
                                "UL-NGU-UP-TNLModifyList",
                                "INTEGER (1..256,...)",
                                "QosFlowAddOrModifyRequestList",
                                "QosFlowListWithCause",
                                "UPTransportLayerInformationList",
                                "OCTET STRING",
                                "UPTransportLayerInformationList",
                                "OCTET STRING",
                                "UPTransportLayerInformation",
                                "SecurityIndication",
                                "MBSSessionSetuporModifyRequestList",
                                "MBSSessionToReleaseList"};
  return convert_enum_idx(names, 13, value, "pdu_session_res_modify_request_transfer_ies_o::value_c::types");
}
uint8_t pdu_session_res_modify_request_transfer_ies_o::value_c::types_opts::to_number() const
{
  if (value == network_instance) {
    return 1;
  }
  invalid_enum_number(value, "pdu_session_res_modify_request_transfer_ies_o::value_c::types");
  return 0;
}

template struct asn1::protocol_ie_field_s<pdu_session_res_modify_request_transfer_ies_o>;

pdu_session_res_modify_request_transfer_ies_container::pdu_session_res_modify_request_transfer_ies_container() :
  pdu_session_aggr_max_bit_rate(130, crit_e::reject),
  ul_ngu_up_tnl_modify_list(140, crit_e::reject),
  network_instance(129, crit_e::reject),
  qos_flow_add_or_modify_request_list(135, crit_e::reject),
  qos_flow_to_release_list(137, crit_e::reject),
  add_ul_ngu_up_tnl_info(126, crit_e::reject),
  common_network_instance(166, crit_e::ignore),
  add_redundant_ul_ngu_up_tnl_info(186, crit_e::ignore),
  redundant_common_network_instance(190, crit_e::ignore),
  redundant_ul_ngu_up_tnl_info(195, crit_e::ignore),
  security_ind(138, crit_e::ignore),
  mbs_session_setupor_modify_request_list(319, crit_e::ignore),
  mbs_session_to_release_list(317, crit_e::ignore)
{
}
SRSASN_CODE pdu_session_res_modify_request_transfer_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += pdu_session_aggr_max_bit_rate_present ? 1 : 0;
  nof_ies += ul_ngu_up_tnl_modify_list_present ? 1 : 0;
  nof_ies += network_instance_present ? 1 : 0;
  nof_ies += qos_flow_add_or_modify_request_list_present ? 1 : 0;
  nof_ies += qos_flow_to_release_list_present ? 1 : 0;
  nof_ies += add_ul_ngu_up_tnl_info_present ? 1 : 0;
  nof_ies += common_network_instance_present ? 1 : 0;
  nof_ies += add_redundant_ul_ngu_up_tnl_info_present ? 1 : 0;
  nof_ies += redundant_common_network_instance_present ? 1 : 0;
  nof_ies += redundant_ul_ngu_up_tnl_info_present ? 1 : 0;
  nof_ies += security_ind_present ? 1 : 0;
  nof_ies += mbs_session_setupor_modify_request_list_present ? 1 : 0;
  nof_ies += mbs_session_to_release_list_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  if (pdu_session_aggr_max_bit_rate_present) {
    HANDLE_CODE(pdu_session_aggr_max_bit_rate.pack(bref));
  }
  if (ul_ngu_up_tnl_modify_list_present) {
    HANDLE_CODE(ul_ngu_up_tnl_modify_list.pack(bref));
  }
  if (network_instance_present) {
    HANDLE_CODE(network_instance.pack(bref));
  }
  if (qos_flow_add_or_modify_request_list_present) {
    HANDLE_CODE(qos_flow_add_or_modify_request_list.pack(bref));
  }
  if (qos_flow_to_release_list_present) {
    HANDLE_CODE(qos_flow_to_release_list.pack(bref));
  }
  if (add_ul_ngu_up_tnl_info_present) {
    HANDLE_CODE(add_ul_ngu_up_tnl_info.pack(bref));
  }
  if (common_network_instance_present) {
    HANDLE_CODE(common_network_instance.pack(bref));
  }
  if (add_redundant_ul_ngu_up_tnl_info_present) {
    HANDLE_CODE(add_redundant_ul_ngu_up_tnl_info.pack(bref));
  }
  if (redundant_common_network_instance_present) {
    HANDLE_CODE(redundant_common_network_instance.pack(bref));
  }
  if (redundant_ul_ngu_up_tnl_info_present) {
    HANDLE_CODE(redundant_ul_ngu_up_tnl_info.pack(bref));
  }
  if (security_ind_present) {
    HANDLE_CODE(security_ind.pack(bref));
  }
  if (mbs_session_setupor_modify_request_list_present) {
    HANDLE_CODE(mbs_session_setupor_modify_request_list.pack(bref));
  }
  if (mbs_session_to_release_list_present) {
    HANDLE_CODE(mbs_session_to_release_list.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_modify_request_transfer_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 130: {
        pdu_session_aggr_max_bit_rate_present = true;
        pdu_session_aggr_max_bit_rate.id      = id;
        HANDLE_CODE(pdu_session_aggr_max_bit_rate.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pdu_session_aggr_max_bit_rate.value.unpack(bref));
        break;
      }
      case 140: {
        ul_ngu_up_tnl_modify_list_present = true;
        ul_ngu_up_tnl_modify_list.id      = id;
        HANDLE_CODE(ul_ngu_up_tnl_modify_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ul_ngu_up_tnl_modify_list.value.unpack(bref));
        break;
      }
      case 129: {
        network_instance_present = true;
        network_instance.id      = id;
        HANDLE_CODE(network_instance.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(network_instance.value.unpack(bref));
        break;
      }
      case 135: {
        qos_flow_add_or_modify_request_list_present = true;
        qos_flow_add_or_modify_request_list.id      = id;
        HANDLE_CODE(qos_flow_add_or_modify_request_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(qos_flow_add_or_modify_request_list.value.unpack(bref));
        break;
      }
      case 137: {
        qos_flow_to_release_list_present = true;
        qos_flow_to_release_list.id      = id;
        HANDLE_CODE(qos_flow_to_release_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(qos_flow_to_release_list.value.unpack(bref));
        break;
      }
      case 126: {
        add_ul_ngu_up_tnl_info_present = true;
        add_ul_ngu_up_tnl_info.id      = id;
        HANDLE_CODE(add_ul_ngu_up_tnl_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(add_ul_ngu_up_tnl_info.value.unpack(bref));
        break;
      }
      case 166: {
        common_network_instance_present = true;
        common_network_instance.id      = id;
        HANDLE_CODE(common_network_instance.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(common_network_instance.value.unpack(bref));
        break;
      }
      case 186: {
        add_redundant_ul_ngu_up_tnl_info_present = true;
        add_redundant_ul_ngu_up_tnl_info.id      = id;
        HANDLE_CODE(add_redundant_ul_ngu_up_tnl_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(add_redundant_ul_ngu_up_tnl_info.value.unpack(bref));
        break;
      }
      case 190: {
        redundant_common_network_instance_present = true;
        redundant_common_network_instance.id      = id;
        HANDLE_CODE(redundant_common_network_instance.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(redundant_common_network_instance.value.unpack(bref));
        break;
      }
      case 195: {
        redundant_ul_ngu_up_tnl_info_present = true;
        redundant_ul_ngu_up_tnl_info.id      = id;
        HANDLE_CODE(redundant_ul_ngu_up_tnl_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(redundant_ul_ngu_up_tnl_info.value.unpack(bref));
        break;
      }
      case 138: {
        security_ind_present = true;
        security_ind.id      = id;
        HANDLE_CODE(security_ind.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(security_ind.value.unpack(bref));
        break;
      }
      case 319: {
        mbs_session_setupor_modify_request_list_present = true;
        mbs_session_setupor_modify_request_list.id      = id;
        HANDLE_CODE(mbs_session_setupor_modify_request_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_setupor_modify_request_list.value.unpack(bref));
        break;
      }
      case 317: {
        mbs_session_to_release_list_present = true;
        mbs_session_to_release_list.id      = id;
        HANDLE_CODE(mbs_session_to_release_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_to_release_list.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_modify_request_transfer_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (pdu_session_aggr_max_bit_rate_present) {
    j.write_fieldname("");
    pdu_session_aggr_max_bit_rate.to_json(j);
  }
  if (ul_ngu_up_tnl_modify_list_present) {
    j.write_fieldname("");
    ul_ngu_up_tnl_modify_list.to_json(j);
  }
  if (network_instance_present) {
    j.write_fieldname("");
    network_instance.to_json(j);
  }
  if (qos_flow_add_or_modify_request_list_present) {
    j.write_fieldname("");
    qos_flow_add_or_modify_request_list.to_json(j);
  }
  if (qos_flow_to_release_list_present) {
    j.write_fieldname("");
    qos_flow_to_release_list.to_json(j);
  }
  if (add_ul_ngu_up_tnl_info_present) {
    j.write_fieldname("");
    add_ul_ngu_up_tnl_info.to_json(j);
  }
  if (common_network_instance_present) {
    j.write_fieldname("");
    common_network_instance.to_json(j);
  }
  if (add_redundant_ul_ngu_up_tnl_info_present) {
    j.write_fieldname("");
    add_redundant_ul_ngu_up_tnl_info.to_json(j);
  }
  if (redundant_common_network_instance_present) {
    j.write_fieldname("");
    redundant_common_network_instance.to_json(j);
  }
  if (redundant_ul_ngu_up_tnl_info_present) {
    j.write_fieldname("");
    redundant_ul_ngu_up_tnl_info.to_json(j);
  }
  if (security_ind_present) {
    j.write_fieldname("");
    security_ind.to_json(j);
  }
  if (mbs_session_setupor_modify_request_list_present) {
    j.write_fieldname("");
    mbs_session_setupor_modify_request_list.to_json(j);
  }
  if (mbs_session_to_release_list_present) {
    j.write_fieldname("");
    mbs_session_to_release_list.to_json(j);
  }
  j.end_obj();
}

// QosFlowAddOrModifyResponseItem-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t qos_flow_add_or_modify_resp_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {221};
  return map_enum_number(names, 1, idx, "id");
}
bool qos_flow_add_or_modify_resp_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 221 == id;
}
crit_e qos_flow_add_or_modify_resp_item_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 221) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
qos_flow_add_or_modify_resp_item_ext_ies_o::ext_c
qos_flow_add_or_modify_resp_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 221) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e qos_flow_add_or_modify_resp_item_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 221) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void qos_flow_add_or_modify_resp_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("INTEGER (1..8,...)", c);
  j.end_obj();
}
SRSASN_CODE qos_flow_add_or_modify_resp_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(pack_integer(bref, c, (uint8_t)1u, (uint8_t)8u, true, true));
  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_flow_add_or_modify_resp_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(unpack_integer(c, bref, (uint8_t)1u, (uint8_t)8u, true, true));
  return SRSASN_SUCCESS;
}

const char* qos_flow_add_or_modify_resp_item_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (1..8,...)"};
  return convert_enum_idx(names, 1, value, "qos_flow_add_or_modify_resp_item_ext_ies_o::ext_c::types");
}
uint8_t qos_flow_add_or_modify_resp_item_ext_ies_o::ext_c::types_opts::to_number() const
{
  static const uint8_t numbers[] = {1};
  return map_enum_number(numbers, 1, value, "qos_flow_add_or_modify_resp_item_ext_ies_o::ext_c::types");
}

// QosFlowAddOrModifyResponseItem ::= SEQUENCE
SRSASN_CODE qos_flow_add_or_modify_resp_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(pack_integer(bref, qos_flow_id, (uint8_t)0u, (uint8_t)63u, true, true));
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_flow_add_or_modify_resp_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(qos_flow_id, bref, (uint8_t)0u, (uint8_t)63u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void qos_flow_add_or_modify_resp_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("qosFlowIdentifier", qos_flow_id);
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// PDUSessionResourceModifyResponseTransfer-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t pdu_session_res_modify_resp_transfer_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {154, 192, 195, 184, 185, 144, 309, 313, 311};
  return map_enum_number(names, 9, idx, "id");
}
bool pdu_session_res_modify_resp_transfer_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {154, 192, 195, 184, 185, 144, 309, 313, 311};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e pdu_session_res_modify_resp_transfer_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 154:
      return crit_e::ignore;
    case 192:
      return crit_e::ignore;
    case 195:
      return crit_e::ignore;
    case 184:
      return crit_e::ignore;
    case 185:
      return crit_e::ignore;
    case 144:
      return crit_e::ignore;
    case 309:
      return crit_e::ignore;
    case 313:
      return crit_e::ignore;
    case 311:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
pdu_session_res_modify_resp_transfer_ext_ies_o::ext_c
pdu_session_res_modify_resp_transfer_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 154:
      ret.set(ext_c::types::add_ngu_up_tnl_info);
      break;
    case 192:
      ret.set(ext_c::types::redundant_dl_ngu_up_tnl_info);
      break;
    case 195:
      ret.set(ext_c::types::redundant_ul_ngu_up_tnl_info);
      break;
    case 184:
      ret.set(ext_c::types::add_redundant_dl_qos_flow_per_tnl_info);
      break;
    case 185:
      ret.set(ext_c::types::add_redundant_ngu_up_tnl_info);
      break;
    case 144:
      ret.set(ext_c::types::secondary_rat_usage_info);
      break;
    case 309:
      ret.set(ext_c::types::mbs_support_ind);
      break;
    case 313:
      ret.set(ext_c::types::mbs_session_setupor_modify_resp_list);
      break;
    case 311:
      ret.set(ext_c::types::mbs_session_failedto_setupor_modify_list);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pdu_session_res_modify_resp_transfer_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 154:
      return presence_e::optional;
    case 192:
      return presence_e::optional;
    case 195:
      return presence_e::optional;
    case 184:
      return presence_e::optional;
    case 185:
      return presence_e::optional;
    case 144:
      return presence_e::optional;
    case 309:
      return presence_e::optional;
    case 313:
      return presence_e::optional;
    case 311:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void pdu_session_res_modify_resp_transfer_ext_ies_o::ext_c::destroy_()
{
  switch (type_) {
    case types::add_ngu_up_tnl_info:
      c.destroy<up_transport_layer_info_pair_list_l>();
      break;
    case types::redundant_dl_ngu_up_tnl_info:
      c.destroy<up_transport_layer_info_c>();
      break;
    case types::redundant_ul_ngu_up_tnl_info:
      c.destroy<up_transport_layer_info_c>();
      break;
    case types::add_redundant_dl_qos_flow_per_tnl_info:
      c.destroy<qos_flow_per_tnl_info_list_l>();
      break;
    case types::add_redundant_ngu_up_tnl_info:
      c.destroy<up_transport_layer_info_pair_list_l>();
      break;
    case types::secondary_rat_usage_info:
      c.destroy<secondary_rat_usage_info_s>();
      break;
    case types::mbs_session_setupor_modify_resp_list:
      c.destroy<mbs_session_setup_resp_list_l>();
      break;
    case types::mbs_session_failedto_setupor_modify_list:
      c.destroy<mbs_session_failedto_setup_list_l>();
      break;
    default:
      break;
  }
}
void pdu_session_res_modify_resp_transfer_ext_ies_o::ext_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::add_ngu_up_tnl_info:
      c.init<up_transport_layer_info_pair_list_l>();
      break;
    case types::redundant_dl_ngu_up_tnl_info:
      c.init<up_transport_layer_info_c>();
      break;
    case types::redundant_ul_ngu_up_tnl_info:
      c.init<up_transport_layer_info_c>();
      break;
    case types::add_redundant_dl_qos_flow_per_tnl_info:
      c.init<qos_flow_per_tnl_info_list_l>();
      break;
    case types::add_redundant_ngu_up_tnl_info:
      c.init<up_transport_layer_info_pair_list_l>();
      break;
    case types::secondary_rat_usage_info:
      c.init<secondary_rat_usage_info_s>();
      break;
    case types::mbs_support_ind:
      break;
    case types::mbs_session_setupor_modify_resp_list:
      c.init<mbs_session_setup_resp_list_l>();
      break;
    case types::mbs_session_failedto_setupor_modify_list:
      c.init<mbs_session_failedto_setup_list_l>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_resp_transfer_ext_ies_o::ext_c");
  }
}
pdu_session_res_modify_resp_transfer_ext_ies_o::ext_c::ext_c(
    const pdu_session_res_modify_resp_transfer_ext_ies_o::ext_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::add_ngu_up_tnl_info:
      c.init(other.c.get<up_transport_layer_info_pair_list_l>());
      break;
    case types::redundant_dl_ngu_up_tnl_info:
      c.init(other.c.get<up_transport_layer_info_c>());
      break;
    case types::redundant_ul_ngu_up_tnl_info:
      c.init(other.c.get<up_transport_layer_info_c>());
      break;
    case types::add_redundant_dl_qos_flow_per_tnl_info:
      c.init(other.c.get<qos_flow_per_tnl_info_list_l>());
      break;
    case types::add_redundant_ngu_up_tnl_info:
      c.init(other.c.get<up_transport_layer_info_pair_list_l>());
      break;
    case types::secondary_rat_usage_info:
      c.init(other.c.get<secondary_rat_usage_info_s>());
      break;
    case types::mbs_support_ind:
      c.init(other.c.get<mbs_support_ind_e>());
      break;
    case types::mbs_session_setupor_modify_resp_list:
      c.init(other.c.get<mbs_session_setup_resp_list_l>());
      break;
    case types::mbs_session_failedto_setupor_modify_list:
      c.init(other.c.get<mbs_session_failedto_setup_list_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_resp_transfer_ext_ies_o::ext_c");
  }
}
pdu_session_res_modify_resp_transfer_ext_ies_o::ext_c& pdu_session_res_modify_resp_transfer_ext_ies_o::ext_c::operator=(
    const pdu_session_res_modify_resp_transfer_ext_ies_o::ext_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::add_ngu_up_tnl_info:
      c.set(other.c.get<up_transport_layer_info_pair_list_l>());
      break;
    case types::redundant_dl_ngu_up_tnl_info:
      c.set(other.c.get<up_transport_layer_info_c>());
      break;
    case types::redundant_ul_ngu_up_tnl_info:
      c.set(other.c.get<up_transport_layer_info_c>());
      break;
    case types::add_redundant_dl_qos_flow_per_tnl_info:
      c.set(other.c.get<qos_flow_per_tnl_info_list_l>());
      break;
    case types::add_redundant_ngu_up_tnl_info:
      c.set(other.c.get<up_transport_layer_info_pair_list_l>());
      break;
    case types::secondary_rat_usage_info:
      c.set(other.c.get<secondary_rat_usage_info_s>());
      break;
    case types::mbs_support_ind:
      c.set(other.c.get<mbs_support_ind_e>());
      break;
    case types::mbs_session_setupor_modify_resp_list:
      c.set(other.c.get<mbs_session_setup_resp_list_l>());
      break;
    case types::mbs_session_failedto_setupor_modify_list:
      c.set(other.c.get<mbs_session_failedto_setup_list_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_resp_transfer_ext_ies_o::ext_c");
  }

  return *this;
}
up_transport_layer_info_pair_list_l& pdu_session_res_modify_resp_transfer_ext_ies_o::ext_c::add_ngu_up_tnl_info()
{
  assert_choice_type(types::add_ngu_up_tnl_info, type_, "Extension");
  return c.get<up_transport_layer_info_pair_list_l>();
}
up_transport_layer_info_c& pdu_session_res_modify_resp_transfer_ext_ies_o::ext_c::redundant_dl_ngu_up_tnl_info()
{
  assert_choice_type(types::redundant_dl_ngu_up_tnl_info, type_, "Extension");
  return c.get<up_transport_layer_info_c>();
}
up_transport_layer_info_c& pdu_session_res_modify_resp_transfer_ext_ies_o::ext_c::redundant_ul_ngu_up_tnl_info()
{
  assert_choice_type(types::redundant_ul_ngu_up_tnl_info, type_, "Extension");
  return c.get<up_transport_layer_info_c>();
}
qos_flow_per_tnl_info_list_l&
pdu_session_res_modify_resp_transfer_ext_ies_o::ext_c::add_redundant_dl_qos_flow_per_tnl_info()
{
  assert_choice_type(types::add_redundant_dl_qos_flow_per_tnl_info, type_, "Extension");
  return c.get<qos_flow_per_tnl_info_list_l>();
}
up_transport_layer_info_pair_list_l&
pdu_session_res_modify_resp_transfer_ext_ies_o::ext_c::add_redundant_ngu_up_tnl_info()
{
  assert_choice_type(types::add_redundant_ngu_up_tnl_info, type_, "Extension");
  return c.get<up_transport_layer_info_pair_list_l>();
}
secondary_rat_usage_info_s& pdu_session_res_modify_resp_transfer_ext_ies_o::ext_c::secondary_rat_usage_info()
{
  assert_choice_type(types::secondary_rat_usage_info, type_, "Extension");
  return c.get<secondary_rat_usage_info_s>();
}
mbs_support_ind_e& pdu_session_res_modify_resp_transfer_ext_ies_o::ext_c::mbs_support_ind()
{
  assert_choice_type(types::mbs_support_ind, type_, "Extension");
  return c.get<mbs_support_ind_e>();
}
mbs_session_setup_resp_list_l&
pdu_session_res_modify_resp_transfer_ext_ies_o::ext_c::mbs_session_setupor_modify_resp_list()
{
  assert_choice_type(types::mbs_session_setupor_modify_resp_list, type_, "Extension");
  return c.get<mbs_session_setup_resp_list_l>();
}
mbs_session_failedto_setup_list_l&
pdu_session_res_modify_resp_transfer_ext_ies_o::ext_c::mbs_session_failedto_setupor_modify_list()
{
  assert_choice_type(types::mbs_session_failedto_setupor_modify_list, type_, "Extension");
  return c.get<mbs_session_failedto_setup_list_l>();
}
const up_transport_layer_info_pair_list_l&
pdu_session_res_modify_resp_transfer_ext_ies_o::ext_c::add_ngu_up_tnl_info() const
{
  assert_choice_type(types::add_ngu_up_tnl_info, type_, "Extension");
  return c.get<up_transport_layer_info_pair_list_l>();
}
const up_transport_layer_info_c&
pdu_session_res_modify_resp_transfer_ext_ies_o::ext_c::redundant_dl_ngu_up_tnl_info() const
{
  assert_choice_type(types::redundant_dl_ngu_up_tnl_info, type_, "Extension");
  return c.get<up_transport_layer_info_c>();
}
const up_transport_layer_info_c&
pdu_session_res_modify_resp_transfer_ext_ies_o::ext_c::redundant_ul_ngu_up_tnl_info() const
{
  assert_choice_type(types::redundant_ul_ngu_up_tnl_info, type_, "Extension");
  return c.get<up_transport_layer_info_c>();
}
const qos_flow_per_tnl_info_list_l&
pdu_session_res_modify_resp_transfer_ext_ies_o::ext_c::add_redundant_dl_qos_flow_per_tnl_info() const
{
  assert_choice_type(types::add_redundant_dl_qos_flow_per_tnl_info, type_, "Extension");
  return c.get<qos_flow_per_tnl_info_list_l>();
}
const up_transport_layer_info_pair_list_l&
pdu_session_res_modify_resp_transfer_ext_ies_o::ext_c::add_redundant_ngu_up_tnl_info() const
{
  assert_choice_type(types::add_redundant_ngu_up_tnl_info, type_, "Extension");
  return c.get<up_transport_layer_info_pair_list_l>();
}
const secondary_rat_usage_info_s&
pdu_session_res_modify_resp_transfer_ext_ies_o::ext_c::secondary_rat_usage_info() const
{
  assert_choice_type(types::secondary_rat_usage_info, type_, "Extension");
  return c.get<secondary_rat_usage_info_s>();
}
const mbs_support_ind_e& pdu_session_res_modify_resp_transfer_ext_ies_o::ext_c::mbs_support_ind() const
{
  assert_choice_type(types::mbs_support_ind, type_, "Extension");
  return c.get<mbs_support_ind_e>();
}
const mbs_session_setup_resp_list_l&
pdu_session_res_modify_resp_transfer_ext_ies_o::ext_c::mbs_session_setupor_modify_resp_list() const
{
  assert_choice_type(types::mbs_session_setupor_modify_resp_list, type_, "Extension");
  return c.get<mbs_session_setup_resp_list_l>();
}
const mbs_session_failedto_setup_list_l&
pdu_session_res_modify_resp_transfer_ext_ies_o::ext_c::mbs_session_failedto_setupor_modify_list() const
{
  assert_choice_type(types::mbs_session_failedto_setupor_modify_list, type_, "Extension");
  return c.get<mbs_session_failedto_setup_list_l>();
}
void pdu_session_res_modify_resp_transfer_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::add_ngu_up_tnl_info:
      j.start_array("UPTransportLayerInformationPairList");
      for (const auto& e1 : c.get<up_transport_layer_info_pair_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::redundant_dl_ngu_up_tnl_info:
      j.write_fieldname("UPTransportLayerInformation");
      c.get<up_transport_layer_info_c>().to_json(j);
      break;
    case types::redundant_ul_ngu_up_tnl_info:
      j.write_fieldname("UPTransportLayerInformation");
      c.get<up_transport_layer_info_c>().to_json(j);
      break;
    case types::add_redundant_dl_qos_flow_per_tnl_info:
      j.start_array("QosFlowPerTNLInformationList");
      for (const auto& e1 : c.get<qos_flow_per_tnl_info_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::add_redundant_ngu_up_tnl_info:
      j.start_array("UPTransportLayerInformationPairList");
      for (const auto& e1 : c.get<up_transport_layer_info_pair_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::secondary_rat_usage_info:
      j.write_fieldname("SecondaryRATUsageInformation");
      c.get<secondary_rat_usage_info_s>().to_json(j);
      break;
    case types::mbs_support_ind:
      j.write_str("MBS-SupportIndicator", "true");
      break;
    case types::mbs_session_setupor_modify_resp_list:
      j.start_array("MBSSessionSetupResponseList");
      for (const auto& e1 : c.get<mbs_session_setup_resp_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::mbs_session_failedto_setupor_modify_list:
      j.start_array("MBSSessionFailedtoSetupList");
      for (const auto& e1 : c.get<mbs_session_failedto_setup_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_resp_transfer_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE pdu_session_res_modify_resp_transfer_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::add_ngu_up_tnl_info:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<up_transport_layer_info_pair_list_l>(), 1, 3, true));
      break;
    case types::redundant_dl_ngu_up_tnl_info:
      HANDLE_CODE(c.get<up_transport_layer_info_c>().pack(bref));
      break;
    case types::redundant_ul_ngu_up_tnl_info:
      HANDLE_CODE(c.get<up_transport_layer_info_c>().pack(bref));
      break;
    case types::add_redundant_dl_qos_flow_per_tnl_info:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<qos_flow_per_tnl_info_list_l>(), 1, 3, true));
      break;
    case types::add_redundant_ngu_up_tnl_info:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<up_transport_layer_info_pair_list_l>(), 1, 3, true));
      break;
    case types::secondary_rat_usage_info:
      HANDLE_CODE(c.get<secondary_rat_usage_info_s>().pack(bref));
      break;
    case types::mbs_support_ind:
      HANDLE_CODE(c.get<mbs_support_ind_e>().pack(bref));
      break;
    case types::mbs_session_setupor_modify_resp_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<mbs_session_setup_resp_list_l>(), 1, 32, true));
      break;
    case types::mbs_session_failedto_setupor_modify_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<mbs_session_failedto_setup_list_l>(), 1, 32, true));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_resp_transfer_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_modify_resp_transfer_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::add_ngu_up_tnl_info:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<up_transport_layer_info_pair_list_l>(), bref, 1, 3, true));
      break;
    case types::redundant_dl_ngu_up_tnl_info:
      HANDLE_CODE(c.get<up_transport_layer_info_c>().unpack(bref));
      break;
    case types::redundant_ul_ngu_up_tnl_info:
      HANDLE_CODE(c.get<up_transport_layer_info_c>().unpack(bref));
      break;
    case types::add_redundant_dl_qos_flow_per_tnl_info:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<qos_flow_per_tnl_info_list_l>(), bref, 1, 3, true));
      break;
    case types::add_redundant_ngu_up_tnl_info:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<up_transport_layer_info_pair_list_l>(), bref, 1, 3, true));
      break;
    case types::secondary_rat_usage_info:
      HANDLE_CODE(c.get<secondary_rat_usage_info_s>().unpack(bref));
      break;
    case types::mbs_support_ind:
      HANDLE_CODE(c.get<mbs_support_ind_e>().unpack(bref));
      break;
    case types::mbs_session_setupor_modify_resp_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<mbs_session_setup_resp_list_l>(), bref, 1, 32, true));
      break;
    case types::mbs_session_failedto_setupor_modify_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<mbs_session_failedto_setup_list_l>(), bref, 1, 32, true));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_resp_transfer_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* pdu_session_res_modify_resp_transfer_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"UPTransportLayerInformationPairList",
                                "UPTransportLayerInformation",
                                "UPTransportLayerInformation",
                                "QosFlowPerTNLInformationList",
                                "UPTransportLayerInformationPairList",
                                "SecondaryRATUsageInformation",
                                "MBS-SupportIndicator",
                                "MBSSessionSetupResponseList",
                                "MBSSessionFailedtoSetupList"};
  return convert_enum_idx(names, 9, value, "pdu_session_res_modify_resp_transfer_ext_ies_o::ext_c::types");
}

template struct asn1::protocol_ext_field_s<pdu_session_res_modify_resp_transfer_ext_ies_o>;

pdu_session_res_modify_resp_transfer_ext_ies_container::pdu_session_res_modify_resp_transfer_ext_ies_container() :
  add_ngu_up_tnl_info(154, crit_e::ignore),
  redundant_dl_ngu_up_tnl_info(192, crit_e::ignore),
  redundant_ul_ngu_up_tnl_info(195, crit_e::ignore),
  add_redundant_dl_qos_flow_per_tnl_info(184, crit_e::ignore),
  add_redundant_ngu_up_tnl_info(185, crit_e::ignore),
  secondary_rat_usage_info(144, crit_e::ignore),
  mbs_support_ind(309, crit_e::ignore),
  mbs_session_setupor_modify_resp_list(313, crit_e::ignore),
  mbs_session_failedto_setupor_modify_list(311, crit_e::ignore)
{
}
SRSASN_CODE pdu_session_res_modify_resp_transfer_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += add_ngu_up_tnl_info_present ? 1 : 0;
  nof_ies += redundant_dl_ngu_up_tnl_info_present ? 1 : 0;
  nof_ies += redundant_ul_ngu_up_tnl_info_present ? 1 : 0;
  nof_ies += add_redundant_dl_qos_flow_per_tnl_info_present ? 1 : 0;
  nof_ies += add_redundant_ngu_up_tnl_info_present ? 1 : 0;
  nof_ies += secondary_rat_usage_info_present ? 1 : 0;
  nof_ies += mbs_support_ind_present ? 1 : 0;
  nof_ies += mbs_session_setupor_modify_resp_list_present ? 1 : 0;
  nof_ies += mbs_session_failedto_setupor_modify_list_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (add_ngu_up_tnl_info_present) {
    HANDLE_CODE(add_ngu_up_tnl_info.pack(bref));
  }
  if (redundant_dl_ngu_up_tnl_info_present) {
    HANDLE_CODE(redundant_dl_ngu_up_tnl_info.pack(bref));
  }
  if (redundant_ul_ngu_up_tnl_info_present) {
    HANDLE_CODE(redundant_ul_ngu_up_tnl_info.pack(bref));
  }
  if (add_redundant_dl_qos_flow_per_tnl_info_present) {
    HANDLE_CODE(add_redundant_dl_qos_flow_per_tnl_info.pack(bref));
  }
  if (add_redundant_ngu_up_tnl_info_present) {
    HANDLE_CODE(add_redundant_ngu_up_tnl_info.pack(bref));
  }
  if (secondary_rat_usage_info_present) {
    HANDLE_CODE(secondary_rat_usage_info.pack(bref));
  }
  if (mbs_support_ind_present) {
    HANDLE_CODE(mbs_support_ind.pack(bref));
  }
  if (mbs_session_setupor_modify_resp_list_present) {
    HANDLE_CODE(mbs_session_setupor_modify_resp_list.pack(bref));
  }
  if (mbs_session_failedto_setupor_modify_list_present) {
    HANDLE_CODE(mbs_session_failedto_setupor_modify_list.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_modify_resp_transfer_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 154: {
        add_ngu_up_tnl_info_present = true;
        add_ngu_up_tnl_info.id      = id;
        HANDLE_CODE(add_ngu_up_tnl_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(add_ngu_up_tnl_info.ext.unpack(bref));
        break;
      }
      case 192: {
        redundant_dl_ngu_up_tnl_info_present = true;
        redundant_dl_ngu_up_tnl_info.id      = id;
        HANDLE_CODE(redundant_dl_ngu_up_tnl_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(redundant_dl_ngu_up_tnl_info.ext.unpack(bref));
        break;
      }
      case 195: {
        redundant_ul_ngu_up_tnl_info_present = true;
        redundant_ul_ngu_up_tnl_info.id      = id;
        HANDLE_CODE(redundant_ul_ngu_up_tnl_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(redundant_ul_ngu_up_tnl_info.ext.unpack(bref));
        break;
      }
      case 184: {
        add_redundant_dl_qos_flow_per_tnl_info_present = true;
        add_redundant_dl_qos_flow_per_tnl_info.id      = id;
        HANDLE_CODE(add_redundant_dl_qos_flow_per_tnl_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(add_redundant_dl_qos_flow_per_tnl_info.ext.unpack(bref));
        break;
      }
      case 185: {
        add_redundant_ngu_up_tnl_info_present = true;
        add_redundant_ngu_up_tnl_info.id      = id;
        HANDLE_CODE(add_redundant_ngu_up_tnl_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(add_redundant_ngu_up_tnl_info.ext.unpack(bref));
        break;
      }
      case 144: {
        secondary_rat_usage_info_present = true;
        secondary_rat_usage_info.id      = id;
        HANDLE_CODE(secondary_rat_usage_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(secondary_rat_usage_info.ext.unpack(bref));
        break;
      }
      case 309: {
        mbs_support_ind_present = true;
        mbs_support_ind.id      = id;
        HANDLE_CODE(mbs_support_ind.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_support_ind.ext.unpack(bref));
        break;
      }
      case 313: {
        mbs_session_setupor_modify_resp_list_present = true;
        mbs_session_setupor_modify_resp_list.id      = id;
        HANDLE_CODE(mbs_session_setupor_modify_resp_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_setupor_modify_resp_list.ext.unpack(bref));
        break;
      }
      case 311: {
        mbs_session_failedto_setupor_modify_list_present = true;
        mbs_session_failedto_setupor_modify_list.id      = id;
        HANDLE_CODE(mbs_session_failedto_setupor_modify_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_failedto_setupor_modify_list.ext.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_modify_resp_transfer_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (add_ngu_up_tnl_info_present) {
    j.write_fieldname("");
    add_ngu_up_tnl_info.to_json(j);
  }
  if (redundant_dl_ngu_up_tnl_info_present) {
    j.write_fieldname("");
    redundant_dl_ngu_up_tnl_info.to_json(j);
  }
  if (redundant_ul_ngu_up_tnl_info_present) {
    j.write_fieldname("");
    redundant_ul_ngu_up_tnl_info.to_json(j);
  }
  if (add_redundant_dl_qos_flow_per_tnl_info_present) {
    j.write_fieldname("");
    add_redundant_dl_qos_flow_per_tnl_info.to_json(j);
  }
  if (add_redundant_ngu_up_tnl_info_present) {
    j.write_fieldname("");
    add_redundant_ngu_up_tnl_info.to_json(j);
  }
  if (secondary_rat_usage_info_present) {
    j.write_fieldname("");
    secondary_rat_usage_info.to_json(j);
  }
  if (mbs_support_ind_present) {
    j.write_fieldname("");
    mbs_support_ind.to_json(j);
  }
  if (mbs_session_setupor_modify_resp_list_present) {
    j.write_fieldname("");
    mbs_session_setupor_modify_resp_list.to_json(j);
  }
  if (mbs_session_failedto_setupor_modify_list_present) {
    j.write_fieldname("");
    mbs_session_failedto_setupor_modify_list.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceModifyResponseTransfer ::= SEQUENCE
SRSASN_CODE pdu_session_res_modify_resp_transfer_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(dl_ngu_up_tnl_info_present, 1));
  HANDLE_CODE(bref.pack(ul_ngu_up_tnl_info_present, 1));
  HANDLE_CODE(bref.pack(qos_flow_add_or_modify_resp_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(add_dl_qos_flow_per_tnl_info.size() > 0, 1));
  HANDLE_CODE(bref.pack(qos_flow_failed_to_add_or_modify_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (dl_ngu_up_tnl_info_present) {
    HANDLE_CODE(dl_ngu_up_tnl_info.pack(bref));
  }
  if (ul_ngu_up_tnl_info_present) {
    HANDLE_CODE(ul_ngu_up_tnl_info.pack(bref));
  }
  if (qos_flow_add_or_modify_resp_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, qos_flow_add_or_modify_resp_list, 1, 64, true));
  }
  if (add_dl_qos_flow_per_tnl_info.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, add_dl_qos_flow_per_tnl_info, 1, 3, true));
  }
  if (qos_flow_failed_to_add_or_modify_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, qos_flow_failed_to_add_or_modify_list, 1, 64, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_modify_resp_transfer_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(dl_ngu_up_tnl_info_present, 1));
  HANDLE_CODE(bref.unpack(ul_ngu_up_tnl_info_present, 1));
  bool qos_flow_add_or_modify_resp_list_present;
  HANDLE_CODE(bref.unpack(qos_flow_add_or_modify_resp_list_present, 1));
  bool add_dl_qos_flow_per_tnl_info_present;
  HANDLE_CODE(bref.unpack(add_dl_qos_flow_per_tnl_info_present, 1));
  bool qos_flow_failed_to_add_or_modify_list_present;
  HANDLE_CODE(bref.unpack(qos_flow_failed_to_add_or_modify_list_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (dl_ngu_up_tnl_info_present) {
    HANDLE_CODE(dl_ngu_up_tnl_info.unpack(bref));
  }
  if (ul_ngu_up_tnl_info_present) {
    HANDLE_CODE(ul_ngu_up_tnl_info.unpack(bref));
  }
  if (qos_flow_add_or_modify_resp_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(qos_flow_add_or_modify_resp_list, bref, 1, 64, true));
  }
  if (add_dl_qos_flow_per_tnl_info_present) {
    HANDLE_CODE(unpack_dyn_seq_of(add_dl_qos_flow_per_tnl_info, bref, 1, 3, true));
  }
  if (qos_flow_failed_to_add_or_modify_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(qos_flow_failed_to_add_or_modify_list, bref, 1, 64, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_modify_resp_transfer_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (dl_ngu_up_tnl_info_present) {
    j.write_fieldname("dL-NGU-UP-TNLInformation");
    dl_ngu_up_tnl_info.to_json(j);
  }
  if (ul_ngu_up_tnl_info_present) {
    j.write_fieldname("uL-NGU-UP-TNLInformation");
    ul_ngu_up_tnl_info.to_json(j);
  }
  if (qos_flow_add_or_modify_resp_list.size() > 0) {
    j.start_array("qosFlowAddOrModifyResponseList");
    for (const auto& e1 : qos_flow_add_or_modify_resp_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (add_dl_qos_flow_per_tnl_info.size() > 0) {
    j.start_array("additionalDLQosFlowPerTNLInformation");
    for (const auto& e1 : add_dl_qos_flow_per_tnl_info) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (qos_flow_failed_to_add_or_modify_list.size() > 0) {
    j.start_array("qosFlowFailedToAddOrModifyList");
    for (const auto& e1 : qos_flow_failed_to_add_or_modify_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceModifyUnsuccessfulTransfer ::= SEQUENCE
SRSASN_CODE pdu_session_res_modify_unsuccessful_transfer_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(crit_diagnostics_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(cause.pack(bref));
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_modify_unsuccessful_transfer_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(crit_diagnostics_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(cause.unpack(bref));
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_modify_unsuccessful_transfer_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("cause");
  cause.to_json(j);
  if (crit_diagnostics_present) {
    j.write_fieldname("criticalityDiagnostics");
    crit_diagnostics.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceNotifyReleasedTransfer-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t pdu_session_res_notify_released_transfer_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {144};
  return map_enum_number(names, 1, idx, "id");
}
bool pdu_session_res_notify_released_transfer_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 144 == id;
}
crit_e pdu_session_res_notify_released_transfer_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 144) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
pdu_session_res_notify_released_transfer_ext_ies_o::ext_c
pdu_session_res_notify_released_transfer_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 144) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pdu_session_res_notify_released_transfer_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 144) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void pdu_session_res_notify_released_transfer_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("SecondaryRATUsageInformation");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE pdu_session_res_notify_released_transfer_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_notify_released_transfer_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* pdu_session_res_notify_released_transfer_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"SecondaryRATUsageInformation"};
  return convert_enum_idx(names, 1, value, "pdu_session_res_notify_released_transfer_ext_ies_o::ext_c::types");
}

// PDUSessionResourceNotifyReleasedTransfer ::= SEQUENCE
SRSASN_CODE pdu_session_res_notify_released_transfer_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(cause.pack(bref));
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_notify_released_transfer_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(cause.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_notify_released_transfer_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("cause");
  cause.to_json(j);
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// NotificationCause ::= ENUMERATED
const char* notif_cause_opts::to_string() const
{
  static const char* names[] = {"fulfilled", "not-fulfilled"};
  return convert_enum_idx(names, 2, value, "notif_cause_e");
}

// QosFlowFeedbackItem ::= SEQUENCE
SRSASN_CODE qos_flow_feedback_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(upd_feedback_present, 1));
  HANDLE_CODE(bref.pack(cnpacket_delay_budget_dl_present, 1));
  HANDLE_CODE(bref.pack(cnpacket_delay_budget_ul_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, qos_flow_id, (uint8_t)0u, (uint8_t)63u, true, true));
  if (upd_feedback_present) {
    HANDLE_CODE(upd_feedback.pack(bref));
  }
  if (cnpacket_delay_budget_dl_present) {
    HANDLE_CODE(pack_integer(bref, cnpacket_delay_budget_dl, (uint32_t)1u, (uint32_t)65535u, true, true));
  }
  if (cnpacket_delay_budget_ul_present) {
    HANDLE_CODE(pack_integer(bref, cnpacket_delay_budget_ul, (uint32_t)1u, (uint32_t)65535u, true, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_flow_feedback_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(upd_feedback_present, 1));
  HANDLE_CODE(bref.unpack(cnpacket_delay_budget_dl_present, 1));
  HANDLE_CODE(bref.unpack(cnpacket_delay_budget_ul_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(qos_flow_id, bref, (uint8_t)0u, (uint8_t)63u, true, true));
  if (upd_feedback_present) {
    HANDLE_CODE(upd_feedback.unpack(bref));
  }
  if (cnpacket_delay_budget_dl_present) {
    HANDLE_CODE(unpack_integer(cnpacket_delay_budget_dl, bref, (uint32_t)1u, (uint32_t)65535u, true, true));
  }
  if (cnpacket_delay_budget_ul_present) {
    HANDLE_CODE(unpack_integer(cnpacket_delay_budget_ul, bref, (uint32_t)1u, (uint32_t)65535u, true, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void qos_flow_feedback_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("qosFlowIdentifier", qos_flow_id);
  if (upd_feedback_present) {
    j.write_str("updateFeedback", upd_feedback.to_string());
  }
  if (cnpacket_delay_budget_dl_present) {
    j.write_int("cNpacketDelayBudgetDL", cnpacket_delay_budget_dl);
  }
  if (cnpacket_delay_budget_ul_present) {
    j.write_int("cNpacketDelayBudgetUL", cnpacket_delay_budget_ul);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// QosFlowNotifyItem-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t qos_flow_notify_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {221};
  return map_enum_number(names, 1, idx, "id");
}
bool qos_flow_notify_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 221 == id;
}
crit_e qos_flow_notify_item_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 221) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
qos_flow_notify_item_ext_ies_o::ext_c qos_flow_notify_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 221) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e qos_flow_notify_item_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 221) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void qos_flow_notify_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("INTEGER (0..8,...)", c);
  j.end_obj();
}
SRSASN_CODE qos_flow_notify_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(pack_integer(bref, c, (uint8_t)0u, (uint8_t)8u, true, true));
  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_flow_notify_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(unpack_integer(c, bref, (uint8_t)0u, (uint8_t)8u, true, true));
  return SRSASN_SUCCESS;
}

const char* qos_flow_notify_item_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..8,...)"};
  return convert_enum_idx(names, 1, value, "qos_flow_notify_item_ext_ies_o::ext_c::types");
}
uint8_t qos_flow_notify_item_ext_ies_o::ext_c::types_opts::to_number() const
{
  static const uint8_t numbers[] = {0};
  return map_enum_number(numbers, 1, value, "qos_flow_notify_item_ext_ies_o::ext_c::types");
}

// QosFlowNotifyItem ::= SEQUENCE
SRSASN_CODE qos_flow_notify_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(pack_integer(bref, qos_flow_id, (uint8_t)0u, (uint8_t)63u, true, true));
  HANDLE_CODE(notif_cause.pack(bref));
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_flow_notify_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(qos_flow_id, bref, (uint8_t)0u, (uint8_t)63u, true, true));
  HANDLE_CODE(notif_cause.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void qos_flow_notify_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("qosFlowIdentifier", qos_flow_id);
  j.write_str("notificationCause", notif_cause.to_string());
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// PDUSessionResourceNotifyTransfer-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t pdu_session_res_notify_transfer_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {144, 278};
  return map_enum_number(names, 2, idx, "id");
}
bool pdu_session_res_notify_transfer_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {144, 278};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e pdu_session_res_notify_transfer_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 144:
      return crit_e::ignore;
    case 278:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
pdu_session_res_notify_transfer_ext_ies_o::ext_c pdu_session_res_notify_transfer_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 144:
      ret.set(ext_c::types::secondary_rat_usage_info);
      break;
    case 278:
      ret.set(ext_c::types::qos_flow_feedback_list);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pdu_session_res_notify_transfer_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 144:
      return presence_e::optional;
    case 278:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void pdu_session_res_notify_transfer_ext_ies_o::ext_c::destroy_()
{
  switch (type_) {
    case types::secondary_rat_usage_info:
      c.destroy<secondary_rat_usage_info_s>();
      break;
    case types::qos_flow_feedback_list:
      c.destroy<qos_flow_feedback_list_l>();
      break;
    default:
      break;
  }
}
void pdu_session_res_notify_transfer_ext_ies_o::ext_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::secondary_rat_usage_info:
      c.init<secondary_rat_usage_info_s>();
      break;
    case types::qos_flow_feedback_list:
      c.init<qos_flow_feedback_list_l>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_notify_transfer_ext_ies_o::ext_c");
  }
}
pdu_session_res_notify_transfer_ext_ies_o::ext_c::ext_c(const pdu_session_res_notify_transfer_ext_ies_o::ext_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::secondary_rat_usage_info:
      c.init(other.c.get<secondary_rat_usage_info_s>());
      break;
    case types::qos_flow_feedback_list:
      c.init(other.c.get<qos_flow_feedback_list_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_notify_transfer_ext_ies_o::ext_c");
  }
}
pdu_session_res_notify_transfer_ext_ies_o::ext_c& pdu_session_res_notify_transfer_ext_ies_o::ext_c::operator=(
    const pdu_session_res_notify_transfer_ext_ies_o::ext_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::secondary_rat_usage_info:
      c.set(other.c.get<secondary_rat_usage_info_s>());
      break;
    case types::qos_flow_feedback_list:
      c.set(other.c.get<qos_flow_feedback_list_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_notify_transfer_ext_ies_o::ext_c");
  }

  return *this;
}
secondary_rat_usage_info_s& pdu_session_res_notify_transfer_ext_ies_o::ext_c::secondary_rat_usage_info()
{
  assert_choice_type(types::secondary_rat_usage_info, type_, "Extension");
  return c.get<secondary_rat_usage_info_s>();
}
qos_flow_feedback_list_l& pdu_session_res_notify_transfer_ext_ies_o::ext_c::qos_flow_feedback_list()
{
  assert_choice_type(types::qos_flow_feedback_list, type_, "Extension");
  return c.get<qos_flow_feedback_list_l>();
}
const secondary_rat_usage_info_s& pdu_session_res_notify_transfer_ext_ies_o::ext_c::secondary_rat_usage_info() const
{
  assert_choice_type(types::secondary_rat_usage_info, type_, "Extension");
  return c.get<secondary_rat_usage_info_s>();
}
const qos_flow_feedback_list_l& pdu_session_res_notify_transfer_ext_ies_o::ext_c::qos_flow_feedback_list() const
{
  assert_choice_type(types::qos_flow_feedback_list, type_, "Extension");
  return c.get<qos_flow_feedback_list_l>();
}
void pdu_session_res_notify_transfer_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::secondary_rat_usage_info:
      j.write_fieldname("SecondaryRATUsageInformation");
      c.get<secondary_rat_usage_info_s>().to_json(j);
      break;
    case types::qos_flow_feedback_list:
      j.start_array("QosFlowFeedbackList");
      for (const auto& e1 : c.get<qos_flow_feedback_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_notify_transfer_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE pdu_session_res_notify_transfer_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::secondary_rat_usage_info:
      HANDLE_CODE(c.get<secondary_rat_usage_info_s>().pack(bref));
      break;
    case types::qos_flow_feedback_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<qos_flow_feedback_list_l>(), 1, 64, true));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_notify_transfer_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_notify_transfer_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::secondary_rat_usage_info:
      HANDLE_CODE(c.get<secondary_rat_usage_info_s>().unpack(bref));
      break;
    case types::qos_flow_feedback_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<qos_flow_feedback_list_l>(), bref, 1, 64, true));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_notify_transfer_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* pdu_session_res_notify_transfer_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"SecondaryRATUsageInformation", "QosFlowFeedbackList"};
  return convert_enum_idx(names, 2, value, "pdu_session_res_notify_transfer_ext_ies_o::ext_c::types");
}

template struct asn1::protocol_ext_field_s<pdu_session_res_notify_transfer_ext_ies_o>;

pdu_session_res_notify_transfer_ext_ies_container::pdu_session_res_notify_transfer_ext_ies_container() :
  secondary_rat_usage_info(144, crit_e::ignore), qos_flow_feedback_list(278, crit_e::ignore)
{
}
SRSASN_CODE pdu_session_res_notify_transfer_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += secondary_rat_usage_info_present ? 1 : 0;
  nof_ies += qos_flow_feedback_list_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (secondary_rat_usage_info_present) {
    HANDLE_CODE(secondary_rat_usage_info.pack(bref));
  }
  if (qos_flow_feedback_list_present) {
    HANDLE_CODE(qos_flow_feedback_list.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_notify_transfer_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 144: {
        secondary_rat_usage_info_present = true;
        secondary_rat_usage_info.id      = id;
        HANDLE_CODE(secondary_rat_usage_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(secondary_rat_usage_info.ext.unpack(bref));
        break;
      }
      case 278: {
        qos_flow_feedback_list_present = true;
        qos_flow_feedback_list.id      = id;
        HANDLE_CODE(qos_flow_feedback_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(qos_flow_feedback_list.ext.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_notify_transfer_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (secondary_rat_usage_info_present) {
    j.write_fieldname("");
    secondary_rat_usage_info.to_json(j);
  }
  if (qos_flow_feedback_list_present) {
    j.write_fieldname("");
    qos_flow_feedback_list.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceNotifyTransfer ::= SEQUENCE
SRSASN_CODE pdu_session_res_notify_transfer_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(qos_flow_notify_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(qos_flow_released_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (qos_flow_notify_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, qos_flow_notify_list, 1, 64, true));
  }
  if (qos_flow_released_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, qos_flow_released_list, 1, 64, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_notify_transfer_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool qos_flow_notify_list_present;
  HANDLE_CODE(bref.unpack(qos_flow_notify_list_present, 1));
  bool qos_flow_released_list_present;
  HANDLE_CODE(bref.unpack(qos_flow_released_list_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (qos_flow_notify_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(qos_flow_notify_list, bref, 1, 64, true));
  }
  if (qos_flow_released_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(qos_flow_released_list, bref, 1, 64, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_notify_transfer_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (qos_flow_notify_list.size() > 0) {
    j.start_array("qosFlowNotifyList");
    for (const auto& e1 : qos_flow_notify_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (qos_flow_released_list.size() > 0) {
    j.start_array("qosFlowReleasedList");
    for (const auto& e1 : qos_flow_released_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceReleaseCommandTransfer ::= SEQUENCE
SRSASN_CODE pdu_session_res_release_cmd_transfer_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(cause.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_release_cmd_transfer_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(cause.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_release_cmd_transfer_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("cause");
  cause.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceReleaseResponseTransfer-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t pdu_session_res_release_resp_transfer_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {144};
  return map_enum_number(names, 1, idx, "id");
}
bool pdu_session_res_release_resp_transfer_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 144 == id;
}
crit_e pdu_session_res_release_resp_transfer_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 144) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
pdu_session_res_release_resp_transfer_ext_ies_o::ext_c
pdu_session_res_release_resp_transfer_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 144) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pdu_session_res_release_resp_transfer_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 144) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void pdu_session_res_release_resp_transfer_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("SecondaryRATUsageInformation");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE pdu_session_res_release_resp_transfer_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_release_resp_transfer_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

const char* pdu_session_res_release_resp_transfer_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"SecondaryRATUsageInformation"};
  return convert_enum_idx(names, 1, value, "pdu_session_res_release_resp_transfer_ext_ies_o::ext_c::types");
}

// PDUSessionResourceReleaseResponseTransfer ::= SEQUENCE
SRSASN_CODE pdu_session_res_release_resp_transfer_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_release_resp_transfer_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_release_resp_transfer_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// QosFlowSetupRequestItem-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t qos_flow_setup_request_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {196, 194};
  return map_enum_number(names, 2, idx, "id");
}
bool qos_flow_setup_request_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {196, 194};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e qos_flow_setup_request_item_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 196:
      return crit_e::ignore;
    case 194:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
qos_flow_setup_request_item_ext_ies_o::ext_c qos_flow_setup_request_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 196:
      ret.set(ext_c::types::tsc_traffic_characteristics);
      break;
    case 194:
      ret.set(ext_c::types::redundant_qos_flow_ind);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e qos_flow_setup_request_item_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 196:
      return presence_e::optional;
    case 194:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void qos_flow_setup_request_item_ext_ies_o::ext_c::destroy_()
{
  switch (type_) {
    case types::tsc_traffic_characteristics:
      c.destroy<tsc_traffic_characteristics_s>();
      break;
    default:
      break;
  }
}
void qos_flow_setup_request_item_ext_ies_o::ext_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::tsc_traffic_characteristics:
      c.init<tsc_traffic_characteristics_s>();
      break;
    case types::redundant_qos_flow_ind:
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "qos_flow_setup_request_item_ext_ies_o::ext_c");
  }
}
qos_flow_setup_request_item_ext_ies_o::ext_c::ext_c(const qos_flow_setup_request_item_ext_ies_o::ext_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::tsc_traffic_characteristics:
      c.init(other.c.get<tsc_traffic_characteristics_s>());
      break;
    case types::redundant_qos_flow_ind:
      c.init(other.c.get<redundant_qos_flow_ind_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "qos_flow_setup_request_item_ext_ies_o::ext_c");
  }
}
qos_flow_setup_request_item_ext_ies_o::ext_c&
qos_flow_setup_request_item_ext_ies_o::ext_c::operator=(const qos_flow_setup_request_item_ext_ies_o::ext_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::tsc_traffic_characteristics:
      c.set(other.c.get<tsc_traffic_characteristics_s>());
      break;
    case types::redundant_qos_flow_ind:
      c.set(other.c.get<redundant_qos_flow_ind_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "qos_flow_setup_request_item_ext_ies_o::ext_c");
  }

  return *this;
}
tsc_traffic_characteristics_s& qos_flow_setup_request_item_ext_ies_o::ext_c::tsc_traffic_characteristics()
{
  assert_choice_type(types::tsc_traffic_characteristics, type_, "Extension");
  return c.get<tsc_traffic_characteristics_s>();
}
redundant_qos_flow_ind_e& qos_flow_setup_request_item_ext_ies_o::ext_c::redundant_qos_flow_ind()
{
  assert_choice_type(types::redundant_qos_flow_ind, type_, "Extension");
  return c.get<redundant_qos_flow_ind_e>();
}
const tsc_traffic_characteristics_s& qos_flow_setup_request_item_ext_ies_o::ext_c::tsc_traffic_characteristics() const
{
  assert_choice_type(types::tsc_traffic_characteristics, type_, "Extension");
  return c.get<tsc_traffic_characteristics_s>();
}
const redundant_qos_flow_ind_e& qos_flow_setup_request_item_ext_ies_o::ext_c::redundant_qos_flow_ind() const
{
  assert_choice_type(types::redundant_qos_flow_ind, type_, "Extension");
  return c.get<redundant_qos_flow_ind_e>();
}
void qos_flow_setup_request_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::tsc_traffic_characteristics:
      j.write_fieldname("TSCTrafficCharacteristics");
      c.get<tsc_traffic_characteristics_s>().to_json(j);
      break;
    case types::redundant_qos_flow_ind:
      j.write_str("RedundantQosFlowIndicator", c.get<redundant_qos_flow_ind_e>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "qos_flow_setup_request_item_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE qos_flow_setup_request_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::tsc_traffic_characteristics:
      HANDLE_CODE(c.get<tsc_traffic_characteristics_s>().pack(bref));
      break;
    case types::redundant_qos_flow_ind:
      HANDLE_CODE(c.get<redundant_qos_flow_ind_e>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "qos_flow_setup_request_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_flow_setup_request_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::tsc_traffic_characteristics:
      HANDLE_CODE(c.get<tsc_traffic_characteristics_s>().unpack(bref));
      break;
    case types::redundant_qos_flow_ind:
      HANDLE_CODE(c.get<redundant_qos_flow_ind_e>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "qos_flow_setup_request_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* qos_flow_setup_request_item_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"TSCTrafficCharacteristics", "RedundantQosFlowIndicator"};
  return convert_enum_idx(names, 2, value, "qos_flow_setup_request_item_ext_ies_o::ext_c::types");
}

template struct asn1::protocol_ext_field_s<qos_flow_setup_request_item_ext_ies_o>;

qos_flow_setup_request_item_ext_ies_container::qos_flow_setup_request_item_ext_ies_container() :
  tsc_traffic_characteristics(196, crit_e::ignore), redundant_qos_flow_ind(194, crit_e::ignore)
{
}
SRSASN_CODE qos_flow_setup_request_item_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += tsc_traffic_characteristics_present ? 1 : 0;
  nof_ies += redundant_qos_flow_ind_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (tsc_traffic_characteristics_present) {
    HANDLE_CODE(tsc_traffic_characteristics.pack(bref));
  }
  if (redundant_qos_flow_ind_present) {
    HANDLE_CODE(redundant_qos_flow_ind.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_flow_setup_request_item_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 196: {
        tsc_traffic_characteristics_present = true;
        tsc_traffic_characteristics.id      = id;
        HANDLE_CODE(tsc_traffic_characteristics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(tsc_traffic_characteristics.ext.unpack(bref));
        break;
      }
      case 194: {
        redundant_qos_flow_ind_present = true;
        redundant_qos_flow_ind.id      = id;
        HANDLE_CODE(redundant_qos_flow_ind.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(redundant_qos_flow_ind.ext.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void qos_flow_setup_request_item_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (tsc_traffic_characteristics_present) {
    j.write_fieldname("");
    tsc_traffic_characteristics.to_json(j);
  }
  if (redundant_qos_flow_ind_present) {
    j.write_fieldname("");
    redundant_qos_flow_ind.to_json(j);
  }
  j.end_obj();
}

// QosFlowSetupRequestItem ::= SEQUENCE
SRSASN_CODE qos_flow_setup_request_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(erab_id_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, qos_flow_id, (uint8_t)0u, (uint8_t)63u, true, true));
  HANDLE_CODE(qos_flow_level_qos_params.pack(bref));
  if (erab_id_present) {
    HANDLE_CODE(pack_integer(bref, erab_id, (uint8_t)0u, (uint8_t)15u, true, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_flow_setup_request_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(erab_id_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(qos_flow_id, bref, (uint8_t)0u, (uint8_t)63u, true, true));
  HANDLE_CODE(qos_flow_level_qos_params.unpack(bref));
  if (erab_id_present) {
    HANDLE_CODE(unpack_integer(erab_id, bref, (uint8_t)0u, (uint8_t)15u, true, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void qos_flow_setup_request_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("qosFlowIdentifier", qos_flow_id);
  j.write_fieldname("qosFlowLevelQosParameters");
  qos_flow_level_qos_params.to_json(j);
  if (erab_id_present) {
    j.write_int("e-RAB-ID", erab_id);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// DataForwardingNotPossible ::= ENUMERATED
const char* data_forwarding_not_possible_opts::to_string() const
{
  static const char* names[] = {"data-forwarding-not-possible"};
  return convert_enum_idx(names, 1, value, "data_forwarding_not_possible_e");
}

// PDUSessionType ::= ENUMERATED
const char* pdu_session_type_opts::to_string() const
{
  static const char* names[] = {"ipv4", "ipv6", "ipv4v6", "ethernet", "unstructured"};
  return convert_enum_idx(names, 5, value, "pdu_session_type_e");
}

// PDUSessionResourceSetupRequestTransferIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t pdu_session_res_setup_request_transfer_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {130, 139, 126, 127, 134, 138, 129, 136, 166, 22, 195, 186, 190, 197, 318};
  return map_enum_number(names, 15, idx, "id");
}
bool pdu_session_res_setup_request_transfer_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {130, 139, 126, 127, 134, 138, 129, 136, 166, 22, 195, 186, 190, 197, 318};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e pdu_session_res_setup_request_transfer_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 130:
      return crit_e::reject;
    case 139:
      return crit_e::reject;
    case 126:
      return crit_e::reject;
    case 127:
      return crit_e::reject;
    case 134:
      return crit_e::reject;
    case 138:
      return crit_e::reject;
    case 129:
      return crit_e::reject;
    case 136:
      return crit_e::reject;
    case 166:
      return crit_e::ignore;
    case 22:
      return crit_e::ignore;
    case 195:
      return crit_e::ignore;
    case 186:
      return crit_e::ignore;
    case 190:
      return crit_e::ignore;
    case 197:
      return crit_e::ignore;
    case 318:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
pdu_session_res_setup_request_transfer_ies_o::value_c
pdu_session_res_setup_request_transfer_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 130:
      ret.set(value_c::types::pdu_session_aggr_max_bit_rate);
      break;
    case 139:
      ret.set(value_c::types::ul_ngu_up_tnl_info);
      break;
    case 126:
      ret.set(value_c::types::add_ul_ngu_up_tnl_info);
      break;
    case 127:
      ret.set(value_c::types::data_forwarding_not_possible);
      break;
    case 134:
      ret.set(value_c::types::pdu_session_type);
      break;
    case 138:
      ret.set(value_c::types::security_ind);
      break;
    case 129:
      ret.set(value_c::types::network_instance);
      break;
    case 136:
      ret.set(value_c::types::qos_flow_setup_request_list);
      break;
    case 166:
      ret.set(value_c::types::common_network_instance);
      break;
    case 22:
      ret.set(value_c::types::direct_forwarding_path_availability);
      break;
    case 195:
      ret.set(value_c::types::redundant_ul_ngu_up_tnl_info);
      break;
    case 186:
      ret.set(value_c::types::add_redundant_ul_ngu_up_tnl_info);
      break;
    case 190:
      ret.set(value_c::types::redundant_common_network_instance);
      break;
    case 197:
      ret.set(value_c::types::redundant_pdu_session_info);
      break;
    case 318:
      ret.set(value_c::types::mbs_session_setup_request_list);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pdu_session_res_setup_request_transfer_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 130:
      return presence_e::optional;
    case 139:
      return presence_e::mandatory;
    case 126:
      return presence_e::optional;
    case 127:
      return presence_e::optional;
    case 134:
      return presence_e::mandatory;
    case 138:
      return presence_e::optional;
    case 129:
      return presence_e::optional;
    case 136:
      return presence_e::mandatory;
    case 166:
      return presence_e::optional;
    case 22:
      return presence_e::optional;
    case 195:
      return presence_e::optional;
    case 186:
      return presence_e::optional;
    case 190:
      return presence_e::optional;
    case 197:
      return presence_e::optional;
    case 318:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void pdu_session_res_setup_request_transfer_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::pdu_session_aggr_max_bit_rate:
      c.destroy<pdu_session_aggr_max_bit_rate_s>();
      break;
    case types::ul_ngu_up_tnl_info:
      c.destroy<up_transport_layer_info_c>();
      break;
    case types::add_ul_ngu_up_tnl_info:
      c.destroy<up_transport_layer_info_list_l>();
      break;
    case types::security_ind:
      c.destroy<security_ind_s>();
      break;
    case types::qos_flow_setup_request_list:
      c.destroy<qos_flow_setup_request_list_l>();
      break;
    case types::common_network_instance:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::redundant_ul_ngu_up_tnl_info:
      c.destroy<up_transport_layer_info_c>();
      break;
    case types::add_redundant_ul_ngu_up_tnl_info:
      c.destroy<up_transport_layer_info_list_l>();
      break;
    case types::redundant_common_network_instance:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::redundant_pdu_session_info:
      c.destroy<redundant_pdu_session_info_s>();
      break;
    case types::mbs_session_setup_request_list:
      c.destroy<mbs_session_setup_request_list_l>();
      break;
    default:
      break;
  }
}
void pdu_session_res_setup_request_transfer_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::pdu_session_aggr_max_bit_rate:
      c.init<pdu_session_aggr_max_bit_rate_s>();
      break;
    case types::ul_ngu_up_tnl_info:
      c.init<up_transport_layer_info_c>();
      break;
    case types::add_ul_ngu_up_tnl_info:
      c.init<up_transport_layer_info_list_l>();
      break;
    case types::data_forwarding_not_possible:
      break;
    case types::pdu_session_type:
      break;
    case types::security_ind:
      c.init<security_ind_s>();
      break;
    case types::network_instance:
      break;
    case types::qos_flow_setup_request_list:
      c.init<qos_flow_setup_request_list_l>();
      break;
    case types::common_network_instance:
      c.init<unbounded_octstring<true>>();
      break;
    case types::direct_forwarding_path_availability:
      break;
    case types::redundant_ul_ngu_up_tnl_info:
      c.init<up_transport_layer_info_c>();
      break;
    case types::add_redundant_ul_ngu_up_tnl_info:
      c.init<up_transport_layer_info_list_l>();
      break;
    case types::redundant_common_network_instance:
      c.init<unbounded_octstring<true>>();
      break;
    case types::redundant_pdu_session_info:
      c.init<redundant_pdu_session_info_s>();
      break;
    case types::mbs_session_setup_request_list:
      c.init<mbs_session_setup_request_list_l>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_setup_request_transfer_ies_o::value_c");
  }
}
pdu_session_res_setup_request_transfer_ies_o::value_c::value_c(
    const pdu_session_res_setup_request_transfer_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::pdu_session_aggr_max_bit_rate:
      c.init(other.c.get<pdu_session_aggr_max_bit_rate_s>());
      break;
    case types::ul_ngu_up_tnl_info:
      c.init(other.c.get<up_transport_layer_info_c>());
      break;
    case types::add_ul_ngu_up_tnl_info:
      c.init(other.c.get<up_transport_layer_info_list_l>());
      break;
    case types::data_forwarding_not_possible:
      c.init(other.c.get<data_forwarding_not_possible_e>());
      break;
    case types::pdu_session_type:
      c.init(other.c.get<pdu_session_type_e>());
      break;
    case types::security_ind:
      c.init(other.c.get<security_ind_s>());
      break;
    case types::network_instance:
      c.init(other.c.get<uint16_t>());
      break;
    case types::qos_flow_setup_request_list:
      c.init(other.c.get<qos_flow_setup_request_list_l>());
      break;
    case types::common_network_instance:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::direct_forwarding_path_availability:
      c.init(other.c.get<direct_forwarding_path_availability_e>());
      break;
    case types::redundant_ul_ngu_up_tnl_info:
      c.init(other.c.get<up_transport_layer_info_c>());
      break;
    case types::add_redundant_ul_ngu_up_tnl_info:
      c.init(other.c.get<up_transport_layer_info_list_l>());
      break;
    case types::redundant_common_network_instance:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::redundant_pdu_session_info:
      c.init(other.c.get<redundant_pdu_session_info_s>());
      break;
    case types::mbs_session_setup_request_list:
      c.init(other.c.get<mbs_session_setup_request_list_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_setup_request_transfer_ies_o::value_c");
  }
}
pdu_session_res_setup_request_transfer_ies_o::value_c& pdu_session_res_setup_request_transfer_ies_o::value_c::operator=(
    const pdu_session_res_setup_request_transfer_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::pdu_session_aggr_max_bit_rate:
      c.set(other.c.get<pdu_session_aggr_max_bit_rate_s>());
      break;
    case types::ul_ngu_up_tnl_info:
      c.set(other.c.get<up_transport_layer_info_c>());
      break;
    case types::add_ul_ngu_up_tnl_info:
      c.set(other.c.get<up_transport_layer_info_list_l>());
      break;
    case types::data_forwarding_not_possible:
      c.set(other.c.get<data_forwarding_not_possible_e>());
      break;
    case types::pdu_session_type:
      c.set(other.c.get<pdu_session_type_e>());
      break;
    case types::security_ind:
      c.set(other.c.get<security_ind_s>());
      break;
    case types::network_instance:
      c.set(other.c.get<uint16_t>());
      break;
    case types::qos_flow_setup_request_list:
      c.set(other.c.get<qos_flow_setup_request_list_l>());
      break;
    case types::common_network_instance:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::direct_forwarding_path_availability:
      c.set(other.c.get<direct_forwarding_path_availability_e>());
      break;
    case types::redundant_ul_ngu_up_tnl_info:
      c.set(other.c.get<up_transport_layer_info_c>());
      break;
    case types::add_redundant_ul_ngu_up_tnl_info:
      c.set(other.c.get<up_transport_layer_info_list_l>());
      break;
    case types::redundant_common_network_instance:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::redundant_pdu_session_info:
      c.set(other.c.get<redundant_pdu_session_info_s>());
      break;
    case types::mbs_session_setup_request_list:
      c.set(other.c.get<mbs_session_setup_request_list_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_setup_request_transfer_ies_o::value_c");
  }

  return *this;
}
pdu_session_aggr_max_bit_rate_s& pdu_session_res_setup_request_transfer_ies_o::value_c::pdu_session_aggr_max_bit_rate()
{
  assert_choice_type(types::pdu_session_aggr_max_bit_rate, type_, "Value");
  return c.get<pdu_session_aggr_max_bit_rate_s>();
}
up_transport_layer_info_c& pdu_session_res_setup_request_transfer_ies_o::value_c::ul_ngu_up_tnl_info()
{
  assert_choice_type(types::ul_ngu_up_tnl_info, type_, "Value");
  return c.get<up_transport_layer_info_c>();
}
up_transport_layer_info_list_l& pdu_session_res_setup_request_transfer_ies_o::value_c::add_ul_ngu_up_tnl_info()
{
  assert_choice_type(types::add_ul_ngu_up_tnl_info, type_, "Value");
  return c.get<up_transport_layer_info_list_l>();
}
data_forwarding_not_possible_e& pdu_session_res_setup_request_transfer_ies_o::value_c::data_forwarding_not_possible()
{
  assert_choice_type(types::data_forwarding_not_possible, type_, "Value");
  return c.get<data_forwarding_not_possible_e>();
}
pdu_session_type_e& pdu_session_res_setup_request_transfer_ies_o::value_c::pdu_session_type()
{
  assert_choice_type(types::pdu_session_type, type_, "Value");
  return c.get<pdu_session_type_e>();
}
security_ind_s& pdu_session_res_setup_request_transfer_ies_o::value_c::security_ind()
{
  assert_choice_type(types::security_ind, type_, "Value");
  return c.get<security_ind_s>();
}
uint16_t& pdu_session_res_setup_request_transfer_ies_o::value_c::network_instance()
{
  assert_choice_type(types::network_instance, type_, "Value");
  return c.get<uint16_t>();
}
qos_flow_setup_request_list_l& pdu_session_res_setup_request_transfer_ies_o::value_c::qos_flow_setup_request_list()
{
  assert_choice_type(types::qos_flow_setup_request_list, type_, "Value");
  return c.get<qos_flow_setup_request_list_l>();
}
unbounded_octstring<true>& pdu_session_res_setup_request_transfer_ies_o::value_c::common_network_instance()
{
  assert_choice_type(types::common_network_instance, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
direct_forwarding_path_availability_e&
pdu_session_res_setup_request_transfer_ies_o::value_c::direct_forwarding_path_availability()
{
  assert_choice_type(types::direct_forwarding_path_availability, type_, "Value");
  return c.get<direct_forwarding_path_availability_e>();
}
up_transport_layer_info_c& pdu_session_res_setup_request_transfer_ies_o::value_c::redundant_ul_ngu_up_tnl_info()
{
  assert_choice_type(types::redundant_ul_ngu_up_tnl_info, type_, "Value");
  return c.get<up_transport_layer_info_c>();
}
up_transport_layer_info_list_l&
pdu_session_res_setup_request_transfer_ies_o::value_c::add_redundant_ul_ngu_up_tnl_info()
{
  assert_choice_type(types::add_redundant_ul_ngu_up_tnl_info, type_, "Value");
  return c.get<up_transport_layer_info_list_l>();
}
unbounded_octstring<true>& pdu_session_res_setup_request_transfer_ies_o::value_c::redundant_common_network_instance()
{
  assert_choice_type(types::redundant_common_network_instance, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
redundant_pdu_session_info_s& pdu_session_res_setup_request_transfer_ies_o::value_c::redundant_pdu_session_info()
{
  assert_choice_type(types::redundant_pdu_session_info, type_, "Value");
  return c.get<redundant_pdu_session_info_s>();
}
mbs_session_setup_request_list_l&
pdu_session_res_setup_request_transfer_ies_o::value_c::mbs_session_setup_request_list()
{
  assert_choice_type(types::mbs_session_setup_request_list, type_, "Value");
  return c.get<mbs_session_setup_request_list_l>();
}
const pdu_session_aggr_max_bit_rate_s&
pdu_session_res_setup_request_transfer_ies_o::value_c::pdu_session_aggr_max_bit_rate() const
{
  assert_choice_type(types::pdu_session_aggr_max_bit_rate, type_, "Value");
  return c.get<pdu_session_aggr_max_bit_rate_s>();
}
const up_transport_layer_info_c& pdu_session_res_setup_request_transfer_ies_o::value_c::ul_ngu_up_tnl_info() const
{
  assert_choice_type(types::ul_ngu_up_tnl_info, type_, "Value");
  return c.get<up_transport_layer_info_c>();
}
const up_transport_layer_info_list_l&
pdu_session_res_setup_request_transfer_ies_o::value_c::add_ul_ngu_up_tnl_info() const
{
  assert_choice_type(types::add_ul_ngu_up_tnl_info, type_, "Value");
  return c.get<up_transport_layer_info_list_l>();
}
const data_forwarding_not_possible_e&
pdu_session_res_setup_request_transfer_ies_o::value_c::data_forwarding_not_possible() const
{
  assert_choice_type(types::data_forwarding_not_possible, type_, "Value");
  return c.get<data_forwarding_not_possible_e>();
}
const pdu_session_type_e& pdu_session_res_setup_request_transfer_ies_o::value_c::pdu_session_type() const
{
  assert_choice_type(types::pdu_session_type, type_, "Value");
  return c.get<pdu_session_type_e>();
}
const security_ind_s& pdu_session_res_setup_request_transfer_ies_o::value_c::security_ind() const
{
  assert_choice_type(types::security_ind, type_, "Value");
  return c.get<security_ind_s>();
}
const uint16_t& pdu_session_res_setup_request_transfer_ies_o::value_c::network_instance() const
{
  assert_choice_type(types::network_instance, type_, "Value");
  return c.get<uint16_t>();
}
const qos_flow_setup_request_list_l&
pdu_session_res_setup_request_transfer_ies_o::value_c::qos_flow_setup_request_list() const
{
  assert_choice_type(types::qos_flow_setup_request_list, type_, "Value");
  return c.get<qos_flow_setup_request_list_l>();
}
const unbounded_octstring<true>& pdu_session_res_setup_request_transfer_ies_o::value_c::common_network_instance() const
{
  assert_choice_type(types::common_network_instance, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const direct_forwarding_path_availability_e&
pdu_session_res_setup_request_transfer_ies_o::value_c::direct_forwarding_path_availability() const
{
  assert_choice_type(types::direct_forwarding_path_availability, type_, "Value");
  return c.get<direct_forwarding_path_availability_e>();
}
const up_transport_layer_info_c&
pdu_session_res_setup_request_transfer_ies_o::value_c::redundant_ul_ngu_up_tnl_info() const
{
  assert_choice_type(types::redundant_ul_ngu_up_tnl_info, type_, "Value");
  return c.get<up_transport_layer_info_c>();
}
const up_transport_layer_info_list_l&
pdu_session_res_setup_request_transfer_ies_o::value_c::add_redundant_ul_ngu_up_tnl_info() const
{
  assert_choice_type(types::add_redundant_ul_ngu_up_tnl_info, type_, "Value");
  return c.get<up_transport_layer_info_list_l>();
}
const unbounded_octstring<true>&
pdu_session_res_setup_request_transfer_ies_o::value_c::redundant_common_network_instance() const
{
  assert_choice_type(types::redundant_common_network_instance, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const redundant_pdu_session_info_s&
pdu_session_res_setup_request_transfer_ies_o::value_c::redundant_pdu_session_info() const
{
  assert_choice_type(types::redundant_pdu_session_info, type_, "Value");
  return c.get<redundant_pdu_session_info_s>();
}
const mbs_session_setup_request_list_l&
pdu_session_res_setup_request_transfer_ies_o::value_c::mbs_session_setup_request_list() const
{
  assert_choice_type(types::mbs_session_setup_request_list, type_, "Value");
  return c.get<mbs_session_setup_request_list_l>();
}
void pdu_session_res_setup_request_transfer_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::pdu_session_aggr_max_bit_rate:
      j.write_fieldname("PDUSessionAggregateMaximumBitRate");
      c.get<pdu_session_aggr_max_bit_rate_s>().to_json(j);
      break;
    case types::ul_ngu_up_tnl_info:
      j.write_fieldname("UPTransportLayerInformation");
      c.get<up_transport_layer_info_c>().to_json(j);
      break;
    case types::add_ul_ngu_up_tnl_info:
      j.start_array("UPTransportLayerInformationList");
      for (const auto& e1 : c.get<up_transport_layer_info_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::data_forwarding_not_possible:
      j.write_str("DataForwardingNotPossible", "data-forwarding-not-possible");
      break;
    case types::pdu_session_type:
      j.write_str("PDUSessionType", c.get<pdu_session_type_e>().to_string());
      break;
    case types::security_ind:
      j.write_fieldname("SecurityIndication");
      c.get<security_ind_s>().to_json(j);
      break;
    case types::network_instance:
      j.write_int("INTEGER (1..256,...)", c.get<uint16_t>());
      break;
    case types::qos_flow_setup_request_list:
      j.start_array("QosFlowSetupRequestList");
      for (const auto& e1 : c.get<qos_flow_setup_request_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::common_network_instance:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::direct_forwarding_path_availability:
      j.write_str("DirectForwardingPathAvailability", "direct-path-available");
      break;
    case types::redundant_ul_ngu_up_tnl_info:
      j.write_fieldname("UPTransportLayerInformation");
      c.get<up_transport_layer_info_c>().to_json(j);
      break;
    case types::add_redundant_ul_ngu_up_tnl_info:
      j.start_array("UPTransportLayerInformationList");
      for (const auto& e1 : c.get<up_transport_layer_info_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::redundant_common_network_instance:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::redundant_pdu_session_info:
      j.write_fieldname("RedundantPDUSessionInformation");
      c.get<redundant_pdu_session_info_s>().to_json(j);
      break;
    case types::mbs_session_setup_request_list:
      j.start_array("MBSSessionSetupRequestList");
      for (const auto& e1 : c.get<mbs_session_setup_request_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_setup_request_transfer_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE pdu_session_res_setup_request_transfer_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::pdu_session_aggr_max_bit_rate:
      HANDLE_CODE(c.get<pdu_session_aggr_max_bit_rate_s>().pack(bref));
      break;
    case types::ul_ngu_up_tnl_info:
      HANDLE_CODE(c.get<up_transport_layer_info_c>().pack(bref));
      break;
    case types::add_ul_ngu_up_tnl_info:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<up_transport_layer_info_list_l>(), 1, 3, true));
      break;
    case types::data_forwarding_not_possible:
      HANDLE_CODE(c.get<data_forwarding_not_possible_e>().pack(bref));
      break;
    case types::pdu_session_type:
      HANDLE_CODE(c.get<pdu_session_type_e>().pack(bref));
      break;
    case types::security_ind:
      HANDLE_CODE(c.get<security_ind_s>().pack(bref));
      break;
    case types::network_instance:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)1u, (uint16_t)256u, true, true));
      break;
    case types::qos_flow_setup_request_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<qos_flow_setup_request_list_l>(), 1, 64, true));
      break;
    case types::common_network_instance:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::direct_forwarding_path_availability:
      HANDLE_CODE(c.get<direct_forwarding_path_availability_e>().pack(bref));
      break;
    case types::redundant_ul_ngu_up_tnl_info:
      HANDLE_CODE(c.get<up_transport_layer_info_c>().pack(bref));
      break;
    case types::add_redundant_ul_ngu_up_tnl_info:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<up_transport_layer_info_list_l>(), 1, 3, true));
      break;
    case types::redundant_common_network_instance:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::redundant_pdu_session_info:
      HANDLE_CODE(c.get<redundant_pdu_session_info_s>().pack(bref));
      break;
    case types::mbs_session_setup_request_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<mbs_session_setup_request_list_l>(), 1, 32, true));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_setup_request_transfer_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_setup_request_transfer_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::pdu_session_aggr_max_bit_rate:
      HANDLE_CODE(c.get<pdu_session_aggr_max_bit_rate_s>().unpack(bref));
      break;
    case types::ul_ngu_up_tnl_info:
      HANDLE_CODE(c.get<up_transport_layer_info_c>().unpack(bref));
      break;
    case types::add_ul_ngu_up_tnl_info:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<up_transport_layer_info_list_l>(), bref, 1, 3, true));
      break;
    case types::data_forwarding_not_possible:
      HANDLE_CODE(c.get<data_forwarding_not_possible_e>().unpack(bref));
      break;
    case types::pdu_session_type:
      HANDLE_CODE(c.get<pdu_session_type_e>().unpack(bref));
      break;
    case types::security_ind:
      HANDLE_CODE(c.get<security_ind_s>().unpack(bref));
      break;
    case types::network_instance:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)1u, (uint16_t)256u, true, true));
      break;
    case types::qos_flow_setup_request_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<qos_flow_setup_request_list_l>(), bref, 1, 64, true));
      break;
    case types::common_network_instance:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::direct_forwarding_path_availability:
      HANDLE_CODE(c.get<direct_forwarding_path_availability_e>().unpack(bref));
      break;
    case types::redundant_ul_ngu_up_tnl_info:
      HANDLE_CODE(c.get<up_transport_layer_info_c>().unpack(bref));
      break;
    case types::add_redundant_ul_ngu_up_tnl_info:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<up_transport_layer_info_list_l>(), bref, 1, 3, true));
      break;
    case types::redundant_common_network_instance:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::redundant_pdu_session_info:
      HANDLE_CODE(c.get<redundant_pdu_session_info_s>().unpack(bref));
      break;
    case types::mbs_session_setup_request_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<mbs_session_setup_request_list_l>(), bref, 1, 32, true));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_setup_request_transfer_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* pdu_session_res_setup_request_transfer_ies_o::value_c::types_opts::to_string() const
{
  static const char* names[] = {"PDUSessionAggregateMaximumBitRate",
                                "UPTransportLayerInformation",
                                "UPTransportLayerInformationList",
                                "DataForwardingNotPossible",
                                "PDUSessionType",
                                "SecurityIndication",
                                "INTEGER (1..256,...)",
                                "QosFlowSetupRequestList",
                                "OCTET STRING",
                                "DirectForwardingPathAvailability",
                                "UPTransportLayerInformation",
                                "UPTransportLayerInformationList",
                                "OCTET STRING",
                                "RedundantPDUSessionInformation",
                                "MBSSessionSetupRequestList"};
  return convert_enum_idx(names, 15, value, "pdu_session_res_setup_request_transfer_ies_o::value_c::types");
}
uint8_t pdu_session_res_setup_request_transfer_ies_o::value_c::types_opts::to_number() const
{
  if (value == network_instance) {
    return 1;
  }
  invalid_enum_number(value, "pdu_session_res_setup_request_transfer_ies_o::value_c::types");
  return 0;
}

template struct asn1::protocol_ie_field_s<pdu_session_res_setup_request_transfer_ies_o>;

pdu_session_res_setup_request_transfer_ies_container::pdu_session_res_setup_request_transfer_ies_container() :
  pdu_session_aggr_max_bit_rate(130, crit_e::reject),
  ul_ngu_up_tnl_info(139, crit_e::reject),
  add_ul_ngu_up_tnl_info(126, crit_e::reject),
  data_forwarding_not_possible(127, crit_e::reject),
  pdu_session_type(134, crit_e::reject),
  security_ind(138, crit_e::reject),
  network_instance(129, crit_e::reject),
  qos_flow_setup_request_list(136, crit_e::reject),
  common_network_instance(166, crit_e::ignore),
  direct_forwarding_path_availability(22, crit_e::ignore),
  redundant_ul_ngu_up_tnl_info(195, crit_e::ignore),
  add_redundant_ul_ngu_up_tnl_info(186, crit_e::ignore),
  redundant_common_network_instance(190, crit_e::ignore),
  redundant_pdu_session_info(197, crit_e::ignore),
  mbs_session_setup_request_list(318, crit_e::ignore)
{
}
SRSASN_CODE pdu_session_res_setup_request_transfer_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += pdu_session_aggr_max_bit_rate_present ? 1 : 0;
  nof_ies += add_ul_ngu_up_tnl_info_present ? 1 : 0;
  nof_ies += data_forwarding_not_possible_present ? 1 : 0;
  nof_ies += security_ind_present ? 1 : 0;
  nof_ies += network_instance_present ? 1 : 0;
  nof_ies += common_network_instance_present ? 1 : 0;
  nof_ies += direct_forwarding_path_availability_present ? 1 : 0;
  nof_ies += redundant_ul_ngu_up_tnl_info_present ? 1 : 0;
  nof_ies += add_redundant_ul_ngu_up_tnl_info_present ? 1 : 0;
  nof_ies += redundant_common_network_instance_present ? 1 : 0;
  nof_ies += redundant_pdu_session_info_present ? 1 : 0;
  nof_ies += mbs_session_setup_request_list_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  if (pdu_session_aggr_max_bit_rate_present) {
    HANDLE_CODE(pdu_session_aggr_max_bit_rate.pack(bref));
  }
  HANDLE_CODE(ul_ngu_up_tnl_info.pack(bref));
  if (add_ul_ngu_up_tnl_info_present) {
    HANDLE_CODE(add_ul_ngu_up_tnl_info.pack(bref));
  }
  if (data_forwarding_not_possible_present) {
    HANDLE_CODE(data_forwarding_not_possible.pack(bref));
  }
  HANDLE_CODE(pdu_session_type.pack(bref));
  if (security_ind_present) {
    HANDLE_CODE(security_ind.pack(bref));
  }
  if (network_instance_present) {
    HANDLE_CODE(network_instance.pack(bref));
  }
  HANDLE_CODE(qos_flow_setup_request_list.pack(bref));
  if (common_network_instance_present) {
    HANDLE_CODE(common_network_instance.pack(bref));
  }
  if (direct_forwarding_path_availability_present) {
    HANDLE_CODE(direct_forwarding_path_availability.pack(bref));
  }
  if (redundant_ul_ngu_up_tnl_info_present) {
    HANDLE_CODE(redundant_ul_ngu_up_tnl_info.pack(bref));
  }
  if (add_redundant_ul_ngu_up_tnl_info_present) {
    HANDLE_CODE(add_redundant_ul_ngu_up_tnl_info.pack(bref));
  }
  if (redundant_common_network_instance_present) {
    HANDLE_CODE(redundant_common_network_instance.pack(bref));
  }
  if (redundant_pdu_session_info_present) {
    HANDLE_CODE(redundant_pdu_session_info.pack(bref));
  }
  if (mbs_session_setup_request_list_present) {
    HANDLE_CODE(mbs_session_setup_request_list.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_setup_request_transfer_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 130: {
        pdu_session_aggr_max_bit_rate_present = true;
        pdu_session_aggr_max_bit_rate.id      = id;
        HANDLE_CODE(pdu_session_aggr_max_bit_rate.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pdu_session_aggr_max_bit_rate.value.unpack(bref));
        break;
      }
      case 139: {
        nof_mandatory_ies--;
        ul_ngu_up_tnl_info.id = id;
        HANDLE_CODE(ul_ngu_up_tnl_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ul_ngu_up_tnl_info.value.unpack(bref));
        break;
      }
      case 126: {
        add_ul_ngu_up_tnl_info_present = true;
        add_ul_ngu_up_tnl_info.id      = id;
        HANDLE_CODE(add_ul_ngu_up_tnl_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(add_ul_ngu_up_tnl_info.value.unpack(bref));
        break;
      }
      case 127: {
        data_forwarding_not_possible_present = true;
        data_forwarding_not_possible.id      = id;
        HANDLE_CODE(data_forwarding_not_possible.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(data_forwarding_not_possible.value.unpack(bref));
        break;
      }
      case 134: {
        nof_mandatory_ies--;
        pdu_session_type.id = id;
        HANDLE_CODE(pdu_session_type.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pdu_session_type.value.unpack(bref));
        break;
      }
      case 138: {
        security_ind_present = true;
        security_ind.id      = id;
        HANDLE_CODE(security_ind.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(security_ind.value.unpack(bref));
        break;
      }
      case 129: {
        network_instance_present = true;
        network_instance.id      = id;
        HANDLE_CODE(network_instance.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(network_instance.value.unpack(bref));
        break;
      }
      case 136: {
        nof_mandatory_ies--;
        qos_flow_setup_request_list.id = id;
        HANDLE_CODE(qos_flow_setup_request_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(qos_flow_setup_request_list.value.unpack(bref));
        break;
      }
      case 166: {
        common_network_instance_present = true;
        common_network_instance.id      = id;
        HANDLE_CODE(common_network_instance.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(common_network_instance.value.unpack(bref));
        break;
      }
      case 22: {
        direct_forwarding_path_availability_present = true;
        direct_forwarding_path_availability.id      = id;
        HANDLE_CODE(direct_forwarding_path_availability.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(direct_forwarding_path_availability.value.unpack(bref));
        break;
      }
      case 195: {
        redundant_ul_ngu_up_tnl_info_present = true;
        redundant_ul_ngu_up_tnl_info.id      = id;
        HANDLE_CODE(redundant_ul_ngu_up_tnl_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(redundant_ul_ngu_up_tnl_info.value.unpack(bref));
        break;
      }
      case 186: {
        add_redundant_ul_ngu_up_tnl_info_present = true;
        add_redundant_ul_ngu_up_tnl_info.id      = id;
        HANDLE_CODE(add_redundant_ul_ngu_up_tnl_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(add_redundant_ul_ngu_up_tnl_info.value.unpack(bref));
        break;
      }
      case 190: {
        redundant_common_network_instance_present = true;
        redundant_common_network_instance.id      = id;
        HANDLE_CODE(redundant_common_network_instance.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(redundant_common_network_instance.value.unpack(bref));
        break;
      }
      case 197: {
        redundant_pdu_session_info_present = true;
        redundant_pdu_session_info.id      = id;
        HANDLE_CODE(redundant_pdu_session_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(redundant_pdu_session_info.value.unpack(bref));
        break;
      }
      case 318: {
        mbs_session_setup_request_list_present = true;
        mbs_session_setup_request_list.id      = id;
        HANDLE_CODE(mbs_session_setup_request_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_setup_request_list.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void pdu_session_res_setup_request_transfer_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (pdu_session_aggr_max_bit_rate_present) {
    j.write_fieldname("");
    pdu_session_aggr_max_bit_rate.to_json(j);
  }
  j.write_fieldname("");
  ul_ngu_up_tnl_info.to_json(j);
  if (add_ul_ngu_up_tnl_info_present) {
    j.write_fieldname("");
    add_ul_ngu_up_tnl_info.to_json(j);
  }
  if (data_forwarding_not_possible_present) {
    j.write_fieldname("");
    data_forwarding_not_possible.to_json(j);
  }
  j.write_fieldname("");
  pdu_session_type.to_json(j);
  if (security_ind_present) {
    j.write_fieldname("");
    security_ind.to_json(j);
  }
  if (network_instance_present) {
    j.write_fieldname("");
    network_instance.to_json(j);
  }
  j.write_fieldname("");
  qos_flow_setup_request_list.to_json(j);
  if (common_network_instance_present) {
    j.write_fieldname("");
    common_network_instance.to_json(j);
  }
  if (direct_forwarding_path_availability_present) {
    j.write_fieldname("");
    direct_forwarding_path_availability.to_json(j);
  }
  if (redundant_ul_ngu_up_tnl_info_present) {
    j.write_fieldname("");
    redundant_ul_ngu_up_tnl_info.to_json(j);
  }
  if (add_redundant_ul_ngu_up_tnl_info_present) {
    j.write_fieldname("");
    add_redundant_ul_ngu_up_tnl_info.to_json(j);
  }
  if (redundant_common_network_instance_present) {
    j.write_fieldname("");
    redundant_common_network_instance.to_json(j);
  }
  if (redundant_pdu_session_info_present) {
    j.write_fieldname("");
    redundant_pdu_session_info.to_json(j);
  }
  if (mbs_session_setup_request_list_present) {
    j.write_fieldname("");
    mbs_session_setup_request_list.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceSetupResponseTransfer-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t pdu_session_res_setup_resp_transfer_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {193, 184, 198, 27, 309, 312, 310};
  return map_enum_number(names, 7, idx, "id");
}
bool pdu_session_res_setup_resp_transfer_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {193, 184, 198, 27, 309, 312, 310};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e pdu_session_res_setup_resp_transfer_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 193:
      return crit_e::ignore;
    case 184:
      return crit_e::ignore;
    case 198:
      return crit_e::ignore;
    case 27:
      return crit_e::ignore;
    case 309:
      return crit_e::ignore;
    case 312:
      return crit_e::ignore;
    case 310:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
pdu_session_res_setup_resp_transfer_ext_ies_o::ext_c
pdu_session_res_setup_resp_transfer_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 193:
      ret.set(ext_c::types::redundant_dl_qos_flow_per_tnl_info);
      break;
    case 184:
      ret.set(ext_c::types::add_redundant_dl_qos_flow_per_tnl_info);
      break;
    case 198:
      ret.set(ext_c::types::used_r_sn_info);
      break;
    case 27:
      ret.set(ext_c::types::global_ran_node_id);
      break;
    case 309:
      ret.set(ext_c::types::mbs_support_ind);
      break;
    case 312:
      ret.set(ext_c::types::mbs_session_setup_resp_list);
      break;
    case 310:
      ret.set(ext_c::types::mbs_session_failedto_setup_list);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pdu_session_res_setup_resp_transfer_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 193:
      return presence_e::optional;
    case 184:
      return presence_e::optional;
    case 198:
      return presence_e::optional;
    case 27:
      return presence_e::optional;
    case 309:
      return presence_e::optional;
    case 312:
      return presence_e::optional;
    case 310:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void pdu_session_res_setup_resp_transfer_ext_ies_o::ext_c::destroy_()
{
  switch (type_) {
    case types::redundant_dl_qos_flow_per_tnl_info:
      c.destroy<qos_flow_per_tnl_info_s>();
      break;
    case types::add_redundant_dl_qos_flow_per_tnl_info:
      c.destroy<qos_flow_per_tnl_info_list_l>();
      break;
    case types::used_r_sn_info:
      c.destroy<redundant_pdu_session_info_s>();
      break;
    case types::global_ran_node_id:
      c.destroy<global_ran_node_id_c>();
      break;
    case types::mbs_session_setup_resp_list:
      c.destroy<mbs_session_setup_resp_list_l>();
      break;
    case types::mbs_session_failedto_setup_list:
      c.destroy<mbs_session_failedto_setup_list_l>();
      break;
    default:
      break;
  }
}
void pdu_session_res_setup_resp_transfer_ext_ies_o::ext_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::redundant_dl_qos_flow_per_tnl_info:
      c.init<qos_flow_per_tnl_info_s>();
      break;
    case types::add_redundant_dl_qos_flow_per_tnl_info:
      c.init<qos_flow_per_tnl_info_list_l>();
      break;
    case types::used_r_sn_info:
      c.init<redundant_pdu_session_info_s>();
      break;
    case types::global_ran_node_id:
      c.init<global_ran_node_id_c>();
      break;
    case types::mbs_support_ind:
      break;
    case types::mbs_session_setup_resp_list:
      c.init<mbs_session_setup_resp_list_l>();
      break;
    case types::mbs_session_failedto_setup_list:
      c.init<mbs_session_failedto_setup_list_l>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_setup_resp_transfer_ext_ies_o::ext_c");
  }
}
pdu_session_res_setup_resp_transfer_ext_ies_o::ext_c::ext_c(
    const pdu_session_res_setup_resp_transfer_ext_ies_o::ext_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::redundant_dl_qos_flow_per_tnl_info:
      c.init(other.c.get<qos_flow_per_tnl_info_s>());
      break;
    case types::add_redundant_dl_qos_flow_per_tnl_info:
      c.init(other.c.get<qos_flow_per_tnl_info_list_l>());
      break;
    case types::used_r_sn_info:
      c.init(other.c.get<redundant_pdu_session_info_s>());
      break;
    case types::global_ran_node_id:
      c.init(other.c.get<global_ran_node_id_c>());
      break;
    case types::mbs_support_ind:
      c.init(other.c.get<mbs_support_ind_e>());
      break;
    case types::mbs_session_setup_resp_list:
      c.init(other.c.get<mbs_session_setup_resp_list_l>());
      break;
    case types::mbs_session_failedto_setup_list:
      c.init(other.c.get<mbs_session_failedto_setup_list_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_setup_resp_transfer_ext_ies_o::ext_c");
  }
}
pdu_session_res_setup_resp_transfer_ext_ies_o::ext_c& pdu_session_res_setup_resp_transfer_ext_ies_o::ext_c::operator=(
    const pdu_session_res_setup_resp_transfer_ext_ies_o::ext_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::redundant_dl_qos_flow_per_tnl_info:
      c.set(other.c.get<qos_flow_per_tnl_info_s>());
      break;
    case types::add_redundant_dl_qos_flow_per_tnl_info:
      c.set(other.c.get<qos_flow_per_tnl_info_list_l>());
      break;
    case types::used_r_sn_info:
      c.set(other.c.get<redundant_pdu_session_info_s>());
      break;
    case types::global_ran_node_id:
      c.set(other.c.get<global_ran_node_id_c>());
      break;
    case types::mbs_support_ind:
      c.set(other.c.get<mbs_support_ind_e>());
      break;
    case types::mbs_session_setup_resp_list:
      c.set(other.c.get<mbs_session_setup_resp_list_l>());
      break;
    case types::mbs_session_failedto_setup_list:
      c.set(other.c.get<mbs_session_failedto_setup_list_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_setup_resp_transfer_ext_ies_o::ext_c");
  }

  return *this;
}
qos_flow_per_tnl_info_s& pdu_session_res_setup_resp_transfer_ext_ies_o::ext_c::redundant_dl_qos_flow_per_tnl_info()
{
  assert_choice_type(types::redundant_dl_qos_flow_per_tnl_info, type_, "Extension");
  return c.get<qos_flow_per_tnl_info_s>();
}
qos_flow_per_tnl_info_list_l&
pdu_session_res_setup_resp_transfer_ext_ies_o::ext_c::add_redundant_dl_qos_flow_per_tnl_info()
{
  assert_choice_type(types::add_redundant_dl_qos_flow_per_tnl_info, type_, "Extension");
  return c.get<qos_flow_per_tnl_info_list_l>();
}
redundant_pdu_session_info_s& pdu_session_res_setup_resp_transfer_ext_ies_o::ext_c::used_r_sn_info()
{
  assert_choice_type(types::used_r_sn_info, type_, "Extension");
  return c.get<redundant_pdu_session_info_s>();
}
global_ran_node_id_c& pdu_session_res_setup_resp_transfer_ext_ies_o::ext_c::global_ran_node_id()
{
  assert_choice_type(types::global_ran_node_id, type_, "Extension");
  return c.get<global_ran_node_id_c>();
}
mbs_support_ind_e& pdu_session_res_setup_resp_transfer_ext_ies_o::ext_c::mbs_support_ind()
{
  assert_choice_type(types::mbs_support_ind, type_, "Extension");
  return c.get<mbs_support_ind_e>();
}
mbs_session_setup_resp_list_l& pdu_session_res_setup_resp_transfer_ext_ies_o::ext_c::mbs_session_setup_resp_list()
{
  assert_choice_type(types::mbs_session_setup_resp_list, type_, "Extension");
  return c.get<mbs_session_setup_resp_list_l>();
}
mbs_session_failedto_setup_list_l&
pdu_session_res_setup_resp_transfer_ext_ies_o::ext_c::mbs_session_failedto_setup_list()
{
  assert_choice_type(types::mbs_session_failedto_setup_list, type_, "Extension");
  return c.get<mbs_session_failedto_setup_list_l>();
}
const qos_flow_per_tnl_info_s&
pdu_session_res_setup_resp_transfer_ext_ies_o::ext_c::redundant_dl_qos_flow_per_tnl_info() const
{
  assert_choice_type(types::redundant_dl_qos_flow_per_tnl_info, type_, "Extension");
  return c.get<qos_flow_per_tnl_info_s>();
}
const qos_flow_per_tnl_info_list_l&
pdu_session_res_setup_resp_transfer_ext_ies_o::ext_c::add_redundant_dl_qos_flow_per_tnl_info() const
{
  assert_choice_type(types::add_redundant_dl_qos_flow_per_tnl_info, type_, "Extension");
  return c.get<qos_flow_per_tnl_info_list_l>();
}
const redundant_pdu_session_info_s& pdu_session_res_setup_resp_transfer_ext_ies_o::ext_c::used_r_sn_info() const
{
  assert_choice_type(types::used_r_sn_info, type_, "Extension");
  return c.get<redundant_pdu_session_info_s>();
}
const global_ran_node_id_c& pdu_session_res_setup_resp_transfer_ext_ies_o::ext_c::global_ran_node_id() const
{
  assert_choice_type(types::global_ran_node_id, type_, "Extension");
  return c.get<global_ran_node_id_c>();
}
const mbs_support_ind_e& pdu_session_res_setup_resp_transfer_ext_ies_o::ext_c::mbs_support_ind() const
{
  assert_choice_type(types::mbs_support_ind, type_, "Extension");
  return c.get<mbs_support_ind_e>();
}
const mbs_session_setup_resp_list_l&
pdu_session_res_setup_resp_transfer_ext_ies_o::ext_c::mbs_session_setup_resp_list() const
{
  assert_choice_type(types::mbs_session_setup_resp_list, type_, "Extension");
  return c.get<mbs_session_setup_resp_list_l>();
}
const mbs_session_failedto_setup_list_l&
pdu_session_res_setup_resp_transfer_ext_ies_o::ext_c::mbs_session_failedto_setup_list() const
{
  assert_choice_type(types::mbs_session_failedto_setup_list, type_, "Extension");
  return c.get<mbs_session_failedto_setup_list_l>();
}
void pdu_session_res_setup_resp_transfer_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::redundant_dl_qos_flow_per_tnl_info:
      j.write_fieldname("QosFlowPerTNLInformation");
      c.get<qos_flow_per_tnl_info_s>().to_json(j);
      break;
    case types::add_redundant_dl_qos_flow_per_tnl_info:
      j.start_array("QosFlowPerTNLInformationList");
      for (const auto& e1 : c.get<qos_flow_per_tnl_info_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::used_r_sn_info:
      j.write_fieldname("RedundantPDUSessionInformation");
      c.get<redundant_pdu_session_info_s>().to_json(j);
      break;
    case types::global_ran_node_id:
      j.write_fieldname("GlobalRANNodeID");
      c.get<global_ran_node_id_c>().to_json(j);
      break;
    case types::mbs_support_ind:
      j.write_str("MBS-SupportIndicator", "true");
      break;
    case types::mbs_session_setup_resp_list:
      j.start_array("MBSSessionSetupResponseList");
      for (const auto& e1 : c.get<mbs_session_setup_resp_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::mbs_session_failedto_setup_list:
      j.start_array("MBSSessionFailedtoSetupList");
      for (const auto& e1 : c.get<mbs_session_failedto_setup_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_setup_resp_transfer_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE pdu_session_res_setup_resp_transfer_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::redundant_dl_qos_flow_per_tnl_info:
      HANDLE_CODE(c.get<qos_flow_per_tnl_info_s>().pack(bref));
      break;
    case types::add_redundant_dl_qos_flow_per_tnl_info:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<qos_flow_per_tnl_info_list_l>(), 1, 3, true));
      break;
    case types::used_r_sn_info:
      HANDLE_CODE(c.get<redundant_pdu_session_info_s>().pack(bref));
      break;
    case types::global_ran_node_id:
      HANDLE_CODE(c.get<global_ran_node_id_c>().pack(bref));
      break;
    case types::mbs_support_ind:
      HANDLE_CODE(c.get<mbs_support_ind_e>().pack(bref));
      break;
    case types::mbs_session_setup_resp_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<mbs_session_setup_resp_list_l>(), 1, 32, true));
      break;
    case types::mbs_session_failedto_setup_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<mbs_session_failedto_setup_list_l>(), 1, 32, true));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_setup_resp_transfer_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_setup_resp_transfer_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::redundant_dl_qos_flow_per_tnl_info:
      HANDLE_CODE(c.get<qos_flow_per_tnl_info_s>().unpack(bref));
      break;
    case types::add_redundant_dl_qos_flow_per_tnl_info:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<qos_flow_per_tnl_info_list_l>(), bref, 1, 3, true));
      break;
    case types::used_r_sn_info:
      HANDLE_CODE(c.get<redundant_pdu_session_info_s>().unpack(bref));
      break;
    case types::global_ran_node_id:
      HANDLE_CODE(c.get<global_ran_node_id_c>().unpack(bref));
      break;
    case types::mbs_support_ind:
      HANDLE_CODE(c.get<mbs_support_ind_e>().unpack(bref));
      break;
    case types::mbs_session_setup_resp_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<mbs_session_setup_resp_list_l>(), bref, 1, 32, true));
      break;
    case types::mbs_session_failedto_setup_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<mbs_session_failedto_setup_list_l>(), bref, 1, 32, true));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_setup_resp_transfer_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* pdu_session_res_setup_resp_transfer_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"QosFlowPerTNLInformation",
                                "QosFlowPerTNLInformationList",
                                "RedundantPDUSessionInformation",
                                "GlobalRANNodeID",
                                "MBS-SupportIndicator",
                                "MBSSessionSetupResponseList",
                                "MBSSessionFailedtoSetupList"};
  return convert_enum_idx(names, 7, value, "pdu_session_res_setup_resp_transfer_ext_ies_o::ext_c::types");
}

template struct asn1::protocol_ext_field_s<pdu_session_res_setup_resp_transfer_ext_ies_o>;

pdu_session_res_setup_resp_transfer_ext_ies_container::pdu_session_res_setup_resp_transfer_ext_ies_container() :
  redundant_dl_qos_flow_per_tnl_info(193, crit_e::ignore),
  add_redundant_dl_qos_flow_per_tnl_info(184, crit_e::ignore),
  used_r_sn_info(198, crit_e::ignore),
  global_ran_node_id(27, crit_e::ignore),
  mbs_support_ind(309, crit_e::ignore),
  mbs_session_setup_resp_list(312, crit_e::ignore),
  mbs_session_failedto_setup_list(310, crit_e::ignore)
{
}
SRSASN_CODE pdu_session_res_setup_resp_transfer_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += redundant_dl_qos_flow_per_tnl_info_present ? 1 : 0;
  nof_ies += add_redundant_dl_qos_flow_per_tnl_info_present ? 1 : 0;
  nof_ies += used_r_sn_info_present ? 1 : 0;
  nof_ies += global_ran_node_id_present ? 1 : 0;
  nof_ies += mbs_support_ind_present ? 1 : 0;
  nof_ies += mbs_session_setup_resp_list_present ? 1 : 0;
  nof_ies += mbs_session_failedto_setup_list_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (redundant_dl_qos_flow_per_tnl_info_present) {
    HANDLE_CODE(redundant_dl_qos_flow_per_tnl_info.pack(bref));
  }
  if (add_redundant_dl_qos_flow_per_tnl_info_present) {
    HANDLE_CODE(add_redundant_dl_qos_flow_per_tnl_info.pack(bref));
  }
  if (used_r_sn_info_present) {
    HANDLE_CODE(used_r_sn_info.pack(bref));
  }
  if (global_ran_node_id_present) {
    HANDLE_CODE(global_ran_node_id.pack(bref));
  }
  if (mbs_support_ind_present) {
    HANDLE_CODE(mbs_support_ind.pack(bref));
  }
  if (mbs_session_setup_resp_list_present) {
    HANDLE_CODE(mbs_session_setup_resp_list.pack(bref));
  }
  if (mbs_session_failedto_setup_list_present) {
    HANDLE_CODE(mbs_session_failedto_setup_list.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_setup_resp_transfer_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 193: {
        redundant_dl_qos_flow_per_tnl_info_present = true;
        redundant_dl_qos_flow_per_tnl_info.id      = id;
        HANDLE_CODE(redundant_dl_qos_flow_per_tnl_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(redundant_dl_qos_flow_per_tnl_info.ext.unpack(bref));
        break;
      }
      case 184: {
        add_redundant_dl_qos_flow_per_tnl_info_present = true;
        add_redundant_dl_qos_flow_per_tnl_info.id      = id;
        HANDLE_CODE(add_redundant_dl_qos_flow_per_tnl_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(add_redundant_dl_qos_flow_per_tnl_info.ext.unpack(bref));
        break;
      }
      case 198: {
        used_r_sn_info_present = true;
        used_r_sn_info.id      = id;
        HANDLE_CODE(used_r_sn_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(used_r_sn_info.ext.unpack(bref));
        break;
      }
      case 27: {
        global_ran_node_id_present = true;
        global_ran_node_id.id      = id;
        HANDLE_CODE(global_ran_node_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(global_ran_node_id.ext.unpack(bref));
        break;
      }
      case 309: {
        mbs_support_ind_present = true;
        mbs_support_ind.id      = id;
        HANDLE_CODE(mbs_support_ind.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_support_ind.ext.unpack(bref));
        break;
      }
      case 312: {
        mbs_session_setup_resp_list_present = true;
        mbs_session_setup_resp_list.id      = id;
        HANDLE_CODE(mbs_session_setup_resp_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_setup_resp_list.ext.unpack(bref));
        break;
      }
      case 310: {
        mbs_session_failedto_setup_list_present = true;
        mbs_session_failedto_setup_list.id      = id;
        HANDLE_CODE(mbs_session_failedto_setup_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_failedto_setup_list.ext.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_setup_resp_transfer_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (redundant_dl_qos_flow_per_tnl_info_present) {
    j.write_fieldname("");
    redundant_dl_qos_flow_per_tnl_info.to_json(j);
  }
  if (add_redundant_dl_qos_flow_per_tnl_info_present) {
    j.write_fieldname("");
    add_redundant_dl_qos_flow_per_tnl_info.to_json(j);
  }
  if (used_r_sn_info_present) {
    j.write_fieldname("");
    used_r_sn_info.to_json(j);
  }
  if (global_ran_node_id_present) {
    j.write_fieldname("");
    global_ran_node_id.to_json(j);
  }
  if (mbs_support_ind_present) {
    j.write_fieldname("");
    mbs_support_ind.to_json(j);
  }
  if (mbs_session_setup_resp_list_present) {
    j.write_fieldname("");
    mbs_session_setup_resp_list.to_json(j);
  }
  if (mbs_session_failedto_setup_list_present) {
    j.write_fieldname("");
    mbs_session_failedto_setup_list.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceSetupResponseTransfer ::= SEQUENCE
SRSASN_CODE pdu_session_res_setup_resp_transfer_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(add_dl_qos_flow_per_tnl_info.size() > 0, 1));
  HANDLE_CODE(bref.pack(security_result_present, 1));
  HANDLE_CODE(bref.pack(qos_flow_failed_to_setup_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(dl_qos_flow_per_tnl_info.pack(bref));
  if (add_dl_qos_flow_per_tnl_info.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, add_dl_qos_flow_per_tnl_info, 1, 3, true));
  }
  if (security_result_present) {
    HANDLE_CODE(security_result.pack(bref));
  }
  if (qos_flow_failed_to_setup_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, qos_flow_failed_to_setup_list, 1, 64, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_setup_resp_transfer_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool add_dl_qos_flow_per_tnl_info_present;
  HANDLE_CODE(bref.unpack(add_dl_qos_flow_per_tnl_info_present, 1));
  HANDLE_CODE(bref.unpack(security_result_present, 1));
  bool qos_flow_failed_to_setup_list_present;
  HANDLE_CODE(bref.unpack(qos_flow_failed_to_setup_list_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(dl_qos_flow_per_tnl_info.unpack(bref));
  if (add_dl_qos_flow_per_tnl_info_present) {
    HANDLE_CODE(unpack_dyn_seq_of(add_dl_qos_flow_per_tnl_info, bref, 1, 3, true));
  }
  if (security_result_present) {
    HANDLE_CODE(security_result.unpack(bref));
  }
  if (qos_flow_failed_to_setup_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(qos_flow_failed_to_setup_list, bref, 1, 64, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_setup_resp_transfer_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("dLQosFlowPerTNLInformation");
  dl_qos_flow_per_tnl_info.to_json(j);
  if (add_dl_qos_flow_per_tnl_info.size() > 0) {
    j.start_array("additionalDLQosFlowPerTNLInformation");
    for (const auto& e1 : add_dl_qos_flow_per_tnl_info) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (security_result_present) {
    j.write_fieldname("securityResult");
    security_result.to_json(j);
  }
  if (qos_flow_failed_to_setup_list.size() > 0) {
    j.start_array("qosFlowFailedToSetupList");
    for (const auto& e1 : qos_flow_failed_to_setup_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDUSessionResourceSetupUnsuccessfulTransfer ::= SEQUENCE
SRSASN_CODE pdu_session_res_setup_unsuccessful_transfer_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(crit_diagnostics_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(cause.pack(bref));
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_setup_unsuccessful_transfer_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(crit_diagnostics_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(cause.unpack(bref));
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdu_session_res_setup_unsuccessful_transfer_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("cause");
  cause.to_json(j);
  if (crit_diagnostics_present) {
    j.write_fieldname("criticalityDiagnostics");
    crit_diagnostics.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// QosFlowParametersItem-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t qos_flow_params_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {187, 188, 279};
  return map_enum_number(names, 3, idx, "id");
}
bool qos_flow_params_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {187, 188, 279};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e qos_flow_params_item_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 187:
      return crit_e::ignore;
    case 188:
      return crit_e::ignore;
    case 279:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
qos_flow_params_item_ext_ies_o::ext_c qos_flow_params_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 187:
      ret.set(ext_c::types::cn_packet_delay_budget_dl);
      break;
    case 188:
      ret.set(ext_c::types::cn_packet_delay_budget_ul);
      break;
    case 279:
      ret.set(ext_c::types::burst_arrival_time_dl);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e qos_flow_params_item_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 187:
      return presence_e::optional;
    case 188:
      return presence_e::optional;
    case 279:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void qos_flow_params_item_ext_ies_o::ext_c::destroy_()
{
  switch (type_) {
    case types::burst_arrival_time_dl:
      c.destroy<unbounded_octstring<true>>();
      break;
    default:
      break;
  }
}
void qos_flow_params_item_ext_ies_o::ext_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::cn_packet_delay_budget_dl:
      break;
    case types::cn_packet_delay_budget_ul:
      break;
    case types::burst_arrival_time_dl:
      c.init<unbounded_octstring<true>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "qos_flow_params_item_ext_ies_o::ext_c");
  }
}
qos_flow_params_item_ext_ies_o::ext_c::ext_c(const qos_flow_params_item_ext_ies_o::ext_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::cn_packet_delay_budget_dl:
      c.init(other.c.get<uint32_t>());
      break;
    case types::cn_packet_delay_budget_ul:
      c.init(other.c.get<uint32_t>());
      break;
    case types::burst_arrival_time_dl:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "qos_flow_params_item_ext_ies_o::ext_c");
  }
}
qos_flow_params_item_ext_ies_o::ext_c&
qos_flow_params_item_ext_ies_o::ext_c::operator=(const qos_flow_params_item_ext_ies_o::ext_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::cn_packet_delay_budget_dl:
      c.set(other.c.get<uint32_t>());
      break;
    case types::cn_packet_delay_budget_ul:
      c.set(other.c.get<uint32_t>());
      break;
    case types::burst_arrival_time_dl:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "qos_flow_params_item_ext_ies_o::ext_c");
  }

  return *this;
}
uint32_t& qos_flow_params_item_ext_ies_o::ext_c::cn_packet_delay_budget_dl()
{
  assert_choice_type(types::cn_packet_delay_budget_dl, type_, "Extension");
  return c.get<uint32_t>();
}
uint32_t& qos_flow_params_item_ext_ies_o::ext_c::cn_packet_delay_budget_ul()
{
  assert_choice_type(types::cn_packet_delay_budget_ul, type_, "Extension");
  return c.get<uint32_t>();
}
unbounded_octstring<true>& qos_flow_params_item_ext_ies_o::ext_c::burst_arrival_time_dl()
{
  assert_choice_type(types::burst_arrival_time_dl, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
const uint32_t& qos_flow_params_item_ext_ies_o::ext_c::cn_packet_delay_budget_dl() const
{
  assert_choice_type(types::cn_packet_delay_budget_dl, type_, "Extension");
  return c.get<uint32_t>();
}
const uint32_t& qos_flow_params_item_ext_ies_o::ext_c::cn_packet_delay_budget_ul() const
{
  assert_choice_type(types::cn_packet_delay_budget_ul, type_, "Extension");
  return c.get<uint32_t>();
}
const unbounded_octstring<true>& qos_flow_params_item_ext_ies_o::ext_c::burst_arrival_time_dl() const
{
  assert_choice_type(types::burst_arrival_time_dl, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
void qos_flow_params_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::cn_packet_delay_budget_dl:
      j.write_int("INTEGER (1..65535,...)", c.get<uint32_t>());
      break;
    case types::cn_packet_delay_budget_ul:
      j.write_int("INTEGER (1..65535,...)", c.get<uint32_t>());
      break;
    case types::burst_arrival_time_dl:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "qos_flow_params_item_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE qos_flow_params_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::cn_packet_delay_budget_dl:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)1u, (uint32_t)65535u, true, true));
      break;
    case types::cn_packet_delay_budget_ul:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)1u, (uint32_t)65535u, true, true));
      break;
    case types::burst_arrival_time_dl:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "qos_flow_params_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_flow_params_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::cn_packet_delay_budget_dl:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)1u, (uint32_t)65535u, true, true));
      break;
    case types::cn_packet_delay_budget_ul:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)1u, (uint32_t)65535u, true, true));
      break;
    case types::burst_arrival_time_dl:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "qos_flow_params_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* qos_flow_params_item_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (1..65535,...)", "INTEGER (1..65535,...)", "OCTET STRING"};
  return convert_enum_idx(names, 3, value, "qos_flow_params_item_ext_ies_o::ext_c::types");
}

template struct asn1::protocol_ext_field_s<qos_flow_params_item_ext_ies_o>;

qos_flow_params_item_ext_ies_container::qos_flow_params_item_ext_ies_container() :
  cn_packet_delay_budget_dl(187, crit_e::ignore),
  cn_packet_delay_budget_ul(188, crit_e::ignore),
  burst_arrival_time_dl(279, crit_e::ignore)
{
}
SRSASN_CODE qos_flow_params_item_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += cn_packet_delay_budget_dl_present ? 1 : 0;
  nof_ies += cn_packet_delay_budget_ul_present ? 1 : 0;
  nof_ies += burst_arrival_time_dl_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (cn_packet_delay_budget_dl_present) {
    HANDLE_CODE(cn_packet_delay_budget_dl.pack(bref));
  }
  if (cn_packet_delay_budget_ul_present) {
    HANDLE_CODE(cn_packet_delay_budget_ul.pack(bref));
  }
  if (burst_arrival_time_dl_present) {
    HANDLE_CODE(burst_arrival_time_dl.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_flow_params_item_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 187: {
        cn_packet_delay_budget_dl_present = true;
        cn_packet_delay_budget_dl.id      = id;
        HANDLE_CODE(cn_packet_delay_budget_dl.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cn_packet_delay_budget_dl.ext.unpack(bref));
        break;
      }
      case 188: {
        cn_packet_delay_budget_ul_present = true;
        cn_packet_delay_budget_ul.id      = id;
        HANDLE_CODE(cn_packet_delay_budget_ul.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cn_packet_delay_budget_ul.ext.unpack(bref));
        break;
      }
      case 279: {
        burst_arrival_time_dl_present = true;
        burst_arrival_time_dl.id      = id;
        HANDLE_CODE(burst_arrival_time_dl.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(burst_arrival_time_dl.ext.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void qos_flow_params_item_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (cn_packet_delay_budget_dl_present) {
    j.write_fieldname("");
    cn_packet_delay_budget_dl.to_json(j);
  }
  if (cn_packet_delay_budget_ul_present) {
    j.write_fieldname("");
    cn_packet_delay_budget_ul.to_json(j);
  }
  if (burst_arrival_time_dl_present) {
    j.write_fieldname("");
    burst_arrival_time_dl.to_json(j);
  }
  j.end_obj();
}

// QosFlowParametersItem ::= SEQUENCE
SRSASN_CODE qos_flow_params_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(alt_qos_para_set_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, qos_flow_id, (uint8_t)0u, (uint8_t)63u, true, true));
  if (alt_qos_para_set_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, alt_qos_para_set_list, 1, 8, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_flow_params_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool alt_qos_para_set_list_present;
  HANDLE_CODE(bref.unpack(alt_qos_para_set_list_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(qos_flow_id, bref, (uint8_t)0u, (uint8_t)63u, true, true));
  if (alt_qos_para_set_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(alt_qos_para_set_list, bref, 1, 8, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void qos_flow_params_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("qosFlowIdentifier", qos_flow_id);
  if (alt_qos_para_set_list.size() > 0) {
    j.start_array("alternativeQoSParaSetList");
    for (const auto& e1 : alt_qos_para_set_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PathSwitchRequestAcknowledgeTransfer-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t path_switch_request_ack_transfer_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {154, 195, 185, 277};
  return map_enum_number(names, 4, idx, "id");
}
bool path_switch_request_ack_transfer_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {154, 195, 185, 277};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e path_switch_request_ack_transfer_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 154:
      return crit_e::ignore;
    case 195:
      return crit_e::ignore;
    case 185:
      return crit_e::ignore;
    case 277:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
path_switch_request_ack_transfer_ext_ies_o::ext_c
path_switch_request_ack_transfer_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 154:
      ret.set(ext_c::types::add_ngu_up_tnl_info);
      break;
    case 195:
      ret.set(ext_c::types::redundant_ul_ngu_up_tnl_info);
      break;
    case 185:
      ret.set(ext_c::types::add_redundant_ngu_up_tnl_info);
      break;
    case 277:
      ret.set(ext_c::types::qos_flow_params_list);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e path_switch_request_ack_transfer_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 154:
      return presence_e::optional;
    case 195:
      return presence_e::optional;
    case 185:
      return presence_e::optional;
    case 277:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void path_switch_request_ack_transfer_ext_ies_o::ext_c::destroy_()
{
  switch (type_) {
    case types::add_ngu_up_tnl_info:
      c.destroy<up_transport_layer_info_pair_list_l>();
      break;
    case types::redundant_ul_ngu_up_tnl_info:
      c.destroy<up_transport_layer_info_c>();
      break;
    case types::add_redundant_ngu_up_tnl_info:
      c.destroy<up_transport_layer_info_pair_list_l>();
      break;
    case types::qos_flow_params_list:
      c.destroy<qos_flow_params_list_l>();
      break;
    default:
      break;
  }
}
void path_switch_request_ack_transfer_ext_ies_o::ext_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::add_ngu_up_tnl_info:
      c.init<up_transport_layer_info_pair_list_l>();
      break;
    case types::redundant_ul_ngu_up_tnl_info:
      c.init<up_transport_layer_info_c>();
      break;
    case types::add_redundant_ngu_up_tnl_info:
      c.init<up_transport_layer_info_pair_list_l>();
      break;
    case types::qos_flow_params_list:
      c.init<qos_flow_params_list_l>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_ack_transfer_ext_ies_o::ext_c");
  }
}
path_switch_request_ack_transfer_ext_ies_o::ext_c::ext_c(const path_switch_request_ack_transfer_ext_ies_o::ext_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::add_ngu_up_tnl_info:
      c.init(other.c.get<up_transport_layer_info_pair_list_l>());
      break;
    case types::redundant_ul_ngu_up_tnl_info:
      c.init(other.c.get<up_transport_layer_info_c>());
      break;
    case types::add_redundant_ngu_up_tnl_info:
      c.init(other.c.get<up_transport_layer_info_pair_list_l>());
      break;
    case types::qos_flow_params_list:
      c.init(other.c.get<qos_flow_params_list_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_ack_transfer_ext_ies_o::ext_c");
  }
}
path_switch_request_ack_transfer_ext_ies_o::ext_c& path_switch_request_ack_transfer_ext_ies_o::ext_c::operator=(
    const path_switch_request_ack_transfer_ext_ies_o::ext_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::add_ngu_up_tnl_info:
      c.set(other.c.get<up_transport_layer_info_pair_list_l>());
      break;
    case types::redundant_ul_ngu_up_tnl_info:
      c.set(other.c.get<up_transport_layer_info_c>());
      break;
    case types::add_redundant_ngu_up_tnl_info:
      c.set(other.c.get<up_transport_layer_info_pair_list_l>());
      break;
    case types::qos_flow_params_list:
      c.set(other.c.get<qos_flow_params_list_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_ack_transfer_ext_ies_o::ext_c");
  }

  return *this;
}
up_transport_layer_info_pair_list_l& path_switch_request_ack_transfer_ext_ies_o::ext_c::add_ngu_up_tnl_info()
{
  assert_choice_type(types::add_ngu_up_tnl_info, type_, "Extension");
  return c.get<up_transport_layer_info_pair_list_l>();
}
up_transport_layer_info_c& path_switch_request_ack_transfer_ext_ies_o::ext_c::redundant_ul_ngu_up_tnl_info()
{
  assert_choice_type(types::redundant_ul_ngu_up_tnl_info, type_, "Extension");
  return c.get<up_transport_layer_info_c>();
}
up_transport_layer_info_pair_list_l& path_switch_request_ack_transfer_ext_ies_o::ext_c::add_redundant_ngu_up_tnl_info()
{
  assert_choice_type(types::add_redundant_ngu_up_tnl_info, type_, "Extension");
  return c.get<up_transport_layer_info_pair_list_l>();
}
qos_flow_params_list_l& path_switch_request_ack_transfer_ext_ies_o::ext_c::qos_flow_params_list()
{
  assert_choice_type(types::qos_flow_params_list, type_, "Extension");
  return c.get<qos_flow_params_list_l>();
}
const up_transport_layer_info_pair_list_l&
path_switch_request_ack_transfer_ext_ies_o::ext_c::add_ngu_up_tnl_info() const
{
  assert_choice_type(types::add_ngu_up_tnl_info, type_, "Extension");
  return c.get<up_transport_layer_info_pair_list_l>();
}
const up_transport_layer_info_c& path_switch_request_ack_transfer_ext_ies_o::ext_c::redundant_ul_ngu_up_tnl_info() const
{
  assert_choice_type(types::redundant_ul_ngu_up_tnl_info, type_, "Extension");
  return c.get<up_transport_layer_info_c>();
}
const up_transport_layer_info_pair_list_l&
path_switch_request_ack_transfer_ext_ies_o::ext_c::add_redundant_ngu_up_tnl_info() const
{
  assert_choice_type(types::add_redundant_ngu_up_tnl_info, type_, "Extension");
  return c.get<up_transport_layer_info_pair_list_l>();
}
const qos_flow_params_list_l& path_switch_request_ack_transfer_ext_ies_o::ext_c::qos_flow_params_list() const
{
  assert_choice_type(types::qos_flow_params_list, type_, "Extension");
  return c.get<qos_flow_params_list_l>();
}
void path_switch_request_ack_transfer_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::add_ngu_up_tnl_info:
      j.start_array("UPTransportLayerInformationPairList");
      for (const auto& e1 : c.get<up_transport_layer_info_pair_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::redundant_ul_ngu_up_tnl_info:
      j.write_fieldname("UPTransportLayerInformation");
      c.get<up_transport_layer_info_c>().to_json(j);
      break;
    case types::add_redundant_ngu_up_tnl_info:
      j.start_array("UPTransportLayerInformationPairList");
      for (const auto& e1 : c.get<up_transport_layer_info_pair_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::qos_flow_params_list:
      j.start_array("QosFlowParametersList");
      for (const auto& e1 : c.get<qos_flow_params_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_ack_transfer_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE path_switch_request_ack_transfer_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::add_ngu_up_tnl_info:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<up_transport_layer_info_pair_list_l>(), 1, 3, true));
      break;
    case types::redundant_ul_ngu_up_tnl_info:
      HANDLE_CODE(c.get<up_transport_layer_info_c>().pack(bref));
      break;
    case types::add_redundant_ngu_up_tnl_info:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<up_transport_layer_info_pair_list_l>(), 1, 3, true));
      break;
    case types::qos_flow_params_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<qos_flow_params_list_l>(), 1, 64, true));
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_ack_transfer_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE path_switch_request_ack_transfer_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::add_ngu_up_tnl_info:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<up_transport_layer_info_pair_list_l>(), bref, 1, 3, true));
      break;
    case types::redundant_ul_ngu_up_tnl_info:
      HANDLE_CODE(c.get<up_transport_layer_info_c>().unpack(bref));
      break;
    case types::add_redundant_ngu_up_tnl_info:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<up_transport_layer_info_pair_list_l>(), bref, 1, 3, true));
      break;
    case types::qos_flow_params_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<qos_flow_params_list_l>(), bref, 1, 64, true));
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_ack_transfer_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* path_switch_request_ack_transfer_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"UPTransportLayerInformationPairList",
                                "UPTransportLayerInformation",
                                "UPTransportLayerInformationPairList",
                                "QosFlowParametersList"};
  return convert_enum_idx(names, 4, value, "path_switch_request_ack_transfer_ext_ies_o::ext_c::types");
}

template struct asn1::protocol_ext_field_s<path_switch_request_ack_transfer_ext_ies_o>;

path_switch_request_ack_transfer_ext_ies_container::path_switch_request_ack_transfer_ext_ies_container() :
  add_ngu_up_tnl_info(154, crit_e::ignore),
  redundant_ul_ngu_up_tnl_info(195, crit_e::ignore),
  add_redundant_ngu_up_tnl_info(185, crit_e::ignore),
  qos_flow_params_list(277, crit_e::ignore)
{
}
SRSASN_CODE path_switch_request_ack_transfer_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += add_ngu_up_tnl_info_present ? 1 : 0;
  nof_ies += redundant_ul_ngu_up_tnl_info_present ? 1 : 0;
  nof_ies += add_redundant_ngu_up_tnl_info_present ? 1 : 0;
  nof_ies += qos_flow_params_list_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (add_ngu_up_tnl_info_present) {
    HANDLE_CODE(add_ngu_up_tnl_info.pack(bref));
  }
  if (redundant_ul_ngu_up_tnl_info_present) {
    HANDLE_CODE(redundant_ul_ngu_up_tnl_info.pack(bref));
  }
  if (add_redundant_ngu_up_tnl_info_present) {
    HANDLE_CODE(add_redundant_ngu_up_tnl_info.pack(bref));
  }
  if (qos_flow_params_list_present) {
    HANDLE_CODE(qos_flow_params_list.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE path_switch_request_ack_transfer_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 154: {
        add_ngu_up_tnl_info_present = true;
        add_ngu_up_tnl_info.id      = id;
        HANDLE_CODE(add_ngu_up_tnl_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(add_ngu_up_tnl_info.ext.unpack(bref));
        break;
      }
      case 195: {
        redundant_ul_ngu_up_tnl_info_present = true;
        redundant_ul_ngu_up_tnl_info.id      = id;
        HANDLE_CODE(redundant_ul_ngu_up_tnl_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(redundant_ul_ngu_up_tnl_info.ext.unpack(bref));
        break;
      }
      case 185: {
        add_redundant_ngu_up_tnl_info_present = true;
        add_redundant_ngu_up_tnl_info.id      = id;
        HANDLE_CODE(add_redundant_ngu_up_tnl_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(add_redundant_ngu_up_tnl_info.ext.unpack(bref));
        break;
      }
      case 277: {
        qos_flow_params_list_present = true;
        qos_flow_params_list.id      = id;
        HANDLE_CODE(qos_flow_params_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(qos_flow_params_list.ext.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void path_switch_request_ack_transfer_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (add_ngu_up_tnl_info_present) {
    j.write_fieldname("");
    add_ngu_up_tnl_info.to_json(j);
  }
  if (redundant_ul_ngu_up_tnl_info_present) {
    j.write_fieldname("");
    redundant_ul_ngu_up_tnl_info.to_json(j);
  }
  if (add_redundant_ngu_up_tnl_info_present) {
    j.write_fieldname("");
    add_redundant_ngu_up_tnl_info.to_json(j);
  }
  if (qos_flow_params_list_present) {
    j.write_fieldname("");
    qos_flow_params_list.to_json(j);
  }
  j.end_obj();
}

// PathSwitchRequestAcknowledgeTransfer ::= SEQUENCE
SRSASN_CODE path_switch_request_ack_transfer_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ul_ngu_up_tnl_info_present, 1));
  HANDLE_CODE(bref.pack(security_ind_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (ul_ngu_up_tnl_info_present) {
    HANDLE_CODE(ul_ngu_up_tnl_info.pack(bref));
  }
  if (security_ind_present) {
    HANDLE_CODE(security_ind.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE path_switch_request_ack_transfer_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ul_ngu_up_tnl_info_present, 1));
  HANDLE_CODE(bref.unpack(security_ind_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (ul_ngu_up_tnl_info_present) {
    HANDLE_CODE(ul_ngu_up_tnl_info.unpack(bref));
  }
  if (security_ind_present) {
    HANDLE_CODE(security_ind.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void path_switch_request_ack_transfer_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (ul_ngu_up_tnl_info_present) {
    j.write_fieldname("uL-NGU-UP-TNLInformation");
    ul_ngu_up_tnl_info.to_json(j);
  }
  if (security_ind_present) {
    j.write_fieldname("securityIndication");
    security_ind.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PathSwitchRequestSetupFailedTransfer ::= SEQUENCE
SRSASN_CODE path_switch_request_setup_failed_transfer_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(cause.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE path_switch_request_setup_failed_transfer_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(cause.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void path_switch_request_setup_failed_transfer_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("cause");
  cause.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// QosFlowAcceptedItem-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t qos_flow_accepted_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {221};
  return map_enum_number(names, 1, idx, "id");
}
bool qos_flow_accepted_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 221 == id;
}
crit_e qos_flow_accepted_item_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 221) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
qos_flow_accepted_item_ext_ies_o::ext_c qos_flow_accepted_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 221) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e qos_flow_accepted_item_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 221) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void qos_flow_accepted_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("INTEGER (1..8,...)", c);
  j.end_obj();
}
SRSASN_CODE qos_flow_accepted_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(pack_integer(bref, c, (uint8_t)1u, (uint8_t)8u, true, true));
  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_flow_accepted_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(unpack_integer(c, bref, (uint8_t)1u, (uint8_t)8u, true, true));
  return SRSASN_SUCCESS;
}

const char* qos_flow_accepted_item_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (1..8,...)"};
  return convert_enum_idx(names, 1, value, "qos_flow_accepted_item_ext_ies_o::ext_c::types");
}
uint8_t qos_flow_accepted_item_ext_ies_o::ext_c::types_opts::to_number() const
{
  static const uint8_t numbers[] = {1};
  return map_enum_number(numbers, 1, value, "qos_flow_accepted_item_ext_ies_o::ext_c::types");
}

// DL-NGU-TNLInformationReused ::= ENUMERATED
const char* dl_ngu_tnl_info_reused_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "dl_ngu_tnl_info_reused_e");
}

// QosFlowAcceptedItem ::= SEQUENCE
SRSASN_CODE qos_flow_accepted_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(pack_integer(bref, qos_flow_id, (uint8_t)0u, (uint8_t)63u, true, true));
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_flow_accepted_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(qos_flow_id, bref, (uint8_t)0u, (uint8_t)63u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void qos_flow_accepted_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("qosFlowIdentifier", qos_flow_id);
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// PathSwitchRequestTransfer-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t path_switch_request_transfer_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {155, 192, 191, 184, 198, 27, 309};
  return map_enum_number(names, 7, idx, "id");
}
bool path_switch_request_transfer_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {155, 192, 191, 184, 198, 27, 309};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e path_switch_request_transfer_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 155:
      return crit_e::ignore;
    case 192:
      return crit_e::ignore;
    case 191:
      return crit_e::ignore;
    case 184:
      return crit_e::ignore;
    case 198:
      return crit_e::ignore;
    case 27:
      return crit_e::ignore;
    case 309:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
path_switch_request_transfer_ext_ies_o::ext_c path_switch_request_transfer_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 155:
      ret.set(ext_c::types::add_dl_qos_flow_per_tnl_info);
      break;
    case 192:
      ret.set(ext_c::types::redundant_dl_ngu_up_tnl_info);
      break;
    case 191:
      ret.set(ext_c::types::redundant_dl_ngu_tnl_info_reused);
      break;
    case 184:
      ret.set(ext_c::types::add_redundant_dl_qos_flow_per_tnl_info);
      break;
    case 198:
      ret.set(ext_c::types::used_r_sn_info);
      break;
    case 27:
      ret.set(ext_c::types::global_ran_node_id);
      break;
    case 309:
      ret.set(ext_c::types::mbs_support_ind);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e path_switch_request_transfer_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 155:
      return presence_e::optional;
    case 192:
      return presence_e::optional;
    case 191:
      return presence_e::optional;
    case 184:
      return presence_e::optional;
    case 198:
      return presence_e::optional;
    case 27:
      return presence_e::optional;
    case 309:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void path_switch_request_transfer_ext_ies_o::ext_c::destroy_()
{
  switch (type_) {
    case types::add_dl_qos_flow_per_tnl_info:
      c.destroy<qos_flow_per_tnl_info_list_l>();
      break;
    case types::redundant_dl_ngu_up_tnl_info:
      c.destroy<up_transport_layer_info_c>();
      break;
    case types::add_redundant_dl_qos_flow_per_tnl_info:
      c.destroy<qos_flow_per_tnl_info_list_l>();
      break;
    case types::used_r_sn_info:
      c.destroy<redundant_pdu_session_info_s>();
      break;
    case types::global_ran_node_id:
      c.destroy<global_ran_node_id_c>();
      break;
    default:
      break;
  }
}
void path_switch_request_transfer_ext_ies_o::ext_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::add_dl_qos_flow_per_tnl_info:
      c.init<qos_flow_per_tnl_info_list_l>();
      break;
    case types::redundant_dl_ngu_up_tnl_info:
      c.init<up_transport_layer_info_c>();
      break;
    case types::redundant_dl_ngu_tnl_info_reused:
      break;
    case types::add_redundant_dl_qos_flow_per_tnl_info:
      c.init<qos_flow_per_tnl_info_list_l>();
      break;
    case types::used_r_sn_info:
      c.init<redundant_pdu_session_info_s>();
      break;
    case types::global_ran_node_id:
      c.init<global_ran_node_id_c>();
      break;
    case types::mbs_support_ind:
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_transfer_ext_ies_o::ext_c");
  }
}
path_switch_request_transfer_ext_ies_o::ext_c::ext_c(const path_switch_request_transfer_ext_ies_o::ext_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::add_dl_qos_flow_per_tnl_info:
      c.init(other.c.get<qos_flow_per_tnl_info_list_l>());
      break;
    case types::redundant_dl_ngu_up_tnl_info:
      c.init(other.c.get<up_transport_layer_info_c>());
      break;
    case types::redundant_dl_ngu_tnl_info_reused:
      c.init(other.c.get<dl_ngu_tnl_info_reused_e>());
      break;
    case types::add_redundant_dl_qos_flow_per_tnl_info:
      c.init(other.c.get<qos_flow_per_tnl_info_list_l>());
      break;
    case types::used_r_sn_info:
      c.init(other.c.get<redundant_pdu_session_info_s>());
      break;
    case types::global_ran_node_id:
      c.init(other.c.get<global_ran_node_id_c>());
      break;
    case types::mbs_support_ind:
      c.init(other.c.get<mbs_support_ind_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_transfer_ext_ies_o::ext_c");
  }
}
path_switch_request_transfer_ext_ies_o::ext_c&
path_switch_request_transfer_ext_ies_o::ext_c::operator=(const path_switch_request_transfer_ext_ies_o::ext_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::add_dl_qos_flow_per_tnl_info:
      c.set(other.c.get<qos_flow_per_tnl_info_list_l>());
      break;
    case types::redundant_dl_ngu_up_tnl_info:
      c.set(other.c.get<up_transport_layer_info_c>());
      break;
    case types::redundant_dl_ngu_tnl_info_reused:
      c.set(other.c.get<dl_ngu_tnl_info_reused_e>());
      break;
    case types::add_redundant_dl_qos_flow_per_tnl_info:
      c.set(other.c.get<qos_flow_per_tnl_info_list_l>());
      break;
    case types::used_r_sn_info:
      c.set(other.c.get<redundant_pdu_session_info_s>());
      break;
    case types::global_ran_node_id:
      c.set(other.c.get<global_ran_node_id_c>());
      break;
    case types::mbs_support_ind:
      c.set(other.c.get<mbs_support_ind_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_transfer_ext_ies_o::ext_c");
  }

  return *this;
}
qos_flow_per_tnl_info_list_l& path_switch_request_transfer_ext_ies_o::ext_c::add_dl_qos_flow_per_tnl_info()
{
  assert_choice_type(types::add_dl_qos_flow_per_tnl_info, type_, "Extension");
  return c.get<qos_flow_per_tnl_info_list_l>();
}
up_transport_layer_info_c& path_switch_request_transfer_ext_ies_o::ext_c::redundant_dl_ngu_up_tnl_info()
{
  assert_choice_type(types::redundant_dl_ngu_up_tnl_info, type_, "Extension");
  return c.get<up_transport_layer_info_c>();
}
dl_ngu_tnl_info_reused_e& path_switch_request_transfer_ext_ies_o::ext_c::redundant_dl_ngu_tnl_info_reused()
{
  assert_choice_type(types::redundant_dl_ngu_tnl_info_reused, type_, "Extension");
  return c.get<dl_ngu_tnl_info_reused_e>();
}
qos_flow_per_tnl_info_list_l& path_switch_request_transfer_ext_ies_o::ext_c::add_redundant_dl_qos_flow_per_tnl_info()
{
  assert_choice_type(types::add_redundant_dl_qos_flow_per_tnl_info, type_, "Extension");
  return c.get<qos_flow_per_tnl_info_list_l>();
}
redundant_pdu_session_info_s& path_switch_request_transfer_ext_ies_o::ext_c::used_r_sn_info()
{
  assert_choice_type(types::used_r_sn_info, type_, "Extension");
  return c.get<redundant_pdu_session_info_s>();
}
global_ran_node_id_c& path_switch_request_transfer_ext_ies_o::ext_c::global_ran_node_id()
{
  assert_choice_type(types::global_ran_node_id, type_, "Extension");
  return c.get<global_ran_node_id_c>();
}
mbs_support_ind_e& path_switch_request_transfer_ext_ies_o::ext_c::mbs_support_ind()
{
  assert_choice_type(types::mbs_support_ind, type_, "Extension");
  return c.get<mbs_support_ind_e>();
}
const qos_flow_per_tnl_info_list_l& path_switch_request_transfer_ext_ies_o::ext_c::add_dl_qos_flow_per_tnl_info() const
{
  assert_choice_type(types::add_dl_qos_flow_per_tnl_info, type_, "Extension");
  return c.get<qos_flow_per_tnl_info_list_l>();
}
const up_transport_layer_info_c& path_switch_request_transfer_ext_ies_o::ext_c::redundant_dl_ngu_up_tnl_info() const
{
  assert_choice_type(types::redundant_dl_ngu_up_tnl_info, type_, "Extension");
  return c.get<up_transport_layer_info_c>();
}
const dl_ngu_tnl_info_reused_e& path_switch_request_transfer_ext_ies_o::ext_c::redundant_dl_ngu_tnl_info_reused() const
{
  assert_choice_type(types::redundant_dl_ngu_tnl_info_reused, type_, "Extension");
  return c.get<dl_ngu_tnl_info_reused_e>();
}
const qos_flow_per_tnl_info_list_l&
path_switch_request_transfer_ext_ies_o::ext_c::add_redundant_dl_qos_flow_per_tnl_info() const
{
  assert_choice_type(types::add_redundant_dl_qos_flow_per_tnl_info, type_, "Extension");
  return c.get<qos_flow_per_tnl_info_list_l>();
}
const redundant_pdu_session_info_s& path_switch_request_transfer_ext_ies_o::ext_c::used_r_sn_info() const
{
  assert_choice_type(types::used_r_sn_info, type_, "Extension");
  return c.get<redundant_pdu_session_info_s>();
}
const global_ran_node_id_c& path_switch_request_transfer_ext_ies_o::ext_c::global_ran_node_id() const
{
  assert_choice_type(types::global_ran_node_id, type_, "Extension");
  return c.get<global_ran_node_id_c>();
}
const mbs_support_ind_e& path_switch_request_transfer_ext_ies_o::ext_c::mbs_support_ind() const
{
  assert_choice_type(types::mbs_support_ind, type_, "Extension");
  return c.get<mbs_support_ind_e>();
}
void path_switch_request_transfer_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::add_dl_qos_flow_per_tnl_info:
      j.start_array("QosFlowPerTNLInformationList");
      for (const auto& e1 : c.get<qos_flow_per_tnl_info_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::redundant_dl_ngu_up_tnl_info:
      j.write_fieldname("UPTransportLayerInformation");
      c.get<up_transport_layer_info_c>().to_json(j);
      break;
    case types::redundant_dl_ngu_tnl_info_reused:
      j.write_str("DL-NGU-TNLInformationReused", "true");
      break;
    case types::add_redundant_dl_qos_flow_per_tnl_info:
      j.start_array("QosFlowPerTNLInformationList");
      for (const auto& e1 : c.get<qos_flow_per_tnl_info_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::used_r_sn_info:
      j.write_fieldname("RedundantPDUSessionInformation");
      c.get<redundant_pdu_session_info_s>().to_json(j);
      break;
    case types::global_ran_node_id:
      j.write_fieldname("GlobalRANNodeID");
      c.get<global_ran_node_id_c>().to_json(j);
      break;
    case types::mbs_support_ind:
      j.write_str("MBS-SupportIndicator", "true");
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_transfer_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE path_switch_request_transfer_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::add_dl_qos_flow_per_tnl_info:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<qos_flow_per_tnl_info_list_l>(), 1, 3, true));
      break;
    case types::redundant_dl_ngu_up_tnl_info:
      HANDLE_CODE(c.get<up_transport_layer_info_c>().pack(bref));
      break;
    case types::redundant_dl_ngu_tnl_info_reused:
      HANDLE_CODE(c.get<dl_ngu_tnl_info_reused_e>().pack(bref));
      break;
    case types::add_redundant_dl_qos_flow_per_tnl_info:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<qos_flow_per_tnl_info_list_l>(), 1, 3, true));
      break;
    case types::used_r_sn_info:
      HANDLE_CODE(c.get<redundant_pdu_session_info_s>().pack(bref));
      break;
    case types::global_ran_node_id:
      HANDLE_CODE(c.get<global_ran_node_id_c>().pack(bref));
      break;
    case types::mbs_support_ind:
      HANDLE_CODE(c.get<mbs_support_ind_e>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_transfer_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE path_switch_request_transfer_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::add_dl_qos_flow_per_tnl_info:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<qos_flow_per_tnl_info_list_l>(), bref, 1, 3, true));
      break;
    case types::redundant_dl_ngu_up_tnl_info:
      HANDLE_CODE(c.get<up_transport_layer_info_c>().unpack(bref));
      break;
    case types::redundant_dl_ngu_tnl_info_reused:
      HANDLE_CODE(c.get<dl_ngu_tnl_info_reused_e>().unpack(bref));
      break;
    case types::add_redundant_dl_qos_flow_per_tnl_info:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<qos_flow_per_tnl_info_list_l>(), bref, 1, 3, true));
      break;
    case types::used_r_sn_info:
      HANDLE_CODE(c.get<redundant_pdu_session_info_s>().unpack(bref));
      break;
    case types::global_ran_node_id:
      HANDLE_CODE(c.get<global_ran_node_id_c>().unpack(bref));
      break;
    case types::mbs_support_ind:
      HANDLE_CODE(c.get<mbs_support_ind_e>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_transfer_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* path_switch_request_transfer_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"QosFlowPerTNLInformationList",
                                "UPTransportLayerInformation",
                                "DL-NGU-TNLInformationReused",
                                "QosFlowPerTNLInformationList",
                                "RedundantPDUSessionInformation",
                                "GlobalRANNodeID",
                                "MBS-SupportIndicator"};
  return convert_enum_idx(names, 7, value, "path_switch_request_transfer_ext_ies_o::ext_c::types");
}

// UserPlaneSecurityInformation ::= SEQUENCE
SRSASN_CODE user_plane_security_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(security_result.pack(bref));
  HANDLE_CODE(security_ind.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE user_plane_security_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(security_result.unpack(bref));
  HANDLE_CODE(security_ind.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void user_plane_security_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("securityResult");
  security_result.to_json(j);
  j.write_fieldname("securityIndication");
  security_ind.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ext_field_s<path_switch_request_transfer_ext_ies_o>;

path_switch_request_transfer_ext_ies_container::path_switch_request_transfer_ext_ies_container() :
  add_dl_qos_flow_per_tnl_info(155, crit_e::ignore),
  redundant_dl_ngu_up_tnl_info(192, crit_e::ignore),
  redundant_dl_ngu_tnl_info_reused(191, crit_e::ignore),
  add_redundant_dl_qos_flow_per_tnl_info(184, crit_e::ignore),
  used_r_sn_info(198, crit_e::ignore),
  global_ran_node_id(27, crit_e::ignore),
  mbs_support_ind(309, crit_e::ignore)
{
}
SRSASN_CODE path_switch_request_transfer_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += add_dl_qos_flow_per_tnl_info_present ? 1 : 0;
  nof_ies += redundant_dl_ngu_up_tnl_info_present ? 1 : 0;
  nof_ies += redundant_dl_ngu_tnl_info_reused_present ? 1 : 0;
  nof_ies += add_redundant_dl_qos_flow_per_tnl_info_present ? 1 : 0;
  nof_ies += used_r_sn_info_present ? 1 : 0;
  nof_ies += global_ran_node_id_present ? 1 : 0;
  nof_ies += mbs_support_ind_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (add_dl_qos_flow_per_tnl_info_present) {
    HANDLE_CODE(add_dl_qos_flow_per_tnl_info.pack(bref));
  }
  if (redundant_dl_ngu_up_tnl_info_present) {
    HANDLE_CODE(redundant_dl_ngu_up_tnl_info.pack(bref));
  }
  if (redundant_dl_ngu_tnl_info_reused_present) {
    HANDLE_CODE(redundant_dl_ngu_tnl_info_reused.pack(bref));
  }
  if (add_redundant_dl_qos_flow_per_tnl_info_present) {
    HANDLE_CODE(add_redundant_dl_qos_flow_per_tnl_info.pack(bref));
  }
  if (used_r_sn_info_present) {
    HANDLE_CODE(used_r_sn_info.pack(bref));
  }
  if (global_ran_node_id_present) {
    HANDLE_CODE(global_ran_node_id.pack(bref));
  }
  if (mbs_support_ind_present) {
    HANDLE_CODE(mbs_support_ind.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE path_switch_request_transfer_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 155: {
        add_dl_qos_flow_per_tnl_info_present = true;
        add_dl_qos_flow_per_tnl_info.id      = id;
        HANDLE_CODE(add_dl_qos_flow_per_tnl_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(add_dl_qos_flow_per_tnl_info.ext.unpack(bref));
        break;
      }
      case 192: {
        redundant_dl_ngu_up_tnl_info_present = true;
        redundant_dl_ngu_up_tnl_info.id      = id;
        HANDLE_CODE(redundant_dl_ngu_up_tnl_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(redundant_dl_ngu_up_tnl_info.ext.unpack(bref));
        break;
      }
      case 191: {
        redundant_dl_ngu_tnl_info_reused_present = true;
        redundant_dl_ngu_tnl_info_reused.id      = id;
        HANDLE_CODE(redundant_dl_ngu_tnl_info_reused.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(redundant_dl_ngu_tnl_info_reused.ext.unpack(bref));
        break;
      }
      case 184: {
        add_redundant_dl_qos_flow_per_tnl_info_present = true;
        add_redundant_dl_qos_flow_per_tnl_info.id      = id;
        HANDLE_CODE(add_redundant_dl_qos_flow_per_tnl_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(add_redundant_dl_qos_flow_per_tnl_info.ext.unpack(bref));
        break;
      }
      case 198: {
        used_r_sn_info_present = true;
        used_r_sn_info.id      = id;
        HANDLE_CODE(used_r_sn_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(used_r_sn_info.ext.unpack(bref));
        break;
      }
      case 27: {
        global_ran_node_id_present = true;
        global_ran_node_id.id      = id;
        HANDLE_CODE(global_ran_node_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(global_ran_node_id.ext.unpack(bref));
        break;
      }
      case 309: {
        mbs_support_ind_present = true;
        mbs_support_ind.id      = id;
        HANDLE_CODE(mbs_support_ind.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_support_ind.ext.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void path_switch_request_transfer_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (add_dl_qos_flow_per_tnl_info_present) {
    j.write_fieldname("");
    add_dl_qos_flow_per_tnl_info.to_json(j);
  }
  if (redundant_dl_ngu_up_tnl_info_present) {
    j.write_fieldname("");
    redundant_dl_ngu_up_tnl_info.to_json(j);
  }
  if (redundant_dl_ngu_tnl_info_reused_present) {
    j.write_fieldname("");
    redundant_dl_ngu_tnl_info_reused.to_json(j);
  }
  if (add_redundant_dl_qos_flow_per_tnl_info_present) {
    j.write_fieldname("");
    add_redundant_dl_qos_flow_per_tnl_info.to_json(j);
  }
  if (used_r_sn_info_present) {
    j.write_fieldname("");
    used_r_sn_info.to_json(j);
  }
  if (global_ran_node_id_present) {
    j.write_fieldname("");
    global_ran_node_id.to_json(j);
  }
  if (mbs_support_ind_present) {
    j.write_fieldname("");
    mbs_support_ind.to_json(j);
  }
  j.end_obj();
}

// PathSwitchRequestTransfer ::= SEQUENCE
SRSASN_CODE path_switch_request_transfer_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(dl_ngu_tnl_info_reused_present, 1));
  HANDLE_CODE(bref.pack(user_plane_security_info_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(dl_ngu_up_tnl_info.pack(bref));
  if (dl_ngu_tnl_info_reused_present) {
    HANDLE_CODE(dl_ngu_tnl_info_reused.pack(bref));
  }
  if (user_plane_security_info_present) {
    HANDLE_CODE(user_plane_security_info.pack(bref));
  }
  HANDLE_CODE(pack_dyn_seq_of(bref, qos_flow_accepted_list, 1, 64, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE path_switch_request_transfer_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(dl_ngu_tnl_info_reused_present, 1));
  HANDLE_CODE(bref.unpack(user_plane_security_info_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(dl_ngu_up_tnl_info.unpack(bref));
  if (dl_ngu_tnl_info_reused_present) {
    HANDLE_CODE(dl_ngu_tnl_info_reused.unpack(bref));
  }
  if (user_plane_security_info_present) {
    HANDLE_CODE(user_plane_security_info.unpack(bref));
  }
  HANDLE_CODE(unpack_dyn_seq_of(qos_flow_accepted_list, bref, 1, 64, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void path_switch_request_transfer_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("dL-NGU-UP-TNLInformation");
  dl_ngu_up_tnl_info.to_json(j);
  if (dl_ngu_tnl_info_reused_present) {
    j.write_str("dL-NGU-TNLInformationReused", "true");
  }
  if (user_plane_security_info_present) {
    j.write_fieldname("userPlaneSecurityInformation");
    user_plane_security_info.to_json(j);
  }
  j.start_array("qosFlowAcceptedList");
  for (const auto& e1 : qos_flow_accepted_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PathSwitchRequestUnsuccessfulTransfer ::= SEQUENCE
SRSASN_CODE path_switch_request_unsuccessful_transfer_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(cause.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE path_switch_request_unsuccessful_transfer_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(cause.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void path_switch_request_unsuccessful_transfer_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("cause");
  cause.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// ProtocolIE-FieldPair{NGAP-PROTOCOL-IES-PAIR : IEsSetParam} ::= SEQUENCE{{NGAP-PROTOCOL-IES-PAIR}}
template <class ies_set_paramT_>
SRSASN_CODE protocol_ie_field_pair_s<ies_set_paramT_>::pack(bit_ref& bref) const
{
  HANDLE_CODE(pack_integer(bref, id, (uint32_t)0u, (uint32_t)65535u, false, true));
  warn_assert(first_crit != ies_set_paramT_::get_first_crit(id), __func__, __LINE__);
  HANDLE_CODE(first_crit.pack(bref));
  HANDLE_CODE(first_value.pack(bref));
  warn_assert(second_crit != ies_set_paramT_::get_second_crit(id), __func__, __LINE__);
  HANDLE_CODE(second_crit.pack(bref));
  HANDLE_CODE(second_value.pack(bref));

  return SRSASN_SUCCESS;
}
template <class ies_set_paramT_>
SRSASN_CODE protocol_ie_field_pair_s<ies_set_paramT_>::unpack(cbit_ref& bref)
{
  HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
  HANDLE_CODE(first_crit.unpack(bref));
  first_value = ies_set_paramT_::get_first_value(id);
  HANDLE_CODE(first_value.unpack(bref));
  HANDLE_CODE(second_crit.unpack(bref));
  second_value = ies_set_paramT_::get_second_value(id);
  HANDLE_CODE(second_value.unpack(bref));

  return SRSASN_SUCCESS;
}
template <class ies_set_paramT_>
void protocol_ie_field_pair_s<ies_set_paramT_>::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", id);
  j.write_str("firstCriticality", first_crit.to_string());
  j.write_str("secondCriticality", second_crit.to_string());
  j.end_obj();
}
template <class ies_set_paramT_>
bool protocol_ie_field_pair_s<ies_set_paramT_>::load_info_obj(const uint32_t& id_)
{
  if (not ies_set_paramT_::is_id_valid(id_)) {
    return false;
  }
  id           = id_;
  first_crit   = ies_set_paramT_::get_first_crit(id);
  first_value  = ies_set_paramT_::get_first_value(id);
  second_crit  = ies_set_paramT_::get_second_crit(id);
  second_value = ies_set_paramT_::get_second_value(id);
  return first_value.type().value != ies_set_paramT_::first_value_c::types_opts::nulltype and
         second_value.type().value != ies_set_paramT_::second_value_c::types_opts::nulltype;
}

// SecondaryRATDataUsageReportTransfer ::= SEQUENCE
SRSASN_CODE secondary_rat_data_usage_report_transfer_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(secondary_rat_usage_info_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (secondary_rat_usage_info_present) {
    HANDLE_CODE(secondary_rat_usage_info.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE secondary_rat_data_usage_report_transfer_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(secondary_rat_usage_info_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (secondary_rat_usage_info_present) {
    HANDLE_CODE(secondary_rat_usage_info.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void secondary_rat_data_usage_report_transfer_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (secondary_rat_usage_info_present) {
    j.write_fieldname("secondaryRATUsageInformation");
    secondary_rat_usage_info.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SourceNodeID ::= CHOICE
void source_node_id_c::destroy_()
{
  switch (type_) {
    case types::sourceen_gnb_id:
      c.destroy<global_gnb_id_s>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<source_node_id_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void source_node_id_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::sourceen_gnb_id:
      c.init<global_gnb_id_s>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<source_node_id_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "source_node_id_c");
  }
}
source_node_id_c::source_node_id_c(const source_node_id_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::sourceen_gnb_id:
      c.init(other.c.get<global_gnb_id_s>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<source_node_id_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "source_node_id_c");
  }
}
source_node_id_c& source_node_id_c::operator=(const source_node_id_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::sourceen_gnb_id:
      c.set(other.c.get<global_gnb_id_s>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<source_node_id_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "source_node_id_c");
  }

  return *this;
}
global_gnb_id_s& source_node_id_c::set_sourceen_gnb_id()
{
  set(types::sourceen_gnb_id);
  return c.get<global_gnb_id_s>();
}
protocol_ie_single_container_s<source_node_id_ext_ies_o>& source_node_id_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<source_node_id_ext_ies_o>>();
}
void source_node_id_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::sourceen_gnb_id:
      j.write_fieldname("sourceengNB-ID");
      c.get<global_gnb_id_s>().to_json(j);
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<source_node_id_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "source_node_id_c");
  }
  j.end_obj();
}
SRSASN_CODE source_node_id_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::sourceen_gnb_id:
      HANDLE_CODE(c.get<global_gnb_id_s>().pack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<source_node_id_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "source_node_id_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE source_node_id_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::sourceen_gnb_id:
      HANDLE_CODE(c.get<global_gnb_id_s>().unpack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<source_node_id_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "source_node_id_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* source_node_id_c::types_opts::to_string() const
{
  static const char* names[] = {"sourceengNB-ID", "choice-Extensions"};
  return convert_enum_idx(names, 2, value, "source_node_id_c::types");
}

// UEHistoryInformationFromTheUE ::= CHOICE
void ue_history_info_from_the_ue_c::destroy_()
{
  switch (type_) {
    case types::nr:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<ue_history_info_from_the_ue_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void ue_history_info_from_the_ue_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::nr:
      c.init<unbounded_octstring<true>>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<ue_history_info_from_the_ue_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_history_info_from_the_ue_c");
  }
}
ue_history_info_from_the_ue_c::ue_history_info_from_the_ue_c(const ue_history_info_from_the_ue_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::nr:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<ue_history_info_from_the_ue_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_history_info_from_the_ue_c");
  }
}
ue_history_info_from_the_ue_c& ue_history_info_from_the_ue_c::operator=(const ue_history_info_from_the_ue_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::nr:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<ue_history_info_from_the_ue_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_history_info_from_the_ue_c");
  }

  return *this;
}
unbounded_octstring<true>& ue_history_info_from_the_ue_c::set_nr()
{
  set(types::nr);
  return c.get<unbounded_octstring<true>>();
}
protocol_ie_single_container_s<ue_history_info_from_the_ue_ext_ies_o>& ue_history_info_from_the_ue_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<ue_history_info_from_the_ue_ext_ies_o>>();
}
void ue_history_info_from_the_ue_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::nr:
      j.write_str("nR", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<ue_history_info_from_the_ue_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ue_history_info_from_the_ue_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_history_info_from_the_ue_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::nr:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<ue_history_info_from_the_ue_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_history_info_from_the_ue_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_history_info_from_the_ue_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::nr:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<ue_history_info_from_the_ue_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_history_info_from_the_ue_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ue_history_info_from_the_ue_c::types_opts::to_string() const
{
  static const char* names[] = {"nR", "choice-Extensions"};
  return convert_enum_idx(names, 2, value, "ue_history_info_from_the_ue_c::types");
}

// SourceNGRANNode-ToTargetNGRANNode-TransparentContainer-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t source_ngran_node_to_target_ngran_node_transparent_container_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {182, 253, 286, 288, 323, 328, 355};
  return map_enum_number(names, 7, idx, "id");
}
bool source_ngran_node_to_target_ngran_node_transparent_container_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {182, 253, 286, 288, 323, 328, 355};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e source_ngran_node_to_target_ngran_node_transparent_container_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 182:
      return crit_e::ignore;
    case 253:
      return crit_e::ignore;
    case 286:
      return crit_e::ignore;
    case 288:
      return crit_e::ignore;
    case 323:
      return crit_e::ignore;
    case 328:
      return crit_e::ignore;
    case 355:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
source_ngran_node_to_target_ngran_node_transparent_container_ext_ies_o::ext_c
source_ngran_node_to_target_ngran_node_transparent_container_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 182:
      ret.set(ext_c::types::s_gnb_ue_x2ap_id);
      break;
    case 253:
      ret.set(ext_c::types::ue_history_info_from_the_ue);
      break;
    case 286:
      ret.set(ext_c::types::source_node_id);
      break;
    case 288:
      ret.set(ext_c::types::ue_context_ref_at_source);
      break;
    case 323:
      ret.set(ext_c::types::mbs_active_session_info_sourceto_target_list);
      break;
    case 328:
      ret.set(ext_c::types::q_mcc_onfig_info);
      break;
    case 355:
      ret.set(ext_c::types::ngap_ie_support_info_request_list);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e source_ngran_node_to_target_ngran_node_transparent_container_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 182:
      return presence_e::optional;
    case 253:
      return presence_e::optional;
    case 286:
      return presence_e::optional;
    case 288:
      return presence_e::optional;
    case 323:
      return presence_e::optional;
    case 328:
      return presence_e::optional;
    case 355:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void source_ngran_node_to_target_ngran_node_transparent_container_ext_ies_o::ext_c::destroy_()
{
  switch (type_) {
    case types::ue_history_info_from_the_ue:
      c.destroy<ue_history_info_from_the_ue_c>();
      break;
    case types::source_node_id:
      c.destroy<source_node_id_c>();
      break;
    case types::mbs_active_session_info_sourceto_target_list:
      c.destroy<mbs_active_session_info_sourceto_target_list_l>();
      break;
    case types::q_mcc_onfig_info:
      c.destroy<q_mcc_onfig_info_s>();
      break;
    case types::ngap_ie_support_info_request_list:
      c.destroy<ngap_ie_support_info_request_list_l>();
      break;
    default:
      break;
  }
}
void source_ngran_node_to_target_ngran_node_transparent_container_ext_ies_o::ext_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::s_gnb_ue_x2ap_id:
      break;
    case types::ue_history_info_from_the_ue:
      c.init<ue_history_info_from_the_ue_c>();
      break;
    case types::source_node_id:
      c.init<source_node_id_c>();
      break;
    case types::ue_context_ref_at_source:
      break;
    case types::mbs_active_session_info_sourceto_target_list:
      c.init<mbs_active_session_info_sourceto_target_list_l>();
      break;
    case types::q_mcc_onfig_info:
      c.init<q_mcc_onfig_info_s>();
      break;
    case types::ngap_ie_support_info_request_list:
      c.init<ngap_ie_support_info_request_list_l>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "source_ngran_node_to_target_ngran_node_transparent_container_ext_ies_o::ext_c");
  }
}
source_ngran_node_to_target_ngran_node_transparent_container_ext_ies_o::ext_c::ext_c(
    const source_ngran_node_to_target_ngran_node_transparent_container_ext_ies_o::ext_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::s_gnb_ue_x2ap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ue_history_info_from_the_ue:
      c.init(other.c.get<ue_history_info_from_the_ue_c>());
      break;
    case types::source_node_id:
      c.init(other.c.get<source_node_id_c>());
      break;
    case types::ue_context_ref_at_source:
      c.init(other.c.get<uint64_t>());
      break;
    case types::mbs_active_session_info_sourceto_target_list:
      c.init(other.c.get<mbs_active_session_info_sourceto_target_list_l>());
      break;
    case types::q_mcc_onfig_info:
      c.init(other.c.get<q_mcc_onfig_info_s>());
      break;
    case types::ngap_ie_support_info_request_list:
      c.init(other.c.get<ngap_ie_support_info_request_list_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "source_ngran_node_to_target_ngran_node_transparent_container_ext_ies_o::ext_c");
  }
}
source_ngran_node_to_target_ngran_node_transparent_container_ext_ies_o::ext_c&
source_ngran_node_to_target_ngran_node_transparent_container_ext_ies_o::ext_c::operator=(
    const source_ngran_node_to_target_ngran_node_transparent_container_ext_ies_o::ext_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::s_gnb_ue_x2ap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ue_history_info_from_the_ue:
      c.set(other.c.get<ue_history_info_from_the_ue_c>());
      break;
    case types::source_node_id:
      c.set(other.c.get<source_node_id_c>());
      break;
    case types::ue_context_ref_at_source:
      c.set(other.c.get<uint64_t>());
      break;
    case types::mbs_active_session_info_sourceto_target_list:
      c.set(other.c.get<mbs_active_session_info_sourceto_target_list_l>());
      break;
    case types::q_mcc_onfig_info:
      c.set(other.c.get<q_mcc_onfig_info_s>());
      break;
    case types::ngap_ie_support_info_request_list:
      c.set(other.c.get<ngap_ie_support_info_request_list_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "source_ngran_node_to_target_ngran_node_transparent_container_ext_ies_o::ext_c");
  }

  return *this;
}
uint64_t& source_ngran_node_to_target_ngran_node_transparent_container_ext_ies_o::ext_c::s_gnb_ue_x2ap_id()
{
  assert_choice_type(types::s_gnb_ue_x2ap_id, type_, "Extension");
  return c.get<uint64_t>();
}
ue_history_info_from_the_ue_c&
source_ngran_node_to_target_ngran_node_transparent_container_ext_ies_o::ext_c::ue_history_info_from_the_ue()
{
  assert_choice_type(types::ue_history_info_from_the_ue, type_, "Extension");
  return c.get<ue_history_info_from_the_ue_c>();
}
source_node_id_c& source_ngran_node_to_target_ngran_node_transparent_container_ext_ies_o::ext_c::source_node_id()
{
  assert_choice_type(types::source_node_id, type_, "Extension");
  return c.get<source_node_id_c>();
}
uint64_t& source_ngran_node_to_target_ngran_node_transparent_container_ext_ies_o::ext_c::ue_context_ref_at_source()
{
  assert_choice_type(types::ue_context_ref_at_source, type_, "Extension");
  return c.get<uint64_t>();
}
mbs_active_session_info_sourceto_target_list_l& source_ngran_node_to_target_ngran_node_transparent_container_ext_ies_o::
    ext_c::mbs_active_session_info_sourceto_target_list()
{
  assert_choice_type(types::mbs_active_session_info_sourceto_target_list, type_, "Extension");
  return c.get<mbs_active_session_info_sourceto_target_list_l>();
}
q_mcc_onfig_info_s& source_ngran_node_to_target_ngran_node_transparent_container_ext_ies_o::ext_c::q_mcc_onfig_info()
{
  assert_choice_type(types::q_mcc_onfig_info, type_, "Extension");
  return c.get<q_mcc_onfig_info_s>();
}
ngap_ie_support_info_request_list_l&
source_ngran_node_to_target_ngran_node_transparent_container_ext_ies_o::ext_c::ngap_ie_support_info_request_list()
{
  assert_choice_type(types::ngap_ie_support_info_request_list, type_, "Extension");
  return c.get<ngap_ie_support_info_request_list_l>();
}
const uint64_t& source_ngran_node_to_target_ngran_node_transparent_container_ext_ies_o::ext_c::s_gnb_ue_x2ap_id() const
{
  assert_choice_type(types::s_gnb_ue_x2ap_id, type_, "Extension");
  return c.get<uint64_t>();
}
const ue_history_info_from_the_ue_c&
source_ngran_node_to_target_ngran_node_transparent_container_ext_ies_o::ext_c::ue_history_info_from_the_ue() const
{
  assert_choice_type(types::ue_history_info_from_the_ue, type_, "Extension");
  return c.get<ue_history_info_from_the_ue_c>();
}
const source_node_id_c&
source_ngran_node_to_target_ngran_node_transparent_container_ext_ies_o::ext_c::source_node_id() const
{
  assert_choice_type(types::source_node_id, type_, "Extension");
  return c.get<source_node_id_c>();
}
const uint64_t&
source_ngran_node_to_target_ngran_node_transparent_container_ext_ies_o::ext_c::ue_context_ref_at_source() const
{
  assert_choice_type(types::ue_context_ref_at_source, type_, "Extension");
  return c.get<uint64_t>();
}
const mbs_active_session_info_sourceto_target_list_l&
source_ngran_node_to_target_ngran_node_transparent_container_ext_ies_o::ext_c::
    mbs_active_session_info_sourceto_target_list() const
{
  assert_choice_type(types::mbs_active_session_info_sourceto_target_list, type_, "Extension");
  return c.get<mbs_active_session_info_sourceto_target_list_l>();
}
const q_mcc_onfig_info_s&
source_ngran_node_to_target_ngran_node_transparent_container_ext_ies_o::ext_c::q_mcc_onfig_info() const
{
  assert_choice_type(types::q_mcc_onfig_info, type_, "Extension");
  return c.get<q_mcc_onfig_info_s>();
}
const ngap_ie_support_info_request_list_l&
source_ngran_node_to_target_ngran_node_transparent_container_ext_ies_o::ext_c::ngap_ie_support_info_request_list() const
{
  assert_choice_type(types::ngap_ie_support_info_request_list, type_, "Extension");
  return c.get<ngap_ie_support_info_request_list_l>();
}
void source_ngran_node_to_target_ngran_node_transparent_container_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::s_gnb_ue_x2ap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::ue_history_info_from_the_ue:
      j.write_fieldname("UEHistoryInformationFromTheUE");
      c.get<ue_history_info_from_the_ue_c>().to_json(j);
      break;
    case types::source_node_id:
      j.write_fieldname("SourceNodeID");
      c.get<source_node_id_c>().to_json(j);
      break;
    case types::ue_context_ref_at_source:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::mbs_active_session_info_sourceto_target_list:
      j.start_array("MBS-ActiveSessionInformation-SourcetoTargetList");
      for (const auto& e1 : c.get<mbs_active_session_info_sourceto_target_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::q_mcc_onfig_info:
      j.write_fieldname("QMCConfigInfo");
      c.get<q_mcc_onfig_info_s>().to_json(j);
      break;
    case types::ngap_ie_support_info_request_list:
      j.start_array("NGAPIESupportInformationRequestList");
      for (const auto& e1 : c.get<ngap_ie_support_info_request_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    default:
      log_invalid_choice_id(type_, "source_ngran_node_to_target_ngran_node_transparent_container_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE source_ngran_node_to_target_ngran_node_transparent_container_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::s_gnb_ue_x2ap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ue_history_info_from_the_ue:
      HANDLE_CODE(c.get<ue_history_info_from_the_ue_c>().pack(bref));
      break;
    case types::source_node_id:
      HANDLE_CODE(c.get<source_node_id_c>().pack(bref));
      break;
    case types::ue_context_ref_at_source:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::mbs_active_session_info_sourceto_target_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<mbs_active_session_info_sourceto_target_list_l>(), 1, 256, true));
      break;
    case types::q_mcc_onfig_info:
      HANDLE_CODE(c.get<q_mcc_onfig_info_s>().pack(bref));
      break;
    case types::ngap_ie_support_info_request_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<ngap_ie_support_info_request_list_l>(), 1, 32, true));
      break;
    default:
      log_invalid_choice_id(type_, "source_ngran_node_to_target_ngran_node_transparent_container_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE source_ngran_node_to_target_ngran_node_transparent_container_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::s_gnb_ue_x2ap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ue_history_info_from_the_ue:
      HANDLE_CODE(c.get<ue_history_info_from_the_ue_c>().unpack(bref));
      break;
    case types::source_node_id:
      HANDLE_CODE(c.get<source_node_id_c>().unpack(bref));
      break;
    case types::ue_context_ref_at_source:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::mbs_active_session_info_sourceto_target_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<mbs_active_session_info_sourceto_target_list_l>(), bref, 1, 256, true));
      break;
    case types::q_mcc_onfig_info:
      HANDLE_CODE(c.get<q_mcc_onfig_info_s>().unpack(bref));
      break;
    case types::ngap_ie_support_info_request_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<ngap_ie_support_info_request_list_l>(), bref, 1, 32, true));
      break;
    default:
      log_invalid_choice_id(type_, "source_ngran_node_to_target_ngran_node_transparent_container_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* source_ngran_node_to_target_ngran_node_transparent_container_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"INTEGER (0..4294967295)",
                                "UEHistoryInformationFromTheUE",
                                "SourceNodeID",
                                "INTEGER (0..4294967295)",
                                "MBS-ActiveSessionInformation-SourcetoTargetList",
                                "QMCConfigInfo",
                                "NGAPIESupportInformationRequestList"};
  return convert_enum_idx(
      names, 7, value, "source_ngran_node_to_target_ngran_node_transparent_container_ext_ies_o::ext_c::types");
}

template struct asn1::protocol_ext_field_s<source_ngran_node_to_target_ngran_node_transparent_container_ext_ies_o>;

source_ngran_node_to_target_ngran_node_transparent_container_ext_ies_container::
    source_ngran_node_to_target_ngran_node_transparent_container_ext_ies_container() :
  s_gnb_ue_x2ap_id(182, crit_e::ignore),
  ue_history_info_from_the_ue(253, crit_e::ignore),
  source_node_id(286, crit_e::ignore),
  ue_context_ref_at_source(288, crit_e::ignore),
  mbs_active_session_info_sourceto_target_list(323, crit_e::ignore),
  q_mcc_onfig_info(328, crit_e::ignore),
  ngap_ie_support_info_request_list(355, crit_e::ignore)
{
}
SRSASN_CODE source_ngran_node_to_target_ngran_node_transparent_container_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += s_gnb_ue_x2ap_id_present ? 1 : 0;
  nof_ies += ue_history_info_from_the_ue_present ? 1 : 0;
  nof_ies += source_node_id_present ? 1 : 0;
  nof_ies += ue_context_ref_at_source_present ? 1 : 0;
  nof_ies += mbs_active_session_info_sourceto_target_list_present ? 1 : 0;
  nof_ies += q_mcc_onfig_info_present ? 1 : 0;
  nof_ies += ngap_ie_support_info_request_list_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (s_gnb_ue_x2ap_id_present) {
    HANDLE_CODE(s_gnb_ue_x2ap_id.pack(bref));
  }
  if (ue_history_info_from_the_ue_present) {
    HANDLE_CODE(ue_history_info_from_the_ue.pack(bref));
  }
  if (source_node_id_present) {
    HANDLE_CODE(source_node_id.pack(bref));
  }
  if (ue_context_ref_at_source_present) {
    HANDLE_CODE(ue_context_ref_at_source.pack(bref));
  }
  if (mbs_active_session_info_sourceto_target_list_present) {
    HANDLE_CODE(mbs_active_session_info_sourceto_target_list.pack(bref));
  }
  if (q_mcc_onfig_info_present) {
    HANDLE_CODE(q_mcc_onfig_info.pack(bref));
  }
  if (ngap_ie_support_info_request_list_present) {
    HANDLE_CODE(ngap_ie_support_info_request_list.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE source_ngran_node_to_target_ngran_node_transparent_container_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 182: {
        s_gnb_ue_x2ap_id_present = true;
        s_gnb_ue_x2ap_id.id      = id;
        HANDLE_CODE(s_gnb_ue_x2ap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(s_gnb_ue_x2ap_id.ext.unpack(bref));
        break;
      }
      case 253: {
        ue_history_info_from_the_ue_present = true;
        ue_history_info_from_the_ue.id      = id;
        HANDLE_CODE(ue_history_info_from_the_ue.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_history_info_from_the_ue.ext.unpack(bref));
        break;
      }
      case 286: {
        source_node_id_present = true;
        source_node_id.id      = id;
        HANDLE_CODE(source_node_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(source_node_id.ext.unpack(bref));
        break;
      }
      case 288: {
        ue_context_ref_at_source_present = true;
        ue_context_ref_at_source.id      = id;
        HANDLE_CODE(ue_context_ref_at_source.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_context_ref_at_source.ext.unpack(bref));
        break;
      }
      case 323: {
        mbs_active_session_info_sourceto_target_list_present = true;
        mbs_active_session_info_sourceto_target_list.id      = id;
        HANDLE_CODE(mbs_active_session_info_sourceto_target_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_active_session_info_sourceto_target_list.ext.unpack(bref));
        break;
      }
      case 328: {
        q_mcc_onfig_info_present = true;
        q_mcc_onfig_info.id      = id;
        HANDLE_CODE(q_mcc_onfig_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(q_mcc_onfig_info.ext.unpack(bref));
        break;
      }
      case 355: {
        ngap_ie_support_info_request_list_present = true;
        ngap_ie_support_info_request_list.id      = id;
        HANDLE_CODE(ngap_ie_support_info_request_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ngap_ie_support_info_request_list.ext.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void source_ngran_node_to_target_ngran_node_transparent_container_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (s_gnb_ue_x2ap_id_present) {
    j.write_fieldname("");
    s_gnb_ue_x2ap_id.to_json(j);
  }
  if (ue_history_info_from_the_ue_present) {
    j.write_fieldname("");
    ue_history_info_from_the_ue.to_json(j);
  }
  if (source_node_id_present) {
    j.write_fieldname("");
    source_node_id.to_json(j);
  }
  if (ue_context_ref_at_source_present) {
    j.write_fieldname("");
    ue_context_ref_at_source.to_json(j);
  }
  if (mbs_active_session_info_sourceto_target_list_present) {
    j.write_fieldname("");
    mbs_active_session_info_sourceto_target_list.to_json(j);
  }
  if (q_mcc_onfig_info_present) {
    j.write_fieldname("");
    q_mcc_onfig_info.to_json(j);
  }
  if (ngap_ie_support_info_request_list_present) {
    j.write_fieldname("");
    ngap_ie_support_info_request_list.to_json(j);
  }
  j.end_obj();
}

// SourceNGRANNode-ToTargetNGRANNode-TransparentContainer ::= SEQUENCE
SRSASN_CODE source_ngran_node_to_target_ngran_node_transparent_container_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(pdu_session_res_info_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(erab_info_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(idx_to_rfsp_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(rrc_container.pack(bref));
  if (pdu_session_res_info_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, pdu_session_res_info_list, 1, 256, true));
  }
  if (erab_info_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, erab_info_list, 1, 256, true));
  }
  HANDLE_CODE(target_cell_id.pack(bref));
  if (idx_to_rfsp_present) {
    HANDLE_CODE(pack_integer(bref, idx_to_rfsp, (uint16_t)1u, (uint16_t)256u, true, true));
  }
  HANDLE_CODE(pack_dyn_seq_of(bref, ue_history_info, 1, 16, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE source_ngran_node_to_target_ngran_node_transparent_container_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool pdu_session_res_info_list_present;
  HANDLE_CODE(bref.unpack(pdu_session_res_info_list_present, 1));
  bool erab_info_list_present;
  HANDLE_CODE(bref.unpack(erab_info_list_present, 1));
  HANDLE_CODE(bref.unpack(idx_to_rfsp_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(rrc_container.unpack(bref));
  if (pdu_session_res_info_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(pdu_session_res_info_list, bref, 1, 256, true));
  }
  if (erab_info_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(erab_info_list, bref, 1, 256, true));
  }
  HANDLE_CODE(target_cell_id.unpack(bref));
  if (idx_to_rfsp_present) {
    HANDLE_CODE(unpack_integer(idx_to_rfsp, bref, (uint16_t)1u, (uint16_t)256u, true, true));
  }
  HANDLE_CODE(unpack_dyn_seq_of(ue_history_info, bref, 1, 16, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void source_ngran_node_to_target_ngran_node_transparent_container_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("rRCContainer", rrc_container.to_string());
  if (pdu_session_res_info_list.size() > 0) {
    j.start_array("pDUSessionResourceInformationList");
    for (const auto& e1 : pdu_session_res_info_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (erab_info_list.size() > 0) {
    j.start_array("e-RABInformationList");
    for (const auto& e1 : erab_info_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  j.write_fieldname("targetCell-ID");
  target_cell_id.to_json(j);
  if (idx_to_rfsp_present) {
    j.write_int("indexToRFSP", idx_to_rfsp);
  }
  j.start_array("uEHistoryInformation");
  for (const auto& e1 : ue_history_info) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TargetNGRANNode-ToSourceNGRANNode-FailureTransparentContainer-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t target_ngran_node_to_source_ngran_node_fail_transparent_container_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {356};
  return map_enum_number(names, 1, idx, "id");
}
bool target_ngran_node_to_source_ngran_node_fail_transparent_container_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 356 == id;
}
crit_e target_ngran_node_to_source_ngran_node_fail_transparent_container_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 356) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
target_ngran_node_to_source_ngran_node_fail_transparent_container_ext_ies_o::ext_c
target_ngran_node_to_source_ngran_node_fail_transparent_container_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 356) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e target_ngran_node_to_source_ngran_node_fail_transparent_container_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 356) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void target_ngran_node_to_source_ngran_node_fail_transparent_container_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("NGAPIESupportInformationResponseList");
  for (const auto& e1 : c) {
    e1.to_json(j);
  }
  j.end_array();
  j.end_obj();
}
SRSASN_CODE
target_ngran_node_to_source_ngran_node_fail_transparent_container_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(pack_dyn_seq_of(bref, c, 1, 32, true));
  return SRSASN_SUCCESS;
}
SRSASN_CODE target_ngran_node_to_source_ngran_node_fail_transparent_container_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(unpack_dyn_seq_of(c, bref, 1, 32, true));
  return SRSASN_SUCCESS;
}

const char*
target_ngran_node_to_source_ngran_node_fail_transparent_container_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"NGAPIESupportInformationResponseList"};
  return convert_enum_idx(
      names, 1, value, "target_ngran_node_to_source_ngran_node_fail_transparent_container_ext_ies_o::ext_c::types");
}

// TargetNGRANNode-ToSourceNGRANNode-FailureTransparentContainer ::= SEQUENCE
SRSASN_CODE target_ngran_node_to_source_ngran_node_fail_transparent_container_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(cell_cag_info_present, 1));
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  if (cell_cag_info_present) {
    HANDLE_CODE(cell_cag_info.pack(bref));
  }
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE target_ngran_node_to_source_ngran_node_fail_transparent_container_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(cell_cag_info_present, 1));
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (cell_cag_info_present) {
    HANDLE_CODE(cell_cag_info.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void target_ngran_node_to_source_ngran_node_fail_transparent_container_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (cell_cag_info_present) {
    j.write_fieldname("cell-CAGInformation");
    cell_cag_info.to_json(j);
  }
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// TargetNGRANNode-ToSourceNGRANNode-TransparentContainer-ExtIEs ::= OBJECT SET OF NGAP-PROTOCOL-EXTENSION
uint32_t target_ngran_node_to_source_ngran_node_transparent_container_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {267, 22, 324, 356};
  return map_enum_number(names, 4, idx, "id");
}
bool target_ngran_node_to_source_ngran_node_transparent_container_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {267, 22, 324, 356};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e target_ngran_node_to_source_ngran_node_transparent_container_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 267:
      return crit_e::ignore;
    case 22:
      return crit_e::ignore;
    case 324:
      return crit_e::ignore;
    case 356:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
target_ngran_node_to_source_ngran_node_transparent_container_ext_ies_o::ext_c
target_ngran_node_to_source_ngran_node_transparent_container_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 267:
      ret.set(ext_c::types::daps_resp_info_list);
      break;
    case 22:
      ret.set(ext_c::types::direct_forwarding_path_availability);
      break;
    case 324:
      ret.set(ext_c::types::mbs_active_session_info_targetto_source_list);
      break;
    case 356:
      ret.set(ext_c::types::ngap_ie_support_info_resp_list);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e target_ngran_node_to_source_ngran_node_transparent_container_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 267:
      return presence_e::optional;
    case 22:
      return presence_e::optional;
    case 324:
      return presence_e::optional;
    case 356:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void target_ngran_node_to_source_ngran_node_transparent_container_ext_ies_o::ext_c::destroy_()
{
  switch (type_) {
    case types::daps_resp_info_list:
      c.destroy<daps_resp_info_list_l>();
      break;
    case types::mbs_active_session_info_targetto_source_list:
      c.destroy<mbs_active_session_info_targetto_source_list_l>();
      break;
    case types::ngap_ie_support_info_resp_list:
      c.destroy<ngap_ie_support_info_resp_list_l>();
      break;
    default:
      break;
  }
}
void target_ngran_node_to_source_ngran_node_transparent_container_ext_ies_o::ext_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::daps_resp_info_list:
      c.init<daps_resp_info_list_l>();
      break;
    case types::direct_forwarding_path_availability:
      break;
    case types::mbs_active_session_info_targetto_source_list:
      c.init<mbs_active_session_info_targetto_source_list_l>();
      break;
    case types::ngap_ie_support_info_resp_list:
      c.init<ngap_ie_support_info_resp_list_l>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "target_ngran_node_to_source_ngran_node_transparent_container_ext_ies_o::ext_c");
  }
}
target_ngran_node_to_source_ngran_node_transparent_container_ext_ies_o::ext_c::ext_c(
    const target_ngran_node_to_source_ngran_node_transparent_container_ext_ies_o::ext_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::daps_resp_info_list:
      c.init(other.c.get<daps_resp_info_list_l>());
      break;
    case types::direct_forwarding_path_availability:
      c.init(other.c.get<direct_forwarding_path_availability_e>());
      break;
    case types::mbs_active_session_info_targetto_source_list:
      c.init(other.c.get<mbs_active_session_info_targetto_source_list_l>());
      break;
    case types::ngap_ie_support_info_resp_list:
      c.init(other.c.get<ngap_ie_support_info_resp_list_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "target_ngran_node_to_source_ngran_node_transparent_container_ext_ies_o::ext_c");
  }
}
target_ngran_node_to_source_ngran_node_transparent_container_ext_ies_o::ext_c&
target_ngran_node_to_source_ngran_node_transparent_container_ext_ies_o::ext_c::operator=(
    const target_ngran_node_to_source_ngran_node_transparent_container_ext_ies_o::ext_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::daps_resp_info_list:
      c.set(other.c.get<daps_resp_info_list_l>());
      break;
    case types::direct_forwarding_path_availability:
      c.set(other.c.get<direct_forwarding_path_availability_e>());
      break;
    case types::mbs_active_session_info_targetto_source_list:
      c.set(other.c.get<mbs_active_session_info_targetto_source_list_l>());
      break;
    case types::ngap_ie_support_info_resp_list:
      c.set(other.c.get<ngap_ie_support_info_resp_list_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "target_ngran_node_to_source_ngran_node_transparent_container_ext_ies_o::ext_c");
  }

  return *this;
}
daps_resp_info_list_l&
target_ngran_node_to_source_ngran_node_transparent_container_ext_ies_o::ext_c::daps_resp_info_list()
{
  assert_choice_type(types::daps_resp_info_list, type_, "Extension");
  return c.get<daps_resp_info_list_l>();
}
direct_forwarding_path_availability_e&
target_ngran_node_to_source_ngran_node_transparent_container_ext_ies_o::ext_c::direct_forwarding_path_availability()
{
  assert_choice_type(types::direct_forwarding_path_availability, type_, "Extension");
  return c.get<direct_forwarding_path_availability_e>();
}
mbs_active_session_info_targetto_source_list_l& target_ngran_node_to_source_ngran_node_transparent_container_ext_ies_o::
    ext_c::mbs_active_session_info_targetto_source_list()
{
  assert_choice_type(types::mbs_active_session_info_targetto_source_list, type_, "Extension");
  return c.get<mbs_active_session_info_targetto_source_list_l>();
}
ngap_ie_support_info_resp_list_l&
target_ngran_node_to_source_ngran_node_transparent_container_ext_ies_o::ext_c::ngap_ie_support_info_resp_list()
{
  assert_choice_type(types::ngap_ie_support_info_resp_list, type_, "Extension");
  return c.get<ngap_ie_support_info_resp_list_l>();
}
const daps_resp_info_list_l&
target_ngran_node_to_source_ngran_node_transparent_container_ext_ies_o::ext_c::daps_resp_info_list() const
{
  assert_choice_type(types::daps_resp_info_list, type_, "Extension");
  return c.get<daps_resp_info_list_l>();
}
const direct_forwarding_path_availability_e&
target_ngran_node_to_source_ngran_node_transparent_container_ext_ies_o::ext_c::direct_forwarding_path_availability()
    const
{
  assert_choice_type(types::direct_forwarding_path_availability, type_, "Extension");
  return c.get<direct_forwarding_path_availability_e>();
}
const mbs_active_session_info_targetto_source_list_l&
target_ngran_node_to_source_ngran_node_transparent_container_ext_ies_o::ext_c::
    mbs_active_session_info_targetto_source_list() const
{
  assert_choice_type(types::mbs_active_session_info_targetto_source_list, type_, "Extension");
  return c.get<mbs_active_session_info_targetto_source_list_l>();
}
const ngap_ie_support_info_resp_list_l&
target_ngran_node_to_source_ngran_node_transparent_container_ext_ies_o::ext_c::ngap_ie_support_info_resp_list() const
{
  assert_choice_type(types::ngap_ie_support_info_resp_list, type_, "Extension");
  return c.get<ngap_ie_support_info_resp_list_l>();
}
void target_ngran_node_to_source_ngran_node_transparent_container_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::daps_resp_info_list:
      j.start_array("DAPSResponseInfoList");
      for (const auto& e1 : c.get<daps_resp_info_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::direct_forwarding_path_availability:
      j.write_str("DirectForwardingPathAvailability", "direct-path-available");
      break;
    case types::mbs_active_session_info_targetto_source_list:
      j.start_array("MBS-ActiveSessionInformation-TargettoSourceList");
      for (const auto& e1 : c.get<mbs_active_session_info_targetto_source_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::ngap_ie_support_info_resp_list:
      j.start_array("NGAPIESupportInformationResponseList");
      for (const auto& e1 : c.get<ngap_ie_support_info_resp_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    default:
      log_invalid_choice_id(type_, "target_ngran_node_to_source_ngran_node_transparent_container_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE target_ngran_node_to_source_ngran_node_transparent_container_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::daps_resp_info_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<daps_resp_info_list_l>(), 1, 32, true));
      break;
    case types::direct_forwarding_path_availability:
      HANDLE_CODE(c.get<direct_forwarding_path_availability_e>().pack(bref));
      break;
    case types::mbs_active_session_info_targetto_source_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<mbs_active_session_info_targetto_source_list_l>(), 1, 256, true));
      break;
    case types::ngap_ie_support_info_resp_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<ngap_ie_support_info_resp_list_l>(), 1, 32, true));
      break;
    default:
      log_invalid_choice_id(type_, "target_ngran_node_to_source_ngran_node_transparent_container_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE target_ngran_node_to_source_ngran_node_transparent_container_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::daps_resp_info_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<daps_resp_info_list_l>(), bref, 1, 32, true));
      break;
    case types::direct_forwarding_path_availability:
      HANDLE_CODE(c.get<direct_forwarding_path_availability_e>().unpack(bref));
      break;
    case types::mbs_active_session_info_targetto_source_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<mbs_active_session_info_targetto_source_list_l>(), bref, 1, 256, true));
      break;
    case types::ngap_ie_support_info_resp_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<ngap_ie_support_info_resp_list_l>(), bref, 1, 32, true));
      break;
    default:
      log_invalid_choice_id(type_, "target_ngran_node_to_source_ngran_node_transparent_container_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* target_ngran_node_to_source_ngran_node_transparent_container_ext_ies_o::ext_c::types_opts::to_string() const
{
  static const char* names[] = {"DAPSResponseInfoList",
                                "DirectForwardingPathAvailability",
                                "MBS-ActiveSessionInformation-TargettoSourceList",
                                "NGAPIESupportInformationResponseList"};
  return convert_enum_idx(
      names, 4, value, "target_ngran_node_to_source_ngran_node_transparent_container_ext_ies_o::ext_c::types");
}

template struct asn1::protocol_ext_field_s<target_ngran_node_to_source_ngran_node_transparent_container_ext_ies_o>;

target_ngran_node_to_source_ngran_node_transparent_container_ext_ies_container::
    target_ngran_node_to_source_ngran_node_transparent_container_ext_ies_container() :
  daps_resp_info_list(267, crit_e::ignore),
  direct_forwarding_path_availability(22, crit_e::ignore),
  mbs_active_session_info_targetto_source_list(324, crit_e::ignore),
  ngap_ie_support_info_resp_list(356, crit_e::ignore)
{
}
SRSASN_CODE target_ngran_node_to_source_ngran_node_transparent_container_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += daps_resp_info_list_present ? 1 : 0;
  nof_ies += direct_forwarding_path_availability_present ? 1 : 0;
  nof_ies += mbs_active_session_info_targetto_source_list_present ? 1 : 0;
  nof_ies += ngap_ie_support_info_resp_list_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (daps_resp_info_list_present) {
    HANDLE_CODE(daps_resp_info_list.pack(bref));
  }
  if (direct_forwarding_path_availability_present) {
    HANDLE_CODE(direct_forwarding_path_availability.pack(bref));
  }
  if (mbs_active_session_info_targetto_source_list_present) {
    HANDLE_CODE(mbs_active_session_info_targetto_source_list.pack(bref));
  }
  if (ngap_ie_support_info_resp_list_present) {
    HANDLE_CODE(ngap_ie_support_info_resp_list.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE target_ngran_node_to_source_ngran_node_transparent_container_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 267: {
        daps_resp_info_list_present = true;
        daps_resp_info_list.id      = id;
        HANDLE_CODE(daps_resp_info_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(daps_resp_info_list.ext.unpack(bref));
        break;
      }
      case 22: {
        direct_forwarding_path_availability_present = true;
        direct_forwarding_path_availability.id      = id;
        HANDLE_CODE(direct_forwarding_path_availability.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(direct_forwarding_path_availability.ext.unpack(bref));
        break;
      }
      case 324: {
        mbs_active_session_info_targetto_source_list_present = true;
        mbs_active_session_info_targetto_source_list.id      = id;
        HANDLE_CODE(mbs_active_session_info_targetto_source_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_active_session_info_targetto_source_list.ext.unpack(bref));
        break;
      }
      case 356: {
        ngap_ie_support_info_resp_list_present = true;
        ngap_ie_support_info_resp_list.id      = id;
        HANDLE_CODE(ngap_ie_support_info_resp_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ngap_ie_support_info_resp_list.ext.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void target_ngran_node_to_source_ngran_node_transparent_container_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (daps_resp_info_list_present) {
    j.write_fieldname("");
    daps_resp_info_list.to_json(j);
  }
  if (direct_forwarding_path_availability_present) {
    j.write_fieldname("");
    direct_forwarding_path_availability.to_json(j);
  }
  if (mbs_active_session_info_targetto_source_list_present) {
    j.write_fieldname("");
    mbs_active_session_info_targetto_source_list.to_json(j);
  }
  if (ngap_ie_support_info_resp_list_present) {
    j.write_fieldname("");
    ngap_ie_support_info_resp_list.to_json(j);
  }
  j.end_obj();
}

// TargetNGRANNode-ToSourceNGRANNode-TransparentContainer ::= SEQUENCE
SRSASN_CODE target_ngran_node_to_source_ngran_node_transparent_container_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(rrc_container.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE target_ngran_node_to_source_ngran_node_transparent_container_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(rrc_container.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void target_ngran_node_to_source_ngran_node_transparent_container_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("rRCContainer", rrc_container.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// UEContextResumeRequestTransfer ::= SEQUENCE
SRSASN_CODE ue_context_resume_request_transfer_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(qos_flow_failed_to_resume_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (qos_flow_failed_to_resume_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, qos_flow_failed_to_resume_list, 1, 64, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_resume_request_transfer_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool qos_flow_failed_to_resume_list_present;
  HANDLE_CODE(bref.unpack(qos_flow_failed_to_resume_list_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (qos_flow_failed_to_resume_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(qos_flow_failed_to_resume_list, bref, 1, 64, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ue_context_resume_request_transfer_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (qos_flow_failed_to_resume_list.size() > 0) {
    j.start_array("qosFlowFailedToResumeList");
    for (const auto& e1 : qos_flow_failed_to_resume_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// UEContextResumeResponseTransfer ::= SEQUENCE
SRSASN_CODE ue_context_resume_resp_transfer_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(qos_flow_failed_to_resume_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (qos_flow_failed_to_resume_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, qos_flow_failed_to_resume_list, 1, 64, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_resume_resp_transfer_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool qos_flow_failed_to_resume_list_present;
  HANDLE_CODE(bref.unpack(qos_flow_failed_to_resume_list_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (qos_flow_failed_to_resume_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(qos_flow_failed_to_resume_list, bref, 1, 64, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ue_context_resume_resp_transfer_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (qos_flow_failed_to_resume_list.size() > 0) {
    j.start_array("qosFlowFailedToResumeList");
    for (const auto& e1 : qos_flow_failed_to_resume_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SuspendIndicator ::= ENUMERATED
const char* suspend_ind_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "suspend_ind_e");
}

// UEContextSuspendRequestTransfer ::= SEQUENCE
SRSASN_CODE ue_context_suspend_request_transfer_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(suspend_ind_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (suspend_ind_present) {
    HANDLE_CODE(suspend_ind.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_suspend_request_transfer_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(suspend_ind_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (suspend_ind_present) {
    HANDLE_CODE(suspend_ind.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ue_context_suspend_request_transfer_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (suspend_ind_present) {
    j.write_str("suspendIndicator", "true");
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}
